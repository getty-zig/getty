<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Build/Cache.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg=="/>
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-comment">//! Manages `zig-cache` directories.</span></span>
<span class="line" id="L2"><span class="tok-comment">//! This is not a general-purpose cache. It is designed to be fast and simple,</span></span>
<span class="line" id="L3"><span class="tok-comment">//! not to withstand attacks using specially-crafted input.</span></span>
<span class="line" id="L4"></span>
<span class="line" id="L5"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Directory = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L6">    <span class="tok-comment">/// This field is redundant for operations that can act on the open directory handle</span></span>
<span class="line" id="L7">    <span class="tok-comment">/// directly, but it is needed when passing the directory to a child process.</span></span>
<span class="line" id="L8">    <span class="tok-comment">/// `null` means cwd.</span></span>
<span class="line" id="L9">    path: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L10">    handle: fs.Dir,</span>
<span class="line" id="L11"></span>
<span class="line" id="L12">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">join</span>(self: Directory, allocator: Allocator, paths: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L13">        <span class="tok-kw">if</span> (self.path) |p| {</span>
<span class="line" id="L14">            <span class="tok-comment">// TODO clean way to do this with only 1 allocation</span>
</span>
<span class="line" id="L15">            <span class="tok-kw">const</span> part2 = <span class="tok-kw">try</span> fs.path.join(allocator, paths);</span>
<span class="line" id="L16">            <span class="tok-kw">defer</span> allocator.free(part2);</span>
<span class="line" id="L17">            <span class="tok-kw">return</span> fs.path.join(allocator, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ p, part2 });</span>
<span class="line" id="L18">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L19">            <span class="tok-kw">return</span> fs.path.join(allocator, paths);</span>
<span class="line" id="L20">        }</span>
<span class="line" id="L21">    }</span>
<span class="line" id="L22"></span>
<span class="line" id="L23">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">joinZ</span>(self: Directory, allocator: Allocator, paths: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![:<span class="tok-number">0</span>]<span class="tok-type">u8</span> {</span>
<span class="line" id="L24">        <span class="tok-kw">if</span> (self.path) |p| {</span>
<span class="line" id="L25">            <span class="tok-comment">// TODO clean way to do this with only 1 allocation</span>
</span>
<span class="line" id="L26">            <span class="tok-kw">const</span> part2 = <span class="tok-kw">try</span> fs.path.join(allocator, paths);</span>
<span class="line" id="L27">            <span class="tok-kw">defer</span> allocator.free(part2);</span>
<span class="line" id="L28">            <span class="tok-kw">return</span> fs.path.joinZ(allocator, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ p, part2 });</span>
<span class="line" id="L29">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L30">            <span class="tok-kw">return</span> fs.path.joinZ(allocator, paths);</span>
<span class="line" id="L31">        }</span>
<span class="line" id="L32">    }</span>
<span class="line" id="L33"></span>
<span class="line" id="L34">    <span class="tok-comment">/// Whether or not the handle should be closed, or the path should be freed</span></span>
<span class="line" id="L35">    <span class="tok-comment">/// is determined by usage, however this function is provided for convenience</span></span>
<span class="line" id="L36">    <span class="tok-comment">/// if it happens to be what the caller needs.</span></span>
<span class="line" id="L37">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">closeAndFree</span>(self: *Directory, gpa: Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L38">        self.handle.close();</span>
<span class="line" id="L39">        <span class="tok-kw">if</span> (self.path) |p| gpa.free(p);</span>
<span class="line" id="L40">        self.* = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L41">    }</span>
<span class="line" id="L42"></span>
<span class="line" id="L43">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(</span>
<span class="line" id="L44">        self: Directory,</span>
<span class="line" id="L45">        <span class="tok-kw">comptime</span> fmt_string: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L46">        options: fmt.FormatOptions,</span>
<span class="line" id="L47">        writer: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L48">    ) !<span class="tok-type">void</span> {</span>
<span class="line" id="L49">        _ = options;</span>
<span class="line" id="L50">        <span class="tok-kw">if</span> (fmt_string.len != <span class="tok-number">0</span>) fmt.invalidFmtError(fmt, self);</span>
<span class="line" id="L51">        <span class="tok-kw">if</span> (self.path) |p| {</span>
<span class="line" id="L52">            <span class="tok-kw">try</span> writer.writeAll(p);</span>
<span class="line" id="L53">            <span class="tok-kw">try</span> writer.writeAll(fs.path.sep_str);</span>
<span class="line" id="L54">        }</span>
<span class="line" id="L55">    }</span>
<span class="line" id="L56">};</span>
<span class="line" id="L57"></span>
<span class="line" id="L58">gpa: Allocator,</span>
<span class="line" id="L59">manifest_dir: fs.Dir,</span>
<span class="line" id="L60">hash: HashHelper = .{},</span>
<span class="line" id="L61"><span class="tok-comment">/// This value is accessed from multiple threads, protected by mutex.</span></span>
<span class="line" id="L62">recent_problematic_timestamp: <span class="tok-type">i128</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L63">mutex: std.Thread.Mutex = .{},</span>
<span class="line" id="L64"></span>
<span class="line" id="L65"><span class="tok-comment">/// A set of strings such as the zig library directory or project source root, which</span></span>
<span class="line" id="L66"><span class="tok-comment">/// are stripped from the file paths before putting into the cache. They</span></span>
<span class="line" id="L67"><span class="tok-comment">/// are replaced with single-character indicators. This is not to save</span></span>
<span class="line" id="L68"><span class="tok-comment">/// space but to eliminate absolute file paths. This improves portability</span></span>
<span class="line" id="L69"><span class="tok-comment">/// and usefulness of the cache for advanced use cases.</span></span>
<span class="line" id="L70">prefixes_buffer: [<span class="tok-number">4</span>]Directory = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L71">prefixes_len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L72"></span>
<span class="line" id="L73"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DepTokenizer = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Cache/DepTokenizer.zig&quot;</span>);</span>
<span class="line" id="L74"></span>
<span class="line" id="L75"><span class="tok-kw">const</span> Cache = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L76"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);</span>
<span class="line" id="L77"><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);</span>
<span class="line" id="L78"><span class="tok-kw">const</span> crypto = std.crypto;</span>
<span class="line" id="L79"><span class="tok-kw">const</span> fs = std.fs;</span>
<span class="line" id="L80"><span class="tok-kw">const</span> assert = std.debug.assert;</span>
<span class="line" id="L81"><span class="tok-kw">const</span> testing = std.testing;</span>
<span class="line" id="L82"><span class="tok-kw">const</span> mem = std.mem;</span>
<span class="line" id="L83"><span class="tok-kw">const</span> fmt = std.fmt;</span>
<span class="line" id="L84"><span class="tok-kw">const</span> Allocator = std.mem.Allocator;</span>
<span class="line" id="L85"><span class="tok-kw">const</span> log = std.log.scoped(.cache);</span>
<span class="line" id="L86"></span>
<span class="line" id="L87"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addPrefix</span>(cache: *Cache, directory: Directory) <span class="tok-type">void</span> {</span>
<span class="line" id="L88">    cache.prefixes_buffer[cache.prefixes_len] = directory;</span>
<span class="line" id="L89">    cache.prefixes_len += <span class="tok-number">1</span>;</span>
<span class="line" id="L90">}</span>
<span class="line" id="L91"></span>
<span class="line" id="L92"><span class="tok-comment">/// Be sure to call `Manifest.deinit` after successful initialization.</span></span>
<span class="line" id="L93"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">obtain</span>(cache: *Cache) Manifest {</span>
<span class="line" id="L94">    <span class="tok-kw">return</span> Manifest{</span>
<span class="line" id="L95">        .cache = cache,</span>
<span class="line" id="L96">        .hash = cache.hash,</span>
<span class="line" id="L97">        .manifest_file = <span class="tok-null">null</span>,</span>
<span class="line" id="L98">        .manifest_dirty = <span class="tok-null">false</span>,</span>
<span class="line" id="L99">        .hex_digest = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L100">    };</span>
<span class="line" id="L101">}</span>
<span class="line" id="L102"></span>
<span class="line" id="L103"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">prefixes</span>(cache: *<span class="tok-kw">const</span> Cache) []<span class="tok-kw">const</span> Directory {</span>
<span class="line" id="L104">    <span class="tok-kw">return</span> cache.prefixes_buffer[<span class="tok-number">0</span>..cache.prefixes_len];</span>
<span class="line" id="L105">}</span>
<span class="line" id="L106"></span>
<span class="line" id="L107"><span class="tok-kw">const</span> PrefixedPath = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L108">    prefix: <span class="tok-type">u8</span>,</span>
<span class="line" id="L109">    sub_path: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L110">};</span>
<span class="line" id="L111"></span>
<span class="line" id="L112"><span class="tok-kw">fn</span> <span class="tok-fn">findPrefix</span>(cache: *<span class="tok-kw">const</span> Cache, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !PrefixedPath {</span>
<span class="line" id="L113">    <span class="tok-kw">const</span> gpa = cache.gpa;</span>
<span class="line" id="L114">    <span class="tok-kw">const</span> resolved_path = <span class="tok-kw">try</span> fs.path.resolve(gpa, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{file_path});</span>
<span class="line" id="L115">    <span class="tok-kw">errdefer</span> gpa.free(resolved_path);</span>
<span class="line" id="L116">    <span class="tok-kw">return</span> findPrefixResolved(cache, resolved_path);</span>
<span class="line" id="L117">}</span>
<span class="line" id="L118"></span>
<span class="line" id="L119"><span class="tok-comment">/// Takes ownership of `resolved_path` on success.</span></span>
<span class="line" id="L120"><span class="tok-kw">fn</span> <span class="tok-fn">findPrefixResolved</span>(cache: *<span class="tok-kw">const</span> Cache, resolved_path: []<span class="tok-type">u8</span>) !PrefixedPath {</span>
<span class="line" id="L121">    <span class="tok-kw">const</span> gpa = cache.gpa;</span>
<span class="line" id="L122">    <span class="tok-kw">const</span> prefixes_slice = cache.prefixes();</span>
<span class="line" id="L123">    <span class="tok-kw">var</span> i: <span class="tok-type">u8</span> = <span class="tok-number">1</span>; <span class="tok-comment">// Start at 1 to skip over checking the null prefix.</span>
</span>
<span class="line" id="L124">    <span class="tok-kw">while</span> (i &lt; prefixes_slice.len) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L125">        <span class="tok-kw">const</span> p = prefixes_slice[i].path.?;</span>
<span class="line" id="L126">        <span class="tok-kw">if</span> (mem.startsWith(<span class="tok-type">u8</span>, resolved_path, p)) {</span>
<span class="line" id="L127">            <span class="tok-comment">// +1 to skip over the path separator here</span>
</span>
<span class="line" id="L128">            <span class="tok-kw">const</span> sub_path = <span class="tok-kw">try</span> gpa.dupe(<span class="tok-type">u8</span>, resolved_path[p.len + <span class="tok-number">1</span> ..]);</span>
<span class="line" id="L129">            gpa.free(resolved_path);</span>
<span class="line" id="L130">            <span class="tok-kw">return</span> PrefixedPath{</span>
<span class="line" id="L131">                .prefix = <span class="tok-builtin">@intCast</span>(<span class="tok-type">u8</span>, i),</span>
<span class="line" id="L132">                .sub_path = sub_path,</span>
<span class="line" id="L133">            };</span>
<span class="line" id="L134">        }</span>
<span class="line" id="L135">    }</span>
<span class="line" id="L136"></span>
<span class="line" id="L137">    <span class="tok-kw">return</span> PrefixedPath{</span>
<span class="line" id="L138">        .prefix = <span class="tok-number">0</span>,</span>
<span class="line" id="L139">        .sub_path = resolved_path,</span>
<span class="line" id="L140">    };</span>
<span class="line" id="L141">}</span>
<span class="line" id="L142"></span>
<span class="line" id="L143"><span class="tok-comment">/// This is 128 bits - Even with 2^54 cache entries, the probably of a collision would be under 10^-6</span></span>
<span class="line" id="L144"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> bin_digest_len = <span class="tok-number">16</span>;</span>
<span class="line" id="L145"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> hex_digest_len = bin_digest_len * <span class="tok-number">2</span>;</span>
<span class="line" id="L146"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> BinDigest = [bin_digest_len]<span class="tok-type">u8</span>;</span>
<span class="line" id="L147"></span>
<span class="line" id="L148"><span class="tok-kw">const</span> manifest_file_size_max = <span class="tok-number">50</span> * <span class="tok-number">1024</span> * <span class="tok-number">1024</span>;</span>
<span class="line" id="L149"></span>
<span class="line" id="L150"><span class="tok-comment">/// The type used for hashing file contents. Currently, this is SipHash128(1, 3), because it</span></span>
<span class="line" id="L151"><span class="tok-comment">/// provides enough collision resistance for the Manifest use cases, while being one of our</span></span>
<span class="line" id="L152"><span class="tok-comment">/// fastest options right now.</span></span>
<span class="line" id="L153"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hasher = crypto.auth.siphash.SipHash128(<span class="tok-number">1</span>, <span class="tok-number">3</span>);</span>
<span class="line" id="L154"></span>
<span class="line" id="L155"><span class="tok-comment">/// Initial state, that can be copied.</span></span>
<span class="line" id="L156"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> hasher_init: Hasher = Hasher.init(&amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** Hasher.key_length);</span>
<span class="line" id="L157"></span>
<span class="line" id="L158"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> File = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L159">    prefixed_path: ?PrefixedPath,</span>
<span class="line" id="L160">    max_file_size: ?<span class="tok-type">usize</span>,</span>
<span class="line" id="L161">    stat: Stat,</span>
<span class="line" id="L162">    bin_digest: BinDigest,</span>
<span class="line" id="L163">    contents: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L164"></span>
<span class="line" id="L165">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Stat = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L166">        inode: fs.File.INode,</span>
<span class="line" id="L167">        size: <span class="tok-type">u64</span>,</span>
<span class="line" id="L168">        mtime: <span class="tok-type">i128</span>,</span>
<span class="line" id="L169">    };</span>
<span class="line" id="L170"></span>
<span class="line" id="L171">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *File, gpa: Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L172">        <span class="tok-kw">if</span> (self.prefixed_path) |pp| {</span>
<span class="line" id="L173">            gpa.free(pp.sub_path);</span>
<span class="line" id="L174">            self.prefixed_path = <span class="tok-null">null</span>;</span>
<span class="line" id="L175">        }</span>
<span class="line" id="L176">        <span class="tok-kw">if</span> (self.contents) |contents| {</span>
<span class="line" id="L177">            gpa.free(contents);</span>
<span class="line" id="L178">            self.contents = <span class="tok-null">null</span>;</span>
<span class="line" id="L179">        }</span>
<span class="line" id="L180">        self.* = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L181">    }</span>
<span class="line" id="L182">};</span>
<span class="line" id="L183"></span>
<span class="line" id="L184"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> HashHelper = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L185">    hasher: Hasher = hasher_init,</span>
<span class="line" id="L186"></span>
<span class="line" id="L187">    <span class="tok-comment">/// Record a slice of bytes as an dependency of the process being cached</span></span>
<span class="line" id="L188">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addBytes</span>(hh: *HashHelper, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L189">        hh.hasher.update(mem.asBytes(&amp;bytes.len));</span>
<span class="line" id="L190">        hh.hasher.update(bytes);</span>
<span class="line" id="L191">    }</span>
<span class="line" id="L192"></span>
<span class="line" id="L193">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOptionalBytes</span>(hh: *HashHelper, optional_bytes: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L194">        hh.add(optional_bytes != <span class="tok-null">null</span>);</span>
<span class="line" id="L195">        hh.addBytes(optional_bytes <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>);</span>
<span class="line" id="L196">    }</span>
<span class="line" id="L197"></span>
<span class="line" id="L198">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addListOfBytes</span>(hh: *HashHelper, list_of_bytes: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L199">        hh.add(list_of_bytes.len);</span>
<span class="line" id="L200">        <span class="tok-kw">for</span> (list_of_bytes) |bytes| hh.addBytes(bytes);</span>
<span class="line" id="L201">    }</span>
<span class="line" id="L202"></span>
<span class="line" id="L203">    <span class="tok-comment">/// Convert the input value into bytes and record it as a dependency of the process being cached.</span></span>
<span class="line" id="L204">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(hh: *HashHelper, x: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L205">        <span class="tok-kw">switch</span> (<span class="tok-builtin">@TypeOf</span>(x)) {</span>
<span class="line" id="L206">            std.builtin.Version =&gt; {</span>
<span class="line" id="L207">                hh.add(x.major);</span>
<span class="line" id="L208">                hh.add(x.minor);</span>
<span class="line" id="L209">                hh.add(x.patch);</span>
<span class="line" id="L210">            },</span>
<span class="line" id="L211">            std.Target.Os.TaggedVersionRange =&gt; {</span>
<span class="line" id="L212">                <span class="tok-kw">switch</span> (x) {</span>
<span class="line" id="L213">                    .linux =&gt; |linux| {</span>
<span class="line" id="L214">                        hh.add(linux.range.min);</span>
<span class="line" id="L215">                        hh.add(linux.range.max);</span>
<span class="line" id="L216">                        hh.add(linux.glibc);</span>
<span class="line" id="L217">                    },</span>
<span class="line" id="L218">                    .windows =&gt; |windows| {</span>
<span class="line" id="L219">                        hh.add(windows.min);</span>
<span class="line" id="L220">                        hh.add(windows.max);</span>
<span class="line" id="L221">                    },</span>
<span class="line" id="L222">                    .semver =&gt; |semver| {</span>
<span class="line" id="L223">                        hh.add(semver.min);</span>
<span class="line" id="L224">                        hh.add(semver.max);</span>
<span class="line" id="L225">                    },</span>
<span class="line" id="L226">                    .none =&gt; {},</span>
<span class="line" id="L227">                }</span>
<span class="line" id="L228">            },</span>
<span class="line" id="L229">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(x))) {</span>
<span class="line" id="L230">                .Bool, .Int, .Enum, .Array =&gt; hh.addBytes(mem.asBytes(&amp;x)),</span>
<span class="line" id="L231">                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unable to hash type &quot;</span> ++ <span class="tok-builtin">@typeName</span>(<span class="tok-builtin">@TypeOf</span>(x))),</span>
<span class="line" id="L232">            },</span>
<span class="line" id="L233">        }</span>
<span class="line" id="L234">    }</span>
<span class="line" id="L235"></span>
<span class="line" id="L236">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOptional</span>(hh: *HashHelper, optional: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L237">        hh.add(optional != <span class="tok-null">null</span>);</span>
<span class="line" id="L238">        hh.add(optional <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>);</span>
<span class="line" id="L239">    }</span>
<span class="line" id="L240"></span>
<span class="line" id="L241">    <span class="tok-comment">/// Returns a hex encoded hash of the inputs, without modifying state.</span></span>
<span class="line" id="L242">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peek</span>(hh: HashHelper) [hex_digest_len]<span class="tok-type">u8</span> {</span>
<span class="line" id="L243">        <span class="tok-kw">var</span> copy = hh;</span>
<span class="line" id="L244">        <span class="tok-kw">return</span> copy.final();</span>
<span class="line" id="L245">    }</span>
<span class="line" id="L246"></span>
<span class="line" id="L247">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peekBin</span>(hh: HashHelper) BinDigest {</span>
<span class="line" id="L248">        <span class="tok-kw">var</span> copy = hh;</span>
<span class="line" id="L249">        <span class="tok-kw">var</span> bin_digest: BinDigest = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L250">        copy.hasher.final(&amp;bin_digest);</span>
<span class="line" id="L251">        <span class="tok-kw">return</span> bin_digest;</span>
<span class="line" id="L252">    }</span>
<span class="line" id="L253"></span>
<span class="line" id="L254">    <span class="tok-comment">/// Returns a hex encoded hash of the inputs, mutating the state of the hasher.</span></span>
<span class="line" id="L255">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">final</span>(hh: *HashHelper) [hex_digest_len]<span class="tok-type">u8</span> {</span>
<span class="line" id="L256">        <span class="tok-kw">var</span> bin_digest: BinDigest = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L257">        hh.hasher.final(&amp;bin_digest);</span>
<span class="line" id="L258"></span>
<span class="line" id="L259">        <span class="tok-kw">var</span> out_digest: [hex_digest_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L260">        _ = fmt.bufPrint(</span>
<span class="line" id="L261">            &amp;out_digest,</span>
<span class="line" id="L262">            <span class="tok-str">&quot;{s}&quot;</span>,</span>
<span class="line" id="L263">            .{fmt.fmtSliceHexLower(&amp;bin_digest)},</span>
<span class="line" id="L264">        ) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L265">        <span class="tok-kw">return</span> out_digest;</span>
<span class="line" id="L266">    }</span>
<span class="line" id="L267">};</span>
<span class="line" id="L268"></span>
<span class="line" id="L269"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Lock = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L270">    manifest_file: fs.File,</span>
<span class="line" id="L271"></span>
<span class="line" id="L272">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">release</span>(lock: *Lock) <span class="tok-type">void</span> {</span>
<span class="line" id="L273">        <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L274">            <span class="tok-comment">// Windows does not guarantee that locks are immediately unlocked when</span>
</span>
<span class="line" id="L275">            <span class="tok-comment">// the file handle is closed. See LockFileEx documentation.</span>
</span>
<span class="line" id="L276">            lock.manifest_file.unlock();</span>
<span class="line" id="L277">        }</span>
<span class="line" id="L278"></span>
<span class="line" id="L279">        lock.manifest_file.close();</span>
<span class="line" id="L280">        lock.* = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L281">    }</span>
<span class="line" id="L282">};</span>
<span class="line" id="L283"></span>
<span class="line" id="L284"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Manifest = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L285">    cache: *Cache,</span>
<span class="line" id="L286">    <span class="tok-comment">/// Current state for incremental hashing.</span></span>
<span class="line" id="L287">    hash: HashHelper,</span>
<span class="line" id="L288">    manifest_file: ?fs.File,</span>
<span class="line" id="L289">    manifest_dirty: <span class="tok-type">bool</span>,</span>
<span class="line" id="L290">    <span class="tok-comment">/// Set this flag to true before calling hit() in order to indicate that</span></span>
<span class="line" id="L291">    <span class="tok-comment">/// upon a cache hit, the code using the cache will not modify the files</span></span>
<span class="line" id="L292">    <span class="tok-comment">/// within the cache directory. This allows multiple processes to utilize</span></span>
<span class="line" id="L293">    <span class="tok-comment">/// the same cache directory at the same time.</span></span>
<span class="line" id="L294">    want_shared_lock: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,</span>
<span class="line" id="L295">    have_exclusive_lock: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L296">    <span class="tok-comment">// Indicate that we want isProblematicTimestamp to perform a filesystem write in</span>
</span>
<span class="line" id="L297">    <span class="tok-comment">// order to obtain a problematic timestamp for the next call. Calls after that</span>
</span>
<span class="line" id="L298">    <span class="tok-comment">// will then use the same timestamp, to avoid unnecessary filesystem writes.</span>
</span>
<span class="line" id="L299">    want_refresh_timestamp: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,</span>
<span class="line" id="L300">    files: std.ArrayListUnmanaged(File) = .{},</span>
<span class="line" id="L301">    hex_digest: [hex_digest_len]<span class="tok-type">u8</span>,</span>
<span class="line" id="L302">    <span class="tok-comment">/// Populated when hit() returns an error because of one</span></span>
<span class="line" id="L303">    <span class="tok-comment">/// of the files listed in the manifest.</span></span>
<span class="line" id="L304">    failed_file_index: ?<span class="tok-type">usize</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L305">    <span class="tok-comment">/// Keeps track of the last time we performed a file system write to observe</span></span>
<span class="line" id="L306">    <span class="tok-comment">/// what time the file system thinks it is, according to its own granularity.</span></span>
<span class="line" id="L307">    recent_problematic_timestamp: <span class="tok-type">i128</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L308"></span>
<span class="line" id="L309">    <span class="tok-comment">/// Add a file as a dependency of process being cached. When `hit` is</span></span>
<span class="line" id="L310">    <span class="tok-comment">/// called, the file's contents will be checked to ensure that it matches</span></span>
<span class="line" id="L311">    <span class="tok-comment">/// the contents from previous times.</span></span>
<span class="line" id="L312">    <span class="tok-comment">///</span></span>
<span class="line" id="L313">    <span class="tok-comment">/// Max file size will be used to determine the amount of space the file contents</span></span>
<span class="line" id="L314">    <span class="tok-comment">/// are allowed to take up in memory. If max_file_size is null, then the contents</span></span>
<span class="line" id="L315">    <span class="tok-comment">/// will not be loaded into memory.</span></span>
<span class="line" id="L316">    <span class="tok-comment">///</span></span>
<span class="line" id="L317">    <span class="tok-comment">/// Returns the index of the entry in the `files` array list. You can use it</span></span>
<span class="line" id="L318">    <span class="tok-comment">/// to access the contents of the file after calling `hit()` like so:</span></span>
<span class="line" id="L319">    <span class="tok-comment">///</span></span>
<span class="line" id="L320">    <span class="tok-comment">/// ```</span></span>
<span class="line" id="L321">    <span class="tok-comment">/// var file_contents = cache_hash.files.items[file_index].contents.?;</span></span>
<span class="line" id="L322">    <span class="tok-comment">/// ```</span></span>
<span class="line" id="L323">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFile</span>(self: *Manifest, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, max_file_size: ?<span class="tok-type">usize</span>) !<span class="tok-type">usize</span> {</span>
<span class="line" id="L324">        assert(self.manifest_file == <span class="tok-null">null</span>);</span>
<span class="line" id="L325"></span>
<span class="line" id="L326">        <span class="tok-kw">const</span> gpa = self.cache.gpa;</span>
<span class="line" id="L327">        <span class="tok-kw">try</span> self.files.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L328">        <span class="tok-kw">const</span> prefixed_path = <span class="tok-kw">try</span> self.cache.findPrefix(file_path);</span>
<span class="line" id="L329">        <span class="tok-kw">errdefer</span> gpa.free(prefixed_path.sub_path);</span>
<span class="line" id="L330"></span>
<span class="line" id="L331">        self.files.addOneAssumeCapacity().* = .{</span>
<span class="line" id="L332">            .prefixed_path = prefixed_path,</span>
<span class="line" id="L333">            .contents = <span class="tok-null">null</span>,</span>
<span class="line" id="L334">            .max_file_size = max_file_size,</span>
<span class="line" id="L335">            .stat = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L336">            .bin_digest = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L337">        };</span>
<span class="line" id="L338"></span>
<span class="line" id="L339">        self.hash.add(prefixed_path.prefix);</span>
<span class="line" id="L340">        self.hash.addBytes(prefixed_path.sub_path);</span>
<span class="line" id="L341"></span>
<span class="line" id="L342">        <span class="tok-kw">return</span> self.files.items.len - <span class="tok-number">1</span>;</span>
<span class="line" id="L343">    }</span>
<span class="line" id="L344"></span>
<span class="line" id="L345">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOptionalFile</span>(self: *Manifest, optional_file_path: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L346">        self.hash.add(optional_file_path != <span class="tok-null">null</span>);</span>
<span class="line" id="L347">        <span class="tok-kw">const</span> file_path = optional_file_path <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L348">        _ = <span class="tok-kw">try</span> self.addFile(file_path, <span class="tok-null">null</span>);</span>
<span class="line" id="L349">    }</span>
<span class="line" id="L350"></span>
<span class="line" id="L351">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addListOfFiles</span>(self: *Manifest, list_of_files: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L352">        self.hash.add(list_of_files.len);</span>
<span class="line" id="L353">        <span class="tok-kw">for</span> (list_of_files) |file_path| {</span>
<span class="line" id="L354">            _ = <span class="tok-kw">try</span> self.addFile(file_path, <span class="tok-null">null</span>);</span>
<span class="line" id="L355">        }</span>
<span class="line" id="L356">    }</span>
<span class="line" id="L357"></span>
<span class="line" id="L358">    <span class="tok-comment">/// Check the cache to see if the input exists in it. If it exists, returns `true`.</span></span>
<span class="line" id="L359">    <span class="tok-comment">/// A hex encoding of its hash is available by calling `final`.</span></span>
<span class="line" id="L360">    <span class="tok-comment">///</span></span>
<span class="line" id="L361">    <span class="tok-comment">/// This function will also acquire an exclusive lock to the manifest file. This means</span></span>
<span class="line" id="L362">    <span class="tok-comment">/// that a process holding a Manifest will block any other process attempting to</span></span>
<span class="line" id="L363">    <span class="tok-comment">/// acquire the lock. If `want_shared_lock` is `true`, a cache hit guarantees the</span></span>
<span class="line" id="L364">    <span class="tok-comment">/// manifest file to be locked in shared mode, and a cache miss guarantees the manifest</span></span>
<span class="line" id="L365">    <span class="tok-comment">/// file to be locked in exclusive mode.</span></span>
<span class="line" id="L366">    <span class="tok-comment">///</span></span>
<span class="line" id="L367">    <span class="tok-comment">/// The lock on the manifest file is released when `deinit` is called. As another</span></span>
<span class="line" id="L368">    <span class="tok-comment">/// option, one may call `toOwnedLock` to obtain a smaller object which can represent</span></span>
<span class="line" id="L369">    <span class="tok-comment">/// the lock. `deinit` is safe to call whether or not `toOwnedLock` has been called.</span></span>
<span class="line" id="L370">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hit</span>(self: *Manifest) !<span class="tok-type">bool</span> {</span>
<span class="line" id="L371">        <span class="tok-kw">const</span> gpa = self.cache.gpa;</span>
<span class="line" id="L372">        assert(self.manifest_file == <span class="tok-null">null</span>);</span>
<span class="line" id="L373"></span>
<span class="line" id="L374">        self.failed_file_index = <span class="tok-null">null</span>;</span>
<span class="line" id="L375"></span>
<span class="line" id="L376">        <span class="tok-kw">const</span> ext = <span class="tok-str">&quot;.txt&quot;</span>;</span>
<span class="line" id="L377">        <span class="tok-kw">var</span> manifest_file_path: [self.hex_digest.len + ext.len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L378"></span>
<span class="line" id="L379">        <span class="tok-kw">var</span> bin_digest: BinDigest = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L380">        self.hash.hasher.final(&amp;bin_digest);</span>
<span class="line" id="L381"></span>
<span class="line" id="L382">        _ = fmt.bufPrint(</span>
<span class="line" id="L383">            &amp;self.hex_digest,</span>
<span class="line" id="L384">            <span class="tok-str">&quot;{s}&quot;</span>,</span>
<span class="line" id="L385">            .{fmt.fmtSliceHexLower(&amp;bin_digest)},</span>
<span class="line" id="L386">        ) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L387"></span>
<span class="line" id="L388">        self.hash.hasher = hasher_init;</span>
<span class="line" id="L389">        self.hash.hasher.update(&amp;bin_digest);</span>
<span class="line" id="L390"></span>
<span class="line" id="L391">        mem.copy(<span class="tok-type">u8</span>, &amp;manifest_file_path, &amp;self.hex_digest);</span>
<span class="line" id="L392">        manifest_file_path[self.hex_digest.len..][<span class="tok-number">0</span>..ext.len].* = ext.*;</span>
<span class="line" id="L393"></span>
<span class="line" id="L394">        <span class="tok-kw">if</span> (self.files.items.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L395">            <span class="tok-comment">// If there are no file inputs, we check if the manifest file exists instead of</span>
</span>
<span class="line" id="L396">            <span class="tok-comment">// comparing the hashes on the files used for the cached item</span>
</span>
<span class="line" id="L397">            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L398">                <span class="tok-kw">if</span> (self.cache.manifest_dir.openFile(&amp;manifest_file_path, .{</span>
<span class="line" id="L399">                    .mode = .read_write,</span>
<span class="line" id="L400">                    .lock = .Exclusive,</span>
<span class="line" id="L401">                    .lock_nonblocking = self.want_shared_lock,</span>
<span class="line" id="L402">                })) |manifest_file| {</span>
<span class="line" id="L403">                    self.manifest_file = manifest_file;</span>
<span class="line" id="L404">                    self.have_exclusive_lock = <span class="tok-null">true</span>;</span>
<span class="line" id="L405">                    <span class="tok-kw">break</span>;</span>
<span class="line" id="L406">                } <span class="tok-kw">else</span> |open_err| <span class="tok-kw">switch</span> (open_err) {</span>
<span class="line" id="L407">                    <span class="tok-kw">error</span>.WouldBlock =&gt; {</span>
<span class="line" id="L408">                        self.manifest_file = <span class="tok-kw">try</span> self.cache.manifest_dir.openFile(&amp;manifest_file_path, .{</span>
<span class="line" id="L409">                            .lock = .Shared,</span>
<span class="line" id="L410">                        });</span>
<span class="line" id="L411">                        <span class="tok-kw">break</span>;</span>
<span class="line" id="L412">                    },</span>
<span class="line" id="L413">                    <span class="tok-kw">error</span>.FileNotFound =&gt; {</span>
<span class="line" id="L414">                        <span class="tok-kw">if</span> (self.cache.manifest_dir.createFile(&amp;manifest_file_path, .{</span>
<span class="line" id="L415">                            .read = <span class="tok-null">true</span>,</span>
<span class="line" id="L416">                            .truncate = <span class="tok-null">false</span>,</span>
<span class="line" id="L417">                            .lock = .Exclusive,</span>
<span class="line" id="L418">                            .lock_nonblocking = self.want_shared_lock,</span>
<span class="line" id="L419">                        })) |manifest_file| {</span>
<span class="line" id="L420">                            self.manifest_file = manifest_file;</span>
<span class="line" id="L421">                            self.manifest_dirty = <span class="tok-null">true</span>;</span>
<span class="line" id="L422">                            self.have_exclusive_lock = <span class="tok-null">true</span>;</span>
<span class="line" id="L423">                            <span class="tok-kw">return</span> <span class="tok-null">false</span>; <span class="tok-comment">// cache miss; exclusive lock already held</span>
</span>
<span class="line" id="L424">                        } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L425">                            <span class="tok-comment">// There are no dir components, so you would think</span>
</span>
<span class="line" id="L426">                            <span class="tok-comment">// that this was unreachable, however we have</span>
</span>
<span class="line" id="L427">                            <span class="tok-comment">// observed on macOS two processes racing to do</span>
</span>
<span class="line" id="L428">                            <span class="tok-comment">// openat() with O_CREAT manifest in ENOENT.</span>
</span>
<span class="line" id="L429">                            <span class="tok-kw">error</span>.WouldBlock, <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L430">                            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L431">                        }</span>
<span class="line" id="L432">                    },</span>
<span class="line" id="L433">                    <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L434">                }</span>
<span class="line" id="L435">            }</span>
<span class="line" id="L436">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L437">            <span class="tok-kw">if</span> (self.cache.manifest_dir.createFile(&amp;manifest_file_path, .{</span>
<span class="line" id="L438">                .read = <span class="tok-null">true</span>,</span>
<span class="line" id="L439">                .truncate = <span class="tok-null">false</span>,</span>
<span class="line" id="L440">                .lock = .Exclusive,</span>
<span class="line" id="L441">                .lock_nonblocking = self.want_shared_lock,</span>
<span class="line" id="L442">            })) |manifest_file| {</span>
<span class="line" id="L443">                self.manifest_file = manifest_file;</span>
<span class="line" id="L444">                self.have_exclusive_lock = <span class="tok-null">true</span>;</span>
<span class="line" id="L445">            } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L446">                <span class="tok-comment">// There are no dir components, so you would think that this was</span>
</span>
<span class="line" id="L447">                <span class="tok-comment">// unreachable, however we have observed on macOS two processes racing</span>
</span>
<span class="line" id="L448">                <span class="tok-comment">// to do openat() with O_CREAT manifest in ENOENT.</span>
</span>
<span class="line" id="L449">                <span class="tok-kw">error</span>.WouldBlock, <span class="tok-kw">error</span>.FileNotFound =&gt; {</span>
<span class="line" id="L450">                    self.manifest_file = <span class="tok-kw">try</span> self.cache.manifest_dir.openFile(&amp;manifest_file_path, .{</span>
<span class="line" id="L451">                        .lock = .Shared,</span>
<span class="line" id="L452">                    });</span>
<span class="line" id="L453">                },</span>
<span class="line" id="L454">                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L455">            }</span>
<span class="line" id="L456">        }</span>
<span class="line" id="L457"></span>
<span class="line" id="L458">        self.want_refresh_timestamp = <span class="tok-null">true</span>;</span>
<span class="line" id="L459"></span>
<span class="line" id="L460">        <span class="tok-kw">const</span> file_contents = <span class="tok-kw">try</span> self.manifest_file.?.reader().readAllAlloc(gpa, manifest_file_size_max);</span>
<span class="line" id="L461">        <span class="tok-kw">defer</span> gpa.free(file_contents);</span>
<span class="line" id="L462"></span>
<span class="line" id="L463">        <span class="tok-kw">const</span> input_file_count = self.files.items.len;</span>
<span class="line" id="L464">        <span class="tok-kw">var</span> any_file_changed = <span class="tok-null">false</span>;</span>
<span class="line" id="L465">        <span class="tok-kw">var</span> line_iter = mem.tokenize(<span class="tok-type">u8</span>, file_contents, <span class="tok-str">&quot;\n&quot;</span>);</span>
<span class="line" id="L466">        <span class="tok-kw">var</span> idx: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L467">        <span class="tok-kw">while</span> (line_iter.next()) |line| {</span>
<span class="line" id="L468">            <span class="tok-kw">defer</span> idx += <span class="tok-number">1</span>;</span>
<span class="line" id="L469"></span>
<span class="line" id="L470">            <span class="tok-kw">const</span> cache_hash_file = <span class="tok-kw">if</span> (idx &lt; input_file_count) &amp;self.files.items[idx] <span class="tok-kw">else</span> blk: {</span>
<span class="line" id="L471">                <span class="tok-kw">const</span> new = <span class="tok-kw">try</span> self.files.addOne(gpa);</span>
<span class="line" id="L472">                new.* = .{</span>
<span class="line" id="L473">                    .prefixed_path = <span class="tok-null">null</span>,</span>
<span class="line" id="L474">                    .contents = <span class="tok-null">null</span>,</span>
<span class="line" id="L475">                    .max_file_size = <span class="tok-null">null</span>,</span>
<span class="line" id="L476">                    .stat = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L477">                    .bin_digest = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L478">                };</span>
<span class="line" id="L479">                <span class="tok-kw">break</span> :blk new;</span>
<span class="line" id="L480">            };</span>
<span class="line" id="L481"></span>
<span class="line" id="L482">            <span class="tok-kw">var</span> iter = mem.tokenize(<span class="tok-type">u8</span>, line, <span class="tok-str">&quot; &quot;</span>);</span>
<span class="line" id="L483">            <span class="tok-kw">const</span> size = iter.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L484">            <span class="tok-kw">const</span> inode = iter.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L485">            <span class="tok-kw">const</span> mtime_nsec_str = iter.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L486">            <span class="tok-kw">const</span> digest_str = iter.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L487">            <span class="tok-kw">const</span> prefix_str = iter.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L488">            <span class="tok-kw">const</span> file_path = iter.rest();</span>
<span class="line" id="L489"></span>
<span class="line" id="L490">            cache_hash_file.stat.size = fmt.parseInt(<span class="tok-type">u64</span>, size, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L491">            cache_hash_file.stat.inode = fmt.parseInt(fs.File.INode, inode, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L492">            cache_hash_file.stat.mtime = fmt.parseInt(<span class="tok-type">i64</span>, mtime_nsec_str, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L493">            _ = fmt.hexToBytes(&amp;cache_hash_file.bin_digest, digest_str) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L494">            <span class="tok-kw">const</span> prefix = fmt.parseInt(<span class="tok-type">u8</span>, prefix_str, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L495">            <span class="tok-kw">if</span> (prefix &gt;= self.cache.prefixes_len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L496"></span>
<span class="line" id="L497">            <span class="tok-kw">if</span> (file_path.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L498">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L499">            }</span>
<span class="line" id="L500">            <span class="tok-kw">if</span> (cache_hash_file.prefixed_path) |pp| {</span>
<span class="line" id="L501">                <span class="tok-kw">if</span> (pp.prefix != prefix <span class="tok-kw">or</span> !mem.eql(<span class="tok-type">u8</span>, file_path, pp.sub_path)) {</span>
<span class="line" id="L502">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L503">                }</span>
<span class="line" id="L504">            }</span>
<span class="line" id="L505"></span>
<span class="line" id="L506">            <span class="tok-kw">if</span> (cache_hash_file.prefixed_path == <span class="tok-null">null</span>) {</span>
<span class="line" id="L507">                cache_hash_file.prefixed_path = .{</span>
<span class="line" id="L508">                    .prefix = prefix,</span>
<span class="line" id="L509">                    .sub_path = <span class="tok-kw">try</span> gpa.dupe(<span class="tok-type">u8</span>, file_path),</span>
<span class="line" id="L510">                };</span>
<span class="line" id="L511">            }</span>
<span class="line" id="L512"></span>
<span class="line" id="L513">            <span class="tok-kw">const</span> pp = cache_hash_file.prefixed_path.?;</span>
<span class="line" id="L514">            <span class="tok-kw">const</span> dir = self.cache.prefixes()[pp.prefix].handle;</span>
<span class="line" id="L515">            <span class="tok-kw">const</span> this_file = dir.openFile(pp.sub_path, .{ .mode = .read_only }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L516">                <span class="tok-kw">error</span>.FileNotFound =&gt; {</span>
<span class="line" id="L517">                    <span class="tok-kw">try</span> self.upgradeToExclusiveLock();</span>
<span class="line" id="L518">                    <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L519">                },</span>
<span class="line" id="L520">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheUnavailable,</span>
<span class="line" id="L521">            };</span>
<span class="line" id="L522">            <span class="tok-kw">defer</span> this_file.close();</span>
<span class="line" id="L523"></span>
<span class="line" id="L524">            <span class="tok-kw">const</span> actual_stat = this_file.stat() <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L525">                self.failed_file_index = idx;</span>
<span class="line" id="L526">                <span class="tok-kw">return</span> err;</span>
<span class="line" id="L527">            };</span>
<span class="line" id="L528">            <span class="tok-kw">const</span> size_match = actual_stat.size == cache_hash_file.stat.size;</span>
<span class="line" id="L529">            <span class="tok-kw">const</span> mtime_match = actual_stat.mtime == cache_hash_file.stat.mtime;</span>
<span class="line" id="L530">            <span class="tok-kw">const</span> inode_match = actual_stat.inode == cache_hash_file.stat.inode;</span>
<span class="line" id="L531"></span>
<span class="line" id="L532">            <span class="tok-kw">if</span> (!size_match <span class="tok-kw">or</span> !mtime_match <span class="tok-kw">or</span> !inode_match) {</span>
<span class="line" id="L533">                self.manifest_dirty = <span class="tok-null">true</span>;</span>
<span class="line" id="L534"></span>
<span class="line" id="L535">                cache_hash_file.stat = .{</span>
<span class="line" id="L536">                    .size = actual_stat.size,</span>
<span class="line" id="L537">                    .mtime = actual_stat.mtime,</span>
<span class="line" id="L538">                    .inode = actual_stat.inode,</span>
<span class="line" id="L539">                };</span>
<span class="line" id="L540"></span>
<span class="line" id="L541">                <span class="tok-kw">if</span> (self.isProblematicTimestamp(cache_hash_file.stat.mtime)) {</span>
<span class="line" id="L542">                    <span class="tok-comment">// The actual file has an unreliable timestamp, force it to be hashed</span>
</span>
<span class="line" id="L543">                    cache_hash_file.stat.mtime = <span class="tok-number">0</span>;</span>
<span class="line" id="L544">                    cache_hash_file.stat.inode = <span class="tok-number">0</span>;</span>
<span class="line" id="L545">                }</span>
<span class="line" id="L546"></span>
<span class="line" id="L547">                <span class="tok-kw">var</span> actual_digest: BinDigest = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L548">                hashFile(this_file, &amp;actual_digest) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L549">                    self.failed_file_index = idx;</span>
<span class="line" id="L550">                    <span class="tok-kw">return</span> err;</span>
<span class="line" id="L551">                };</span>
<span class="line" id="L552"></span>
<span class="line" id="L553">                <span class="tok-kw">if</span> (!mem.eql(<span class="tok-type">u8</span>, &amp;cache_hash_file.bin_digest, &amp;actual_digest)) {</span>
<span class="line" id="L554">                    cache_hash_file.bin_digest = actual_digest;</span>
<span class="line" id="L555">                    <span class="tok-comment">// keep going until we have the input file digests</span>
</span>
<span class="line" id="L556">                    any_file_changed = <span class="tok-null">true</span>;</span>
<span class="line" id="L557">                }</span>
<span class="line" id="L558">            }</span>
<span class="line" id="L559"></span>
<span class="line" id="L560">            <span class="tok-kw">if</span> (!any_file_changed) {</span>
<span class="line" id="L561">                self.hash.hasher.update(&amp;cache_hash_file.bin_digest);</span>
<span class="line" id="L562">            }</span>
<span class="line" id="L563">        }</span>
<span class="line" id="L564"></span>
<span class="line" id="L565">        <span class="tok-kw">if</span> (any_file_changed) {</span>
<span class="line" id="L566">            <span class="tok-comment">// cache miss</span>
</span>
<span class="line" id="L567">            <span class="tok-comment">// keep the manifest file open</span>
</span>
<span class="line" id="L568">            self.unhit(bin_digest, input_file_count);</span>
<span class="line" id="L569">            <span class="tok-kw">try</span> self.upgradeToExclusiveLock();</span>
<span class="line" id="L570">            <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L571">        }</span>
<span class="line" id="L572"></span>
<span class="line" id="L573">        <span class="tok-kw">if</span> (idx &lt; input_file_count) {</span>
<span class="line" id="L574">            self.manifest_dirty = <span class="tok-null">true</span>;</span>
<span class="line" id="L575">            <span class="tok-kw">while</span> (idx &lt; input_file_count) : (idx += <span class="tok-number">1</span>) {</span>
<span class="line" id="L576">                <span class="tok-kw">const</span> ch_file = &amp;self.files.items[idx];</span>
<span class="line" id="L577">                self.populateFileHash(ch_file) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L578">                    self.failed_file_index = idx;</span>
<span class="line" id="L579">                    <span class="tok-kw">return</span> err;</span>
<span class="line" id="L580">                };</span>
<span class="line" id="L581">            }</span>
<span class="line" id="L582">            <span class="tok-kw">try</span> self.upgradeToExclusiveLock();</span>
<span class="line" id="L583">            <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L584">        }</span>
<span class="line" id="L585"></span>
<span class="line" id="L586">        <span class="tok-kw">if</span> (self.want_shared_lock) {</span>
<span class="line" id="L587">            <span class="tok-kw">try</span> self.downgradeToSharedLock();</span>
<span class="line" id="L588">        }</span>
<span class="line" id="L589"></span>
<span class="line" id="L590">        <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L591">    }</span>
<span class="line" id="L592"></span>
<span class="line" id="L593">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unhit</span>(self: *Manifest, bin_digest: BinDigest, input_file_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L594">        <span class="tok-comment">// Reset the hash.</span>
</span>
<span class="line" id="L595">        self.hash.hasher = hasher_init;</span>
<span class="line" id="L596">        self.hash.hasher.update(&amp;bin_digest);</span>
<span class="line" id="L597"></span>
<span class="line" id="L598">        <span class="tok-comment">// Remove files not in the initial hash.</span>
</span>
<span class="line" id="L599">        <span class="tok-kw">for</span> (self.files.items[input_file_count..]) |*file| {</span>
<span class="line" id="L600">            file.deinit(self.cache.gpa);</span>
<span class="line" id="L601">        }</span>
<span class="line" id="L602">        self.files.shrinkRetainingCapacity(input_file_count);</span>
<span class="line" id="L603"></span>
<span class="line" id="L604">        <span class="tok-kw">for</span> (self.files.items) |file| {</span>
<span class="line" id="L605">            self.hash.hasher.update(&amp;file.bin_digest);</span>
<span class="line" id="L606">        }</span>
<span class="line" id="L607">    }</span>
<span class="line" id="L608"></span>
<span class="line" id="L609">    <span class="tok-kw">fn</span> <span class="tok-fn">isProblematicTimestamp</span>(man: *Manifest, file_time: <span class="tok-type">i128</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L610">        <span class="tok-comment">// If the file_time is prior to the most recent problematic timestamp</span>
</span>
<span class="line" id="L611">        <span class="tok-comment">// then we don't need to access the filesystem.</span>
</span>
<span class="line" id="L612">        <span class="tok-kw">if</span> (file_time &lt; man.recent_problematic_timestamp)</span>
<span class="line" id="L613">            <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L614"></span>
<span class="line" id="L615">        <span class="tok-comment">// Next we will check the globally shared Cache timestamp, which is accessed</span>
</span>
<span class="line" id="L616">        <span class="tok-comment">// from multiple threads.</span>
</span>
<span class="line" id="L617">        man.cache.mutex.lock();</span>
<span class="line" id="L618">        <span class="tok-kw">defer</span> man.cache.mutex.unlock();</span>
<span class="line" id="L619"></span>
<span class="line" id="L620">        <span class="tok-comment">// Save the global one to our local one to avoid locking next time.</span>
</span>
<span class="line" id="L621">        man.recent_problematic_timestamp = man.cache.recent_problematic_timestamp;</span>
<span class="line" id="L622">        <span class="tok-kw">if</span> (file_time &lt; man.recent_problematic_timestamp)</span>
<span class="line" id="L623">            <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L624"></span>
<span class="line" id="L625">        <span class="tok-comment">// This flag prevents multiple filesystem writes for the same hit() call.</span>
</span>
<span class="line" id="L626">        <span class="tok-kw">if</span> (man.want_refresh_timestamp) {</span>
<span class="line" id="L627">            man.want_refresh_timestamp = <span class="tok-null">false</span>;</span>
<span class="line" id="L628"></span>
<span class="line" id="L629">            <span class="tok-kw">var</span> file = man.cache.manifest_dir.createFile(<span class="tok-str">&quot;timestamp&quot;</span>, .{</span>
<span class="line" id="L630">                .read = <span class="tok-null">true</span>,</span>
<span class="line" id="L631">                .truncate = <span class="tok-null">true</span>,</span>
<span class="line" id="L632">            }) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L633">            <span class="tok-kw">defer</span> file.close();</span>
<span class="line" id="L634"></span>
<span class="line" id="L635">            <span class="tok-comment">// Save locally and also save globally (we still hold the global lock).</span>
</span>
<span class="line" id="L636">            man.recent_problematic_timestamp = (file.stat() <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">true</span>).mtime;</span>
<span class="line" id="L637">            man.cache.recent_problematic_timestamp = man.recent_problematic_timestamp;</span>
<span class="line" id="L638">        }</span>
<span class="line" id="L639"></span>
<span class="line" id="L640">        <span class="tok-kw">return</span> file_time &gt;= man.recent_problematic_timestamp;</span>
<span class="line" id="L641">    }</span>
<span class="line" id="L642"></span>
<span class="line" id="L643">    <span class="tok-kw">fn</span> <span class="tok-fn">populateFileHash</span>(self: *Manifest, ch_file: *File) !<span class="tok-type">void</span> {</span>
<span class="line" id="L644">        <span class="tok-kw">const</span> pp = ch_file.prefixed_path.?;</span>
<span class="line" id="L645">        <span class="tok-kw">const</span> dir = self.cache.prefixes()[pp.prefix].handle;</span>
<span class="line" id="L646">        <span class="tok-kw">const</span> file = <span class="tok-kw">try</span> dir.openFile(pp.sub_path, .{});</span>
<span class="line" id="L647">        <span class="tok-kw">defer</span> file.close();</span>
<span class="line" id="L648"></span>
<span class="line" id="L649">        <span class="tok-kw">const</span> actual_stat = <span class="tok-kw">try</span> file.stat();</span>
<span class="line" id="L650">        ch_file.stat = .{</span>
<span class="line" id="L651">            .size = actual_stat.size,</span>
<span class="line" id="L652">            .mtime = actual_stat.mtime,</span>
<span class="line" id="L653">            .inode = actual_stat.inode,</span>
<span class="line" id="L654">        };</span>
<span class="line" id="L655"></span>
<span class="line" id="L656">        <span class="tok-kw">if</span> (self.isProblematicTimestamp(ch_file.stat.mtime)) {</span>
<span class="line" id="L657">            <span class="tok-comment">// The actual file has an unreliable timestamp, force it to be hashed</span>
</span>
<span class="line" id="L658">            ch_file.stat.mtime = <span class="tok-number">0</span>;</span>
<span class="line" id="L659">            ch_file.stat.inode = <span class="tok-number">0</span>;</span>
<span class="line" id="L660">        }</span>
<span class="line" id="L661"></span>
<span class="line" id="L662">        <span class="tok-kw">if</span> (ch_file.max_file_size) |max_file_size| {</span>
<span class="line" id="L663">            <span class="tok-kw">if</span> (ch_file.stat.size &gt; max_file_size) {</span>
<span class="line" id="L664">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig;</span>
<span class="line" id="L665">            }</span>
<span class="line" id="L666"></span>
<span class="line" id="L667">            <span class="tok-kw">const</span> contents = <span class="tok-kw">try</span> self.cache.gpa.alloc(<span class="tok-type">u8</span>, <span class="tok-builtin">@intCast</span>(<span class="tok-type">usize</span>, ch_file.stat.size));</span>
<span class="line" id="L668">            <span class="tok-kw">errdefer</span> self.cache.gpa.free(contents);</span>
<span class="line" id="L669"></span>
<span class="line" id="L670">            <span class="tok-comment">// Hash while reading from disk, to keep the contents in the cpu cache while</span>
</span>
<span class="line" id="L671">            <span class="tok-comment">// doing hashing.</span>
</span>
<span class="line" id="L672">            <span class="tok-kw">var</span> hasher = hasher_init;</span>
<span class="line" id="L673">            <span class="tok-kw">var</span> off: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L674">            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L675">                <span class="tok-comment">// give me everything you've got, captain</span>
</span>
<span class="line" id="L676">                <span class="tok-kw">const</span> bytes_read = <span class="tok-kw">try</span> file.read(contents[off..]);</span>
<span class="line" id="L677">                <span class="tok-kw">if</span> (bytes_read == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;</span>
<span class="line" id="L678">                hasher.update(contents[off..][<span class="tok-number">0</span>..bytes_read]);</span>
<span class="line" id="L679">                off += bytes_read;</span>
<span class="line" id="L680">            }</span>
<span class="line" id="L681">            hasher.final(&amp;ch_file.bin_digest);</span>
<span class="line" id="L682"></span>
<span class="line" id="L683">            ch_file.contents = contents;</span>
<span class="line" id="L684">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L685">            <span class="tok-kw">try</span> hashFile(file, &amp;ch_file.bin_digest);</span>
<span class="line" id="L686">        }</span>
<span class="line" id="L687"></span>
<span class="line" id="L688">        self.hash.hasher.update(&amp;ch_file.bin_digest);</span>
<span class="line" id="L689">    }</span>
<span class="line" id="L690"></span>
<span class="line" id="L691">    <span class="tok-comment">/// Add a file as a dependency of process being cached, after the initial hash has been</span></span>
<span class="line" id="L692">    <span class="tok-comment">/// calculated. This is useful for processes that don't know all the files that</span></span>
<span class="line" id="L693">    <span class="tok-comment">/// are depended on ahead of time. For example, a source file that can import other files</span></span>
<span class="line" id="L694">    <span class="tok-comment">/// will need to be recompiled if the imported file is changed.</span></span>
<span class="line" id="L695">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFilePostFetch</span>(self: *Manifest, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, max_file_size: <span class="tok-type">usize</span>) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L696">        assert(self.manifest_file != <span class="tok-null">null</span>);</span>
<span class="line" id="L697"></span>
<span class="line" id="L698">        <span class="tok-kw">const</span> gpa = self.cache.gpa;</span>
<span class="line" id="L699">        <span class="tok-kw">const</span> prefixed_path = <span class="tok-kw">try</span> self.cache.findPrefix(file_path);</span>
<span class="line" id="L700">        <span class="tok-kw">errdefer</span> gpa.free(prefixed_path.sub_path);</span>
<span class="line" id="L701"></span>
<span class="line" id="L702">        <span class="tok-kw">const</span> new_ch_file = <span class="tok-kw">try</span> self.files.addOne(gpa);</span>
<span class="line" id="L703">        new_ch_file.* = .{</span>
<span class="line" id="L704">            .prefixed_path = prefixed_path,</span>
<span class="line" id="L705">            .max_file_size = max_file_size,</span>
<span class="line" id="L706">            .stat = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L707">            .bin_digest = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L708">            .contents = <span class="tok-null">null</span>,</span>
<span class="line" id="L709">        };</span>
<span class="line" id="L710">        <span class="tok-kw">errdefer</span> self.files.shrinkRetainingCapacity(self.files.items.len - <span class="tok-number">1</span>);</span>
<span class="line" id="L711"></span>
<span class="line" id="L712">        <span class="tok-kw">try</span> self.populateFileHash(new_ch_file);</span>
<span class="line" id="L713"></span>
<span class="line" id="L714">        <span class="tok-kw">return</span> new_ch_file.contents.?;</span>
<span class="line" id="L715">    }</span>
<span class="line" id="L716"></span>
<span class="line" id="L717">    <span class="tok-comment">/// Add a file as a dependency of process being cached, after the initial hash has been</span></span>
<span class="line" id="L718">    <span class="tok-comment">/// calculated. This is useful for processes that don't know the all the files that</span></span>
<span class="line" id="L719">    <span class="tok-comment">/// are depended on ahead of time. For example, a source file that can import other files</span></span>
<span class="line" id="L720">    <span class="tok-comment">/// will need to be recompiled if the imported file is changed.</span></span>
<span class="line" id="L721">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFilePost</span>(self: *Manifest, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L722">        assert(self.manifest_file != <span class="tok-null">null</span>);</span>
<span class="line" id="L723"></span>
<span class="line" id="L724">        <span class="tok-kw">const</span> gpa = self.cache.gpa;</span>
<span class="line" id="L725">        <span class="tok-kw">const</span> prefixed_path = <span class="tok-kw">try</span> self.cache.findPrefix(file_path);</span>
<span class="line" id="L726">        <span class="tok-kw">errdefer</span> gpa.free(prefixed_path.sub_path);</span>
<span class="line" id="L727"></span>
<span class="line" id="L728">        <span class="tok-kw">const</span> new_ch_file = <span class="tok-kw">try</span> self.files.addOne(gpa);</span>
<span class="line" id="L729">        new_ch_file.* = .{</span>
<span class="line" id="L730">            .prefixed_path = prefixed_path,</span>
<span class="line" id="L731">            .max_file_size = <span class="tok-null">null</span>,</span>
<span class="line" id="L732">            .stat = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L733">            .bin_digest = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L734">            .contents = <span class="tok-null">null</span>,</span>
<span class="line" id="L735">        };</span>
<span class="line" id="L736">        <span class="tok-kw">errdefer</span> self.files.shrinkRetainingCapacity(self.files.items.len - <span class="tok-number">1</span>);</span>
<span class="line" id="L737"></span>
<span class="line" id="L738">        <span class="tok-kw">try</span> self.populateFileHash(new_ch_file);</span>
<span class="line" id="L739">    }</span>
<span class="line" id="L740"></span>
<span class="line" id="L741">    <span class="tok-comment">/// Like `addFilePost` but when the file contents have already been loaded from disk.</span></span>
<span class="line" id="L742">    <span class="tok-comment">/// On success, cache takes ownership of `resolved_path`.</span></span>
<span class="line" id="L743">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFilePostContents</span>(</span>
<span class="line" id="L744">        self: *Manifest,</span>
<span class="line" id="L745">        resolved_path: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L746">        bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L747">        stat: File.Stat,</span>
<span class="line" id="L748">    ) <span class="tok-kw">error</span>{OutOfMemory}!<span class="tok-type">void</span> {</span>
<span class="line" id="L749">        assert(self.manifest_file != <span class="tok-null">null</span>);</span>
<span class="line" id="L750">        <span class="tok-kw">const</span> gpa = self.cache.gpa;</span>
<span class="line" id="L751"></span>
<span class="line" id="L752">        <span class="tok-kw">const</span> ch_file = <span class="tok-kw">try</span> self.files.addOne(gpa);</span>
<span class="line" id="L753">        <span class="tok-kw">errdefer</span> self.files.shrinkRetainingCapacity(self.files.items.len - <span class="tok-number">1</span>);</span>
<span class="line" id="L754"></span>
<span class="line" id="L755">        <span class="tok-kw">const</span> prefixed_path = <span class="tok-kw">try</span> self.cache.findPrefixResolved(resolved_path);</span>
<span class="line" id="L756">        <span class="tok-kw">errdefer</span> gpa.free(prefixed_path.sub_path);</span>
<span class="line" id="L757"></span>
<span class="line" id="L758">        ch_file.* = .{</span>
<span class="line" id="L759">            .prefixed_path = prefixed_path,</span>
<span class="line" id="L760">            .max_file_size = <span class="tok-null">null</span>,</span>
<span class="line" id="L761">            .stat = stat,</span>
<span class="line" id="L762">            .bin_digest = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L763">            .contents = <span class="tok-null">null</span>,</span>
<span class="line" id="L764">        };</span>
<span class="line" id="L765"></span>
<span class="line" id="L766">        <span class="tok-kw">if</span> (self.isProblematicTimestamp(ch_file.stat.mtime)) {</span>
<span class="line" id="L767">            <span class="tok-comment">// The actual file has an unreliable timestamp, force it to be hashed</span>
</span>
<span class="line" id="L768">            ch_file.stat.mtime = <span class="tok-number">0</span>;</span>
<span class="line" id="L769">            ch_file.stat.inode = <span class="tok-number">0</span>;</span>
<span class="line" id="L770">        }</span>
<span class="line" id="L771"></span>
<span class="line" id="L772">        {</span>
<span class="line" id="L773">            <span class="tok-kw">var</span> hasher = hasher_init;</span>
<span class="line" id="L774">            hasher.update(bytes);</span>
<span class="line" id="L775">            hasher.final(&amp;ch_file.bin_digest);</span>
<span class="line" id="L776">        }</span>
<span class="line" id="L777"></span>
<span class="line" id="L778">        self.hash.hasher.update(&amp;ch_file.bin_digest);</span>
<span class="line" id="L779">    }</span>
<span class="line" id="L780"></span>
<span class="line" id="L781">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addDepFilePost</span>(self: *Manifest, dir: fs.Dir, dep_file_basename: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L782">        assert(self.manifest_file != <span class="tok-null">null</span>);</span>
<span class="line" id="L783"></span>
<span class="line" id="L784">        <span class="tok-kw">const</span> dep_file_contents = <span class="tok-kw">try</span> dir.readFileAlloc(self.cache.gpa, dep_file_basename, manifest_file_size_max);</span>
<span class="line" id="L785">        <span class="tok-kw">defer</span> self.cache.gpa.free(dep_file_contents);</span>
<span class="line" id="L786"></span>
<span class="line" id="L787">        <span class="tok-kw">var</span> error_buf = std.ArrayList(<span class="tok-type">u8</span>).init(self.cache.gpa);</span>
<span class="line" id="L788">        <span class="tok-kw">defer</span> error_buf.deinit();</span>
<span class="line" id="L789"></span>
<span class="line" id="L790">        <span class="tok-kw">var</span> it: DepTokenizer = .{ .bytes = dep_file_contents };</span>
<span class="line" id="L791"></span>
<span class="line" id="L792">        <span class="tok-comment">// Skip first token: target.</span>
</span>
<span class="line" id="L793">        <span class="tok-kw">switch</span> (it.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>) { <span class="tok-comment">// Empty dep file OK.</span>
</span>
<span class="line" id="L794">            .target, .target_must_resolve, .prereq =&gt; {},</span>
<span class="line" id="L795">            <span class="tok-kw">else</span> =&gt; |err| {</span>
<span class="line" id="L796">                <span class="tok-kw">try</span> err.printError(error_buf.writer());</span>
<span class="line" id="L797">                log.err(<span class="tok-str">&quot;failed parsing {s}: {s}&quot;</span>, .{ dep_file_basename, error_buf.items });</span>
<span class="line" id="L798">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDepFile;</span>
<span class="line" id="L799">            },</span>
<span class="line" id="L800">        }</span>
<span class="line" id="L801">        <span class="tok-comment">// Process 0+ preqreqs.</span>
</span>
<span class="line" id="L802">        <span class="tok-comment">// Clang is invoked in single-source mode so we never get more targets.</span>
</span>
<span class="line" id="L803">        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L804">            <span class="tok-kw">switch</span> (it.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>) {</span>
<span class="line" id="L805">                .target, .target_must_resolve =&gt; <span class="tok-kw">return</span>,</span>
<span class="line" id="L806">                .prereq =&gt; |file_path| <span class="tok-kw">try</span> self.addFilePost(file_path),</span>
<span class="line" id="L807">                <span class="tok-kw">else</span> =&gt; |err| {</span>
<span class="line" id="L808">                    <span class="tok-kw">try</span> err.printError(error_buf.writer());</span>
<span class="line" id="L809">                    log.err(<span class="tok-str">&quot;failed parsing {s}: {s}&quot;</span>, .{ dep_file_basename, error_buf.items });</span>
<span class="line" id="L810">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDepFile;</span>
<span class="line" id="L811">                },</span>
<span class="line" id="L812">            }</span>
<span class="line" id="L813">        }</span>
<span class="line" id="L814">    }</span>
<span class="line" id="L815"></span>
<span class="line" id="L816">    <span class="tok-comment">/// Returns a hex encoded hash of the inputs.</span></span>
<span class="line" id="L817">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">final</span>(self: *Manifest) [hex_digest_len]<span class="tok-type">u8</span> {</span>
<span class="line" id="L818">        assert(self.manifest_file != <span class="tok-null">null</span>);</span>
<span class="line" id="L819"></span>
<span class="line" id="L820">        <span class="tok-comment">// We don't close the manifest file yet, because we want to</span>
</span>
<span class="line" id="L821">        <span class="tok-comment">// keep it locked until the API user is done using it.</span>
</span>
<span class="line" id="L822">        <span class="tok-comment">// We also don't write out the manifest yet, because until</span>
</span>
<span class="line" id="L823">        <span class="tok-comment">// cache_release is called we still might be working on creating</span>
</span>
<span class="line" id="L824">        <span class="tok-comment">// the artifacts to cache.</span>
</span>
<span class="line" id="L825"></span>
<span class="line" id="L826">        <span class="tok-kw">var</span> bin_digest: BinDigest = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L827">        self.hash.hasher.final(&amp;bin_digest);</span>
<span class="line" id="L828"></span>
<span class="line" id="L829">        <span class="tok-kw">var</span> out_digest: [hex_digest_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L830">        _ = fmt.bufPrint(</span>
<span class="line" id="L831">            &amp;out_digest,</span>
<span class="line" id="L832">            <span class="tok-str">&quot;{s}&quot;</span>,</span>
<span class="line" id="L833">            .{fmt.fmtSliceHexLower(&amp;bin_digest)},</span>
<span class="line" id="L834">        ) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L835"></span>
<span class="line" id="L836">        <span class="tok-kw">return</span> out_digest;</span>
<span class="line" id="L837">    }</span>
<span class="line" id="L838"></span>
<span class="line" id="L839">    <span class="tok-comment">/// If `want_shared_lock` is true, this function automatically downgrades the</span></span>
<span class="line" id="L840">    <span class="tok-comment">/// lock from exclusive to shared.</span></span>
<span class="line" id="L841">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeManifest</span>(self: *Manifest) !<span class="tok-type">void</span> {</span>
<span class="line" id="L842">        assert(self.have_exclusive_lock);</span>
<span class="line" id="L843"></span>
<span class="line" id="L844">        <span class="tok-kw">const</span> manifest_file = self.manifest_file.?;</span>
<span class="line" id="L845">        <span class="tok-kw">if</span> (self.manifest_dirty) {</span>
<span class="line" id="L846">            self.manifest_dirty = <span class="tok-null">false</span>;</span>
<span class="line" id="L847"></span>
<span class="line" id="L848">            <span class="tok-kw">var</span> contents = std.ArrayList(<span class="tok-type">u8</span>).init(self.cache.gpa);</span>
<span class="line" id="L849">            <span class="tok-kw">defer</span> contents.deinit();</span>
<span class="line" id="L850"></span>
<span class="line" id="L851">            <span class="tok-kw">const</span> writer = contents.writer();</span>
<span class="line" id="L852">            <span class="tok-kw">var</span> encoded_digest: [hex_digest_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L853"></span>
<span class="line" id="L854">            <span class="tok-kw">for</span> (self.files.items) |file| {</span>
<span class="line" id="L855">                _ = fmt.bufPrint(</span>
<span class="line" id="L856">                    &amp;encoded_digest,</span>
<span class="line" id="L857">                    <span class="tok-str">&quot;{s}&quot;</span>,</span>
<span class="line" id="L858">                    .{fmt.fmtSliceHexLower(&amp;file.bin_digest)},</span>
<span class="line" id="L859">                ) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L860">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{d} {d} {d} {s} {d} {s}\n&quot;</span>, .{</span>
<span class="line" id="L861">                    file.stat.size,</span>
<span class="line" id="L862">                    file.stat.inode,</span>
<span class="line" id="L863">                    file.stat.mtime,</span>
<span class="line" id="L864">                    &amp;encoded_digest,</span>
<span class="line" id="L865">                    file.prefixed_path.?.prefix,</span>
<span class="line" id="L866">                    file.prefixed_path.?.sub_path,</span>
<span class="line" id="L867">                });</span>
<span class="line" id="L868">            }</span>
<span class="line" id="L869"></span>
<span class="line" id="L870">            <span class="tok-kw">try</span> manifest_file.setEndPos(contents.items.len);</span>
<span class="line" id="L871">            <span class="tok-kw">try</span> manifest_file.pwriteAll(contents.items, <span class="tok-number">0</span>);</span>
<span class="line" id="L872">        }</span>
<span class="line" id="L873"></span>
<span class="line" id="L874">        <span class="tok-kw">if</span> (self.want_shared_lock) {</span>
<span class="line" id="L875">            <span class="tok-kw">try</span> self.downgradeToSharedLock();</span>
<span class="line" id="L876">        }</span>
<span class="line" id="L877">    }</span>
<span class="line" id="L878"></span>
<span class="line" id="L879">    <span class="tok-kw">fn</span> <span class="tok-fn">downgradeToSharedLock</span>(self: *Manifest) !<span class="tok-type">void</span> {</span>
<span class="line" id="L880">        <span class="tok-kw">if</span> (!self.have_exclusive_lock) <span class="tok-kw">return</span>;</span>
<span class="line" id="L881"></span>
<span class="line" id="L882">        <span class="tok-comment">// WASI does not currently support flock, so we bypass it here.</span>
</span>
<span class="line" id="L883">        <span class="tok-comment">// TODO: If/when flock is supported on WASI, this check should be removed.</span>
</span>
<span class="line" id="L884">        <span class="tok-comment">//       See https://github.com/WebAssembly/wasi-filesystem/issues/2</span>
</span>
<span class="line" id="L885">        <span class="tok-kw">if</span> (builtin.os.tag != .wasi <span class="tok-kw">or</span> std.process.can_spawn <span class="tok-kw">or</span> !builtin.single_threaded) {</span>
<span class="line" id="L886">            <span class="tok-kw">const</span> manifest_file = self.manifest_file.?;</span>
<span class="line" id="L887">            <span class="tok-kw">try</span> manifest_file.downgradeLock();</span>
<span class="line" id="L888">        }</span>
<span class="line" id="L889"></span>
<span class="line" id="L890">        self.have_exclusive_lock = <span class="tok-null">false</span>;</span>
<span class="line" id="L891">    }</span>
<span class="line" id="L892"></span>
<span class="line" id="L893">    <span class="tok-kw">fn</span> <span class="tok-fn">upgradeToExclusiveLock</span>(self: *Manifest) !<span class="tok-type">void</span> {</span>
<span class="line" id="L894">        <span class="tok-kw">if</span> (self.have_exclusive_lock) <span class="tok-kw">return</span>;</span>
<span class="line" id="L895">        assert(self.manifest_file != <span class="tok-null">null</span>);</span>
<span class="line" id="L896"></span>
<span class="line" id="L897">        <span class="tok-comment">// WASI does not currently support flock, so we bypass it here.</span>
</span>
<span class="line" id="L898">        <span class="tok-comment">// TODO: If/when flock is supported on WASI, this check should be removed.</span>
</span>
<span class="line" id="L899">        <span class="tok-comment">//       See https://github.com/WebAssembly/wasi-filesystem/issues/2</span>
</span>
<span class="line" id="L900">        <span class="tok-kw">if</span> (builtin.os.tag != .wasi <span class="tok-kw">or</span> std.process.can_spawn <span class="tok-kw">or</span> !builtin.single_threaded) {</span>
<span class="line" id="L901">            <span class="tok-kw">const</span> manifest_file = self.manifest_file.?;</span>
<span class="line" id="L902">            <span class="tok-comment">// Here we intentionally have a period where the lock is released, in case there are</span>
</span>
<span class="line" id="L903">            <span class="tok-comment">// other processes holding a shared lock.</span>
</span>
<span class="line" id="L904">            manifest_file.unlock();</span>
<span class="line" id="L905">            <span class="tok-kw">try</span> manifest_file.lock(.Exclusive);</span>
<span class="line" id="L906">        }</span>
<span class="line" id="L907">        self.have_exclusive_lock = <span class="tok-null">true</span>;</span>
<span class="line" id="L908">    }</span>
<span class="line" id="L909"></span>
<span class="line" id="L910">    <span class="tok-comment">/// Obtain only the data needed to maintain a lock on the manifest file.</span></span>
<span class="line" id="L911">    <span class="tok-comment">/// The `Manifest` remains safe to deinit.</span></span>
<span class="line" id="L912">    <span class="tok-comment">/// Don't forget to call `writeManifest` before this!</span></span>
<span class="line" id="L913">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toOwnedLock</span>(self: *Manifest) Lock {</span>
<span class="line" id="L914">        <span class="tok-kw">const</span> lock: Lock = .{</span>
<span class="line" id="L915">            .manifest_file = self.manifest_file.?,</span>
<span class="line" id="L916">        };</span>
<span class="line" id="L917"></span>
<span class="line" id="L918">        self.manifest_file = <span class="tok-null">null</span>;</span>
<span class="line" id="L919">        <span class="tok-kw">return</span> lock;</span>
<span class="line" id="L920">    }</span>
<span class="line" id="L921"></span>
<span class="line" id="L922">    <span class="tok-comment">/// Releases the manifest file and frees any memory the Manifest was using.</span></span>
<span class="line" id="L923">    <span class="tok-comment">/// `Manifest.hit` must be called first.</span></span>
<span class="line" id="L924">    <span class="tok-comment">/// Don't forget to call `writeManifest` before this!</span></span>
<span class="line" id="L925">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *Manifest) <span class="tok-type">void</span> {</span>
<span class="line" id="L926">        <span class="tok-kw">if</span> (self.manifest_file) |file| {</span>
<span class="line" id="L927">            <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L928">                <span class="tok-comment">// See Lock.release for why this is required on Windows</span>
</span>
<span class="line" id="L929">                file.unlock();</span>
<span class="line" id="L930">            }</span>
<span class="line" id="L931"></span>
<span class="line" id="L932">            file.close();</span>
<span class="line" id="L933">        }</span>
<span class="line" id="L934">        <span class="tok-kw">for</span> (self.files.items) |*file| {</span>
<span class="line" id="L935">            file.deinit(self.cache.gpa);</span>
<span class="line" id="L936">        }</span>
<span class="line" id="L937">        self.files.deinit(self.cache.gpa);</span>
<span class="line" id="L938">    }</span>
<span class="line" id="L939">};</span>
<span class="line" id="L940"></span>
<span class="line" id="L941"><span class="tok-comment">/// On operating systems that support symlinks, does a readlink. On other operating systems,</span></span>
<span class="line" id="L942"><span class="tok-comment">/// uses the file contents. Windows supports symlinks but only with elevated privileges, so</span></span>
<span class="line" id="L943"><span class="tok-comment">/// it is treated as not supporting symlinks.</span></span>
<span class="line" id="L944"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readSmallFile</span>(dir: fs.Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L945">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L946">        <span class="tok-kw">return</span> dir.readFile(sub_path, buffer);</span>
<span class="line" id="L947">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L948">        <span class="tok-kw">return</span> dir.readLink(sub_path, buffer);</span>
<span class="line" id="L949">    }</span>
<span class="line" id="L950">}</span>
<span class="line" id="L951"></span>
<span class="line" id="L952"><span class="tok-comment">/// On operating systems that support symlinks, does a symlink. On other operating systems,</span></span>
<span class="line" id="L953"><span class="tok-comment">/// uses the file contents. Windows supports symlinks but only with elevated privileges, so</span></span>
<span class="line" id="L954"><span class="tok-comment">/// it is treated as not supporting symlinks.</span></span>
<span class="line" id="L955"><span class="tok-comment">/// `data` must be a valid UTF-8 encoded file path and 255 bytes or fewer.</span></span>
<span class="line" id="L956"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeSmallFile</span>(dir: fs.Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L957">    assert(data.len &lt;= <span class="tok-number">255</span>);</span>
<span class="line" id="L958">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L959">        <span class="tok-kw">return</span> dir.writeFile(sub_path, data);</span>
<span class="line" id="L960">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L961">        <span class="tok-kw">return</span> dir.symLink(data, sub_path, .{});</span>
<span class="line" id="L962">    }</span>
<span class="line" id="L963">}</span>
<span class="line" id="L964"></span>
<span class="line" id="L965"><span class="tok-kw">fn</span> <span class="tok-fn">hashFile</span>(file: fs.File, bin_digest: *[Hasher.mac_length]<span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L966">    <span class="tok-kw">var</span> buf: [<span class="tok-number">1024</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L967"></span>
<span class="line" id="L968">    <span class="tok-kw">var</span> hasher = hasher_init;</span>
<span class="line" id="L969">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L970">        <span class="tok-kw">const</span> bytes_read = <span class="tok-kw">try</span> file.read(&amp;buf);</span>
<span class="line" id="L971">        <span class="tok-kw">if</span> (bytes_read == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;</span>
<span class="line" id="L972">        hasher.update(buf[<span class="tok-number">0</span>..bytes_read]);</span>
<span class="line" id="L973">    }</span>
<span class="line" id="L974"></span>
<span class="line" id="L975">    hasher.final(bin_digest);</span>
<span class="line" id="L976">}</span>
<span class="line" id="L977"></span>
<span class="line" id="L978"><span class="tok-comment">// Create/Write a file, close it, then grab its stat.mtime timestamp.</span>
</span>
<span class="line" id="L979"><span class="tok-kw">fn</span> <span class="tok-fn">testGetCurrentFileTimestamp</span>(dir: fs.Dir) !<span class="tok-type">i128</span> {</span>
<span class="line" id="L980">    <span class="tok-kw">const</span> test_out_file = <span class="tok-str">&quot;test-filetimestamp.tmp&quot;</span>;</span>
<span class="line" id="L981"></span>
<span class="line" id="L982">    <span class="tok-kw">var</span> file = <span class="tok-kw">try</span> dir.createFile(test_out_file, .{</span>
<span class="line" id="L983">        .read = <span class="tok-null">true</span>,</span>
<span class="line" id="L984">        .truncate = <span class="tok-null">true</span>,</span>
<span class="line" id="L985">    });</span>
<span class="line" id="L986">    <span class="tok-kw">defer</span> {</span>
<span class="line" id="L987">        file.close();</span>
<span class="line" id="L988">        dir.deleteFile(test_out_file) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L989">    }</span>
<span class="line" id="L990"></span>
<span class="line" id="L991">    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> file.stat()).mtime;</span>
<span class="line" id="L992">}</span>
<span class="line" id="L993"></span>
<span class="line" id="L994"><span class="tok-kw">test</span> <span class="tok-str">&quot;cache file and then recall it&quot;</span> {</span>
<span class="line" id="L995">    <span class="tok-kw">if</span> (builtin.os.tag == .wasi) {</span>
<span class="line" id="L996">        <span class="tok-comment">// https://github.com/ziglang/zig/issues/5437</span>
</span>
<span class="line" id="L997">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;</span>
<span class="line" id="L998">    }</span>
<span class="line" id="L999"></span>
<span class="line" id="L1000">    <span class="tok-kw">var</span> tmp = testing.tmpDir(.{});</span>
<span class="line" id="L1001">    <span class="tok-kw">defer</span> tmp.cleanup();</span>
<span class="line" id="L1002"></span>
<span class="line" id="L1003">    <span class="tok-kw">const</span> temp_file = <span class="tok-str">&quot;test.txt&quot;</span>;</span>
<span class="line" id="L1004">    <span class="tok-kw">const</span> temp_manifest_dir = <span class="tok-str">&quot;temp_manifest_dir&quot;</span>;</span>
<span class="line" id="L1005"></span>
<span class="line" id="L1006">    <span class="tok-kw">try</span> tmp.dir.writeFile(temp_file, <span class="tok-str">&quot;Hello, world!\n&quot;</span>);</span>
<span class="line" id="L1007"></span>
<span class="line" id="L1008">    <span class="tok-comment">// Wait for file timestamps to tick</span>
</span>
<span class="line" id="L1009">    <span class="tok-kw">const</span> initial_time = <span class="tok-kw">try</span> testGetCurrentFileTimestamp(tmp.dir);</span>
<span class="line" id="L1010">    <span class="tok-kw">while</span> ((<span class="tok-kw">try</span> testGetCurrentFileTimestamp(tmp.dir)) == initial_time) {</span>
<span class="line" id="L1011">        std.time.sleep(<span class="tok-number">1</span>);</span>
<span class="line" id="L1012">    }</span>
<span class="line" id="L1013"></span>
<span class="line" id="L1014">    <span class="tok-kw">var</span> digest1: [hex_digest_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1015">    <span class="tok-kw">var</span> digest2: [hex_digest_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1016"></span>
<span class="line" id="L1017">    {</span>
<span class="line" id="L1018">        <span class="tok-kw">var</span> cache = Cache{</span>
<span class="line" id="L1019">            .gpa = testing.allocator,</span>
<span class="line" id="L1020">            .manifest_dir = <span class="tok-kw">try</span> tmp.dir.makeOpenPath(temp_manifest_dir, .{}),</span>
<span class="line" id="L1021">        };</span>
<span class="line" id="L1022">        cache.addPrefix(.{ .path = <span class="tok-null">null</span>, .handle = tmp.dir });</span>
<span class="line" id="L1023">        <span class="tok-kw">defer</span> cache.manifest_dir.close();</span>
<span class="line" id="L1024"></span>
<span class="line" id="L1025">        {</span>
<span class="line" id="L1026">            <span class="tok-kw">var</span> ch = cache.obtain();</span>
<span class="line" id="L1027">            <span class="tok-kw">defer</span> ch.deinit();</span>
<span class="line" id="L1028"></span>
<span class="line" id="L1029">            ch.hash.add(<span class="tok-null">true</span>);</span>
<span class="line" id="L1030">            ch.hash.add(<span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-number">1234</span>));</span>
<span class="line" id="L1031">            ch.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);</span>
<span class="line" id="L1032">            _ = <span class="tok-kw">try</span> ch.addFile(temp_file, <span class="tok-null">null</span>);</span>
<span class="line" id="L1033"></span>
<span class="line" id="L1034">            <span class="tok-comment">// There should be nothing in the cache</span>
</span>
<span class="line" id="L1035">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-null">false</span>, <span class="tok-kw">try</span> ch.hit());</span>
<span class="line" id="L1036"></span>
<span class="line" id="L1037">            digest1 = ch.final();</span>
<span class="line" id="L1038">            <span class="tok-kw">try</span> ch.writeManifest();</span>
<span class="line" id="L1039">        }</span>
<span class="line" id="L1040">        {</span>
<span class="line" id="L1041">            <span class="tok-kw">var</span> ch = cache.obtain();</span>
<span class="line" id="L1042">            <span class="tok-kw">defer</span> ch.deinit();</span>
<span class="line" id="L1043"></span>
<span class="line" id="L1044">            ch.hash.add(<span class="tok-null">true</span>);</span>
<span class="line" id="L1045">            ch.hash.add(<span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-number">1234</span>));</span>
<span class="line" id="L1046">            ch.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);</span>
<span class="line" id="L1047">            _ = <span class="tok-kw">try</span> ch.addFile(temp_file, <span class="tok-null">null</span>);</span>
<span class="line" id="L1048"></span>
<span class="line" id="L1049">            <span class="tok-comment">// Cache hit! We just &quot;built&quot; the same file</span>
</span>
<span class="line" id="L1050">            <span class="tok-kw">try</span> testing.expect(<span class="tok-kw">try</span> ch.hit());</span>
<span class="line" id="L1051">            digest2 = ch.final();</span>
<span class="line" id="L1052"></span>
<span class="line" id="L1053">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-null">false</span>, ch.have_exclusive_lock);</span>
<span class="line" id="L1054">        }</span>
<span class="line" id="L1055"></span>
<span class="line" id="L1056">        <span class="tok-kw">try</span> testing.expectEqual(digest1, digest2);</span>
<span class="line" id="L1057">    }</span>
<span class="line" id="L1058">}</span>
<span class="line" id="L1059"></span>
<span class="line" id="L1060"><span class="tok-kw">test</span> <span class="tok-str">&quot;check that changing a file makes cache fail&quot;</span> {</span>
<span class="line" id="L1061">    <span class="tok-kw">if</span> (builtin.os.tag == .wasi) {</span>
<span class="line" id="L1062">        <span class="tok-comment">// https://github.com/ziglang/zig/issues/5437</span>
</span>
<span class="line" id="L1063">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;</span>
<span class="line" id="L1064">    }</span>
<span class="line" id="L1065">    <span class="tok-kw">var</span> tmp = testing.tmpDir(.{});</span>
<span class="line" id="L1066">    <span class="tok-kw">defer</span> tmp.cleanup();</span>
<span class="line" id="L1067"></span>
<span class="line" id="L1068">    <span class="tok-kw">const</span> temp_file = <span class="tok-str">&quot;cache_hash_change_file_test.txt&quot;</span>;</span>
<span class="line" id="L1069">    <span class="tok-kw">const</span> temp_manifest_dir = <span class="tok-str">&quot;cache_hash_change_file_manifest_dir&quot;</span>;</span>
<span class="line" id="L1070">    <span class="tok-kw">const</span> original_temp_file_contents = <span class="tok-str">&quot;Hello, world!\n&quot;</span>;</span>
<span class="line" id="L1071">    <span class="tok-kw">const</span> updated_temp_file_contents = <span class="tok-str">&quot;Hello, world; but updated!\n&quot;</span>;</span>
<span class="line" id="L1072"></span>
<span class="line" id="L1073">    <span class="tok-kw">try</span> tmp.dir.writeFile(temp_file, original_temp_file_contents);</span>
<span class="line" id="L1074"></span>
<span class="line" id="L1075">    <span class="tok-comment">// Wait for file timestamps to tick</span>
</span>
<span class="line" id="L1076">    <span class="tok-kw">const</span> initial_time = <span class="tok-kw">try</span> testGetCurrentFileTimestamp(tmp.dir);</span>
<span class="line" id="L1077">    <span class="tok-kw">while</span> ((<span class="tok-kw">try</span> testGetCurrentFileTimestamp(tmp.dir)) == initial_time) {</span>
<span class="line" id="L1078">        std.time.sleep(<span class="tok-number">1</span>);</span>
<span class="line" id="L1079">    }</span>
<span class="line" id="L1080"></span>
<span class="line" id="L1081">    <span class="tok-kw">var</span> digest1: [hex_digest_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1082">    <span class="tok-kw">var</span> digest2: [hex_digest_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1083"></span>
<span class="line" id="L1084">    {</span>
<span class="line" id="L1085">        <span class="tok-kw">var</span> cache = Cache{</span>
<span class="line" id="L1086">            .gpa = testing.allocator,</span>
<span class="line" id="L1087">            .manifest_dir = <span class="tok-kw">try</span> tmp.dir.makeOpenPath(temp_manifest_dir, .{}),</span>
<span class="line" id="L1088">        };</span>
<span class="line" id="L1089">        cache.addPrefix(.{ .path = <span class="tok-null">null</span>, .handle = tmp.dir });</span>
<span class="line" id="L1090">        <span class="tok-kw">defer</span> cache.manifest_dir.close();</span>
<span class="line" id="L1091"></span>
<span class="line" id="L1092">        {</span>
<span class="line" id="L1093">            <span class="tok-kw">var</span> ch = cache.obtain();</span>
<span class="line" id="L1094">            <span class="tok-kw">defer</span> ch.deinit();</span>
<span class="line" id="L1095"></span>
<span class="line" id="L1096">            ch.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);</span>
<span class="line" id="L1097">            <span class="tok-kw">const</span> temp_file_idx = <span class="tok-kw">try</span> ch.addFile(temp_file, <span class="tok-number">100</span>);</span>
<span class="line" id="L1098"></span>
<span class="line" id="L1099">            <span class="tok-comment">// There should be nothing in the cache</span>
</span>
<span class="line" id="L1100">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-null">false</span>, <span class="tok-kw">try</span> ch.hit());</span>
<span class="line" id="L1101"></span>
<span class="line" id="L1102">            <span class="tok-kw">try</span> testing.expect(mem.eql(<span class="tok-type">u8</span>, original_temp_file_contents, ch.files.items[temp_file_idx].contents.?));</span>
<span class="line" id="L1103"></span>
<span class="line" id="L1104">            digest1 = ch.final();</span>
<span class="line" id="L1105"></span>
<span class="line" id="L1106">            <span class="tok-kw">try</span> ch.writeManifest();</span>
<span class="line" id="L1107">        }</span>
<span class="line" id="L1108"></span>
<span class="line" id="L1109">        <span class="tok-kw">try</span> tmp.dir.writeFile(temp_file, updated_temp_file_contents);</span>
<span class="line" id="L1110"></span>
<span class="line" id="L1111">        {</span>
<span class="line" id="L1112">            <span class="tok-kw">var</span> ch = cache.obtain();</span>
<span class="line" id="L1113">            <span class="tok-kw">defer</span> ch.deinit();</span>
<span class="line" id="L1114"></span>
<span class="line" id="L1115">            ch.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);</span>
<span class="line" id="L1116">            <span class="tok-kw">const</span> temp_file_idx = <span class="tok-kw">try</span> ch.addFile(temp_file, <span class="tok-number">100</span>);</span>
<span class="line" id="L1117"></span>
<span class="line" id="L1118">            <span class="tok-comment">// A file that we depend on has been updated, so the cache should not contain an entry for it</span>
</span>
<span class="line" id="L1119">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-null">false</span>, <span class="tok-kw">try</span> ch.hit());</span>
<span class="line" id="L1120"></span>
<span class="line" id="L1121">            <span class="tok-comment">// The cache system does not keep the contents of re-hashed input files.</span>
</span>
<span class="line" id="L1122">            <span class="tok-kw">try</span> testing.expect(ch.files.items[temp_file_idx].contents == <span class="tok-null">null</span>);</span>
<span class="line" id="L1123"></span>
<span class="line" id="L1124">            digest2 = ch.final();</span>
<span class="line" id="L1125"></span>
<span class="line" id="L1126">            <span class="tok-kw">try</span> ch.writeManifest();</span>
<span class="line" id="L1127">        }</span>
<span class="line" id="L1128"></span>
<span class="line" id="L1129">        <span class="tok-kw">try</span> testing.expect(!mem.eql(<span class="tok-type">u8</span>, digest1[<span class="tok-number">0</span>..], digest2[<span class="tok-number">0</span>..]));</span>
<span class="line" id="L1130">    }</span>
<span class="line" id="L1131">}</span>
<span class="line" id="L1132"></span>
<span class="line" id="L1133"><span class="tok-kw">test</span> <span class="tok-str">&quot;no file inputs&quot;</span> {</span>
<span class="line" id="L1134">    <span class="tok-kw">if</span> (builtin.os.tag == .wasi) {</span>
<span class="line" id="L1135">        <span class="tok-comment">// https://github.com/ziglang/zig/issues/5437</span>
</span>
<span class="line" id="L1136">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;</span>
<span class="line" id="L1137">    }</span>
<span class="line" id="L1138"></span>
<span class="line" id="L1139">    <span class="tok-kw">var</span> tmp = testing.tmpDir(.{});</span>
<span class="line" id="L1140">    <span class="tok-kw">defer</span> tmp.cleanup();</span>
<span class="line" id="L1141"></span>
<span class="line" id="L1142">    <span class="tok-kw">const</span> temp_manifest_dir = <span class="tok-str">&quot;no_file_inputs_manifest_dir&quot;</span>;</span>
<span class="line" id="L1143"></span>
<span class="line" id="L1144">    <span class="tok-kw">var</span> digest1: [hex_digest_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1145">    <span class="tok-kw">var</span> digest2: [hex_digest_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1146"></span>
<span class="line" id="L1147">    <span class="tok-kw">var</span> cache = Cache{</span>
<span class="line" id="L1148">        .gpa = testing.allocator,</span>
<span class="line" id="L1149">        .manifest_dir = <span class="tok-kw">try</span> tmp.dir.makeOpenPath(temp_manifest_dir, .{}),</span>
<span class="line" id="L1150">    };</span>
<span class="line" id="L1151">    cache.addPrefix(.{ .path = <span class="tok-null">null</span>, .handle = tmp.dir });</span>
<span class="line" id="L1152">    <span class="tok-kw">defer</span> cache.manifest_dir.close();</span>
<span class="line" id="L1153"></span>
<span class="line" id="L1154">    {</span>
<span class="line" id="L1155">        <span class="tok-kw">var</span> man = cache.obtain();</span>
<span class="line" id="L1156">        <span class="tok-kw">defer</span> man.deinit();</span>
<span class="line" id="L1157"></span>
<span class="line" id="L1158">        man.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);</span>
<span class="line" id="L1159"></span>
<span class="line" id="L1160">        <span class="tok-comment">// There should be nothing in the cache</span>
</span>
<span class="line" id="L1161">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-null">false</span>, <span class="tok-kw">try</span> man.hit());</span>
<span class="line" id="L1162"></span>
<span class="line" id="L1163">        digest1 = man.final();</span>
<span class="line" id="L1164"></span>
<span class="line" id="L1165">        <span class="tok-kw">try</span> man.writeManifest();</span>
<span class="line" id="L1166">    }</span>
<span class="line" id="L1167">    {</span>
<span class="line" id="L1168">        <span class="tok-kw">var</span> man = cache.obtain();</span>
<span class="line" id="L1169">        <span class="tok-kw">defer</span> man.deinit();</span>
<span class="line" id="L1170"></span>
<span class="line" id="L1171">        man.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);</span>
<span class="line" id="L1172"></span>
<span class="line" id="L1173">        <span class="tok-kw">try</span> testing.expect(<span class="tok-kw">try</span> man.hit());</span>
<span class="line" id="L1174">        digest2 = man.final();</span>
<span class="line" id="L1175">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-null">false</span>, man.have_exclusive_lock);</span>
<span class="line" id="L1176">    }</span>
<span class="line" id="L1177"></span>
<span class="line" id="L1178">    <span class="tok-kw">try</span> testing.expectEqual(digest1, digest2);</span>
<span class="line" id="L1179">}</span>
<span class="line" id="L1180"></span>
<span class="line" id="L1181"><span class="tok-kw">test</span> <span class="tok-str">&quot;Manifest with files added after initial hash work&quot;</span> {</span>
<span class="line" id="L1182">    <span class="tok-kw">if</span> (builtin.os.tag == .wasi) {</span>
<span class="line" id="L1183">        <span class="tok-comment">// https://github.com/ziglang/zig/issues/5437</span>
</span>
<span class="line" id="L1184">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;</span>
<span class="line" id="L1185">    }</span>
<span class="line" id="L1186">    <span class="tok-kw">var</span> tmp = testing.tmpDir(.{});</span>
<span class="line" id="L1187">    <span class="tok-kw">defer</span> tmp.cleanup();</span>
<span class="line" id="L1188"></span>
<span class="line" id="L1189">    <span class="tok-kw">const</span> temp_file1 = <span class="tok-str">&quot;cache_hash_post_file_test1.txt&quot;</span>;</span>
<span class="line" id="L1190">    <span class="tok-kw">const</span> temp_file2 = <span class="tok-str">&quot;cache_hash_post_file_test2.txt&quot;</span>;</span>
<span class="line" id="L1191">    <span class="tok-kw">const</span> temp_manifest_dir = <span class="tok-str">&quot;cache_hash_post_file_manifest_dir&quot;</span>;</span>
<span class="line" id="L1192"></span>
<span class="line" id="L1193">    <span class="tok-kw">try</span> tmp.dir.writeFile(temp_file1, <span class="tok-str">&quot;Hello, world!\n&quot;</span>);</span>
<span class="line" id="L1194">    <span class="tok-kw">try</span> tmp.dir.writeFile(temp_file2, <span class="tok-str">&quot;Hello world the second!\n&quot;</span>);</span>
<span class="line" id="L1195"></span>
<span class="line" id="L1196">    <span class="tok-comment">// Wait for file timestamps to tick</span>
</span>
<span class="line" id="L1197">    <span class="tok-kw">const</span> initial_time = <span class="tok-kw">try</span> testGetCurrentFileTimestamp(tmp.dir);</span>
<span class="line" id="L1198">    <span class="tok-kw">while</span> ((<span class="tok-kw">try</span> testGetCurrentFileTimestamp(tmp.dir)) == initial_time) {</span>
<span class="line" id="L1199">        std.time.sleep(<span class="tok-number">1</span>);</span>
<span class="line" id="L1200">    }</span>
<span class="line" id="L1201"></span>
<span class="line" id="L1202">    <span class="tok-kw">var</span> digest1: [hex_digest_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1203">    <span class="tok-kw">var</span> digest2: [hex_digest_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1204">    <span class="tok-kw">var</span> digest3: [hex_digest_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1205"></span>
<span class="line" id="L1206">    {</span>
<span class="line" id="L1207">        <span class="tok-kw">var</span> cache = Cache{</span>
<span class="line" id="L1208">            .gpa = testing.allocator,</span>
<span class="line" id="L1209">            .manifest_dir = <span class="tok-kw">try</span> tmp.dir.makeOpenPath(temp_manifest_dir, .{}),</span>
<span class="line" id="L1210">        };</span>
<span class="line" id="L1211">        cache.addPrefix(.{ .path = <span class="tok-null">null</span>, .handle = tmp.dir });</span>
<span class="line" id="L1212">        <span class="tok-kw">defer</span> cache.manifest_dir.close();</span>
<span class="line" id="L1213"></span>
<span class="line" id="L1214">        {</span>
<span class="line" id="L1215">            <span class="tok-kw">var</span> ch = cache.obtain();</span>
<span class="line" id="L1216">            <span class="tok-kw">defer</span> ch.deinit();</span>
<span class="line" id="L1217"></span>
<span class="line" id="L1218">            ch.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);</span>
<span class="line" id="L1219">            _ = <span class="tok-kw">try</span> ch.addFile(temp_file1, <span class="tok-null">null</span>);</span>
<span class="line" id="L1220"></span>
<span class="line" id="L1221">            <span class="tok-comment">// There should be nothing in the cache</span>
</span>
<span class="line" id="L1222">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-null">false</span>, <span class="tok-kw">try</span> ch.hit());</span>
<span class="line" id="L1223"></span>
<span class="line" id="L1224">            _ = <span class="tok-kw">try</span> ch.addFilePost(temp_file2);</span>
<span class="line" id="L1225"></span>
<span class="line" id="L1226">            digest1 = ch.final();</span>
<span class="line" id="L1227">            <span class="tok-kw">try</span> ch.writeManifest();</span>
<span class="line" id="L1228">        }</span>
<span class="line" id="L1229">        {</span>
<span class="line" id="L1230">            <span class="tok-kw">var</span> ch = cache.obtain();</span>
<span class="line" id="L1231">            <span class="tok-kw">defer</span> ch.deinit();</span>
<span class="line" id="L1232"></span>
<span class="line" id="L1233">            ch.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);</span>
<span class="line" id="L1234">            _ = <span class="tok-kw">try</span> ch.addFile(temp_file1, <span class="tok-null">null</span>);</span>
<span class="line" id="L1235"></span>
<span class="line" id="L1236">            <span class="tok-kw">try</span> testing.expect(<span class="tok-kw">try</span> ch.hit());</span>
<span class="line" id="L1237">            digest2 = ch.final();</span>
<span class="line" id="L1238"></span>
<span class="line" id="L1239">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-null">false</span>, ch.have_exclusive_lock);</span>
<span class="line" id="L1240">        }</span>
<span class="line" id="L1241">        <span class="tok-kw">try</span> testing.expect(mem.eql(<span class="tok-type">u8</span>, &amp;digest1, &amp;digest2));</span>
<span class="line" id="L1242"></span>
<span class="line" id="L1243">        <span class="tok-comment">// Modify the file added after initial hash</span>
</span>
<span class="line" id="L1244">        <span class="tok-kw">try</span> tmp.dir.writeFile(temp_file2, <span class="tok-str">&quot;Hello world the second, updated\n&quot;</span>);</span>
<span class="line" id="L1245"></span>
<span class="line" id="L1246">        <span class="tok-comment">// Wait for file timestamps to tick</span>
</span>
<span class="line" id="L1247">        <span class="tok-kw">const</span> initial_time2 = <span class="tok-kw">try</span> testGetCurrentFileTimestamp(tmp.dir);</span>
<span class="line" id="L1248">        <span class="tok-kw">while</span> ((<span class="tok-kw">try</span> testGetCurrentFileTimestamp(tmp.dir)) == initial_time2) {</span>
<span class="line" id="L1249">            std.time.sleep(<span class="tok-number">1</span>);</span>
<span class="line" id="L1250">        }</span>
<span class="line" id="L1251"></span>
<span class="line" id="L1252">        {</span>
<span class="line" id="L1253">            <span class="tok-kw">var</span> ch = cache.obtain();</span>
<span class="line" id="L1254">            <span class="tok-kw">defer</span> ch.deinit();</span>
<span class="line" id="L1255"></span>
<span class="line" id="L1256">            ch.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);</span>
<span class="line" id="L1257">            _ = <span class="tok-kw">try</span> ch.addFile(temp_file1, <span class="tok-null">null</span>);</span>
<span class="line" id="L1258"></span>
<span class="line" id="L1259">            <span class="tok-comment">// A file that we depend on has been updated, so the cache should not contain an entry for it</span>
</span>
<span class="line" id="L1260">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-null">false</span>, <span class="tok-kw">try</span> ch.hit());</span>
<span class="line" id="L1261"></span>
<span class="line" id="L1262">            _ = <span class="tok-kw">try</span> ch.addFilePost(temp_file2);</span>
<span class="line" id="L1263"></span>
<span class="line" id="L1264">            digest3 = ch.final();</span>
<span class="line" id="L1265"></span>
<span class="line" id="L1266">            <span class="tok-kw">try</span> ch.writeManifest();</span>
<span class="line" id="L1267">        }</span>
<span class="line" id="L1268"></span>
<span class="line" id="L1269">        <span class="tok-kw">try</span> testing.expect(!mem.eql(<span class="tok-type">u8</span>, &amp;digest1, &amp;digest3));</span>
<span class="line" id="L1270">    }</span>
<span class="line" id="L1271">}</span>
<span class="line" id="L1272"></span>
</code></pre></body>
</html>