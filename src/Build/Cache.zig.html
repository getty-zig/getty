<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Build/Cache.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg=="/>
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-comment">//! Manages `zig-cache` directories.</span></span>
<span class="line" id="L2"><span class="tok-comment">//! This is not a general-purpose cache. It is designed to be fast and simple,</span></span>
<span class="line" id="L3"><span class="tok-comment">//! not to withstand attacks using specially-crafted input.</span></span>
<span class="line" id="L4"></span>
<span class="line" id="L5"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Directory = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L6">    <span class="tok-comment">/// This field is redundant for operations that can act on the open directory handle</span></span>
<span class="line" id="L7">    <span class="tok-comment">/// directly, but it is needed when passing the directory to a child process.</span></span>
<span class="line" id="L8">    <span class="tok-comment">/// `null` means cwd.</span></span>
<span class="line" id="L9">    path: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L10">    handle: std.fs.Dir,</span>
<span class="line" id="L11"></span>
<span class="line" id="L12">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">join</span>(self: Directory, allocator: Allocator, paths: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L13">        <span class="tok-kw">if</span> (self.path) |p| {</span>
<span class="line" id="L14">            <span class="tok-comment">// TODO clean way to do this with only 1 allocation</span>
</span>
<span class="line" id="L15">            <span class="tok-kw">const</span> part2 = <span class="tok-kw">try</span> std.fs.path.join(allocator, paths);</span>
<span class="line" id="L16">            <span class="tok-kw">defer</span> allocator.free(part2);</span>
<span class="line" id="L17">            <span class="tok-kw">return</span> std.fs.path.join(allocator, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ p, part2 });</span>
<span class="line" id="L18">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L19">            <span class="tok-kw">return</span> std.fs.path.join(allocator, paths);</span>
<span class="line" id="L20">        }</span>
<span class="line" id="L21">    }</span>
<span class="line" id="L22"></span>
<span class="line" id="L23">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">joinZ</span>(self: Directory, allocator: Allocator, paths: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![:<span class="tok-number">0</span>]<span class="tok-type">u8</span> {</span>
<span class="line" id="L24">        <span class="tok-kw">if</span> (self.path) |p| {</span>
<span class="line" id="L25">            <span class="tok-comment">// TODO clean way to do this with only 1 allocation</span>
</span>
<span class="line" id="L26">            <span class="tok-kw">const</span> part2 = <span class="tok-kw">try</span> std.fs.path.join(allocator, paths);</span>
<span class="line" id="L27">            <span class="tok-kw">defer</span> allocator.free(part2);</span>
<span class="line" id="L28">            <span class="tok-kw">return</span> std.fs.path.joinZ(allocator, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ p, part2 });</span>
<span class="line" id="L29">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L30">            <span class="tok-kw">return</span> std.fs.path.joinZ(allocator, paths);</span>
<span class="line" id="L31">        }</span>
<span class="line" id="L32">    }</span>
<span class="line" id="L33"></span>
<span class="line" id="L34">    <span class="tok-comment">/// Whether or not the handle should be closed, or the path should be freed</span></span>
<span class="line" id="L35">    <span class="tok-comment">/// is determined by usage, however this function is provided for convenience</span></span>
<span class="line" id="L36">    <span class="tok-comment">/// if it happens to be what the caller needs.</span></span>
<span class="line" id="L37">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">closeAndFree</span>(self: *Directory, gpa: Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L38">        self.handle.close();</span>
<span class="line" id="L39">        <span class="tok-kw">if</span> (self.path) |p| gpa.free(p);</span>
<span class="line" id="L40">        self.* = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L41">    }</span>
<span class="line" id="L42">};</span>
<span class="line" id="L43"></span>
<span class="line" id="L44">gpa: Allocator,</span>
<span class="line" id="L45">manifest_dir: fs.Dir,</span>
<span class="line" id="L46">hash: HashHelper = .{},</span>
<span class="line" id="L47"><span class="tok-comment">/// This value is accessed from multiple threads, protected by mutex.</span></span>
<span class="line" id="L48">recent_problematic_timestamp: <span class="tok-type">i128</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L49">mutex: std.Thread.Mutex = .{},</span>
<span class="line" id="L50"></span>
<span class="line" id="L51"><span class="tok-comment">/// A set of strings such as the zig library directory or project source root, which</span></span>
<span class="line" id="L52"><span class="tok-comment">/// are stripped from the file paths before putting into the cache. They</span></span>
<span class="line" id="L53"><span class="tok-comment">/// are replaced with single-character indicators. This is not to save</span></span>
<span class="line" id="L54"><span class="tok-comment">/// space but to eliminate absolute file paths. This improves portability</span></span>
<span class="line" id="L55"><span class="tok-comment">/// and usefulness of the cache for advanced use cases.</span></span>
<span class="line" id="L56">prefixes_buffer: [<span class="tok-number">4</span>]Directory = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L57">prefixes_len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L58"></span>
<span class="line" id="L59"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DepTokenizer = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Cache/DepTokenizer.zig&quot;</span>);</span>
<span class="line" id="L60"></span>
<span class="line" id="L61"><span class="tok-kw">const</span> Cache = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L62"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);</span>
<span class="line" id="L63"><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);</span>
<span class="line" id="L64"><span class="tok-kw">const</span> crypto = std.crypto;</span>
<span class="line" id="L65"><span class="tok-kw">const</span> fs = std.fs;</span>
<span class="line" id="L66"><span class="tok-kw">const</span> assert = std.debug.assert;</span>
<span class="line" id="L67"><span class="tok-kw">const</span> testing = std.testing;</span>
<span class="line" id="L68"><span class="tok-kw">const</span> mem = std.mem;</span>
<span class="line" id="L69"><span class="tok-kw">const</span> fmt = std.fmt;</span>
<span class="line" id="L70"><span class="tok-kw">const</span> Allocator = std.mem.Allocator;</span>
<span class="line" id="L71"><span class="tok-kw">const</span> log = std.log.scoped(.cache);</span>
<span class="line" id="L72"></span>
<span class="line" id="L73"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addPrefix</span>(cache: *Cache, directory: Directory) <span class="tok-type">void</span> {</span>
<span class="line" id="L74">    cache.prefixes_buffer[cache.prefixes_len] = directory;</span>
<span class="line" id="L75">    cache.prefixes_len += <span class="tok-number">1</span>;</span>
<span class="line" id="L76">}</span>
<span class="line" id="L77"></span>
<span class="line" id="L78"><span class="tok-comment">/// Be sure to call `Manifest.deinit` after successful initialization.</span></span>
<span class="line" id="L79"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">obtain</span>(cache: *Cache) Manifest {</span>
<span class="line" id="L80">    <span class="tok-kw">return</span> Manifest{</span>
<span class="line" id="L81">        .cache = cache,</span>
<span class="line" id="L82">        .hash = cache.hash,</span>
<span class="line" id="L83">        .manifest_file = <span class="tok-null">null</span>,</span>
<span class="line" id="L84">        .manifest_dirty = <span class="tok-null">false</span>,</span>
<span class="line" id="L85">        .hex_digest = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L86">    };</span>
<span class="line" id="L87">}</span>
<span class="line" id="L88"></span>
<span class="line" id="L89"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">prefixes</span>(cache: *<span class="tok-kw">const</span> Cache) []<span class="tok-kw">const</span> Directory {</span>
<span class="line" id="L90">    <span class="tok-kw">return</span> cache.prefixes_buffer[<span class="tok-number">0</span>..cache.prefixes_len];</span>
<span class="line" id="L91">}</span>
<span class="line" id="L92"></span>
<span class="line" id="L93"><span class="tok-kw">const</span> PrefixedPath = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L94">    prefix: <span class="tok-type">u8</span>,</span>
<span class="line" id="L95">    sub_path: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L96">};</span>
<span class="line" id="L97"></span>
<span class="line" id="L98"><span class="tok-kw">fn</span> <span class="tok-fn">findPrefix</span>(cache: *<span class="tok-kw">const</span> Cache, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !PrefixedPath {</span>
<span class="line" id="L99">    <span class="tok-kw">const</span> gpa = cache.gpa;</span>
<span class="line" id="L100">    <span class="tok-kw">const</span> resolved_path = <span class="tok-kw">try</span> fs.path.resolve(gpa, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{file_path});</span>
<span class="line" id="L101">    <span class="tok-kw">errdefer</span> gpa.free(resolved_path);</span>
<span class="line" id="L102">    <span class="tok-kw">return</span> findPrefixResolved(cache, resolved_path);</span>
<span class="line" id="L103">}</span>
<span class="line" id="L104"></span>
<span class="line" id="L105"><span class="tok-comment">/// Takes ownership of `resolved_path` on success.</span></span>
<span class="line" id="L106"><span class="tok-kw">fn</span> <span class="tok-fn">findPrefixResolved</span>(cache: *<span class="tok-kw">const</span> Cache, resolved_path: []<span class="tok-type">u8</span>) !PrefixedPath {</span>
<span class="line" id="L107">    <span class="tok-kw">const</span> gpa = cache.gpa;</span>
<span class="line" id="L108">    <span class="tok-kw">const</span> prefixes_slice = cache.prefixes();</span>
<span class="line" id="L109">    <span class="tok-kw">var</span> i: <span class="tok-type">u8</span> = <span class="tok-number">1</span>; <span class="tok-comment">// Start at 1 to skip over checking the null prefix.</span>
</span>
<span class="line" id="L110">    <span class="tok-kw">while</span> (i &lt; prefixes_slice.len) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L111">        <span class="tok-kw">const</span> p = prefixes_slice[i].path.?;</span>
<span class="line" id="L112">        <span class="tok-kw">if</span> (mem.startsWith(<span class="tok-type">u8</span>, resolved_path, p)) {</span>
<span class="line" id="L113">            <span class="tok-comment">// +1 to skip over the path separator here</span>
</span>
<span class="line" id="L114">            <span class="tok-kw">const</span> sub_path = <span class="tok-kw">try</span> gpa.dupe(<span class="tok-type">u8</span>, resolved_path[p.len + <span class="tok-number">1</span> ..]);</span>
<span class="line" id="L115">            gpa.free(resolved_path);</span>
<span class="line" id="L116">            <span class="tok-kw">return</span> PrefixedPath{</span>
<span class="line" id="L117">                .prefix = <span class="tok-builtin">@intCast</span>(<span class="tok-type">u8</span>, i),</span>
<span class="line" id="L118">                .sub_path = sub_path,</span>
<span class="line" id="L119">            };</span>
<span class="line" id="L120">        }</span>
<span class="line" id="L121">    }</span>
<span class="line" id="L122"></span>
<span class="line" id="L123">    <span class="tok-kw">return</span> PrefixedPath{</span>
<span class="line" id="L124">        .prefix = <span class="tok-number">0</span>,</span>
<span class="line" id="L125">        .sub_path = resolved_path,</span>
<span class="line" id="L126">    };</span>
<span class="line" id="L127">}</span>
<span class="line" id="L128"></span>
<span class="line" id="L129"><span class="tok-comment">/// This is 128 bits - Even with 2^54 cache entries, the probably of a collision would be under 10^-6</span></span>
<span class="line" id="L130"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> bin_digest_len = <span class="tok-number">16</span>;</span>
<span class="line" id="L131"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> hex_digest_len = bin_digest_len * <span class="tok-number">2</span>;</span>
<span class="line" id="L132"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> BinDigest = [bin_digest_len]<span class="tok-type">u8</span>;</span>
<span class="line" id="L133"></span>
<span class="line" id="L134"><span class="tok-kw">const</span> manifest_file_size_max = <span class="tok-number">50</span> * <span class="tok-number">1024</span> * <span class="tok-number">1024</span>;</span>
<span class="line" id="L135"></span>
<span class="line" id="L136"><span class="tok-comment">/// The type used for hashing file contents. Currently, this is SipHash128(1, 3), because it</span></span>
<span class="line" id="L137"><span class="tok-comment">/// provides enough collision resistance for the Manifest use cases, while being one of our</span></span>
<span class="line" id="L138"><span class="tok-comment">/// fastest options right now.</span></span>
<span class="line" id="L139"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hasher = crypto.auth.siphash.SipHash128(<span class="tok-number">1</span>, <span class="tok-number">3</span>);</span>
<span class="line" id="L140"></span>
<span class="line" id="L141"><span class="tok-comment">/// Initial state, that can be copied.</span></span>
<span class="line" id="L142"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> hasher_init: Hasher = Hasher.init(&amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** Hasher.key_length);</span>
<span class="line" id="L143"></span>
<span class="line" id="L144"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> File = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L145">    prefixed_path: ?PrefixedPath,</span>
<span class="line" id="L146">    max_file_size: ?<span class="tok-type">usize</span>,</span>
<span class="line" id="L147">    stat: Stat,</span>
<span class="line" id="L148">    bin_digest: BinDigest,</span>
<span class="line" id="L149">    contents: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L150"></span>
<span class="line" id="L151">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Stat = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L152">        inode: fs.File.INode,</span>
<span class="line" id="L153">        size: <span class="tok-type">u64</span>,</span>
<span class="line" id="L154">        mtime: <span class="tok-type">i128</span>,</span>
<span class="line" id="L155">    };</span>
<span class="line" id="L156"></span>
<span class="line" id="L157">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *File, gpa: Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L158">        <span class="tok-kw">if</span> (self.prefixed_path) |pp| {</span>
<span class="line" id="L159">            gpa.free(pp.sub_path);</span>
<span class="line" id="L160">            self.prefixed_path = <span class="tok-null">null</span>;</span>
<span class="line" id="L161">        }</span>
<span class="line" id="L162">        <span class="tok-kw">if</span> (self.contents) |contents| {</span>
<span class="line" id="L163">            gpa.free(contents);</span>
<span class="line" id="L164">            self.contents = <span class="tok-null">null</span>;</span>
<span class="line" id="L165">        }</span>
<span class="line" id="L166">        self.* = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L167">    }</span>
<span class="line" id="L168">};</span>
<span class="line" id="L169"></span>
<span class="line" id="L170"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> HashHelper = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L171">    hasher: Hasher = hasher_init,</span>
<span class="line" id="L172"></span>
<span class="line" id="L173">    <span class="tok-comment">/// Record a slice of bytes as an dependency of the process being cached</span></span>
<span class="line" id="L174">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addBytes</span>(hh: *HashHelper, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L175">        hh.hasher.update(mem.asBytes(&amp;bytes.len));</span>
<span class="line" id="L176">        hh.hasher.update(bytes);</span>
<span class="line" id="L177">    }</span>
<span class="line" id="L178"></span>
<span class="line" id="L179">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOptionalBytes</span>(hh: *HashHelper, optional_bytes: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L180">        hh.add(optional_bytes != <span class="tok-null">null</span>);</span>
<span class="line" id="L181">        hh.addBytes(optional_bytes <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>);</span>
<span class="line" id="L182">    }</span>
<span class="line" id="L183"></span>
<span class="line" id="L184">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addListOfBytes</span>(hh: *HashHelper, list_of_bytes: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L185">        hh.add(list_of_bytes.len);</span>
<span class="line" id="L186">        <span class="tok-kw">for</span> (list_of_bytes) |bytes| hh.addBytes(bytes);</span>
<span class="line" id="L187">    }</span>
<span class="line" id="L188"></span>
<span class="line" id="L189">    <span class="tok-comment">/// Convert the input value into bytes and record it as a dependency of the process being cached.</span></span>
<span class="line" id="L190">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(hh: *HashHelper, x: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L191">        <span class="tok-kw">switch</span> (<span class="tok-builtin">@TypeOf</span>(x)) {</span>
<span class="line" id="L192">            std.builtin.Version =&gt; {</span>
<span class="line" id="L193">                hh.add(x.major);</span>
<span class="line" id="L194">                hh.add(x.minor);</span>
<span class="line" id="L195">                hh.add(x.patch);</span>
<span class="line" id="L196">            },</span>
<span class="line" id="L197">            std.Target.Os.TaggedVersionRange =&gt; {</span>
<span class="line" id="L198">                <span class="tok-kw">switch</span> (x) {</span>
<span class="line" id="L199">                    .linux =&gt; |linux| {</span>
<span class="line" id="L200">                        hh.add(linux.range.min);</span>
<span class="line" id="L201">                        hh.add(linux.range.max);</span>
<span class="line" id="L202">                        hh.add(linux.glibc);</span>
<span class="line" id="L203">                    },</span>
<span class="line" id="L204">                    .windows =&gt; |windows| {</span>
<span class="line" id="L205">                        hh.add(windows.min);</span>
<span class="line" id="L206">                        hh.add(windows.max);</span>
<span class="line" id="L207">                    },</span>
<span class="line" id="L208">                    .semver =&gt; |semver| {</span>
<span class="line" id="L209">                        hh.add(semver.min);</span>
<span class="line" id="L210">                        hh.add(semver.max);</span>
<span class="line" id="L211">                    },</span>
<span class="line" id="L212">                    .none =&gt; {},</span>
<span class="line" id="L213">                }</span>
<span class="line" id="L214">            },</span>
<span class="line" id="L215">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(x))) {</span>
<span class="line" id="L216">                .Bool, .Int, .Enum, .Array =&gt; hh.addBytes(mem.asBytes(&amp;x)),</span>
<span class="line" id="L217">                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unable to hash type &quot;</span> ++ <span class="tok-builtin">@typeName</span>(<span class="tok-builtin">@TypeOf</span>(x))),</span>
<span class="line" id="L218">            },</span>
<span class="line" id="L219">        }</span>
<span class="line" id="L220">    }</span>
<span class="line" id="L221"></span>
<span class="line" id="L222">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOptional</span>(hh: *HashHelper, optional: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L223">        hh.add(optional != <span class="tok-null">null</span>);</span>
<span class="line" id="L224">        hh.add(optional <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>);</span>
<span class="line" id="L225">    }</span>
<span class="line" id="L226"></span>
<span class="line" id="L227">    <span class="tok-comment">/// Returns a hex encoded hash of the inputs, without modifying state.</span></span>
<span class="line" id="L228">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peek</span>(hh: HashHelper) [hex_digest_len]<span class="tok-type">u8</span> {</span>
<span class="line" id="L229">        <span class="tok-kw">var</span> copy = hh;</span>
<span class="line" id="L230">        <span class="tok-kw">return</span> copy.final();</span>
<span class="line" id="L231">    }</span>
<span class="line" id="L232"></span>
<span class="line" id="L233">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peekBin</span>(hh: HashHelper) BinDigest {</span>
<span class="line" id="L234">        <span class="tok-kw">var</span> copy = hh;</span>
<span class="line" id="L235">        <span class="tok-kw">var</span> bin_digest: BinDigest = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L236">        copy.hasher.final(&amp;bin_digest);</span>
<span class="line" id="L237">        <span class="tok-kw">return</span> bin_digest;</span>
<span class="line" id="L238">    }</span>
<span class="line" id="L239"></span>
<span class="line" id="L240">    <span class="tok-comment">/// Returns a hex encoded hash of the inputs, mutating the state of the hasher.</span></span>
<span class="line" id="L241">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">final</span>(hh: *HashHelper) [hex_digest_len]<span class="tok-type">u8</span> {</span>
<span class="line" id="L242">        <span class="tok-kw">var</span> bin_digest: BinDigest = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L243">        hh.hasher.final(&amp;bin_digest);</span>
<span class="line" id="L244"></span>
<span class="line" id="L245">        <span class="tok-kw">var</span> out_digest: [hex_digest_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L246">        _ = std.fmt.bufPrint(</span>
<span class="line" id="L247">            &amp;out_digest,</span>
<span class="line" id="L248">            <span class="tok-str">&quot;{s}&quot;</span>,</span>
<span class="line" id="L249">            .{std.fmt.fmtSliceHexLower(&amp;bin_digest)},</span>
<span class="line" id="L250">        ) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L251">        <span class="tok-kw">return</span> out_digest;</span>
<span class="line" id="L252">    }</span>
<span class="line" id="L253">};</span>
<span class="line" id="L254"></span>
<span class="line" id="L255"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Lock = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L256">    manifest_file: fs.File,</span>
<span class="line" id="L257"></span>
<span class="line" id="L258">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">release</span>(lock: *Lock) <span class="tok-type">void</span> {</span>
<span class="line" id="L259">        <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L260">            <span class="tok-comment">// Windows does not guarantee that locks are immediately unlocked when</span>
</span>
<span class="line" id="L261">            <span class="tok-comment">// the file handle is closed. See LockFileEx documentation.</span>
</span>
<span class="line" id="L262">            lock.manifest_file.unlock();</span>
<span class="line" id="L263">        }</span>
<span class="line" id="L264"></span>
<span class="line" id="L265">        lock.manifest_file.close();</span>
<span class="line" id="L266">        lock.* = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L267">    }</span>
<span class="line" id="L268">};</span>
<span class="line" id="L269"></span>
<span class="line" id="L270"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Manifest = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L271">    cache: *Cache,</span>
<span class="line" id="L272">    <span class="tok-comment">/// Current state for incremental hashing.</span></span>
<span class="line" id="L273">    hash: HashHelper,</span>
<span class="line" id="L274">    manifest_file: ?fs.File,</span>
<span class="line" id="L275">    manifest_dirty: <span class="tok-type">bool</span>,</span>
<span class="line" id="L276">    <span class="tok-comment">/// Set this flag to true before calling hit() in order to indicate that</span></span>
<span class="line" id="L277">    <span class="tok-comment">/// upon a cache hit, the code using the cache will not modify the files</span></span>
<span class="line" id="L278">    <span class="tok-comment">/// within the cache directory. This allows multiple processes to utilize</span></span>
<span class="line" id="L279">    <span class="tok-comment">/// the same cache directory at the same time.</span></span>
<span class="line" id="L280">    want_shared_lock: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,</span>
<span class="line" id="L281">    have_exclusive_lock: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L282">    <span class="tok-comment">// Indicate that we want isProblematicTimestamp to perform a filesystem write in</span>
</span>
<span class="line" id="L283">    <span class="tok-comment">// order to obtain a problematic timestamp for the next call. Calls after that</span>
</span>
<span class="line" id="L284">    <span class="tok-comment">// will then use the same timestamp, to avoid unnecessary filesystem writes.</span>
</span>
<span class="line" id="L285">    want_refresh_timestamp: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,</span>
<span class="line" id="L286">    files: std.ArrayListUnmanaged(File) = .{},</span>
<span class="line" id="L287">    hex_digest: [hex_digest_len]<span class="tok-type">u8</span>,</span>
<span class="line" id="L288">    <span class="tok-comment">/// Populated when hit() returns an error because of one</span></span>
<span class="line" id="L289">    <span class="tok-comment">/// of the files listed in the manifest.</span></span>
<span class="line" id="L290">    failed_file_index: ?<span class="tok-type">usize</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L291">    <span class="tok-comment">/// Keeps track of the last time we performed a file system write to observe</span></span>
<span class="line" id="L292">    <span class="tok-comment">/// what time the file system thinks it is, according to its own granularity.</span></span>
<span class="line" id="L293">    recent_problematic_timestamp: <span class="tok-type">i128</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L294"></span>
<span class="line" id="L295">    <span class="tok-comment">/// Add a file as a dependency of process being cached. When `hit` is</span></span>
<span class="line" id="L296">    <span class="tok-comment">/// called, the file's contents will be checked to ensure that it matches</span></span>
<span class="line" id="L297">    <span class="tok-comment">/// the contents from previous times.</span></span>
<span class="line" id="L298">    <span class="tok-comment">///</span></span>
<span class="line" id="L299">    <span class="tok-comment">/// Max file size will be used to determine the amount of space the file contents</span></span>
<span class="line" id="L300">    <span class="tok-comment">/// are allowed to take up in memory. If max_file_size is null, then the contents</span></span>
<span class="line" id="L301">    <span class="tok-comment">/// will not be loaded into memory.</span></span>
<span class="line" id="L302">    <span class="tok-comment">///</span></span>
<span class="line" id="L303">    <span class="tok-comment">/// Returns the index of the entry in the `files` array list. You can use it</span></span>
<span class="line" id="L304">    <span class="tok-comment">/// to access the contents of the file after calling `hit()` like so:</span></span>
<span class="line" id="L305">    <span class="tok-comment">///</span></span>
<span class="line" id="L306">    <span class="tok-comment">/// ```</span></span>
<span class="line" id="L307">    <span class="tok-comment">/// var file_contents = cache_hash.files.items[file_index].contents.?;</span></span>
<span class="line" id="L308">    <span class="tok-comment">/// ```</span></span>
<span class="line" id="L309">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFile</span>(self: *Manifest, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, max_file_size: ?<span class="tok-type">usize</span>) !<span class="tok-type">usize</span> {</span>
<span class="line" id="L310">        assert(self.manifest_file == <span class="tok-null">null</span>);</span>
<span class="line" id="L311"></span>
<span class="line" id="L312">        <span class="tok-kw">const</span> gpa = self.cache.gpa;</span>
<span class="line" id="L313">        <span class="tok-kw">try</span> self.files.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L314">        <span class="tok-kw">const</span> prefixed_path = <span class="tok-kw">try</span> self.cache.findPrefix(file_path);</span>
<span class="line" id="L315">        <span class="tok-kw">errdefer</span> gpa.free(prefixed_path.sub_path);</span>
<span class="line" id="L316"></span>
<span class="line" id="L317">        self.files.addOneAssumeCapacity().* = .{</span>
<span class="line" id="L318">            .prefixed_path = prefixed_path,</span>
<span class="line" id="L319">            .contents = <span class="tok-null">null</span>,</span>
<span class="line" id="L320">            .max_file_size = max_file_size,</span>
<span class="line" id="L321">            .stat = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L322">            .bin_digest = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L323">        };</span>
<span class="line" id="L324"></span>
<span class="line" id="L325">        self.hash.add(prefixed_path.prefix);</span>
<span class="line" id="L326">        self.hash.addBytes(prefixed_path.sub_path);</span>
<span class="line" id="L327"></span>
<span class="line" id="L328">        <span class="tok-kw">return</span> self.files.items.len - <span class="tok-number">1</span>;</span>
<span class="line" id="L329">    }</span>
<span class="line" id="L330"></span>
<span class="line" id="L331">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOptionalFile</span>(self: *Manifest, optional_file_path: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L332">        self.hash.add(optional_file_path != <span class="tok-null">null</span>);</span>
<span class="line" id="L333">        <span class="tok-kw">const</span> file_path = optional_file_path <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L334">        _ = <span class="tok-kw">try</span> self.addFile(file_path, <span class="tok-null">null</span>);</span>
<span class="line" id="L335">    }</span>
<span class="line" id="L336"></span>
<span class="line" id="L337">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addListOfFiles</span>(self: *Manifest, list_of_files: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L338">        self.hash.add(list_of_files.len);</span>
<span class="line" id="L339">        <span class="tok-kw">for</span> (list_of_files) |file_path| {</span>
<span class="line" id="L340">            _ = <span class="tok-kw">try</span> self.addFile(file_path, <span class="tok-null">null</span>);</span>
<span class="line" id="L341">        }</span>
<span class="line" id="L342">    }</span>
<span class="line" id="L343"></span>
<span class="line" id="L344">    <span class="tok-comment">/// Check the cache to see if the input exists in it. If it exists, returns `true`.</span></span>
<span class="line" id="L345">    <span class="tok-comment">/// A hex encoding of its hash is available by calling `final`.</span></span>
<span class="line" id="L346">    <span class="tok-comment">///</span></span>
<span class="line" id="L347">    <span class="tok-comment">/// This function will also acquire an exclusive lock to the manifest file. This means</span></span>
<span class="line" id="L348">    <span class="tok-comment">/// that a process holding a Manifest will block any other process attempting to</span></span>
<span class="line" id="L349">    <span class="tok-comment">/// acquire the lock. If `want_shared_lock` is `true`, a cache hit guarantees the</span></span>
<span class="line" id="L350">    <span class="tok-comment">/// manifest file to be locked in shared mode, and a cache miss guarantees the manifest</span></span>
<span class="line" id="L351">    <span class="tok-comment">/// file to be locked in exclusive mode.</span></span>
<span class="line" id="L352">    <span class="tok-comment">///</span></span>
<span class="line" id="L353">    <span class="tok-comment">/// The lock on the manifest file is released when `deinit` is called. As another</span></span>
<span class="line" id="L354">    <span class="tok-comment">/// option, one may call `toOwnedLock` to obtain a smaller object which can represent</span></span>
<span class="line" id="L355">    <span class="tok-comment">/// the lock. `deinit` is safe to call whether or not `toOwnedLock` has been called.</span></span>
<span class="line" id="L356">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hit</span>(self: *Manifest) !<span class="tok-type">bool</span> {</span>
<span class="line" id="L357">        <span class="tok-kw">const</span> gpa = self.cache.gpa;</span>
<span class="line" id="L358">        assert(self.manifest_file == <span class="tok-null">null</span>);</span>
<span class="line" id="L359"></span>
<span class="line" id="L360">        self.failed_file_index = <span class="tok-null">null</span>;</span>
<span class="line" id="L361"></span>
<span class="line" id="L362">        <span class="tok-kw">const</span> ext = <span class="tok-str">&quot;.txt&quot;</span>;</span>
<span class="line" id="L363">        <span class="tok-kw">var</span> manifest_file_path: [self.hex_digest.len + ext.len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L364"></span>
<span class="line" id="L365">        <span class="tok-kw">var</span> bin_digest: BinDigest = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L366">        self.hash.hasher.final(&amp;bin_digest);</span>
<span class="line" id="L367"></span>
<span class="line" id="L368">        _ = std.fmt.bufPrint(</span>
<span class="line" id="L369">            &amp;self.hex_digest,</span>
<span class="line" id="L370">            <span class="tok-str">&quot;{s}&quot;</span>,</span>
<span class="line" id="L371">            .{std.fmt.fmtSliceHexLower(&amp;bin_digest)},</span>
<span class="line" id="L372">        ) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L373"></span>
<span class="line" id="L374">        self.hash.hasher = hasher_init;</span>
<span class="line" id="L375">        self.hash.hasher.update(&amp;bin_digest);</span>
<span class="line" id="L376"></span>
<span class="line" id="L377">        mem.copy(<span class="tok-type">u8</span>, &amp;manifest_file_path, &amp;self.hex_digest);</span>
<span class="line" id="L378">        manifest_file_path[self.hex_digest.len..][<span class="tok-number">0</span>..ext.len].* = ext.*;</span>
<span class="line" id="L379"></span>
<span class="line" id="L380">        <span class="tok-kw">if</span> (self.files.items.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L381">            <span class="tok-comment">// If there are no file inputs, we check if the manifest file exists instead of</span>
</span>
<span class="line" id="L382">            <span class="tok-comment">// comparing the hashes on the files used for the cached item</span>
</span>
<span class="line" id="L383">            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L384">                <span class="tok-kw">if</span> (self.cache.manifest_dir.openFile(&amp;manifest_file_path, .{</span>
<span class="line" id="L385">                    .mode = .read_write,</span>
<span class="line" id="L386">                    .lock = .Exclusive,</span>
<span class="line" id="L387">                    .lock_nonblocking = self.want_shared_lock,</span>
<span class="line" id="L388">                })) |manifest_file| {</span>
<span class="line" id="L389">                    self.manifest_file = manifest_file;</span>
<span class="line" id="L390">                    self.have_exclusive_lock = <span class="tok-null">true</span>;</span>
<span class="line" id="L391">                    <span class="tok-kw">break</span>;</span>
<span class="line" id="L392">                } <span class="tok-kw">else</span> |open_err| <span class="tok-kw">switch</span> (open_err) {</span>
<span class="line" id="L393">                    <span class="tok-kw">error</span>.WouldBlock =&gt; {</span>
<span class="line" id="L394">                        self.manifest_file = <span class="tok-kw">try</span> self.cache.manifest_dir.openFile(&amp;manifest_file_path, .{</span>
<span class="line" id="L395">                            .lock = .Shared,</span>
<span class="line" id="L396">                        });</span>
<span class="line" id="L397">                        <span class="tok-kw">break</span>;</span>
<span class="line" id="L398">                    },</span>
<span class="line" id="L399">                    <span class="tok-kw">error</span>.FileNotFound =&gt; {</span>
<span class="line" id="L400">                        <span class="tok-kw">if</span> (self.cache.manifest_dir.createFile(&amp;manifest_file_path, .{</span>
<span class="line" id="L401">                            .read = <span class="tok-null">true</span>,</span>
<span class="line" id="L402">                            .truncate = <span class="tok-null">false</span>,</span>
<span class="line" id="L403">                            .lock = .Exclusive,</span>
<span class="line" id="L404">                            .lock_nonblocking = self.want_shared_lock,</span>
<span class="line" id="L405">                        })) |manifest_file| {</span>
<span class="line" id="L406">                            self.manifest_file = manifest_file;</span>
<span class="line" id="L407">                            self.manifest_dirty = <span class="tok-null">true</span>;</span>
<span class="line" id="L408">                            self.have_exclusive_lock = <span class="tok-null">true</span>;</span>
<span class="line" id="L409">                            <span class="tok-kw">return</span> <span class="tok-null">false</span>; <span class="tok-comment">// cache miss; exclusive lock already held</span>
</span>
<span class="line" id="L410">                        } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L411">                            <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L412">                            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L413">                        }</span>
<span class="line" id="L414">                    },</span>
<span class="line" id="L415">                    <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L416">                }</span>
<span class="line" id="L417">            }</span>
<span class="line" id="L418">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L419">            <span class="tok-kw">if</span> (self.cache.manifest_dir.createFile(&amp;manifest_file_path, .{</span>
<span class="line" id="L420">                .read = <span class="tok-null">true</span>,</span>
<span class="line" id="L421">                .truncate = <span class="tok-null">false</span>,</span>
<span class="line" id="L422">                .lock = .Exclusive,</span>
<span class="line" id="L423">                .lock_nonblocking = self.want_shared_lock,</span>
<span class="line" id="L424">            })) |manifest_file| {</span>
<span class="line" id="L425">                self.manifest_file = manifest_file;</span>
<span class="line" id="L426">                self.have_exclusive_lock = <span class="tok-null">true</span>;</span>
<span class="line" id="L427">            } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L428">                <span class="tok-kw">error</span>.WouldBlock =&gt; {</span>
<span class="line" id="L429">                    self.manifest_file = <span class="tok-kw">try</span> self.cache.manifest_dir.openFile(&amp;manifest_file_path, .{</span>
<span class="line" id="L430">                        .lock = .Shared,</span>
<span class="line" id="L431">                    });</span>
<span class="line" id="L432">                },</span>
<span class="line" id="L433">                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L434">            }</span>
<span class="line" id="L435">        }</span>
<span class="line" id="L436"></span>
<span class="line" id="L437">        self.want_refresh_timestamp = <span class="tok-null">true</span>;</span>
<span class="line" id="L438"></span>
<span class="line" id="L439">        <span class="tok-kw">const</span> file_contents = <span class="tok-kw">try</span> self.manifest_file.?.reader().readAllAlloc(gpa, manifest_file_size_max);</span>
<span class="line" id="L440">        <span class="tok-kw">defer</span> gpa.free(file_contents);</span>
<span class="line" id="L441"></span>
<span class="line" id="L442">        <span class="tok-kw">const</span> input_file_count = self.files.items.len;</span>
<span class="line" id="L443">        <span class="tok-kw">var</span> any_file_changed = <span class="tok-null">false</span>;</span>
<span class="line" id="L444">        <span class="tok-kw">var</span> line_iter = mem.tokenize(<span class="tok-type">u8</span>, file_contents, <span class="tok-str">&quot;\n&quot;</span>);</span>
<span class="line" id="L445">        <span class="tok-kw">var</span> idx: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L446">        <span class="tok-kw">while</span> (line_iter.next()) |line| {</span>
<span class="line" id="L447">            <span class="tok-kw">defer</span> idx += <span class="tok-number">1</span>;</span>
<span class="line" id="L448"></span>
<span class="line" id="L449">            <span class="tok-kw">const</span> cache_hash_file = <span class="tok-kw">if</span> (idx &lt; input_file_count) &amp;self.files.items[idx] <span class="tok-kw">else</span> blk: {</span>
<span class="line" id="L450">                <span class="tok-kw">const</span> new = <span class="tok-kw">try</span> self.files.addOne(gpa);</span>
<span class="line" id="L451">                new.* = .{</span>
<span class="line" id="L452">                    .prefixed_path = <span class="tok-null">null</span>,</span>
<span class="line" id="L453">                    .contents = <span class="tok-null">null</span>,</span>
<span class="line" id="L454">                    .max_file_size = <span class="tok-null">null</span>,</span>
<span class="line" id="L455">                    .stat = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L456">                    .bin_digest = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L457">                };</span>
<span class="line" id="L458">                <span class="tok-kw">break</span> :blk new;</span>
<span class="line" id="L459">            };</span>
<span class="line" id="L460"></span>
<span class="line" id="L461">            <span class="tok-kw">var</span> iter = mem.tokenize(<span class="tok-type">u8</span>, line, <span class="tok-str">&quot; &quot;</span>);</span>
<span class="line" id="L462">            <span class="tok-kw">const</span> size = iter.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L463">            <span class="tok-kw">const</span> inode = iter.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L464">            <span class="tok-kw">const</span> mtime_nsec_str = iter.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L465">            <span class="tok-kw">const</span> digest_str = iter.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L466">            <span class="tok-kw">const</span> prefix_str = iter.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L467">            <span class="tok-kw">const</span> file_path = iter.rest();</span>
<span class="line" id="L468"></span>
<span class="line" id="L469">            cache_hash_file.stat.size = fmt.parseInt(<span class="tok-type">u64</span>, size, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L470">            cache_hash_file.stat.inode = fmt.parseInt(fs.File.INode, inode, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L471">            cache_hash_file.stat.mtime = fmt.parseInt(<span class="tok-type">i64</span>, mtime_nsec_str, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L472">            _ = std.fmt.hexToBytes(&amp;cache_hash_file.bin_digest, digest_str) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L473">            <span class="tok-kw">const</span> prefix = fmt.parseInt(<span class="tok-type">u8</span>, prefix_str, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L474">            <span class="tok-kw">if</span> (prefix &gt;= self.cache.prefixes_len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L475"></span>
<span class="line" id="L476">            <span class="tok-kw">if</span> (file_path.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L477">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L478">            }</span>
<span class="line" id="L479">            <span class="tok-kw">if</span> (cache_hash_file.prefixed_path) |pp| {</span>
<span class="line" id="L480">                <span class="tok-kw">if</span> (pp.prefix != prefix <span class="tok-kw">or</span> !mem.eql(<span class="tok-type">u8</span>, file_path, pp.sub_path)) {</span>
<span class="line" id="L481">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L482">                }</span>
<span class="line" id="L483">            }</span>
<span class="line" id="L484"></span>
<span class="line" id="L485">            <span class="tok-kw">if</span> (cache_hash_file.prefixed_path == <span class="tok-null">null</span>) {</span>
<span class="line" id="L486">                cache_hash_file.prefixed_path = .{</span>
<span class="line" id="L487">                    .prefix = prefix,</span>
<span class="line" id="L488">                    .sub_path = <span class="tok-kw">try</span> gpa.dupe(<span class="tok-type">u8</span>, file_path),</span>
<span class="line" id="L489">                };</span>
<span class="line" id="L490">            }</span>
<span class="line" id="L491"></span>
<span class="line" id="L492">            <span class="tok-kw">const</span> pp = cache_hash_file.prefixed_path.?;</span>
<span class="line" id="L493">            <span class="tok-kw">const</span> dir = self.cache.prefixes()[pp.prefix].handle;</span>
<span class="line" id="L494">            <span class="tok-kw">const</span> this_file = dir.openFile(pp.sub_path, .{ .mode = .read_only }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L495">                <span class="tok-kw">error</span>.FileNotFound =&gt; {</span>
<span class="line" id="L496">                    <span class="tok-kw">try</span> self.upgradeToExclusiveLock();</span>
<span class="line" id="L497">                    <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L498">                },</span>
<span class="line" id="L499">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheUnavailable,</span>
<span class="line" id="L500">            };</span>
<span class="line" id="L501">            <span class="tok-kw">defer</span> this_file.close();</span>
<span class="line" id="L502"></span>
<span class="line" id="L503">            <span class="tok-kw">const</span> actual_stat = this_file.stat() <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L504">                self.failed_file_index = idx;</span>
<span class="line" id="L505">                <span class="tok-kw">return</span> err;</span>
<span class="line" id="L506">            };</span>
<span class="line" id="L507">            <span class="tok-kw">const</span> size_match = actual_stat.size == cache_hash_file.stat.size;</span>
<span class="line" id="L508">            <span class="tok-kw">const</span> mtime_match = actual_stat.mtime == cache_hash_file.stat.mtime;</span>
<span class="line" id="L509">            <span class="tok-kw">const</span> inode_match = actual_stat.inode == cache_hash_file.stat.inode;</span>
<span class="line" id="L510"></span>
<span class="line" id="L511">            <span class="tok-kw">if</span> (!size_match <span class="tok-kw">or</span> !mtime_match <span class="tok-kw">or</span> !inode_match) {</span>
<span class="line" id="L512">                self.manifest_dirty = <span class="tok-null">true</span>;</span>
<span class="line" id="L513"></span>
<span class="line" id="L514">                cache_hash_file.stat = .{</span>
<span class="line" id="L515">                    .size = actual_stat.size,</span>
<span class="line" id="L516">                    .mtime = actual_stat.mtime,</span>
<span class="line" id="L517">                    .inode = actual_stat.inode,</span>
<span class="line" id="L518">                };</span>
<span class="line" id="L519"></span>
<span class="line" id="L520">                <span class="tok-kw">if</span> (self.isProblematicTimestamp(cache_hash_file.stat.mtime)) {</span>
<span class="line" id="L521">                    <span class="tok-comment">// The actual file has an unreliable timestamp, force it to be hashed</span>
</span>
<span class="line" id="L522">                    cache_hash_file.stat.mtime = <span class="tok-number">0</span>;</span>
<span class="line" id="L523">                    cache_hash_file.stat.inode = <span class="tok-number">0</span>;</span>
<span class="line" id="L524">                }</span>
<span class="line" id="L525"></span>
<span class="line" id="L526">                <span class="tok-kw">var</span> actual_digest: BinDigest = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L527">                hashFile(this_file, &amp;actual_digest) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L528">                    self.failed_file_index = idx;</span>
<span class="line" id="L529">                    <span class="tok-kw">return</span> err;</span>
<span class="line" id="L530">                };</span>
<span class="line" id="L531"></span>
<span class="line" id="L532">                <span class="tok-kw">if</span> (!mem.eql(<span class="tok-type">u8</span>, &amp;cache_hash_file.bin_digest, &amp;actual_digest)) {</span>
<span class="line" id="L533">                    cache_hash_file.bin_digest = actual_digest;</span>
<span class="line" id="L534">                    <span class="tok-comment">// keep going until we have the input file digests</span>
</span>
<span class="line" id="L535">                    any_file_changed = <span class="tok-null">true</span>;</span>
<span class="line" id="L536">                }</span>
<span class="line" id="L537">            }</span>
<span class="line" id="L538"></span>
<span class="line" id="L539">            <span class="tok-kw">if</span> (!any_file_changed) {</span>
<span class="line" id="L540">                self.hash.hasher.update(&amp;cache_hash_file.bin_digest);</span>
<span class="line" id="L541">            }</span>
<span class="line" id="L542">        }</span>
<span class="line" id="L543"></span>
<span class="line" id="L544">        <span class="tok-kw">if</span> (any_file_changed) {</span>
<span class="line" id="L545">            <span class="tok-comment">// cache miss</span>
</span>
<span class="line" id="L546">            <span class="tok-comment">// keep the manifest file open</span>
</span>
<span class="line" id="L547">            self.unhit(bin_digest, input_file_count);</span>
<span class="line" id="L548">            <span class="tok-kw">try</span> self.upgradeToExclusiveLock();</span>
<span class="line" id="L549">            <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L550">        }</span>
<span class="line" id="L551"></span>
<span class="line" id="L552">        <span class="tok-kw">if</span> (idx &lt; input_file_count) {</span>
<span class="line" id="L553">            self.manifest_dirty = <span class="tok-null">true</span>;</span>
<span class="line" id="L554">            <span class="tok-kw">while</span> (idx &lt; input_file_count) : (idx += <span class="tok-number">1</span>) {</span>
<span class="line" id="L555">                <span class="tok-kw">const</span> ch_file = &amp;self.files.items[idx];</span>
<span class="line" id="L556">                self.populateFileHash(ch_file) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L557">                    self.failed_file_index = idx;</span>
<span class="line" id="L558">                    <span class="tok-kw">return</span> err;</span>
<span class="line" id="L559">                };</span>
<span class="line" id="L560">            }</span>
<span class="line" id="L561">            <span class="tok-kw">try</span> self.upgradeToExclusiveLock();</span>
<span class="line" id="L562">            <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L563">        }</span>
<span class="line" id="L564"></span>
<span class="line" id="L565">        <span class="tok-kw">if</span> (self.want_shared_lock) {</span>
<span class="line" id="L566">            <span class="tok-kw">try</span> self.downgradeToSharedLock();</span>
<span class="line" id="L567">        }</span>
<span class="line" id="L568"></span>
<span class="line" id="L569">        <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L570">    }</span>
<span class="line" id="L571"></span>
<span class="line" id="L572">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unhit</span>(self: *Manifest, bin_digest: BinDigest, input_file_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L573">        <span class="tok-comment">// Reset the hash.</span>
</span>
<span class="line" id="L574">        self.hash.hasher = hasher_init;</span>
<span class="line" id="L575">        self.hash.hasher.update(&amp;bin_digest);</span>
<span class="line" id="L576"></span>
<span class="line" id="L577">        <span class="tok-comment">// Remove files not in the initial hash.</span>
</span>
<span class="line" id="L578">        <span class="tok-kw">for</span> (self.files.items[input_file_count..]) |*file| {</span>
<span class="line" id="L579">            file.deinit(self.cache.gpa);</span>
<span class="line" id="L580">        }</span>
<span class="line" id="L581">        self.files.shrinkRetainingCapacity(input_file_count);</span>
<span class="line" id="L582"></span>
<span class="line" id="L583">        <span class="tok-kw">for</span> (self.files.items) |file| {</span>
<span class="line" id="L584">            self.hash.hasher.update(&amp;file.bin_digest);</span>
<span class="line" id="L585">        }</span>
<span class="line" id="L586">    }</span>
<span class="line" id="L587"></span>
<span class="line" id="L588">    <span class="tok-kw">fn</span> <span class="tok-fn">isProblematicTimestamp</span>(man: *Manifest, file_time: <span class="tok-type">i128</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L589">        <span class="tok-comment">// If the file_time is prior to the most recent problematic timestamp</span>
</span>
<span class="line" id="L590">        <span class="tok-comment">// then we don't need to access the filesystem.</span>
</span>
<span class="line" id="L591">        <span class="tok-kw">if</span> (file_time &lt; man.recent_problematic_timestamp)</span>
<span class="line" id="L592">            <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L593"></span>
<span class="line" id="L594">        <span class="tok-comment">// Next we will check the globally shared Cache timestamp, which is accessed</span>
</span>
<span class="line" id="L595">        <span class="tok-comment">// from multiple threads.</span>
</span>
<span class="line" id="L596">        man.cache.mutex.lock();</span>
<span class="line" id="L597">        <span class="tok-kw">defer</span> man.cache.mutex.unlock();</span>
<span class="line" id="L598"></span>
<span class="line" id="L599">        <span class="tok-comment">// Save the global one to our local one to avoid locking next time.</span>
</span>
<span class="line" id="L600">        man.recent_problematic_timestamp = man.cache.recent_problematic_timestamp;</span>
<span class="line" id="L601">        <span class="tok-kw">if</span> (file_time &lt; man.recent_problematic_timestamp)</span>
<span class="line" id="L602">            <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L603"></span>
<span class="line" id="L604">        <span class="tok-comment">// This flag prevents multiple filesystem writes for the same hit() call.</span>
</span>
<span class="line" id="L605">        <span class="tok-kw">if</span> (man.want_refresh_timestamp) {</span>
<span class="line" id="L606">            man.want_refresh_timestamp = <span class="tok-null">false</span>;</span>
<span class="line" id="L607"></span>
<span class="line" id="L608">            <span class="tok-kw">var</span> file = man.cache.manifest_dir.createFile(<span class="tok-str">&quot;timestamp&quot;</span>, .{</span>
<span class="line" id="L609">                .read = <span class="tok-null">true</span>,</span>
<span class="line" id="L610">                .truncate = <span class="tok-null">true</span>,</span>
<span class="line" id="L611">            }) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L612">            <span class="tok-kw">defer</span> file.close();</span>
<span class="line" id="L613"></span>
<span class="line" id="L614">            <span class="tok-comment">// Save locally and also save globally (we still hold the global lock).</span>
</span>
<span class="line" id="L615">            man.recent_problematic_timestamp = (file.stat() <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">true</span>).mtime;</span>
<span class="line" id="L616">            man.cache.recent_problematic_timestamp = man.recent_problematic_timestamp;</span>
<span class="line" id="L617">        }</span>
<span class="line" id="L618"></span>
<span class="line" id="L619">        <span class="tok-kw">return</span> file_time &gt;= man.recent_problematic_timestamp;</span>
<span class="line" id="L620">    }</span>
<span class="line" id="L621"></span>
<span class="line" id="L622">    <span class="tok-kw">fn</span> <span class="tok-fn">populateFileHash</span>(self: *Manifest, ch_file: *File) !<span class="tok-type">void</span> {</span>
<span class="line" id="L623">        <span class="tok-kw">const</span> pp = ch_file.prefixed_path.?;</span>
<span class="line" id="L624">        <span class="tok-kw">const</span> dir = self.cache.prefixes()[pp.prefix].handle;</span>
<span class="line" id="L625">        <span class="tok-kw">const</span> file = <span class="tok-kw">try</span> dir.openFile(pp.sub_path, .{});</span>
<span class="line" id="L626">        <span class="tok-kw">defer</span> file.close();</span>
<span class="line" id="L627"></span>
<span class="line" id="L628">        <span class="tok-kw">const</span> actual_stat = <span class="tok-kw">try</span> file.stat();</span>
<span class="line" id="L629">        ch_file.stat = .{</span>
<span class="line" id="L630">            .size = actual_stat.size,</span>
<span class="line" id="L631">            .mtime = actual_stat.mtime,</span>
<span class="line" id="L632">            .inode = actual_stat.inode,</span>
<span class="line" id="L633">        };</span>
<span class="line" id="L634"></span>
<span class="line" id="L635">        <span class="tok-kw">if</span> (self.isProblematicTimestamp(ch_file.stat.mtime)) {</span>
<span class="line" id="L636">            <span class="tok-comment">// The actual file has an unreliable timestamp, force it to be hashed</span>
</span>
<span class="line" id="L637">            ch_file.stat.mtime = <span class="tok-number">0</span>;</span>
<span class="line" id="L638">            ch_file.stat.inode = <span class="tok-number">0</span>;</span>
<span class="line" id="L639">        }</span>
<span class="line" id="L640"></span>
<span class="line" id="L641">        <span class="tok-kw">if</span> (ch_file.max_file_size) |max_file_size| {</span>
<span class="line" id="L642">            <span class="tok-kw">if</span> (ch_file.stat.size &gt; max_file_size) {</span>
<span class="line" id="L643">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig;</span>
<span class="line" id="L644">            }</span>
<span class="line" id="L645"></span>
<span class="line" id="L646">            <span class="tok-kw">const</span> contents = <span class="tok-kw">try</span> self.cache.gpa.alloc(<span class="tok-type">u8</span>, <span class="tok-builtin">@intCast</span>(<span class="tok-type">usize</span>, ch_file.stat.size));</span>
<span class="line" id="L647">            <span class="tok-kw">errdefer</span> self.cache.gpa.free(contents);</span>
<span class="line" id="L648"></span>
<span class="line" id="L649">            <span class="tok-comment">// Hash while reading from disk, to keep the contents in the cpu cache while</span>
</span>
<span class="line" id="L650">            <span class="tok-comment">// doing hashing.</span>
</span>
<span class="line" id="L651">            <span class="tok-kw">var</span> hasher = hasher_init;</span>
<span class="line" id="L652">            <span class="tok-kw">var</span> off: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L653">            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L654">                <span class="tok-comment">// give me everything you've got, captain</span>
</span>
<span class="line" id="L655">                <span class="tok-kw">const</span> bytes_read = <span class="tok-kw">try</span> file.read(contents[off..]);</span>
<span class="line" id="L656">                <span class="tok-kw">if</span> (bytes_read == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;</span>
<span class="line" id="L657">                hasher.update(contents[off..][<span class="tok-number">0</span>..bytes_read]);</span>
<span class="line" id="L658">                off += bytes_read;</span>
<span class="line" id="L659">            }</span>
<span class="line" id="L660">            hasher.final(&amp;ch_file.bin_digest);</span>
<span class="line" id="L661"></span>
<span class="line" id="L662">            ch_file.contents = contents;</span>
<span class="line" id="L663">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L664">            <span class="tok-kw">try</span> hashFile(file, &amp;ch_file.bin_digest);</span>
<span class="line" id="L665">        }</span>
<span class="line" id="L666"></span>
<span class="line" id="L667">        self.hash.hasher.update(&amp;ch_file.bin_digest);</span>
<span class="line" id="L668">    }</span>
<span class="line" id="L669"></span>
<span class="line" id="L670">    <span class="tok-comment">/// Add a file as a dependency of process being cached, after the initial hash has been</span></span>
<span class="line" id="L671">    <span class="tok-comment">/// calculated. This is useful for processes that don't know all the files that</span></span>
<span class="line" id="L672">    <span class="tok-comment">/// are depended on ahead of time. For example, a source file that can import other files</span></span>
<span class="line" id="L673">    <span class="tok-comment">/// will need to be recompiled if the imported file is changed.</span></span>
<span class="line" id="L674">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFilePostFetch</span>(self: *Manifest, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, max_file_size: <span class="tok-type">usize</span>) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L675">        assert(self.manifest_file != <span class="tok-null">null</span>);</span>
<span class="line" id="L676"></span>
<span class="line" id="L677">        <span class="tok-kw">const</span> gpa = self.cache.gpa;</span>
<span class="line" id="L678">        <span class="tok-kw">const</span> prefixed_path = <span class="tok-kw">try</span> self.cache.findPrefix(file_path);</span>
<span class="line" id="L679">        <span class="tok-kw">errdefer</span> gpa.free(prefixed_path.sub_path);</span>
<span class="line" id="L680"></span>
<span class="line" id="L681">        <span class="tok-kw">const</span> new_ch_file = <span class="tok-kw">try</span> self.files.addOne(gpa);</span>
<span class="line" id="L682">        new_ch_file.* = .{</span>
<span class="line" id="L683">            .prefixed_path = prefixed_path,</span>
<span class="line" id="L684">            .max_file_size = max_file_size,</span>
<span class="line" id="L685">            .stat = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L686">            .bin_digest = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L687">            .contents = <span class="tok-null">null</span>,</span>
<span class="line" id="L688">        };</span>
<span class="line" id="L689">        <span class="tok-kw">errdefer</span> self.files.shrinkRetainingCapacity(self.files.items.len - <span class="tok-number">1</span>);</span>
<span class="line" id="L690"></span>
<span class="line" id="L691">        <span class="tok-kw">try</span> self.populateFileHash(new_ch_file);</span>
<span class="line" id="L692"></span>
<span class="line" id="L693">        <span class="tok-kw">return</span> new_ch_file.contents.?;</span>
<span class="line" id="L694">    }</span>
<span class="line" id="L695"></span>
<span class="line" id="L696">    <span class="tok-comment">/// Add a file as a dependency of process being cached, after the initial hash has been</span></span>
<span class="line" id="L697">    <span class="tok-comment">/// calculated. This is useful for processes that don't know the all the files that</span></span>
<span class="line" id="L698">    <span class="tok-comment">/// are depended on ahead of time. For example, a source file that can import other files</span></span>
<span class="line" id="L699">    <span class="tok-comment">/// will need to be recompiled if the imported file is changed.</span></span>
<span class="line" id="L700">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFilePost</span>(self: *Manifest, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L701">        assert(self.manifest_file != <span class="tok-null">null</span>);</span>
<span class="line" id="L702"></span>
<span class="line" id="L703">        <span class="tok-kw">const</span> gpa = self.cache.gpa;</span>
<span class="line" id="L704">        <span class="tok-kw">const</span> prefixed_path = <span class="tok-kw">try</span> self.cache.findPrefix(file_path);</span>
<span class="line" id="L705">        <span class="tok-kw">errdefer</span> gpa.free(prefixed_path.sub_path);</span>
<span class="line" id="L706"></span>
<span class="line" id="L707">        <span class="tok-kw">const</span> new_ch_file = <span class="tok-kw">try</span> self.files.addOne(gpa);</span>
<span class="line" id="L708">        new_ch_file.* = .{</span>
<span class="line" id="L709">            .prefixed_path = prefixed_path,</span>
<span class="line" id="L710">            .max_file_size = <span class="tok-null">null</span>,</span>
<span class="line" id="L711">            .stat = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L712">            .bin_digest = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L713">            .contents = <span class="tok-null">null</span>,</span>
<span class="line" id="L714">        };</span>
<span class="line" id="L715">        <span class="tok-kw">errdefer</span> self.files.shrinkRetainingCapacity(self.files.items.len - <span class="tok-number">1</span>);</span>
<span class="line" id="L716"></span>
<span class="line" id="L717">        <span class="tok-kw">try</span> self.populateFileHash(new_ch_file);</span>
<span class="line" id="L718">    }</span>
<span class="line" id="L719"></span>
<span class="line" id="L720">    <span class="tok-comment">/// Like `addFilePost` but when the file contents have already been loaded from disk.</span></span>
<span class="line" id="L721">    <span class="tok-comment">/// On success, cache takes ownership of `resolved_path`.</span></span>
<span class="line" id="L722">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFilePostContents</span>(</span>
<span class="line" id="L723">        self: *Manifest,</span>
<span class="line" id="L724">        resolved_path: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L725">        bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L726">        stat: File.Stat,</span>
<span class="line" id="L727">    ) <span class="tok-kw">error</span>{OutOfMemory}!<span class="tok-type">void</span> {</span>
<span class="line" id="L728">        assert(self.manifest_file != <span class="tok-null">null</span>);</span>
<span class="line" id="L729">        <span class="tok-kw">const</span> gpa = self.cache.gpa;</span>
<span class="line" id="L730"></span>
<span class="line" id="L731">        <span class="tok-kw">const</span> ch_file = <span class="tok-kw">try</span> self.files.addOne(gpa);</span>
<span class="line" id="L732">        <span class="tok-kw">errdefer</span> self.files.shrinkRetainingCapacity(self.files.items.len - <span class="tok-number">1</span>);</span>
<span class="line" id="L733"></span>
<span class="line" id="L734">        <span class="tok-kw">const</span> prefixed_path = <span class="tok-kw">try</span> self.cache.findPrefixResolved(resolved_path);</span>
<span class="line" id="L735">        <span class="tok-kw">errdefer</span> gpa.free(prefixed_path.sub_path);</span>
<span class="line" id="L736"></span>
<span class="line" id="L737">        ch_file.* = .{</span>
<span class="line" id="L738">            .prefixed_path = prefixed_path,</span>
<span class="line" id="L739">            .max_file_size = <span class="tok-null">null</span>,</span>
<span class="line" id="L740">            .stat = stat,</span>
<span class="line" id="L741">            .bin_digest = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L742">            .contents = <span class="tok-null">null</span>,</span>
<span class="line" id="L743">        };</span>
<span class="line" id="L744"></span>
<span class="line" id="L745">        <span class="tok-kw">if</span> (self.isProblematicTimestamp(ch_file.stat.mtime)) {</span>
<span class="line" id="L746">            <span class="tok-comment">// The actual file has an unreliable timestamp, force it to be hashed</span>
</span>
<span class="line" id="L747">            ch_file.stat.mtime = <span class="tok-number">0</span>;</span>
<span class="line" id="L748">            ch_file.stat.inode = <span class="tok-number">0</span>;</span>
<span class="line" id="L749">        }</span>
<span class="line" id="L750"></span>
<span class="line" id="L751">        {</span>
<span class="line" id="L752">            <span class="tok-kw">var</span> hasher = hasher_init;</span>
<span class="line" id="L753">            hasher.update(bytes);</span>
<span class="line" id="L754">            hasher.final(&amp;ch_file.bin_digest);</span>
<span class="line" id="L755">        }</span>
<span class="line" id="L756"></span>
<span class="line" id="L757">        self.hash.hasher.update(&amp;ch_file.bin_digest);</span>
<span class="line" id="L758">    }</span>
<span class="line" id="L759"></span>
<span class="line" id="L760">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addDepFilePost</span>(self: *Manifest, dir: fs.Dir, dep_file_basename: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L761">        assert(self.manifest_file != <span class="tok-null">null</span>);</span>
<span class="line" id="L762"></span>
<span class="line" id="L763">        <span class="tok-kw">const</span> dep_file_contents = <span class="tok-kw">try</span> dir.readFileAlloc(self.cache.gpa, dep_file_basename, manifest_file_size_max);</span>
<span class="line" id="L764">        <span class="tok-kw">defer</span> self.cache.gpa.free(dep_file_contents);</span>
<span class="line" id="L765"></span>
<span class="line" id="L766">        <span class="tok-kw">var</span> error_buf = std.ArrayList(<span class="tok-type">u8</span>).init(self.cache.gpa);</span>
<span class="line" id="L767">        <span class="tok-kw">defer</span> error_buf.deinit();</span>
<span class="line" id="L768"></span>
<span class="line" id="L769">        <span class="tok-kw">var</span> it: DepTokenizer = .{ .bytes = dep_file_contents };</span>
<span class="line" id="L770"></span>
<span class="line" id="L771">        <span class="tok-comment">// Skip first token: target.</span>
</span>
<span class="line" id="L772">        <span class="tok-kw">switch</span> (it.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>) { <span class="tok-comment">// Empty dep file OK.</span>
</span>
<span class="line" id="L773">            .target, .target_must_resolve, .prereq =&gt; {},</span>
<span class="line" id="L774">            <span class="tok-kw">else</span> =&gt; |err| {</span>
<span class="line" id="L775">                <span class="tok-kw">try</span> err.printError(error_buf.writer());</span>
<span class="line" id="L776">                log.err(<span class="tok-str">&quot;failed parsing {s}: {s}&quot;</span>, .{ dep_file_basename, error_buf.items });</span>
<span class="line" id="L777">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDepFile;</span>
<span class="line" id="L778">            },</span>
<span class="line" id="L779">        }</span>
<span class="line" id="L780">        <span class="tok-comment">// Process 0+ preqreqs.</span>
</span>
<span class="line" id="L781">        <span class="tok-comment">// Clang is invoked in single-source mode so we never get more targets.</span>
</span>
<span class="line" id="L782">        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L783">            <span class="tok-kw">switch</span> (it.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>) {</span>
<span class="line" id="L784">                .target, .target_must_resolve =&gt; <span class="tok-kw">return</span>,</span>
<span class="line" id="L785">                .prereq =&gt; |file_path| <span class="tok-kw">try</span> self.addFilePost(file_path),</span>
<span class="line" id="L786">                <span class="tok-kw">else</span> =&gt; |err| {</span>
<span class="line" id="L787">                    <span class="tok-kw">try</span> err.printError(error_buf.writer());</span>
<span class="line" id="L788">                    log.err(<span class="tok-str">&quot;failed parsing {s}: {s}&quot;</span>, .{ dep_file_basename, error_buf.items });</span>
<span class="line" id="L789">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDepFile;</span>
<span class="line" id="L790">                },</span>
<span class="line" id="L791">            }</span>
<span class="line" id="L792">        }</span>
<span class="line" id="L793">    }</span>
<span class="line" id="L794"></span>
<span class="line" id="L795">    <span class="tok-comment">/// Returns a hex encoded hash of the inputs.</span></span>
<span class="line" id="L796">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">final</span>(self: *Manifest) [hex_digest_len]<span class="tok-type">u8</span> {</span>
<span class="line" id="L797">        assert(self.manifest_file != <span class="tok-null">null</span>);</span>
<span class="line" id="L798"></span>
<span class="line" id="L799">        <span class="tok-comment">// We don't close the manifest file yet, because we want to</span>
</span>
<span class="line" id="L800">        <span class="tok-comment">// keep it locked until the API user is done using it.</span>
</span>
<span class="line" id="L801">        <span class="tok-comment">// We also don't write out the manifest yet, because until</span>
</span>
<span class="line" id="L802">        <span class="tok-comment">// cache_release is called we still might be working on creating</span>
</span>
<span class="line" id="L803">        <span class="tok-comment">// the artifacts to cache.</span>
</span>
<span class="line" id="L804"></span>
<span class="line" id="L805">        <span class="tok-kw">var</span> bin_digest: BinDigest = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L806">        self.hash.hasher.final(&amp;bin_digest);</span>
<span class="line" id="L807"></span>
<span class="line" id="L808">        <span class="tok-kw">var</span> out_digest: [hex_digest_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L809">        _ = std.fmt.bufPrint(</span>
<span class="line" id="L810">            &amp;out_digest,</span>
<span class="line" id="L811">            <span class="tok-str">&quot;{s}&quot;</span>,</span>
<span class="line" id="L812">            .{std.fmt.fmtSliceHexLower(&amp;bin_digest)},</span>
<span class="line" id="L813">        ) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L814"></span>
<span class="line" id="L815">        <span class="tok-kw">return</span> out_digest;</span>
<span class="line" id="L816">    }</span>
<span class="line" id="L817"></span>
<span class="line" id="L818">    <span class="tok-comment">/// If `want_shared_lock` is true, this function automatically downgrades the</span></span>
<span class="line" id="L819">    <span class="tok-comment">/// lock from exclusive to shared.</span></span>
<span class="line" id="L820">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeManifest</span>(self: *Manifest) !<span class="tok-type">void</span> {</span>
<span class="line" id="L821">        assert(self.have_exclusive_lock);</span>
<span class="line" id="L822"></span>
<span class="line" id="L823">        <span class="tok-kw">const</span> manifest_file = self.manifest_file.?;</span>
<span class="line" id="L824">        <span class="tok-kw">if</span> (self.manifest_dirty) {</span>
<span class="line" id="L825">            self.manifest_dirty = <span class="tok-null">false</span>;</span>
<span class="line" id="L826"></span>
<span class="line" id="L827">            <span class="tok-kw">var</span> contents = std.ArrayList(<span class="tok-type">u8</span>).init(self.cache.gpa);</span>
<span class="line" id="L828">            <span class="tok-kw">defer</span> contents.deinit();</span>
<span class="line" id="L829"></span>
<span class="line" id="L830">            <span class="tok-kw">const</span> writer = contents.writer();</span>
<span class="line" id="L831">            <span class="tok-kw">var</span> encoded_digest: [hex_digest_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L832"></span>
<span class="line" id="L833">            <span class="tok-kw">for</span> (self.files.items) |file| {</span>
<span class="line" id="L834">                _ = std.fmt.bufPrint(</span>
<span class="line" id="L835">                    &amp;encoded_digest,</span>
<span class="line" id="L836">                    <span class="tok-str">&quot;{s}&quot;</span>,</span>
<span class="line" id="L837">                    .{std.fmt.fmtSliceHexLower(&amp;file.bin_digest)},</span>
<span class="line" id="L838">                ) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L839">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{d} {d} {d} {s} {d} {s}\n&quot;</span>, .{</span>
<span class="line" id="L840">                    file.stat.size,</span>
<span class="line" id="L841">                    file.stat.inode,</span>
<span class="line" id="L842">                    file.stat.mtime,</span>
<span class="line" id="L843">                    &amp;encoded_digest,</span>
<span class="line" id="L844">                    file.prefixed_path.?.prefix,</span>
<span class="line" id="L845">                    file.prefixed_path.?.sub_path,</span>
<span class="line" id="L846">                });</span>
<span class="line" id="L847">            }</span>
<span class="line" id="L848"></span>
<span class="line" id="L849">            <span class="tok-kw">try</span> manifest_file.setEndPos(contents.items.len);</span>
<span class="line" id="L850">            <span class="tok-kw">try</span> manifest_file.pwriteAll(contents.items, <span class="tok-number">0</span>);</span>
<span class="line" id="L851">        }</span>
<span class="line" id="L852"></span>
<span class="line" id="L853">        <span class="tok-kw">if</span> (self.want_shared_lock) {</span>
<span class="line" id="L854">            <span class="tok-kw">try</span> self.downgradeToSharedLock();</span>
<span class="line" id="L855">        }</span>
<span class="line" id="L856">    }</span>
<span class="line" id="L857"></span>
<span class="line" id="L858">    <span class="tok-kw">fn</span> <span class="tok-fn">downgradeToSharedLock</span>(self: *Manifest) !<span class="tok-type">void</span> {</span>
<span class="line" id="L859">        <span class="tok-kw">if</span> (!self.have_exclusive_lock) <span class="tok-kw">return</span>;</span>
<span class="line" id="L860"></span>
<span class="line" id="L861">        <span class="tok-comment">// WASI does not currently support flock, so we bypass it here.</span>
</span>
<span class="line" id="L862">        <span class="tok-comment">// TODO: If/when flock is supported on WASI, this check should be removed.</span>
</span>
<span class="line" id="L863">        <span class="tok-comment">//       See https://github.com/WebAssembly/wasi-filesystem/issues/2</span>
</span>
<span class="line" id="L864">        <span class="tok-kw">if</span> (builtin.os.tag != .wasi <span class="tok-kw">or</span> std.process.can_spawn <span class="tok-kw">or</span> !builtin.single_threaded) {</span>
<span class="line" id="L865">            <span class="tok-kw">const</span> manifest_file = self.manifest_file.?;</span>
<span class="line" id="L866">            <span class="tok-kw">try</span> manifest_file.downgradeLock();</span>
<span class="line" id="L867">        }</span>
<span class="line" id="L868"></span>
<span class="line" id="L869">        self.have_exclusive_lock = <span class="tok-null">false</span>;</span>
<span class="line" id="L870">    }</span>
<span class="line" id="L871"></span>
<span class="line" id="L872">    <span class="tok-kw">fn</span> <span class="tok-fn">upgradeToExclusiveLock</span>(self: *Manifest) !<span class="tok-type">void</span> {</span>
<span class="line" id="L873">        <span class="tok-kw">if</span> (self.have_exclusive_lock) <span class="tok-kw">return</span>;</span>
<span class="line" id="L874">        assert(self.manifest_file != <span class="tok-null">null</span>);</span>
<span class="line" id="L875"></span>
<span class="line" id="L876">        <span class="tok-comment">// WASI does not currently support flock, so we bypass it here.</span>
</span>
<span class="line" id="L877">        <span class="tok-comment">// TODO: If/when flock is supported on WASI, this check should be removed.</span>
</span>
<span class="line" id="L878">        <span class="tok-comment">//       See https://github.com/WebAssembly/wasi-filesystem/issues/2</span>
</span>
<span class="line" id="L879">        <span class="tok-kw">if</span> (builtin.os.tag != .wasi <span class="tok-kw">or</span> std.process.can_spawn <span class="tok-kw">or</span> !builtin.single_threaded) {</span>
<span class="line" id="L880">            <span class="tok-kw">const</span> manifest_file = self.manifest_file.?;</span>
<span class="line" id="L881">            <span class="tok-comment">// Here we intentionally have a period where the lock is released, in case there are</span>
</span>
<span class="line" id="L882">            <span class="tok-comment">// other processes holding a shared lock.</span>
</span>
<span class="line" id="L883">            manifest_file.unlock();</span>
<span class="line" id="L884">            <span class="tok-kw">try</span> manifest_file.lock(.Exclusive);</span>
<span class="line" id="L885">        }</span>
<span class="line" id="L886">        self.have_exclusive_lock = <span class="tok-null">true</span>;</span>
<span class="line" id="L887">    }</span>
<span class="line" id="L888"></span>
<span class="line" id="L889">    <span class="tok-comment">/// Obtain only the data needed to maintain a lock on the manifest file.</span></span>
<span class="line" id="L890">    <span class="tok-comment">/// The `Manifest` remains safe to deinit.</span></span>
<span class="line" id="L891">    <span class="tok-comment">/// Don't forget to call `writeManifest` before this!</span></span>
<span class="line" id="L892">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toOwnedLock</span>(self: *Manifest) Lock {</span>
<span class="line" id="L893">        <span class="tok-kw">const</span> lock: Lock = .{</span>
<span class="line" id="L894">            .manifest_file = self.manifest_file.?,</span>
<span class="line" id="L895">        };</span>
<span class="line" id="L896"></span>
<span class="line" id="L897">        self.manifest_file = <span class="tok-null">null</span>;</span>
<span class="line" id="L898">        <span class="tok-kw">return</span> lock;</span>
<span class="line" id="L899">    }</span>
<span class="line" id="L900"></span>
<span class="line" id="L901">    <span class="tok-comment">/// Releases the manifest file and frees any memory the Manifest was using.</span></span>
<span class="line" id="L902">    <span class="tok-comment">/// `Manifest.hit` must be called first.</span></span>
<span class="line" id="L903">    <span class="tok-comment">/// Don't forget to call `writeManifest` before this!</span></span>
<span class="line" id="L904">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *Manifest) <span class="tok-type">void</span> {</span>
<span class="line" id="L905">        <span class="tok-kw">if</span> (self.manifest_file) |file| {</span>
<span class="line" id="L906">            <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L907">                <span class="tok-comment">// See Lock.release for why this is required on Windows</span>
</span>
<span class="line" id="L908">                file.unlock();</span>
<span class="line" id="L909">            }</span>
<span class="line" id="L910"></span>
<span class="line" id="L911">            file.close();</span>
<span class="line" id="L912">        }</span>
<span class="line" id="L913">        <span class="tok-kw">for</span> (self.files.items) |*file| {</span>
<span class="line" id="L914">            file.deinit(self.cache.gpa);</span>
<span class="line" id="L915">        }</span>
<span class="line" id="L916">        self.files.deinit(self.cache.gpa);</span>
<span class="line" id="L917">    }</span>
<span class="line" id="L918">};</span>
<span class="line" id="L919"></span>
<span class="line" id="L920"><span class="tok-comment">/// On operating systems that support symlinks, does a readlink. On other operating systems,</span></span>
<span class="line" id="L921"><span class="tok-comment">/// uses the file contents. Windows supports symlinks but only with elevated privileges, so</span></span>
<span class="line" id="L922"><span class="tok-comment">/// it is treated as not supporting symlinks.</span></span>
<span class="line" id="L923"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readSmallFile</span>(dir: fs.Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L924">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L925">        <span class="tok-kw">return</span> dir.readFile(sub_path, buffer);</span>
<span class="line" id="L926">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L927">        <span class="tok-kw">return</span> dir.readLink(sub_path, buffer);</span>
<span class="line" id="L928">    }</span>
<span class="line" id="L929">}</span>
<span class="line" id="L930"></span>
<span class="line" id="L931"><span class="tok-comment">/// On operating systems that support symlinks, does a symlink. On other operating systems,</span></span>
<span class="line" id="L932"><span class="tok-comment">/// uses the file contents. Windows supports symlinks but only with elevated privileges, so</span></span>
<span class="line" id="L933"><span class="tok-comment">/// it is treated as not supporting symlinks.</span></span>
<span class="line" id="L934"><span class="tok-comment">/// `data` must be a valid UTF-8 encoded file path and 255 bytes or fewer.</span></span>
<span class="line" id="L935"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeSmallFile</span>(dir: fs.Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L936">    assert(data.len &lt;= <span class="tok-number">255</span>);</span>
<span class="line" id="L937">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L938">        <span class="tok-kw">return</span> dir.writeFile(sub_path, data);</span>
<span class="line" id="L939">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L940">        <span class="tok-kw">return</span> dir.symLink(data, sub_path, .{});</span>
<span class="line" id="L941">    }</span>
<span class="line" id="L942">}</span>
<span class="line" id="L943"></span>
<span class="line" id="L944"><span class="tok-kw">fn</span> <span class="tok-fn">hashFile</span>(file: fs.File, bin_digest: *[Hasher.mac_length]<span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L945">    <span class="tok-kw">var</span> buf: [<span class="tok-number">1024</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L946"></span>
<span class="line" id="L947">    <span class="tok-kw">var</span> hasher = hasher_init;</span>
<span class="line" id="L948">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L949">        <span class="tok-kw">const</span> bytes_read = <span class="tok-kw">try</span> file.read(&amp;buf);</span>
<span class="line" id="L950">        <span class="tok-kw">if</span> (bytes_read == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;</span>
<span class="line" id="L951">        hasher.update(buf[<span class="tok-number">0</span>..bytes_read]);</span>
<span class="line" id="L952">    }</span>
<span class="line" id="L953"></span>
<span class="line" id="L954">    hasher.final(bin_digest);</span>
<span class="line" id="L955">}</span>
<span class="line" id="L956"></span>
<span class="line" id="L957"><span class="tok-comment">// Create/Write a file, close it, then grab its stat.mtime timestamp.</span>
</span>
<span class="line" id="L958"><span class="tok-kw">fn</span> <span class="tok-fn">testGetCurrentFileTimestamp</span>() !<span class="tok-type">i128</span> {</span>
<span class="line" id="L959">    <span class="tok-kw">var</span> file = <span class="tok-kw">try</span> fs.cwd().createFile(<span class="tok-str">&quot;test-filetimestamp.tmp&quot;</span>, .{</span>
<span class="line" id="L960">        .read = <span class="tok-null">true</span>,</span>
<span class="line" id="L961">        .truncate = <span class="tok-null">true</span>,</span>
<span class="line" id="L962">    });</span>
<span class="line" id="L963">    <span class="tok-kw">defer</span> file.close();</span>
<span class="line" id="L964"></span>
<span class="line" id="L965">    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> file.stat()).mtime;</span>
<span class="line" id="L966">}</span>
<span class="line" id="L967"></span>
<span class="line" id="L968"><span class="tok-kw">test</span> <span class="tok-str">&quot;cache file and then recall it&quot;</span> {</span>
<span class="line" id="L969">    <span class="tok-kw">if</span> (builtin.os.tag == .wasi) {</span>
<span class="line" id="L970">        <span class="tok-comment">// https://github.com/ziglang/zig/issues/5437</span>
</span>
<span class="line" id="L971">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;</span>
<span class="line" id="L972">    }</span>
<span class="line" id="L973"></span>
<span class="line" id="L974">    <span class="tok-kw">const</span> cwd = fs.cwd();</span>
<span class="line" id="L975"></span>
<span class="line" id="L976">    <span class="tok-kw">const</span> temp_file = <span class="tok-str">&quot;test.txt&quot;</span>;</span>
<span class="line" id="L977">    <span class="tok-kw">const</span> temp_manifest_dir = <span class="tok-str">&quot;temp_manifest_dir&quot;</span>;</span>
<span class="line" id="L978"></span>
<span class="line" id="L979">    <span class="tok-kw">try</span> cwd.writeFile(temp_file, <span class="tok-str">&quot;Hello, world!\n&quot;</span>);</span>
<span class="line" id="L980"></span>
<span class="line" id="L981">    <span class="tok-comment">// Wait for file timestamps to tick</span>
</span>
<span class="line" id="L982">    <span class="tok-kw">const</span> initial_time = <span class="tok-kw">try</span> testGetCurrentFileTimestamp();</span>
<span class="line" id="L983">    <span class="tok-kw">while</span> ((<span class="tok-kw">try</span> testGetCurrentFileTimestamp()) == initial_time) {</span>
<span class="line" id="L984">        std.time.sleep(<span class="tok-number">1</span>);</span>
<span class="line" id="L985">    }</span>
<span class="line" id="L986"></span>
<span class="line" id="L987">    <span class="tok-kw">var</span> digest1: [hex_digest_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L988">    <span class="tok-kw">var</span> digest2: [hex_digest_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L989"></span>
<span class="line" id="L990">    {</span>
<span class="line" id="L991">        <span class="tok-kw">var</span> cache = Cache{</span>
<span class="line" id="L992">            .gpa = testing.allocator,</span>
<span class="line" id="L993">            .manifest_dir = <span class="tok-kw">try</span> cwd.makeOpenPath(temp_manifest_dir, .{}),</span>
<span class="line" id="L994">        };</span>
<span class="line" id="L995">        cache.addPrefix(.{ .path = <span class="tok-null">null</span>, .handle = fs.cwd() });</span>
<span class="line" id="L996">        <span class="tok-kw">defer</span> cache.manifest_dir.close();</span>
<span class="line" id="L997"></span>
<span class="line" id="L998">        {</span>
<span class="line" id="L999">            <span class="tok-kw">var</span> ch = cache.obtain();</span>
<span class="line" id="L1000">            <span class="tok-kw">defer</span> ch.deinit();</span>
<span class="line" id="L1001"></span>
<span class="line" id="L1002">            ch.hash.add(<span class="tok-null">true</span>);</span>
<span class="line" id="L1003">            ch.hash.add(<span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-number">1234</span>));</span>
<span class="line" id="L1004">            ch.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);</span>
<span class="line" id="L1005">            _ = <span class="tok-kw">try</span> ch.addFile(temp_file, <span class="tok-null">null</span>);</span>
<span class="line" id="L1006"></span>
<span class="line" id="L1007">            <span class="tok-comment">// There should be nothing in the cache</span>
</span>
<span class="line" id="L1008">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-null">false</span>, <span class="tok-kw">try</span> ch.hit());</span>
<span class="line" id="L1009"></span>
<span class="line" id="L1010">            digest1 = ch.final();</span>
<span class="line" id="L1011">            <span class="tok-kw">try</span> ch.writeManifest();</span>
<span class="line" id="L1012">        }</span>
<span class="line" id="L1013">        {</span>
<span class="line" id="L1014">            <span class="tok-kw">var</span> ch = cache.obtain();</span>
<span class="line" id="L1015">            <span class="tok-kw">defer</span> ch.deinit();</span>
<span class="line" id="L1016"></span>
<span class="line" id="L1017">            ch.hash.add(<span class="tok-null">true</span>);</span>
<span class="line" id="L1018">            ch.hash.add(<span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-number">1234</span>));</span>
<span class="line" id="L1019">            ch.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);</span>
<span class="line" id="L1020">            _ = <span class="tok-kw">try</span> ch.addFile(temp_file, <span class="tok-null">null</span>);</span>
<span class="line" id="L1021"></span>
<span class="line" id="L1022">            <span class="tok-comment">// Cache hit! We just &quot;built&quot; the same file</span>
</span>
<span class="line" id="L1023">            <span class="tok-kw">try</span> testing.expect(<span class="tok-kw">try</span> ch.hit());</span>
<span class="line" id="L1024">            digest2 = ch.final();</span>
<span class="line" id="L1025"></span>
<span class="line" id="L1026">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-null">false</span>, ch.have_exclusive_lock);</span>
<span class="line" id="L1027">        }</span>
<span class="line" id="L1028"></span>
<span class="line" id="L1029">        <span class="tok-kw">try</span> testing.expectEqual(digest1, digest2);</span>
<span class="line" id="L1030">    }</span>
<span class="line" id="L1031"></span>
<span class="line" id="L1032">    <span class="tok-kw">try</span> cwd.deleteTree(temp_manifest_dir);</span>
<span class="line" id="L1033">    <span class="tok-kw">try</span> cwd.deleteFile(temp_file);</span>
<span class="line" id="L1034">}</span>
<span class="line" id="L1035"></span>
<span class="line" id="L1036"><span class="tok-kw">test</span> <span class="tok-str">&quot;check that changing a file makes cache fail&quot;</span> {</span>
<span class="line" id="L1037">    <span class="tok-kw">if</span> (builtin.os.tag == .wasi) {</span>
<span class="line" id="L1038">        <span class="tok-comment">// https://github.com/ziglang/zig/issues/5437</span>
</span>
<span class="line" id="L1039">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;</span>
<span class="line" id="L1040">    }</span>
<span class="line" id="L1041">    <span class="tok-kw">const</span> cwd = fs.cwd();</span>
<span class="line" id="L1042"></span>
<span class="line" id="L1043">    <span class="tok-kw">const</span> temp_file = <span class="tok-str">&quot;cache_hash_change_file_test.txt&quot;</span>;</span>
<span class="line" id="L1044">    <span class="tok-kw">const</span> temp_manifest_dir = <span class="tok-str">&quot;cache_hash_change_file_manifest_dir&quot;</span>;</span>
<span class="line" id="L1045">    <span class="tok-kw">const</span> original_temp_file_contents = <span class="tok-str">&quot;Hello, world!\n&quot;</span>;</span>
<span class="line" id="L1046">    <span class="tok-kw">const</span> updated_temp_file_contents = <span class="tok-str">&quot;Hello, world; but updated!\n&quot;</span>;</span>
<span class="line" id="L1047"></span>
<span class="line" id="L1048">    <span class="tok-kw">try</span> cwd.deleteTree(temp_manifest_dir);</span>
<span class="line" id="L1049">    <span class="tok-kw">try</span> cwd.deleteTree(temp_file);</span>
<span class="line" id="L1050"></span>
<span class="line" id="L1051">    <span class="tok-kw">try</span> cwd.writeFile(temp_file, original_temp_file_contents);</span>
<span class="line" id="L1052"></span>
<span class="line" id="L1053">    <span class="tok-comment">// Wait for file timestamps to tick</span>
</span>
<span class="line" id="L1054">    <span class="tok-kw">const</span> initial_time = <span class="tok-kw">try</span> testGetCurrentFileTimestamp();</span>
<span class="line" id="L1055">    <span class="tok-kw">while</span> ((<span class="tok-kw">try</span> testGetCurrentFileTimestamp()) == initial_time) {</span>
<span class="line" id="L1056">        std.time.sleep(<span class="tok-number">1</span>);</span>
<span class="line" id="L1057">    }</span>
<span class="line" id="L1058"></span>
<span class="line" id="L1059">    <span class="tok-kw">var</span> digest1: [hex_digest_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1060">    <span class="tok-kw">var</span> digest2: [hex_digest_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1061"></span>
<span class="line" id="L1062">    {</span>
<span class="line" id="L1063">        <span class="tok-kw">var</span> cache = Cache{</span>
<span class="line" id="L1064">            .gpa = testing.allocator,</span>
<span class="line" id="L1065">            .manifest_dir = <span class="tok-kw">try</span> cwd.makeOpenPath(temp_manifest_dir, .{}),</span>
<span class="line" id="L1066">        };</span>
<span class="line" id="L1067">        cache.addPrefix(.{ .path = <span class="tok-null">null</span>, .handle = fs.cwd() });</span>
<span class="line" id="L1068">        <span class="tok-kw">defer</span> cache.manifest_dir.close();</span>
<span class="line" id="L1069"></span>
<span class="line" id="L1070">        {</span>
<span class="line" id="L1071">            <span class="tok-kw">var</span> ch = cache.obtain();</span>
<span class="line" id="L1072">            <span class="tok-kw">defer</span> ch.deinit();</span>
<span class="line" id="L1073"></span>
<span class="line" id="L1074">            ch.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);</span>
<span class="line" id="L1075">            <span class="tok-kw">const</span> temp_file_idx = <span class="tok-kw">try</span> ch.addFile(temp_file, <span class="tok-number">100</span>);</span>
<span class="line" id="L1076"></span>
<span class="line" id="L1077">            <span class="tok-comment">// There should be nothing in the cache</span>
</span>
<span class="line" id="L1078">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-null">false</span>, <span class="tok-kw">try</span> ch.hit());</span>
<span class="line" id="L1079"></span>
<span class="line" id="L1080">            <span class="tok-kw">try</span> testing.expect(mem.eql(<span class="tok-type">u8</span>, original_temp_file_contents, ch.files.items[temp_file_idx].contents.?));</span>
<span class="line" id="L1081"></span>
<span class="line" id="L1082">            digest1 = ch.final();</span>
<span class="line" id="L1083"></span>
<span class="line" id="L1084">            <span class="tok-kw">try</span> ch.writeManifest();</span>
<span class="line" id="L1085">        }</span>
<span class="line" id="L1086"></span>
<span class="line" id="L1087">        <span class="tok-kw">try</span> cwd.writeFile(temp_file, updated_temp_file_contents);</span>
<span class="line" id="L1088"></span>
<span class="line" id="L1089">        {</span>
<span class="line" id="L1090">            <span class="tok-kw">var</span> ch = cache.obtain();</span>
<span class="line" id="L1091">            <span class="tok-kw">defer</span> ch.deinit();</span>
<span class="line" id="L1092"></span>
<span class="line" id="L1093">            ch.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);</span>
<span class="line" id="L1094">            <span class="tok-kw">const</span> temp_file_idx = <span class="tok-kw">try</span> ch.addFile(temp_file, <span class="tok-number">100</span>);</span>
<span class="line" id="L1095"></span>
<span class="line" id="L1096">            <span class="tok-comment">// A file that we depend on has been updated, so the cache should not contain an entry for it</span>
</span>
<span class="line" id="L1097">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-null">false</span>, <span class="tok-kw">try</span> ch.hit());</span>
<span class="line" id="L1098"></span>
<span class="line" id="L1099">            <span class="tok-comment">// The cache system does not keep the contents of re-hashed input files.</span>
</span>
<span class="line" id="L1100">            <span class="tok-kw">try</span> testing.expect(ch.files.items[temp_file_idx].contents == <span class="tok-null">null</span>);</span>
<span class="line" id="L1101"></span>
<span class="line" id="L1102">            digest2 = ch.final();</span>
<span class="line" id="L1103"></span>
<span class="line" id="L1104">            <span class="tok-kw">try</span> ch.writeManifest();</span>
<span class="line" id="L1105">        }</span>
<span class="line" id="L1106"></span>
<span class="line" id="L1107">        <span class="tok-kw">try</span> testing.expect(!mem.eql(<span class="tok-type">u8</span>, digest1[<span class="tok-number">0</span>..], digest2[<span class="tok-number">0</span>..]));</span>
<span class="line" id="L1108">    }</span>
<span class="line" id="L1109"></span>
<span class="line" id="L1110">    <span class="tok-kw">try</span> cwd.deleteTree(temp_manifest_dir);</span>
<span class="line" id="L1111">    <span class="tok-kw">try</span> cwd.deleteTree(temp_file);</span>
<span class="line" id="L1112">}</span>
<span class="line" id="L1113"></span>
<span class="line" id="L1114"><span class="tok-kw">test</span> <span class="tok-str">&quot;no file inputs&quot;</span> {</span>
<span class="line" id="L1115">    <span class="tok-kw">if</span> (builtin.os.tag == .wasi) {</span>
<span class="line" id="L1116">        <span class="tok-comment">// https://github.com/ziglang/zig/issues/5437</span>
</span>
<span class="line" id="L1117">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;</span>
<span class="line" id="L1118">    }</span>
<span class="line" id="L1119">    <span class="tok-kw">const</span> cwd = fs.cwd();</span>
<span class="line" id="L1120">    <span class="tok-kw">const</span> temp_manifest_dir = <span class="tok-str">&quot;no_file_inputs_manifest_dir&quot;</span>;</span>
<span class="line" id="L1121">    <span class="tok-kw">defer</span> cwd.deleteTree(temp_manifest_dir) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L1122"></span>
<span class="line" id="L1123">    <span class="tok-kw">var</span> digest1: [hex_digest_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1124">    <span class="tok-kw">var</span> digest2: [hex_digest_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1125"></span>
<span class="line" id="L1126">    <span class="tok-kw">var</span> cache = Cache{</span>
<span class="line" id="L1127">        .gpa = testing.allocator,</span>
<span class="line" id="L1128">        .manifest_dir = <span class="tok-kw">try</span> cwd.makeOpenPath(temp_manifest_dir, .{}),</span>
<span class="line" id="L1129">    };</span>
<span class="line" id="L1130">    cache.addPrefix(.{ .path = <span class="tok-null">null</span>, .handle = fs.cwd() });</span>
<span class="line" id="L1131">    <span class="tok-kw">defer</span> cache.manifest_dir.close();</span>
<span class="line" id="L1132"></span>
<span class="line" id="L1133">    {</span>
<span class="line" id="L1134">        <span class="tok-kw">var</span> man = cache.obtain();</span>
<span class="line" id="L1135">        <span class="tok-kw">defer</span> man.deinit();</span>
<span class="line" id="L1136"></span>
<span class="line" id="L1137">        man.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);</span>
<span class="line" id="L1138"></span>
<span class="line" id="L1139">        <span class="tok-comment">// There should be nothing in the cache</span>
</span>
<span class="line" id="L1140">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-null">false</span>, <span class="tok-kw">try</span> man.hit());</span>
<span class="line" id="L1141"></span>
<span class="line" id="L1142">        digest1 = man.final();</span>
<span class="line" id="L1143"></span>
<span class="line" id="L1144">        <span class="tok-kw">try</span> man.writeManifest();</span>
<span class="line" id="L1145">    }</span>
<span class="line" id="L1146">    {</span>
<span class="line" id="L1147">        <span class="tok-kw">var</span> man = cache.obtain();</span>
<span class="line" id="L1148">        <span class="tok-kw">defer</span> man.deinit();</span>
<span class="line" id="L1149"></span>
<span class="line" id="L1150">        man.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);</span>
<span class="line" id="L1151"></span>
<span class="line" id="L1152">        <span class="tok-kw">try</span> testing.expect(<span class="tok-kw">try</span> man.hit());</span>
<span class="line" id="L1153">        digest2 = man.final();</span>
<span class="line" id="L1154">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-null">false</span>, man.have_exclusive_lock);</span>
<span class="line" id="L1155">    }</span>
<span class="line" id="L1156"></span>
<span class="line" id="L1157">    <span class="tok-kw">try</span> testing.expectEqual(digest1, digest2);</span>
<span class="line" id="L1158">}</span>
<span class="line" id="L1159"></span>
<span class="line" id="L1160"><span class="tok-kw">test</span> <span class="tok-str">&quot;Manifest with files added after initial hash work&quot;</span> {</span>
<span class="line" id="L1161">    <span class="tok-kw">if</span> (builtin.os.tag == .wasi) {</span>
<span class="line" id="L1162">        <span class="tok-comment">// https://github.com/ziglang/zig/issues/5437</span>
</span>
<span class="line" id="L1163">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;</span>
<span class="line" id="L1164">    }</span>
<span class="line" id="L1165">    <span class="tok-kw">const</span> cwd = fs.cwd();</span>
<span class="line" id="L1166"></span>
<span class="line" id="L1167">    <span class="tok-kw">const</span> temp_file1 = <span class="tok-str">&quot;cache_hash_post_file_test1.txt&quot;</span>;</span>
<span class="line" id="L1168">    <span class="tok-kw">const</span> temp_file2 = <span class="tok-str">&quot;cache_hash_post_file_test2.txt&quot;</span>;</span>
<span class="line" id="L1169">    <span class="tok-kw">const</span> temp_manifest_dir = <span class="tok-str">&quot;cache_hash_post_file_manifest_dir&quot;</span>;</span>
<span class="line" id="L1170"></span>
<span class="line" id="L1171">    <span class="tok-kw">try</span> cwd.writeFile(temp_file1, <span class="tok-str">&quot;Hello, world!\n&quot;</span>);</span>
<span class="line" id="L1172">    <span class="tok-kw">try</span> cwd.writeFile(temp_file2, <span class="tok-str">&quot;Hello world the second!\n&quot;</span>);</span>
<span class="line" id="L1173"></span>
<span class="line" id="L1174">    <span class="tok-comment">// Wait for file timestamps to tick</span>
</span>
<span class="line" id="L1175">    <span class="tok-kw">const</span> initial_time = <span class="tok-kw">try</span> testGetCurrentFileTimestamp();</span>
<span class="line" id="L1176">    <span class="tok-kw">while</span> ((<span class="tok-kw">try</span> testGetCurrentFileTimestamp()) == initial_time) {</span>
<span class="line" id="L1177">        std.time.sleep(<span class="tok-number">1</span>);</span>
<span class="line" id="L1178">    }</span>
<span class="line" id="L1179"></span>
<span class="line" id="L1180">    <span class="tok-kw">var</span> digest1: [hex_digest_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1181">    <span class="tok-kw">var</span> digest2: [hex_digest_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1182">    <span class="tok-kw">var</span> digest3: [hex_digest_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1183"></span>
<span class="line" id="L1184">    {</span>
<span class="line" id="L1185">        <span class="tok-kw">var</span> cache = Cache{</span>
<span class="line" id="L1186">            .gpa = testing.allocator,</span>
<span class="line" id="L1187">            .manifest_dir = <span class="tok-kw">try</span> cwd.makeOpenPath(temp_manifest_dir, .{}),</span>
<span class="line" id="L1188">        };</span>
<span class="line" id="L1189">        cache.addPrefix(.{ .path = <span class="tok-null">null</span>, .handle = fs.cwd() });</span>
<span class="line" id="L1190">        <span class="tok-kw">defer</span> cache.manifest_dir.close();</span>
<span class="line" id="L1191"></span>
<span class="line" id="L1192">        {</span>
<span class="line" id="L1193">            <span class="tok-kw">var</span> ch = cache.obtain();</span>
<span class="line" id="L1194">            <span class="tok-kw">defer</span> ch.deinit();</span>
<span class="line" id="L1195"></span>
<span class="line" id="L1196">            ch.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);</span>
<span class="line" id="L1197">            _ = <span class="tok-kw">try</span> ch.addFile(temp_file1, <span class="tok-null">null</span>);</span>
<span class="line" id="L1198"></span>
<span class="line" id="L1199">            <span class="tok-comment">// There should be nothing in the cache</span>
</span>
<span class="line" id="L1200">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-null">false</span>, <span class="tok-kw">try</span> ch.hit());</span>
<span class="line" id="L1201"></span>
<span class="line" id="L1202">            _ = <span class="tok-kw">try</span> ch.addFilePost(temp_file2);</span>
<span class="line" id="L1203"></span>
<span class="line" id="L1204">            digest1 = ch.final();</span>
<span class="line" id="L1205">            <span class="tok-kw">try</span> ch.writeManifest();</span>
<span class="line" id="L1206">        }</span>
<span class="line" id="L1207">        {</span>
<span class="line" id="L1208">            <span class="tok-kw">var</span> ch = cache.obtain();</span>
<span class="line" id="L1209">            <span class="tok-kw">defer</span> ch.deinit();</span>
<span class="line" id="L1210"></span>
<span class="line" id="L1211">            ch.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);</span>
<span class="line" id="L1212">            _ = <span class="tok-kw">try</span> ch.addFile(temp_file1, <span class="tok-null">null</span>);</span>
<span class="line" id="L1213"></span>
<span class="line" id="L1214">            <span class="tok-kw">try</span> testing.expect(<span class="tok-kw">try</span> ch.hit());</span>
<span class="line" id="L1215">            digest2 = ch.final();</span>
<span class="line" id="L1216"></span>
<span class="line" id="L1217">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-null">false</span>, ch.have_exclusive_lock);</span>
<span class="line" id="L1218">        }</span>
<span class="line" id="L1219">        <span class="tok-kw">try</span> testing.expect(mem.eql(<span class="tok-type">u8</span>, &amp;digest1, &amp;digest2));</span>
<span class="line" id="L1220"></span>
<span class="line" id="L1221">        <span class="tok-comment">// Modify the file added after initial hash</span>
</span>
<span class="line" id="L1222">        <span class="tok-kw">try</span> cwd.writeFile(temp_file2, <span class="tok-str">&quot;Hello world the second, updated\n&quot;</span>);</span>
<span class="line" id="L1223"></span>
<span class="line" id="L1224">        <span class="tok-comment">// Wait for file timestamps to tick</span>
</span>
<span class="line" id="L1225">        <span class="tok-kw">const</span> initial_time2 = <span class="tok-kw">try</span> testGetCurrentFileTimestamp();</span>
<span class="line" id="L1226">        <span class="tok-kw">while</span> ((<span class="tok-kw">try</span> testGetCurrentFileTimestamp()) == initial_time2) {</span>
<span class="line" id="L1227">            std.time.sleep(<span class="tok-number">1</span>);</span>
<span class="line" id="L1228">        }</span>
<span class="line" id="L1229"></span>
<span class="line" id="L1230">        {</span>
<span class="line" id="L1231">            <span class="tok-kw">var</span> ch = cache.obtain();</span>
<span class="line" id="L1232">            <span class="tok-kw">defer</span> ch.deinit();</span>
<span class="line" id="L1233"></span>
<span class="line" id="L1234">            ch.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);</span>
<span class="line" id="L1235">            _ = <span class="tok-kw">try</span> ch.addFile(temp_file1, <span class="tok-null">null</span>);</span>
<span class="line" id="L1236"></span>
<span class="line" id="L1237">            <span class="tok-comment">// A file that we depend on has been updated, so the cache should not contain an entry for it</span>
</span>
<span class="line" id="L1238">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-null">false</span>, <span class="tok-kw">try</span> ch.hit());</span>
<span class="line" id="L1239"></span>
<span class="line" id="L1240">            _ = <span class="tok-kw">try</span> ch.addFilePost(temp_file2);</span>
<span class="line" id="L1241"></span>
<span class="line" id="L1242">            digest3 = ch.final();</span>
<span class="line" id="L1243"></span>
<span class="line" id="L1244">            <span class="tok-kw">try</span> ch.writeManifest();</span>
<span class="line" id="L1245">        }</span>
<span class="line" id="L1246"></span>
<span class="line" id="L1247">        <span class="tok-kw">try</span> testing.expect(!mem.eql(<span class="tok-type">u8</span>, &amp;digest1, &amp;digest3));</span>
<span class="line" id="L1248">    }</span>
<span class="line" id="L1249"></span>
<span class="line" id="L1250">    <span class="tok-kw">try</span> cwd.deleteTree(temp_manifest_dir);</span>
<span class="line" id="L1251">    <span class="tok-kw">try</span> cwd.deleteFile(temp_file1);</span>
<span class="line" id="L1252">    <span class="tok-kw">try</span> cwd.deleteFile(temp_file2);</span>
<span class="line" id="L1253">}</span>
<span class="line" id="L1254"></span>
</code></pre></body>
</html>