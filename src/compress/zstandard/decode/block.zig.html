<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>compress/zstandard/decode/block.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg=="/>
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);</span>
<span class="line" id="L2"><span class="tok-kw">const</span> assert = std.debug.assert;</span>
<span class="line" id="L3"><span class="tok-kw">const</span> RingBuffer = std.RingBuffer;</span>
<span class="line" id="L4"></span>
<span class="line" id="L5"><span class="tok-kw">const</span> types = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;../types.zig&quot;</span>);</span>
<span class="line" id="L6"><span class="tok-kw">const</span> frame = types.frame;</span>
<span class="line" id="L7"><span class="tok-kw">const</span> Table = types.compressed_block.Table;</span>
<span class="line" id="L8"><span class="tok-kw">const</span> LiteralsSection = types.compressed_block.LiteralsSection;</span>
<span class="line" id="L9"><span class="tok-kw">const</span> SequencesSection = types.compressed_block.SequencesSection;</span>
<span class="line" id="L10"></span>
<span class="line" id="L11"><span class="tok-kw">const</span> huffman = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;huffman.zig&quot;</span>);</span>
<span class="line" id="L12"><span class="tok-kw">const</span> readers = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;../readers.zig&quot;</span>);</span>
<span class="line" id="L13"></span>
<span class="line" id="L14"><span class="tok-kw">const</span> decodeFseTable = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fse.zig&quot;</span>).decodeFseTable;</span>
<span class="line" id="L15"></span>
<span class="line" id="L16"><span class="tok-kw">const</span> readInt = std.mem.readIntLittle;</span>
<span class="line" id="L17"></span>
<span class="line" id="L18"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <span class="tok-kw">error</span>{</span>
<span class="line" id="L19">    BlockSizeOverMaximum,</span>
<span class="line" id="L20">    MalformedBlockSize,</span>
<span class="line" id="L21">    ReservedBlock,</span>
<span class="line" id="L22">    MalformedRleBlock,</span>
<span class="line" id="L23">    MalformedCompressedBlock,</span>
<span class="line" id="L24">};</span>
<span class="line" id="L25"></span>
<span class="line" id="L26"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DecodeState = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L27">    repeat_offsets: [<span class="tok-number">3</span>]<span class="tok-type">u32</span>,</span>
<span class="line" id="L28"></span>
<span class="line" id="L29">    offset: StateData(<span class="tok-number">8</span>),</span>
<span class="line" id="L30">    match: StateData(<span class="tok-number">9</span>),</span>
<span class="line" id="L31">    literal: StateData(<span class="tok-number">9</span>),</span>
<span class="line" id="L32"></span>
<span class="line" id="L33">    offset_fse_buffer: []Table.Fse,</span>
<span class="line" id="L34">    match_fse_buffer: []Table.Fse,</span>
<span class="line" id="L35">    literal_fse_buffer: []Table.Fse,</span>
<span class="line" id="L36"></span>
<span class="line" id="L37">    fse_tables_undefined: <span class="tok-type">bool</span>,</span>
<span class="line" id="L38"></span>
<span class="line" id="L39">    literal_stream_reader: readers.ReverseBitReader,</span>
<span class="line" id="L40">    literal_stream_index: <span class="tok-type">usize</span>,</span>
<span class="line" id="L41">    literal_streams: LiteralsSection.Streams,</span>
<span class="line" id="L42">    literal_header: LiteralsSection.Header,</span>
<span class="line" id="L43">    huffman_tree: ?LiteralsSection.HuffmanTree,</span>
<span class="line" id="L44"></span>
<span class="line" id="L45">    literal_written_count: <span class="tok-type">usize</span>,</span>
<span class="line" id="L46">    written_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L47"></span>
<span class="line" id="L48">    <span class="tok-kw">fn</span> <span class="tok-fn">StateData</span>(<span class="tok-kw">comptime</span> max_accuracy_log: <span class="tok-type">comptime_int</span>) <span class="tok-type">type</span> {</span>
<span class="line" id="L49">        <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L50">            state: State,</span>
<span class="line" id="L51">            table: Table,</span>
<span class="line" id="L52">            accuracy_log: <span class="tok-type">u8</span>,</span>
<span class="line" id="L53"></span>
<span class="line" id="L54">            <span class="tok-kw">const</span> State = std.meta.Int(.unsigned, max_accuracy_log);</span>
<span class="line" id="L55">        };</span>
<span class="line" id="L56">    }</span>
<span class="line" id="L57"></span>
<span class="line" id="L58">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(</span>
<span class="line" id="L59">        literal_fse_buffer: []Table.Fse,</span>
<span class="line" id="L60">        match_fse_buffer: []Table.Fse,</span>
<span class="line" id="L61">        offset_fse_buffer: []Table.Fse,</span>
<span class="line" id="L62">    ) DecodeState {</span>
<span class="line" id="L63">        <span class="tok-kw">return</span> DecodeState{</span>
<span class="line" id="L64">            .repeat_offsets = .{</span>
<span class="line" id="L65">                types.compressed_block.start_repeated_offset_1,</span>
<span class="line" id="L66">                types.compressed_block.start_repeated_offset_2,</span>
<span class="line" id="L67">                types.compressed_block.start_repeated_offset_3,</span>
<span class="line" id="L68">            },</span>
<span class="line" id="L69"></span>
<span class="line" id="L70">            .offset = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L71">            .match = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L72">            .literal = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L73"></span>
<span class="line" id="L74">            .literal_fse_buffer = literal_fse_buffer,</span>
<span class="line" id="L75">            .match_fse_buffer = match_fse_buffer,</span>
<span class="line" id="L76">            .offset_fse_buffer = offset_fse_buffer,</span>
<span class="line" id="L77"></span>
<span class="line" id="L78">            .fse_tables_undefined = <span class="tok-null">true</span>,</span>
<span class="line" id="L79"></span>
<span class="line" id="L80">            .literal_written_count = <span class="tok-number">0</span>,</span>
<span class="line" id="L81">            .literal_header = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L82">            .literal_streams = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L83">            .literal_stream_reader = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L84">            .literal_stream_index = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L85">            .huffman_tree = <span class="tok-null">null</span>,</span>
<span class="line" id="L86"></span>
<span class="line" id="L87">            .written_count = <span class="tok-number">0</span>,</span>
<span class="line" id="L88">        };</span>
<span class="line" id="L89">    }</span>
<span class="line" id="L90"></span>
<span class="line" id="L91">    <span class="tok-comment">/// Prepare the decoder to decode a compressed block. Loads the literals</span></span>
<span class="line" id="L92">    <span class="tok-comment">/// stream and Huffman tree from `literals` and reads the FSE tables from</span></span>
<span class="line" id="L93">    <span class="tok-comment">/// `source`.</span></span>
<span class="line" id="L94">    <span class="tok-comment">///</span></span>
<span class="line" id="L95">    <span class="tok-comment">/// Errors returned:</span></span>
<span class="line" id="L96">    <span class="tok-comment">///   - `error.BitStreamHasNoStartBit` if the (reversed) literal bitstream's</span></span>
<span class="line" id="L97">    <span class="tok-comment">///     first byte does not have any bits set</span></span>
<span class="line" id="L98">    <span class="tok-comment">///   - `error.TreelessLiteralsFirst` `literals` is a treeless literals</span></span>
<span class="line" id="L99">    <span class="tok-comment">///     section and the decode state does not have a Huffman tree from a</span></span>
<span class="line" id="L100">    <span class="tok-comment">///     previous block</span></span>
<span class="line" id="L101">    <span class="tok-comment">///   - `error.RepeatModeFirst` on the first call if one of the sequence FSE</span></span>
<span class="line" id="L102">    <span class="tok-comment">///     tables is set to repeat mode</span></span>
<span class="line" id="L103">    <span class="tok-comment">///   - `error.MalformedAccuracyLog` if an FSE table has an invalid accuracy</span></span>
<span class="line" id="L104">    <span class="tok-comment">///   - `error.MalformedFseTable` if there are errors decoding an FSE table</span></span>
<span class="line" id="L105">    <span class="tok-comment">///   - `error.EndOfStream` if `source` ends before all FSE tables are read</span></span>
<span class="line" id="L106">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">prepare</span>(</span>
<span class="line" id="L107">        self: *DecodeState,</span>
<span class="line" id="L108">        source: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L109">        literals: LiteralsSection,</span>
<span class="line" id="L110">        sequences_header: SequencesSection.Header,</span>
<span class="line" id="L111">    ) !<span class="tok-type">void</span> {</span>
<span class="line" id="L112">        self.literal_written_count = <span class="tok-number">0</span>;</span>
<span class="line" id="L113">        self.literal_header = literals.header;</span>
<span class="line" id="L114">        self.literal_streams = literals.streams;</span>
<span class="line" id="L115"></span>
<span class="line" id="L116">        <span class="tok-kw">if</span> (literals.huffman_tree) |tree| {</span>
<span class="line" id="L117">            self.huffman_tree = tree;</span>
<span class="line" id="L118">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (literals.header.block_type == .treeless <span class="tok-kw">and</span> self.huffman_tree == <span class="tok-null">null</span>) {</span>
<span class="line" id="L119">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TreelessLiteralsFirst;</span>
<span class="line" id="L120">        }</span>
<span class="line" id="L121"></span>
<span class="line" id="L122">        <span class="tok-kw">switch</span> (literals.header.block_type) {</span>
<span class="line" id="L123">            .raw, .rle =&gt; {},</span>
<span class="line" id="L124">            .compressed, .treeless =&gt; {</span>
<span class="line" id="L125">                self.literal_stream_index = <span class="tok-number">0</span>;</span>
<span class="line" id="L126">                <span class="tok-kw">switch</span> (literals.streams) {</span>
<span class="line" id="L127">                    .one =&gt; |slice| <span class="tok-kw">try</span> self.initLiteralStream(slice),</span>
<span class="line" id="L128">                    .four =&gt; |streams| <span class="tok-kw">try</span> self.initLiteralStream(streams[<span class="tok-number">0</span>]),</span>
<span class="line" id="L129">                }</span>
<span class="line" id="L130">            },</span>
<span class="line" id="L131">        }</span>
<span class="line" id="L132"></span>
<span class="line" id="L133">        <span class="tok-kw">if</span> (sequences_header.sequence_count &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L134">            <span class="tok-kw">try</span> self.updateFseTable(source, .literal, sequences_header.literal_lengths);</span>
<span class="line" id="L135">            <span class="tok-kw">try</span> self.updateFseTable(source, .offset, sequences_header.offsets);</span>
<span class="line" id="L136">            <span class="tok-kw">try</span> self.updateFseTable(source, .match, sequences_header.match_lengths);</span>
<span class="line" id="L137">            self.fse_tables_undefined = <span class="tok-null">false</span>;</span>
<span class="line" id="L138">        }</span>
<span class="line" id="L139">    }</span>
<span class="line" id="L140"></span>
<span class="line" id="L141">    <span class="tok-comment">/// Read initial FSE states for sequence decoding.</span></span>
<span class="line" id="L142">    <span class="tok-comment">///</span></span>
<span class="line" id="L143">    <span class="tok-comment">/// Errors returned:</span></span>
<span class="line" id="L144">    <span class="tok-comment">///   - `error.EndOfStream` if `bit_reader` does not contain enough bits.</span></span>
<span class="line" id="L145">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readInitialFseState</span>(self: *DecodeState, bit_reader: *readers.ReverseBitReader) <span class="tok-kw">error</span>{EndOfStream}!<span class="tok-type">void</span> {</span>
<span class="line" id="L146">        self.literal.state = <span class="tok-kw">try</span> bit_reader.readBitsNoEof(<span class="tok-type">u9</span>, self.literal.accuracy_log);</span>
<span class="line" id="L147">        self.offset.state = <span class="tok-kw">try</span> bit_reader.readBitsNoEof(<span class="tok-type">u8</span>, self.offset.accuracy_log);</span>
<span class="line" id="L148">        self.match.state = <span class="tok-kw">try</span> bit_reader.readBitsNoEof(<span class="tok-type">u9</span>, self.match.accuracy_log);</span>
<span class="line" id="L149">    }</span>
<span class="line" id="L150"></span>
<span class="line" id="L151">    <span class="tok-kw">fn</span> <span class="tok-fn">updateRepeatOffset</span>(self: *DecodeState, offset: <span class="tok-type">u32</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L152">        self.repeat_offsets[<span class="tok-number">2</span>] = self.repeat_offsets[<span class="tok-number">1</span>];</span>
<span class="line" id="L153">        self.repeat_offsets[<span class="tok-number">1</span>] = self.repeat_offsets[<span class="tok-number">0</span>];</span>
<span class="line" id="L154">        self.repeat_offsets[<span class="tok-number">0</span>] = offset;</span>
<span class="line" id="L155">    }</span>
<span class="line" id="L156"></span>
<span class="line" id="L157">    <span class="tok-kw">fn</span> <span class="tok-fn">useRepeatOffset</span>(self: *DecodeState, index: <span class="tok-type">usize</span>) <span class="tok-type">u32</span> {</span>
<span class="line" id="L158">        <span class="tok-kw">if</span> (index == <span class="tok-number">1</span>)</span>
<span class="line" id="L159">            std.mem.swap(<span class="tok-type">u32</span>, &amp;self.repeat_offsets[<span class="tok-number">0</span>], &amp;self.repeat_offsets[<span class="tok-number">1</span>])</span>
<span class="line" id="L160">        <span class="tok-kw">else</span> <span class="tok-kw">if</span> (index == <span class="tok-number">2</span>) {</span>
<span class="line" id="L161">            std.mem.swap(<span class="tok-type">u32</span>, &amp;self.repeat_offsets[<span class="tok-number">0</span>], &amp;self.repeat_offsets[<span class="tok-number">2</span>]);</span>
<span class="line" id="L162">            std.mem.swap(<span class="tok-type">u32</span>, &amp;self.repeat_offsets[<span class="tok-number">1</span>], &amp;self.repeat_offsets[<span class="tok-number">2</span>]);</span>
<span class="line" id="L163">        }</span>
<span class="line" id="L164">        <span class="tok-kw">return</span> self.repeat_offsets[<span class="tok-number">0</span>];</span>
<span class="line" id="L165">    }</span>
<span class="line" id="L166"></span>
<span class="line" id="L167">    <span class="tok-kw">const</span> DataType = <span class="tok-kw">enum</span> { offset, match, literal };</span>
<span class="line" id="L168"></span>
<span class="line" id="L169">    <span class="tok-kw">fn</span> <span class="tok-fn">updateState</span>(</span>
<span class="line" id="L170">        self: *DecodeState,</span>
<span class="line" id="L171">        <span class="tok-kw">comptime</span> choice: DataType,</span>
<span class="line" id="L172">        bit_reader: *readers.ReverseBitReader,</span>
<span class="line" id="L173">    ) <span class="tok-kw">error</span>{ MalformedFseBits, EndOfStream }!<span class="tok-type">void</span> {</span>
<span class="line" id="L174">        <span class="tok-kw">switch</span> (<span class="tok-builtin">@field</span>(self, <span class="tok-builtin">@tagName</span>(choice)).table) {</span>
<span class="line" id="L175">            .rle =&gt; {},</span>
<span class="line" id="L176">            .fse =&gt; |table| {</span>
<span class="line" id="L177">                <span class="tok-kw">const</span> data = table[<span class="tok-builtin">@field</span>(self, <span class="tok-builtin">@tagName</span>(choice)).state];</span>
<span class="line" id="L178">                <span class="tok-kw">const</span> T = <span class="tok-builtin">@TypeOf</span>(<span class="tok-builtin">@field</span>(self, <span class="tok-builtin">@tagName</span>(choice))).State;</span>
<span class="line" id="L179">                <span class="tok-kw">const</span> bits_summand = <span class="tok-kw">try</span> bit_reader.readBitsNoEof(T, data.bits);</span>
<span class="line" id="L180">                <span class="tok-kw">const</span> next_state = std.math.cast(</span>
<span class="line" id="L181">                    <span class="tok-builtin">@TypeOf</span>(<span class="tok-builtin">@field</span>(self, <span class="tok-builtin">@tagName</span>(choice))).State,</span>
<span class="line" id="L182">                    data.baseline + bits_summand,</span>
<span class="line" id="L183">                ) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedFseBits;</span>
<span class="line" id="L184">                <span class="tok-builtin">@field</span>(self, <span class="tok-builtin">@tagName</span>(choice)).state = next_state;</span>
<span class="line" id="L185">            },</span>
<span class="line" id="L186">        }</span>
<span class="line" id="L187">    }</span>
<span class="line" id="L188"></span>
<span class="line" id="L189">    <span class="tok-kw">const</span> FseTableError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L190">        MalformedFseTable,</span>
<span class="line" id="L191">        MalformedAccuracyLog,</span>
<span class="line" id="L192">        RepeatModeFirst,</span>
<span class="line" id="L193">        EndOfStream,</span>
<span class="line" id="L194">    };</span>
<span class="line" id="L195"></span>
<span class="line" id="L196">    <span class="tok-kw">fn</span> <span class="tok-fn">updateFseTable</span>(</span>
<span class="line" id="L197">        self: *DecodeState,</span>
<span class="line" id="L198">        source: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L199">        <span class="tok-kw">comptime</span> choice: DataType,</span>
<span class="line" id="L200">        mode: SequencesSection.Header.Mode,</span>
<span class="line" id="L201">    ) !<span class="tok-type">void</span> {</span>
<span class="line" id="L202">        <span class="tok-kw">const</span> field_name = <span class="tok-builtin">@tagName</span>(choice);</span>
<span class="line" id="L203">        <span class="tok-kw">switch</span> (mode) {</span>
<span class="line" id="L204">            .predefined =&gt; {</span>
<span class="line" id="L205">                <span class="tok-builtin">@field</span>(self, field_name).accuracy_log =</span>
<span class="line" id="L206">                    <span class="tok-builtin">@field</span>(types.compressed_block.default_accuracy_log, field_name);</span>
<span class="line" id="L207"></span>
<span class="line" id="L208">                <span class="tok-builtin">@field</span>(self, field_name).table =</span>
<span class="line" id="L209">                    <span class="tok-builtin">@field</span>(types.compressed_block, <span class="tok-str">&quot;predefined_&quot;</span> ++ field_name ++ <span class="tok-str">&quot;_fse_table&quot;</span>);</span>
<span class="line" id="L210">            },</span>
<span class="line" id="L211">            .rle =&gt; {</span>
<span class="line" id="L212">                <span class="tok-builtin">@field</span>(self, field_name).accuracy_log = <span class="tok-number">0</span>;</span>
<span class="line" id="L213">                <span class="tok-builtin">@field</span>(self, field_name).table = .{ .rle = <span class="tok-kw">try</span> source.readByte() };</span>
<span class="line" id="L214">            },</span>
<span class="line" id="L215">            .fse =&gt; {</span>
<span class="line" id="L216">                <span class="tok-kw">var</span> bit_reader = readers.bitReader(source);</span>
<span class="line" id="L217"></span>
<span class="line" id="L218">                <span class="tok-kw">const</span> table_size = <span class="tok-kw">try</span> decodeFseTable(</span>
<span class="line" id="L219">                    &amp;bit_reader,</span>
<span class="line" id="L220">                    <span class="tok-builtin">@field</span>(types.compressed_block.table_symbol_count_max, field_name),</span>
<span class="line" id="L221">                    <span class="tok-builtin">@field</span>(types.compressed_block.table_accuracy_log_max, field_name),</span>
<span class="line" id="L222">                    <span class="tok-builtin">@field</span>(self, field_name ++ <span class="tok-str">&quot;_fse_buffer&quot;</span>),</span>
<span class="line" id="L223">                );</span>
<span class="line" id="L224">                <span class="tok-builtin">@field</span>(self, field_name).table = .{</span>
<span class="line" id="L225">                    .fse = <span class="tok-builtin">@field</span>(self, field_name ++ <span class="tok-str">&quot;_fse_buffer&quot;</span>)[<span class="tok-number">0</span>..table_size],</span>
<span class="line" id="L226">                };</span>
<span class="line" id="L227">                <span class="tok-builtin">@field</span>(self, field_name).accuracy_log = std.math.log2_int_ceil(<span class="tok-type">usize</span>, table_size);</span>
<span class="line" id="L228">            },</span>
<span class="line" id="L229">            .repeat =&gt; <span class="tok-kw">if</span> (self.fse_tables_undefined) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.RepeatModeFirst,</span>
<span class="line" id="L230">        }</span>
<span class="line" id="L231">    }</span>
<span class="line" id="L232"></span>
<span class="line" id="L233">    <span class="tok-kw">const</span> Sequence = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L234">        literal_length: <span class="tok-type">u32</span>,</span>
<span class="line" id="L235">        match_length: <span class="tok-type">u32</span>,</span>
<span class="line" id="L236">        offset: <span class="tok-type">u32</span>,</span>
<span class="line" id="L237">    };</span>
<span class="line" id="L238"></span>
<span class="line" id="L239">    <span class="tok-kw">fn</span> <span class="tok-fn">nextSequence</span>(</span>
<span class="line" id="L240">        self: *DecodeState,</span>
<span class="line" id="L241">        bit_reader: *readers.ReverseBitReader,</span>
<span class="line" id="L242">    ) <span class="tok-kw">error</span>{ InvalidBitStream, EndOfStream }!Sequence {</span>
<span class="line" id="L243">        <span class="tok-kw">const</span> raw_code = self.getCode(.offset);</span>
<span class="line" id="L244">        <span class="tok-kw">const</span> offset_code = std.math.cast(<span class="tok-type">u5</span>, raw_code) <span class="tok-kw">orelse</span> {</span>
<span class="line" id="L245">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidBitStream;</span>
<span class="line" id="L246">        };</span>
<span class="line" id="L247">        <span class="tok-kw">const</span> offset_value = (<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>) &lt;&lt; offset_code) + <span class="tok-kw">try</span> bit_reader.readBitsNoEof(<span class="tok-type">u32</span>, offset_code);</span>
<span class="line" id="L248"></span>
<span class="line" id="L249">        <span class="tok-kw">const</span> match_code = self.getCode(.match);</span>
<span class="line" id="L250">        <span class="tok-kw">if</span> (match_code &gt;= types.compressed_block.match_length_code_table.len)</span>
<span class="line" id="L251">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidBitStream;</span>
<span class="line" id="L252">        <span class="tok-kw">const</span> match = types.compressed_block.match_length_code_table[match_code];</span>
<span class="line" id="L253">        <span class="tok-kw">const</span> match_length = match[<span class="tok-number">0</span>] + <span class="tok-kw">try</span> bit_reader.readBitsNoEof(<span class="tok-type">u32</span>, match[<span class="tok-number">1</span>]);</span>
<span class="line" id="L254"></span>
<span class="line" id="L255">        <span class="tok-kw">const</span> literal_code = self.getCode(.literal);</span>
<span class="line" id="L256">        <span class="tok-kw">if</span> (literal_code &gt;= types.compressed_block.literals_length_code_table.len)</span>
<span class="line" id="L257">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidBitStream;</span>
<span class="line" id="L258">        <span class="tok-kw">const</span> literal = types.compressed_block.literals_length_code_table[literal_code];</span>
<span class="line" id="L259">        <span class="tok-kw">const</span> literal_length = literal[<span class="tok-number">0</span>] + <span class="tok-kw">try</span> bit_reader.readBitsNoEof(<span class="tok-type">u32</span>, literal[<span class="tok-number">1</span>]);</span>
<span class="line" id="L260"></span>
<span class="line" id="L261">        <span class="tok-kw">const</span> offset = <span class="tok-kw">if</span> (offset_value &gt; <span class="tok-number">3</span>) offset: {</span>
<span class="line" id="L262">            <span class="tok-kw">const</span> offset = offset_value - <span class="tok-number">3</span>;</span>
<span class="line" id="L263">            self.updateRepeatOffset(offset);</span>
<span class="line" id="L264">            <span class="tok-kw">break</span> :offset offset;</span>
<span class="line" id="L265">        } <span class="tok-kw">else</span> offset: {</span>
<span class="line" id="L266">            <span class="tok-kw">if</span> (literal_length == <span class="tok-number">0</span>) {</span>
<span class="line" id="L267">                <span class="tok-kw">if</span> (offset_value == <span class="tok-number">3</span>) {</span>
<span class="line" id="L268">                    <span class="tok-kw">const</span> offset = self.repeat_offsets[<span class="tok-number">0</span>] - <span class="tok-number">1</span>;</span>
<span class="line" id="L269">                    self.updateRepeatOffset(offset);</span>
<span class="line" id="L270">                    <span class="tok-kw">break</span> :offset offset;</span>
<span class="line" id="L271">                }</span>
<span class="line" id="L272">                <span class="tok-kw">break</span> :offset self.useRepeatOffset(offset_value);</span>
<span class="line" id="L273">            }</span>
<span class="line" id="L274">            <span class="tok-kw">break</span> :offset self.useRepeatOffset(offset_value - <span class="tok-number">1</span>);</span>
<span class="line" id="L275">        };</span>
<span class="line" id="L276"></span>
<span class="line" id="L277">        <span class="tok-kw">if</span> (offset == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidBitStream;</span>
<span class="line" id="L278"></span>
<span class="line" id="L279">        <span class="tok-kw">return</span> .{</span>
<span class="line" id="L280">            .literal_length = literal_length,</span>
<span class="line" id="L281">            .match_length = match_length,</span>
<span class="line" id="L282">            .offset = offset,</span>
<span class="line" id="L283">        };</span>
<span class="line" id="L284">    }</span>
<span class="line" id="L285"></span>
<span class="line" id="L286">    <span class="tok-kw">fn</span> <span class="tok-fn">executeSequenceSlice</span>(</span>
<span class="line" id="L287">        self: *DecodeState,</span>
<span class="line" id="L288">        dest: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L289">        write_pos: <span class="tok-type">usize</span>,</span>
<span class="line" id="L290">        sequence: Sequence,</span>
<span class="line" id="L291">    ) (<span class="tok-kw">error</span>{MalformedSequence} || DecodeLiteralsError)!<span class="tok-type">void</span> {</span>
<span class="line" id="L292">        <span class="tok-kw">if</span> (sequence.offset &gt; write_pos + sequence.literal_length) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedSequence;</span>
<span class="line" id="L293"></span>
<span class="line" id="L294">        <span class="tok-kw">try</span> self.decodeLiteralsSlice(dest[write_pos..], sequence.literal_length);</span>
<span class="line" id="L295">        <span class="tok-kw">const</span> copy_start = write_pos + sequence.literal_length - sequence.offset;</span>
<span class="line" id="L296">        <span class="tok-kw">const</span> copy_end = copy_start + sequence.match_length;</span>
<span class="line" id="L297">        <span class="tok-comment">// NOTE: we ignore the usage message for std.mem.copy and copy with dest.ptr &gt;= src.ptr</span>
</span>
<span class="line" id="L298">        <span class="tok-comment">//       to allow repeats</span>
</span>
<span class="line" id="L299">        std.mem.copy(<span class="tok-type">u8</span>, dest[write_pos + sequence.literal_length ..], dest[copy_start..copy_end]);</span>
<span class="line" id="L300">        self.written_count += sequence.match_length;</span>
<span class="line" id="L301">    }</span>
<span class="line" id="L302"></span>
<span class="line" id="L303">    <span class="tok-kw">fn</span> <span class="tok-fn">executeSequenceRingBuffer</span>(</span>
<span class="line" id="L304">        self: *DecodeState,</span>
<span class="line" id="L305">        dest: *RingBuffer,</span>
<span class="line" id="L306">        sequence: Sequence,</span>
<span class="line" id="L307">    ) (<span class="tok-kw">error</span>{MalformedSequence} || DecodeLiteralsError)!<span class="tok-type">void</span> {</span>
<span class="line" id="L308">        <span class="tok-kw">if</span> (sequence.offset &gt; <span class="tok-builtin">@min</span>(dest.data.len, self.written_count + sequence.literal_length))</span>
<span class="line" id="L309">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedSequence;</span>
<span class="line" id="L310"></span>
<span class="line" id="L311">        <span class="tok-kw">try</span> self.decodeLiteralsRingBuffer(dest, sequence.literal_length);</span>
<span class="line" id="L312">        <span class="tok-kw">const</span> copy_start = dest.write_index + dest.data.len - sequence.offset;</span>
<span class="line" id="L313">        <span class="tok-kw">const</span> copy_slice = dest.sliceAt(copy_start, sequence.match_length);</span>
<span class="line" id="L314">        <span class="tok-comment">// TODO: would std.mem.copy and figuring out dest slice be better/faster?</span>
</span>
<span class="line" id="L315">        <span class="tok-kw">for</span> (copy_slice.first) |b| dest.writeAssumeCapacity(b);</span>
<span class="line" id="L316">        <span class="tok-kw">for</span> (copy_slice.second) |b| dest.writeAssumeCapacity(b);</span>
<span class="line" id="L317">        self.written_count += sequence.match_length;</span>
<span class="line" id="L318">    }</span>
<span class="line" id="L319"></span>
<span class="line" id="L320">    <span class="tok-kw">const</span> DecodeSequenceError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L321">        InvalidBitStream,</span>
<span class="line" id="L322">        EndOfStream,</span>
<span class="line" id="L323">        MalformedSequence,</span>
<span class="line" id="L324">        MalformedFseBits,</span>
<span class="line" id="L325">    } || DecodeLiteralsError;</span>
<span class="line" id="L326"></span>
<span class="line" id="L327">    <span class="tok-comment">/// Decode one sequence from `bit_reader` into `dest`, written starting at</span></span>
<span class="line" id="L328">    <span class="tok-comment">/// `write_pos` and update FSE states if `last_sequence` is `false`.</span></span>
<span class="line" id="L329">    <span class="tok-comment">/// `prepare()` must be called for the block before attempting to decode</span></span>
<span class="line" id="L330">    <span class="tok-comment">/// sequences.</span></span>
<span class="line" id="L331">    <span class="tok-comment">///</span></span>
<span class="line" id="L332">    <span class="tok-comment">/// Errors returned:</span></span>
<span class="line" id="L333">    <span class="tok-comment">///   - `error.MalformedSequence` if the decompressed sequence would be</span></span>
<span class="line" id="L334">    <span class="tok-comment">///     longer than `sequence_size_limit` or the sequence's offset is too</span></span>
<span class="line" id="L335">    <span class="tok-comment">///     large</span></span>
<span class="line" id="L336">    <span class="tok-comment">///   - `error.UnexpectedEndOfLiteralStream` if the decoder state's literal</span></span>
<span class="line" id="L337">    <span class="tok-comment">///     streams do not contain enough literals for the sequence (this may</span></span>
<span class="line" id="L338">    <span class="tok-comment">///     mean the literal stream or the sequence is malformed).</span></span>
<span class="line" id="L339">    <span class="tok-comment">///   - `error.InvalidBitStream` if the FSE sequence bitstream is malformed</span></span>
<span class="line" id="L340">    <span class="tok-comment">///   - `error.EndOfStream` if `bit_reader` does not contain enough bits</span></span>
<span class="line" id="L341">    <span class="tok-comment">///   - `error.DestTooSmall` if `dest` is not large enough to holde the</span></span>
<span class="line" id="L342">    <span class="tok-comment">///     decompressed sequence</span></span>
<span class="line" id="L343">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeSequenceSlice</span>(</span>
<span class="line" id="L344">        self: *DecodeState,</span>
<span class="line" id="L345">        dest: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L346">        write_pos: <span class="tok-type">usize</span>,</span>
<span class="line" id="L347">        bit_reader: *readers.ReverseBitReader,</span>
<span class="line" id="L348">        sequence_size_limit: <span class="tok-type">usize</span>,</span>
<span class="line" id="L349">        last_sequence: <span class="tok-type">bool</span>,</span>
<span class="line" id="L350">    ) (<span class="tok-kw">error</span>{DestTooSmall} || DecodeSequenceError)!<span class="tok-type">usize</span> {</span>
<span class="line" id="L351">        <span class="tok-kw">const</span> sequence = <span class="tok-kw">try</span> self.nextSequence(bit_reader);</span>
<span class="line" id="L352">        <span class="tok-kw">const</span> sequence_length = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, sequence.literal_length) + sequence.match_length;</span>
<span class="line" id="L353">        <span class="tok-kw">if</span> (sequence_length &gt; sequence_size_limit) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedSequence;</span>
<span class="line" id="L354">        <span class="tok-kw">if</span> (sequence_length &gt; dest[write_pos..].len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DestTooSmall;</span>
<span class="line" id="L355"></span>
<span class="line" id="L356">        <span class="tok-kw">try</span> self.executeSequenceSlice(dest, write_pos, sequence);</span>
<span class="line" id="L357">        <span class="tok-kw">if</span> (!last_sequence) {</span>
<span class="line" id="L358">            <span class="tok-kw">try</span> self.updateState(.literal, bit_reader);</span>
<span class="line" id="L359">            <span class="tok-kw">try</span> self.updateState(.match, bit_reader);</span>
<span class="line" id="L360">            <span class="tok-kw">try</span> self.updateState(.offset, bit_reader);</span>
<span class="line" id="L361">        }</span>
<span class="line" id="L362">        <span class="tok-kw">return</span> sequence_length;</span>
<span class="line" id="L363">    }</span>
<span class="line" id="L364"></span>
<span class="line" id="L365">    <span class="tok-comment">/// Decode one sequence from `bit_reader` into `dest`; see</span></span>
<span class="line" id="L366">    <span class="tok-comment">/// `decodeSequenceSlice`.</span></span>
<span class="line" id="L367">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeSequenceRingBuffer</span>(</span>
<span class="line" id="L368">        self: *DecodeState,</span>
<span class="line" id="L369">        dest: *RingBuffer,</span>
<span class="line" id="L370">        bit_reader: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L371">        sequence_size_limit: <span class="tok-type">usize</span>,</span>
<span class="line" id="L372">        last_sequence: <span class="tok-type">bool</span>,</span>
<span class="line" id="L373">    ) DecodeSequenceError!<span class="tok-type">usize</span> {</span>
<span class="line" id="L374">        <span class="tok-kw">const</span> sequence = <span class="tok-kw">try</span> self.nextSequence(bit_reader);</span>
<span class="line" id="L375">        <span class="tok-kw">const</span> sequence_length = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, sequence.literal_length) + sequence.match_length;</span>
<span class="line" id="L376">        <span class="tok-kw">if</span> (sequence_length &gt; sequence_size_limit) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedSequence;</span>
<span class="line" id="L377"></span>
<span class="line" id="L378">        <span class="tok-kw">try</span> self.executeSequenceRingBuffer(dest, sequence);</span>
<span class="line" id="L379">        <span class="tok-kw">if</span> (!last_sequence) {</span>
<span class="line" id="L380">            <span class="tok-kw">try</span> self.updateState(.literal, bit_reader);</span>
<span class="line" id="L381">            <span class="tok-kw">try</span> self.updateState(.match, bit_reader);</span>
<span class="line" id="L382">            <span class="tok-kw">try</span> self.updateState(.offset, bit_reader);</span>
<span class="line" id="L383">        }</span>
<span class="line" id="L384">        <span class="tok-kw">return</span> sequence_length;</span>
<span class="line" id="L385">    }</span>
<span class="line" id="L386"></span>
<span class="line" id="L387">    <span class="tok-kw">fn</span> <span class="tok-fn">nextLiteralMultiStream</span>(</span>
<span class="line" id="L388">        self: *DecodeState,</span>
<span class="line" id="L389">    ) <span class="tok-kw">error</span>{BitStreamHasNoStartBit}!<span class="tok-type">void</span> {</span>
<span class="line" id="L390">        self.literal_stream_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L391">        <span class="tok-kw">try</span> self.initLiteralStream(self.literal_streams.four[self.literal_stream_index]);</span>
<span class="line" id="L392">    }</span>
<span class="line" id="L393"></span>
<span class="line" id="L394">    <span class="tok-kw">fn</span> <span class="tok-fn">initLiteralStream</span>(self: *DecodeState, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-kw">error</span>{BitStreamHasNoStartBit}!<span class="tok-type">void</span> {</span>
<span class="line" id="L395">        <span class="tok-kw">try</span> self.literal_stream_reader.init(bytes);</span>
<span class="line" id="L396">    }</span>
<span class="line" id="L397"></span>
<span class="line" id="L398">    <span class="tok-kw">fn</span> <span class="tok-fn">isLiteralStreamEmpty</span>(self: *DecodeState) <span class="tok-type">bool</span> {</span>
<span class="line" id="L399">        <span class="tok-kw">switch</span> (self.literal_streams) {</span>
<span class="line" id="L400">            .one =&gt; <span class="tok-kw">return</span> self.literal_stream_reader.isEmpty(),</span>
<span class="line" id="L401">            .four =&gt; <span class="tok-kw">return</span> self.literal_stream_index == <span class="tok-number">3</span> <span class="tok-kw">and</span> self.literal_stream_reader.isEmpty(),</span>
<span class="line" id="L402">        }</span>
<span class="line" id="L403">    }</span>
<span class="line" id="L404"></span>
<span class="line" id="L405">    <span class="tok-kw">const</span> LiteralBitsError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L406">        BitStreamHasNoStartBit,</span>
<span class="line" id="L407">        UnexpectedEndOfLiteralStream,</span>
<span class="line" id="L408">    };</span>
<span class="line" id="L409">    <span class="tok-kw">fn</span> <span class="tok-fn">readLiteralsBits</span>(</span>
<span class="line" id="L410">        self: *DecodeState,</span>
<span class="line" id="L411">        bit_count_to_read: <span class="tok-type">usize</span>,</span>
<span class="line" id="L412">    ) LiteralBitsError!<span class="tok-type">u16</span> {</span>
<span class="line" id="L413">        <span class="tok-kw">return</span> self.literal_stream_reader.readBitsNoEof(<span class="tok-type">u16</span>, bit_count_to_read) <span class="tok-kw">catch</span> bits: {</span>
<span class="line" id="L414">            <span class="tok-kw">if</span> (self.literal_streams == .four <span class="tok-kw">and</span> self.literal_stream_index &lt; <span class="tok-number">3</span>) {</span>
<span class="line" id="L415">                <span class="tok-kw">try</span> self.nextLiteralMultiStream();</span>
<span class="line" id="L416">                <span class="tok-kw">break</span> :bits self.literal_stream_reader.readBitsNoEof(<span class="tok-type">u16</span>, bit_count_to_read) <span class="tok-kw">catch</span></span>
<span class="line" id="L417">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedEndOfLiteralStream;</span>
<span class="line" id="L418">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L419">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedEndOfLiteralStream;</span>
<span class="line" id="L420">            }</span>
<span class="line" id="L421">        };</span>
<span class="line" id="L422">    }</span>
<span class="line" id="L423"></span>
<span class="line" id="L424">    <span class="tok-kw">const</span> DecodeLiteralsError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L425">        MalformedLiteralsLength,</span>
<span class="line" id="L426">        NotFound,</span>
<span class="line" id="L427">    } || LiteralBitsError;</span>
<span class="line" id="L428"></span>
<span class="line" id="L429">    <span class="tok-comment">/// Decode `len` bytes of literals into `dest`.</span></span>
<span class="line" id="L430">    <span class="tok-comment">///</span></span>
<span class="line" id="L431">    <span class="tok-comment">/// Errors returned:</span></span>
<span class="line" id="L432">    <span class="tok-comment">///   - `error.MalformedLiteralsLength` if the number of literal bytes</span></span>
<span class="line" id="L433">    <span class="tok-comment">///     decoded by `self` plus `len` is greater than the regenerated size of</span></span>
<span class="line" id="L434">    <span class="tok-comment">///     `literals`</span></span>
<span class="line" id="L435">    <span class="tok-comment">///   - `error.UnexpectedEndOfLiteralStream` and `error.NotFound` if there</span></span>
<span class="line" id="L436">    <span class="tok-comment">///     are problems decoding Huffman compressed literals</span></span>
<span class="line" id="L437">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeLiteralsSlice</span>(</span>
<span class="line" id="L438">        self: *DecodeState,</span>
<span class="line" id="L439">        dest: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L440">        len: <span class="tok-type">usize</span>,</span>
<span class="line" id="L441">    ) DecodeLiteralsError!<span class="tok-type">void</span> {</span>
<span class="line" id="L442">        <span class="tok-kw">if</span> (self.literal_written_count + len &gt; self.literal_header.regenerated_size)</span>
<span class="line" id="L443">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedLiteralsLength;</span>
<span class="line" id="L444"></span>
<span class="line" id="L445">        <span class="tok-kw">switch</span> (self.literal_header.block_type) {</span>
<span class="line" id="L446">            .raw =&gt; {</span>
<span class="line" id="L447">                <span class="tok-kw">const</span> literals_end = self.literal_written_count + len;</span>
<span class="line" id="L448">                <span class="tok-kw">const</span> literal_data = self.literal_streams.one[self.literal_written_count..literals_end];</span>
<span class="line" id="L449">                std.mem.copy(<span class="tok-type">u8</span>, dest, literal_data);</span>
<span class="line" id="L450">                self.literal_written_count += len;</span>
<span class="line" id="L451">                self.written_count += len;</span>
<span class="line" id="L452">            },</span>
<span class="line" id="L453">            .rle =&gt; {</span>
<span class="line" id="L454">                <span class="tok-kw">for</span> (<span class="tok-number">0</span>..len) |i| {</span>
<span class="line" id="L455">                    dest[i] = self.literal_streams.one[<span class="tok-number">0</span>];</span>
<span class="line" id="L456">                }</span>
<span class="line" id="L457">                self.literal_written_count += len;</span>
<span class="line" id="L458">                self.written_count += len;</span>
<span class="line" id="L459">            },</span>
<span class="line" id="L460">            .compressed, .treeless =&gt; {</span>
<span class="line" id="L461">                <span class="tok-comment">// const written_bytes_per_stream = (literals.header.regenerated_size + 3) / 4;</span>
</span>
<span class="line" id="L462">                <span class="tok-kw">const</span> huffman_tree = self.huffman_tree <span class="tok-kw">orelse</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L463">                <span class="tok-kw">const</span> max_bit_count = huffman_tree.max_bit_count;</span>
<span class="line" id="L464">                <span class="tok-kw">const</span> starting_bit_count = LiteralsSection.HuffmanTree.weightToBitCount(</span>
<span class="line" id="L465">                    huffman_tree.nodes[huffman_tree.symbol_count_minus_one].weight,</span>
<span class="line" id="L466">                    max_bit_count,</span>
<span class="line" id="L467">                );</span>
<span class="line" id="L468">                <span class="tok-kw">var</span> bits_read: <span class="tok-type">u4</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L469">                <span class="tok-kw">var</span> huffman_tree_index: <span class="tok-type">usize</span> = huffman_tree.symbol_count_minus_one;</span>
<span class="line" id="L470">                <span class="tok-kw">var</span> bit_count_to_read: <span class="tok-type">u4</span> = starting_bit_count;</span>
<span class="line" id="L471">                <span class="tok-kw">for</span> (<span class="tok-number">0</span>..len) |i| {</span>
<span class="line" id="L472">                    <span class="tok-kw">var</span> prefix: <span class="tok-type">u16</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L473">                    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L474">                        <span class="tok-kw">const</span> new_bits = self.readLiteralsBits(bit_count_to_read) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L475">                            <span class="tok-kw">return</span> err;</span>
<span class="line" id="L476">                        };</span>
<span class="line" id="L477">                        prefix &lt;&lt;= bit_count_to_read;</span>
<span class="line" id="L478">                        prefix |= new_bits;</span>
<span class="line" id="L479">                        bits_read += bit_count_to_read;</span>
<span class="line" id="L480">                        <span class="tok-kw">const</span> result = huffman_tree.query(huffman_tree_index, prefix) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L481">                            <span class="tok-kw">return</span> err;</span>
<span class="line" id="L482">                        };</span>
<span class="line" id="L483"></span>
<span class="line" id="L484">                        <span class="tok-kw">switch</span> (result) {</span>
<span class="line" id="L485">                            .symbol =&gt; |sym| {</span>
<span class="line" id="L486">                                dest[i] = sym;</span>
<span class="line" id="L487">                                bit_count_to_read = starting_bit_count;</span>
<span class="line" id="L488">                                bits_read = <span class="tok-number">0</span>;</span>
<span class="line" id="L489">                                huffman_tree_index = huffman_tree.symbol_count_minus_one;</span>
<span class="line" id="L490">                                <span class="tok-kw">break</span>;</span>
<span class="line" id="L491">                            },</span>
<span class="line" id="L492">                            .index =&gt; |index| {</span>
<span class="line" id="L493">                                huffman_tree_index = index;</span>
<span class="line" id="L494">                                <span class="tok-kw">const</span> bit_count = LiteralsSection.HuffmanTree.weightToBitCount(</span>
<span class="line" id="L495">                                    huffman_tree.nodes[index].weight,</span>
<span class="line" id="L496">                                    max_bit_count,</span>
<span class="line" id="L497">                                );</span>
<span class="line" id="L498">                                bit_count_to_read = bit_count - bits_read;</span>
<span class="line" id="L499">                            },</span>
<span class="line" id="L500">                        }</span>
<span class="line" id="L501">                    }</span>
<span class="line" id="L502">                }</span>
<span class="line" id="L503">                self.literal_written_count += len;</span>
<span class="line" id="L504">                self.written_count += len;</span>
<span class="line" id="L505">            },</span>
<span class="line" id="L506">        }</span>
<span class="line" id="L507">    }</span>
<span class="line" id="L508"></span>
<span class="line" id="L509">    <span class="tok-comment">/// Decode literals into `dest`; see `decodeLiteralsSlice()`.</span></span>
<span class="line" id="L510">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeLiteralsRingBuffer</span>(</span>
<span class="line" id="L511">        self: *DecodeState,</span>
<span class="line" id="L512">        dest: *RingBuffer,</span>
<span class="line" id="L513">        len: <span class="tok-type">usize</span>,</span>
<span class="line" id="L514">    ) DecodeLiteralsError!<span class="tok-type">void</span> {</span>
<span class="line" id="L515">        <span class="tok-kw">if</span> (self.literal_written_count + len &gt; self.literal_header.regenerated_size)</span>
<span class="line" id="L516">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedLiteralsLength;</span>
<span class="line" id="L517"></span>
<span class="line" id="L518">        <span class="tok-kw">switch</span> (self.literal_header.block_type) {</span>
<span class="line" id="L519">            .raw =&gt; {</span>
<span class="line" id="L520">                <span class="tok-kw">const</span> literals_end = self.literal_written_count + len;</span>
<span class="line" id="L521">                <span class="tok-kw">const</span> literal_data = self.literal_streams.one[self.literal_written_count..literals_end];</span>
<span class="line" id="L522">                dest.writeSliceAssumeCapacity(literal_data);</span>
<span class="line" id="L523">                self.literal_written_count += len;</span>
<span class="line" id="L524">                self.written_count += len;</span>
<span class="line" id="L525">            },</span>
<span class="line" id="L526">            .rle =&gt; {</span>
<span class="line" id="L527">                <span class="tok-kw">for</span> (<span class="tok-number">0</span>..len) |_| {</span>
<span class="line" id="L528">                    dest.writeAssumeCapacity(self.literal_streams.one[<span class="tok-number">0</span>]);</span>
<span class="line" id="L529">                }</span>
<span class="line" id="L530">                self.literal_written_count += len;</span>
<span class="line" id="L531">                self.written_count += len;</span>
<span class="line" id="L532">            },</span>
<span class="line" id="L533">            .compressed, .treeless =&gt; {</span>
<span class="line" id="L534">                <span class="tok-comment">// const written_bytes_per_stream = (literals.header.regenerated_size + 3) / 4;</span>
</span>
<span class="line" id="L535">                <span class="tok-kw">const</span> huffman_tree = self.huffman_tree <span class="tok-kw">orelse</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L536">                <span class="tok-kw">const</span> max_bit_count = huffman_tree.max_bit_count;</span>
<span class="line" id="L537">                <span class="tok-kw">const</span> starting_bit_count = LiteralsSection.HuffmanTree.weightToBitCount(</span>
<span class="line" id="L538">                    huffman_tree.nodes[huffman_tree.symbol_count_minus_one].weight,</span>
<span class="line" id="L539">                    max_bit_count,</span>
<span class="line" id="L540">                );</span>
<span class="line" id="L541">                <span class="tok-kw">var</span> bits_read: <span class="tok-type">u4</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L542">                <span class="tok-kw">var</span> huffman_tree_index: <span class="tok-type">usize</span> = huffman_tree.symbol_count_minus_one;</span>
<span class="line" id="L543">                <span class="tok-kw">var</span> bit_count_to_read: <span class="tok-type">u4</span> = starting_bit_count;</span>
<span class="line" id="L544">                <span class="tok-kw">for</span> (<span class="tok-number">0</span>..len) |_| {</span>
<span class="line" id="L545">                    <span class="tok-kw">var</span> prefix: <span class="tok-type">u16</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L546">                    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L547">                        <span class="tok-kw">const</span> new_bits = <span class="tok-kw">try</span> self.readLiteralsBits(bit_count_to_read);</span>
<span class="line" id="L548">                        prefix &lt;&lt;= bit_count_to_read;</span>
<span class="line" id="L549">                        prefix |= new_bits;</span>
<span class="line" id="L550">                        bits_read += bit_count_to_read;</span>
<span class="line" id="L551">                        <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> huffman_tree.query(huffman_tree_index, prefix);</span>
<span class="line" id="L552"></span>
<span class="line" id="L553">                        <span class="tok-kw">switch</span> (result) {</span>
<span class="line" id="L554">                            .symbol =&gt; |sym| {</span>
<span class="line" id="L555">                                dest.writeAssumeCapacity(sym);</span>
<span class="line" id="L556">                                bit_count_to_read = starting_bit_count;</span>
<span class="line" id="L557">                                bits_read = <span class="tok-number">0</span>;</span>
<span class="line" id="L558">                                huffman_tree_index = huffman_tree.symbol_count_minus_one;</span>
<span class="line" id="L559">                                <span class="tok-kw">break</span>;</span>
<span class="line" id="L560">                            },</span>
<span class="line" id="L561">                            .index =&gt; |index| {</span>
<span class="line" id="L562">                                huffman_tree_index = index;</span>
<span class="line" id="L563">                                <span class="tok-kw">const</span> bit_count = LiteralsSection.HuffmanTree.weightToBitCount(</span>
<span class="line" id="L564">                                    huffman_tree.nodes[index].weight,</span>
<span class="line" id="L565">                                    max_bit_count,</span>
<span class="line" id="L566">                                );</span>
<span class="line" id="L567">                                bit_count_to_read = bit_count - bits_read;</span>
<span class="line" id="L568">                            },</span>
<span class="line" id="L569">                        }</span>
<span class="line" id="L570">                    }</span>
<span class="line" id="L571">                }</span>
<span class="line" id="L572">                self.literal_written_count += len;</span>
<span class="line" id="L573">                self.written_count += len;</span>
<span class="line" id="L574">            },</span>
<span class="line" id="L575">        }</span>
<span class="line" id="L576">    }</span>
<span class="line" id="L577"></span>
<span class="line" id="L578">    <span class="tok-kw">fn</span> <span class="tok-fn">getCode</span>(self: *DecodeState, <span class="tok-kw">comptime</span> choice: DataType) <span class="tok-type">u32</span> {</span>
<span class="line" id="L579">        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@field</span>(self, <span class="tok-builtin">@tagName</span>(choice)).table) {</span>
<span class="line" id="L580">            .rle =&gt; |value| value,</span>
<span class="line" id="L581">            .fse =&gt; |table| table[<span class="tok-builtin">@field</span>(self, <span class="tok-builtin">@tagName</span>(choice)).state].symbol,</span>
<span class="line" id="L582">        };</span>
<span class="line" id="L583">    }</span>
<span class="line" id="L584">};</span>
<span class="line" id="L585"></span>
<span class="line" id="L586"><span class="tok-comment">/// Decode a single block from `src` into `dest`. The beginning of `src` must be</span></span>
<span class="line" id="L587"><span class="tok-comment">/// the start of the block content (i.e. directly after the block header).</span></span>
<span class="line" id="L588"><span class="tok-comment">/// Increments `consumed_count` by the number of bytes read from `src` to decode</span></span>
<span class="line" id="L589"><span class="tok-comment">/// the block and returns the decompressed size of the block.</span></span>
<span class="line" id="L590"><span class="tok-comment">///</span></span>
<span class="line" id="L591"><span class="tok-comment">/// Errors returned:</span></span>
<span class="line" id="L592"><span class="tok-comment">///</span></span>
<span class="line" id="L593"><span class="tok-comment">///   - `error.BlockSizeOverMaximum` if block's size is larger than 1 &lt;&lt; 17 or</span></span>
<span class="line" id="L594"><span class="tok-comment">///     `dest[written_count..].len`</span></span>
<span class="line" id="L595"><span class="tok-comment">///   - `error.MalformedBlockSize` if `src.len` is smaller than the block size</span></span>
<span class="line" id="L596"><span class="tok-comment">///     and the block is a raw or compressed block</span></span>
<span class="line" id="L597"><span class="tok-comment">///   - `error.ReservedBlock` if the block is a reserved block</span></span>
<span class="line" id="L598"><span class="tok-comment">///   - `error.MalformedRleBlock` if the block is an RLE block and `src.len &lt; 1`</span></span>
<span class="line" id="L599"><span class="tok-comment">///   - `error.MalformedCompressedBlock` if there are errors decoding a</span></span>
<span class="line" id="L600"><span class="tok-comment">///     compressed block</span></span>
<span class="line" id="L601"><span class="tok-comment">///   - `error.DestTooSmall` is `dest` is not large enough to hold the</span></span>
<span class="line" id="L602"><span class="tok-comment">///     decompressed block</span></span>
<span class="line" id="L603"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeBlock</span>(</span>
<span class="line" id="L604">    dest: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L605">    src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L606">    block_header: frame.Zstandard.Block.Header,</span>
<span class="line" id="L607">    decode_state: *DecodeState,</span>
<span class="line" id="L608">    consumed_count: *<span class="tok-type">usize</span>,</span>
<span class="line" id="L609">    block_size_max: <span class="tok-type">usize</span>,</span>
<span class="line" id="L610">    written_count: <span class="tok-type">usize</span>,</span>
<span class="line" id="L611">) (<span class="tok-kw">error</span>{DestTooSmall} || Error)!<span class="tok-type">usize</span> {</span>
<span class="line" id="L612">    <span class="tok-kw">const</span> block_size = block_header.block_size;</span>
<span class="line" id="L613">    <span class="tok-kw">if</span> (block_size_max &lt; block_size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BlockSizeOverMaximum;</span>
<span class="line" id="L614">    <span class="tok-kw">switch</span> (block_header.block_type) {</span>
<span class="line" id="L615">        .raw =&gt; {</span>
<span class="line" id="L616">            <span class="tok-kw">if</span> (src.len &lt; block_size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedBlockSize;</span>
<span class="line" id="L617">            <span class="tok-kw">if</span> (dest[written_count..].len &lt; block_size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DestTooSmall;</span>
<span class="line" id="L618">            <span class="tok-kw">const</span> data = src[<span class="tok-number">0</span>..block_size];</span>
<span class="line" id="L619">            std.mem.copy(<span class="tok-type">u8</span>, dest[written_count..], data);</span>
<span class="line" id="L620">            consumed_count.* += block_size;</span>
<span class="line" id="L621">            decode_state.written_count += block_size;</span>
<span class="line" id="L622">            <span class="tok-kw">return</span> block_size;</span>
<span class="line" id="L623">        },</span>
<span class="line" id="L624">        .rle =&gt; {</span>
<span class="line" id="L625">            <span class="tok-kw">if</span> (src.len &lt; <span class="tok-number">1</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedRleBlock;</span>
<span class="line" id="L626">            <span class="tok-kw">if</span> (dest[written_count..].len &lt; block_size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DestTooSmall;</span>
<span class="line" id="L627">            <span class="tok-kw">for</span> (written_count..block_size + written_count) |write_pos| {</span>
<span class="line" id="L628">                dest[write_pos] = src[<span class="tok-number">0</span>];</span>
<span class="line" id="L629">            }</span>
<span class="line" id="L630">            consumed_count.* += <span class="tok-number">1</span>;</span>
<span class="line" id="L631">            decode_state.written_count += block_size;</span>
<span class="line" id="L632">            <span class="tok-kw">return</span> block_size;</span>
<span class="line" id="L633">        },</span>
<span class="line" id="L634">        .compressed =&gt; {</span>
<span class="line" id="L635">            <span class="tok-kw">if</span> (src.len &lt; block_size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedBlockSize;</span>
<span class="line" id="L636">            <span class="tok-kw">var</span> bytes_read: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L637">            <span class="tok-kw">const</span> literals = decodeLiteralsSectionSlice(src[<span class="tok-number">0</span>..block_size], &amp;bytes_read) <span class="tok-kw">catch</span></span>
<span class="line" id="L638">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L639">            <span class="tok-kw">var</span> fbs = std.io.fixedBufferStream(src[bytes_read..block_size]);</span>
<span class="line" id="L640">            <span class="tok-kw">const</span> fbs_reader = fbs.reader();</span>
<span class="line" id="L641">            <span class="tok-kw">const</span> sequences_header = decodeSequencesHeader(fbs_reader) <span class="tok-kw">catch</span></span>
<span class="line" id="L642">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L643"></span>
<span class="line" id="L644">            decode_state.prepare(fbs_reader, literals, sequences_header) <span class="tok-kw">catch</span></span>
<span class="line" id="L645">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L646"></span>
<span class="line" id="L647">            bytes_read += fbs.pos;</span>
<span class="line" id="L648"></span>
<span class="line" id="L649">            <span class="tok-kw">var</span> bytes_written: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L650">            {</span>
<span class="line" id="L651">                <span class="tok-kw">const</span> bit_stream_bytes = src[bytes_read..block_size];</span>
<span class="line" id="L652">                <span class="tok-kw">var</span> bit_stream: readers.ReverseBitReader = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L653">                bit_stream.init(bit_stream_bytes) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L654"></span>
<span class="line" id="L655">                <span class="tok-kw">if</span> (sequences_header.sequence_count &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L656">                    decode_state.readInitialFseState(&amp;bit_stream) <span class="tok-kw">catch</span></span>
<span class="line" id="L657">                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L658"></span>
<span class="line" id="L659">                    <span class="tok-kw">var</span> sequence_size_limit = block_size_max;</span>
<span class="line" id="L660">                    <span class="tok-kw">for</span> (<span class="tok-number">0</span>..sequences_header.sequence_count) |i| {</span>
<span class="line" id="L661">                        <span class="tok-kw">const</span> write_pos = written_count + bytes_written;</span>
<span class="line" id="L662">                        <span class="tok-kw">const</span> decompressed_size = decode_state.decodeSequenceSlice(</span>
<span class="line" id="L663">                            dest,</span>
<span class="line" id="L664">                            write_pos,</span>
<span class="line" id="L665">                            &amp;bit_stream,</span>
<span class="line" id="L666">                            sequence_size_limit,</span>
<span class="line" id="L667">                            i == sequences_header.sequence_count - <span class="tok-number">1</span>,</span>
<span class="line" id="L668">                        ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L669">                            <span class="tok-kw">error</span>.DestTooSmall =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DestTooSmall,</span>
<span class="line" id="L670">                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock,</span>
<span class="line" id="L671">                        };</span>
<span class="line" id="L672">                        bytes_written += decompressed_size;</span>
<span class="line" id="L673">                        sequence_size_limit -= decompressed_size;</span>
<span class="line" id="L674">                    }</span>
<span class="line" id="L675">                }</span>
<span class="line" id="L676"></span>
<span class="line" id="L677">                <span class="tok-kw">if</span> (!bit_stream.isEmpty()) {</span>
<span class="line" id="L678">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L679">                }</span>
<span class="line" id="L680">            }</span>
<span class="line" id="L681"></span>
<span class="line" id="L682">            <span class="tok-kw">if</span> (decode_state.literal_written_count &lt; literals.header.regenerated_size) {</span>
<span class="line" id="L683">                <span class="tok-kw">const</span> len = literals.header.regenerated_size - decode_state.literal_written_count;</span>
<span class="line" id="L684">                <span class="tok-kw">if</span> (len &gt; dest[written_count + bytes_written ..].len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DestTooSmall;</span>
<span class="line" id="L685">                decode_state.decodeLiteralsSlice(dest[written_count + bytes_written ..], len) <span class="tok-kw">catch</span></span>
<span class="line" id="L686">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L687">                bytes_written += len;</span>
<span class="line" id="L688">            }</span>
<span class="line" id="L689"></span>
<span class="line" id="L690">            <span class="tok-kw">switch</span> (decode_state.literal_header.block_type) {</span>
<span class="line" id="L691">                .treeless, .compressed =&gt; {</span>
<span class="line" id="L692">                    <span class="tok-kw">if</span> (!decode_state.isLiteralStreamEmpty()) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L693">                },</span>
<span class="line" id="L694">                .raw, .rle =&gt; {},</span>
<span class="line" id="L695">            }</span>
<span class="line" id="L696"></span>
<span class="line" id="L697">            consumed_count.* += block_size;</span>
<span class="line" id="L698">            <span class="tok-kw">return</span> bytes_written;</span>
<span class="line" id="L699">        },</span>
<span class="line" id="L700">        .reserved =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReservedBlock,</span>
<span class="line" id="L701">    }</span>
<span class="line" id="L702">}</span>
<span class="line" id="L703"></span>
<span class="line" id="L704"><span class="tok-comment">/// Decode a single block from `src` into `dest`; see `decodeBlock()`. Returns</span></span>
<span class="line" id="L705"><span class="tok-comment">/// the size of the decompressed block, which can be used with `dest.sliceLast()`</span></span>
<span class="line" id="L706"><span class="tok-comment">/// to get the decompressed bytes. `error.BlockSizeOverMaximum` is returned if</span></span>
<span class="line" id="L707"><span class="tok-comment">/// the block's compressed or decompressed size is larger than `block_size_max`.</span></span>
<span class="line" id="L708"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeBlockRingBuffer</span>(</span>
<span class="line" id="L709">    dest: *RingBuffer,</span>
<span class="line" id="L710">    src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L711">    block_header: frame.Zstandard.Block.Header,</span>
<span class="line" id="L712">    decode_state: *DecodeState,</span>
<span class="line" id="L713">    consumed_count: *<span class="tok-type">usize</span>,</span>
<span class="line" id="L714">    block_size_max: <span class="tok-type">usize</span>,</span>
<span class="line" id="L715">) Error!<span class="tok-type">usize</span> {</span>
<span class="line" id="L716">    <span class="tok-kw">const</span> block_size = block_header.block_size;</span>
<span class="line" id="L717">    <span class="tok-kw">if</span> (block_size_max &lt; block_size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BlockSizeOverMaximum;</span>
<span class="line" id="L718">    <span class="tok-kw">switch</span> (block_header.block_type) {</span>
<span class="line" id="L719">        .raw =&gt; {</span>
<span class="line" id="L720">            <span class="tok-kw">if</span> (src.len &lt; block_size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedBlockSize;</span>
<span class="line" id="L721">            <span class="tok-kw">const</span> data = src[<span class="tok-number">0</span>..block_size];</span>
<span class="line" id="L722">            dest.writeSliceAssumeCapacity(data);</span>
<span class="line" id="L723">            consumed_count.* += block_size;</span>
<span class="line" id="L724">            decode_state.written_count += block_size;</span>
<span class="line" id="L725">            <span class="tok-kw">return</span> block_size;</span>
<span class="line" id="L726">        },</span>
<span class="line" id="L727">        .rle =&gt; {</span>
<span class="line" id="L728">            <span class="tok-kw">if</span> (src.len &lt; <span class="tok-number">1</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedRleBlock;</span>
<span class="line" id="L729">            <span class="tok-kw">for</span> (<span class="tok-number">0</span>..block_size) |_| {</span>
<span class="line" id="L730">                dest.writeAssumeCapacity(src[<span class="tok-number">0</span>]);</span>
<span class="line" id="L731">            }</span>
<span class="line" id="L732">            consumed_count.* += <span class="tok-number">1</span>;</span>
<span class="line" id="L733">            decode_state.written_count += block_size;</span>
<span class="line" id="L734">            <span class="tok-kw">return</span> block_size;</span>
<span class="line" id="L735">        },</span>
<span class="line" id="L736">        .compressed =&gt; {</span>
<span class="line" id="L737">            <span class="tok-kw">if</span> (src.len &lt; block_size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedBlockSize;</span>
<span class="line" id="L738">            <span class="tok-kw">var</span> bytes_read: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L739">            <span class="tok-kw">const</span> literals = decodeLiteralsSectionSlice(src[<span class="tok-number">0</span>..block_size], &amp;bytes_read) <span class="tok-kw">catch</span></span>
<span class="line" id="L740">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L741">            <span class="tok-kw">var</span> fbs = std.io.fixedBufferStream(src[bytes_read..block_size]);</span>
<span class="line" id="L742">            <span class="tok-kw">const</span> fbs_reader = fbs.reader();</span>
<span class="line" id="L743">            <span class="tok-kw">const</span> sequences_header = decodeSequencesHeader(fbs_reader) <span class="tok-kw">catch</span></span>
<span class="line" id="L744">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L745"></span>
<span class="line" id="L746">            decode_state.prepare(fbs_reader, literals, sequences_header) <span class="tok-kw">catch</span></span>
<span class="line" id="L747">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L748"></span>
<span class="line" id="L749">            bytes_read += fbs.pos;</span>
<span class="line" id="L750"></span>
<span class="line" id="L751">            <span class="tok-kw">var</span> bytes_written: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L752">            {</span>
<span class="line" id="L753">                <span class="tok-kw">const</span> bit_stream_bytes = src[bytes_read..block_size];</span>
<span class="line" id="L754">                <span class="tok-kw">var</span> bit_stream: readers.ReverseBitReader = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L755">                bit_stream.init(bit_stream_bytes) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L756"></span>
<span class="line" id="L757">                <span class="tok-kw">if</span> (sequences_header.sequence_count &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L758">                    decode_state.readInitialFseState(&amp;bit_stream) <span class="tok-kw">catch</span></span>
<span class="line" id="L759">                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L760"></span>
<span class="line" id="L761">                    <span class="tok-kw">var</span> sequence_size_limit = block_size_max;</span>
<span class="line" id="L762">                    <span class="tok-kw">for</span> (<span class="tok-number">0</span>..sequences_header.sequence_count) |i| {</span>
<span class="line" id="L763">                        <span class="tok-kw">const</span> decompressed_size = decode_state.decodeSequenceRingBuffer(</span>
<span class="line" id="L764">                            dest,</span>
<span class="line" id="L765">                            &amp;bit_stream,</span>
<span class="line" id="L766">                            sequence_size_limit,</span>
<span class="line" id="L767">                            i == sequences_header.sequence_count - <span class="tok-number">1</span>,</span>
<span class="line" id="L768">                        ) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L769">                        bytes_written += decompressed_size;</span>
<span class="line" id="L770">                        sequence_size_limit -= decompressed_size;</span>
<span class="line" id="L771">                    }</span>
<span class="line" id="L772">                }</span>
<span class="line" id="L773"></span>
<span class="line" id="L774">                <span class="tok-kw">if</span> (!bit_stream.isEmpty()) {</span>
<span class="line" id="L775">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L776">                }</span>
<span class="line" id="L777">            }</span>
<span class="line" id="L778"></span>
<span class="line" id="L779">            <span class="tok-kw">if</span> (decode_state.literal_written_count &lt; literals.header.regenerated_size) {</span>
<span class="line" id="L780">                <span class="tok-kw">const</span> len = literals.header.regenerated_size - decode_state.literal_written_count;</span>
<span class="line" id="L781">                decode_state.decodeLiteralsRingBuffer(dest, len) <span class="tok-kw">catch</span></span>
<span class="line" id="L782">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L783">                bytes_written += len;</span>
<span class="line" id="L784">            }</span>
<span class="line" id="L785"></span>
<span class="line" id="L786">            <span class="tok-kw">switch</span> (decode_state.literal_header.block_type) {</span>
<span class="line" id="L787">                .treeless, .compressed =&gt; {</span>
<span class="line" id="L788">                    <span class="tok-kw">if</span> (!decode_state.isLiteralStreamEmpty()) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L789">                },</span>
<span class="line" id="L790">                .raw, .rle =&gt; {},</span>
<span class="line" id="L791">            }</span>
<span class="line" id="L792"></span>
<span class="line" id="L793">            consumed_count.* += block_size;</span>
<span class="line" id="L794">            <span class="tok-kw">if</span> (bytes_written &gt; block_size_max) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BlockSizeOverMaximum;</span>
<span class="line" id="L795">            <span class="tok-kw">return</span> bytes_written;</span>
<span class="line" id="L796">        },</span>
<span class="line" id="L797">        .reserved =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReservedBlock,</span>
<span class="line" id="L798">    }</span>
<span class="line" id="L799">}</span>
<span class="line" id="L800"></span>
<span class="line" id="L801"><span class="tok-comment">/// Decode a single block from `source` into `dest`. Literal and sequence data</span></span>
<span class="line" id="L802"><span class="tok-comment">/// from the block is copied into `literals_buffer` and `sequence_buffer`, which</span></span>
<span class="line" id="L803"><span class="tok-comment">/// must be large enough or `error.LiteralsBufferTooSmall` and</span></span>
<span class="line" id="L804"><span class="tok-comment">/// `error.SequenceBufferTooSmall` are returned (the maximum block size is an</span></span>
<span class="line" id="L805"><span class="tok-comment">/// upper bound for the size of both buffers). See `decodeBlock`</span></span>
<span class="line" id="L806"><span class="tok-comment">/// and `decodeBlockRingBuffer` for function that can decode a block without</span></span>
<span class="line" id="L807"><span class="tok-comment">/// these extra copies. `error.EndOfStream` is returned if `source` does not</span></span>
<span class="line" id="L808"><span class="tok-comment">/// contain enough bytes.</span></span>
<span class="line" id="L809"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeBlockReader</span>(</span>
<span class="line" id="L810">    dest: *RingBuffer,</span>
<span class="line" id="L811">    source: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L812">    block_header: frame.Zstandard.Block.Header,</span>
<span class="line" id="L813">    decode_state: *DecodeState,</span>
<span class="line" id="L814">    block_size_max: <span class="tok-type">usize</span>,</span>
<span class="line" id="L815">    literals_buffer: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L816">    sequence_buffer: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L817">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L818">    <span class="tok-kw">const</span> block_size = block_header.block_size;</span>
<span class="line" id="L819">    <span class="tok-kw">var</span> block_reader_limited = std.io.limitedReader(source, block_size);</span>
<span class="line" id="L820">    <span class="tok-kw">const</span> block_reader = block_reader_limited.reader();</span>
<span class="line" id="L821">    <span class="tok-kw">if</span> (block_size_max &lt; block_size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BlockSizeOverMaximum;</span>
<span class="line" id="L822">    <span class="tok-kw">switch</span> (block_header.block_type) {</span>
<span class="line" id="L823">        .raw =&gt; {</span>
<span class="line" id="L824">            <span class="tok-kw">if</span> (block_size == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;</span>
<span class="line" id="L825">            <span class="tok-kw">const</span> slice = dest.sliceAt(dest.write_index, block_size);</span>
<span class="line" id="L826">            <span class="tok-kw">try</span> source.readNoEof(slice.first);</span>
<span class="line" id="L827">            <span class="tok-kw">try</span> source.readNoEof(slice.second);</span>
<span class="line" id="L828">            dest.write_index = dest.mask2(dest.write_index + block_size);</span>
<span class="line" id="L829">            decode_state.written_count += block_size;</span>
<span class="line" id="L830">        },</span>
<span class="line" id="L831">        .rle =&gt; {</span>
<span class="line" id="L832">            <span class="tok-kw">const</span> byte = <span class="tok-kw">try</span> source.readByte();</span>
<span class="line" id="L833">            <span class="tok-kw">for</span> (<span class="tok-number">0</span>..block_size) |_| {</span>
<span class="line" id="L834">                dest.writeAssumeCapacity(byte);</span>
<span class="line" id="L835">            }</span>
<span class="line" id="L836">            decode_state.written_count += block_size;</span>
<span class="line" id="L837">        },</span>
<span class="line" id="L838">        .compressed =&gt; {</span>
<span class="line" id="L839">            <span class="tok-kw">const</span> literals = <span class="tok-kw">try</span> decodeLiteralsSection(block_reader, literals_buffer);</span>
<span class="line" id="L840">            <span class="tok-kw">const</span> sequences_header = <span class="tok-kw">try</span> decodeSequencesHeader(block_reader);</span>
<span class="line" id="L841"></span>
<span class="line" id="L842">            <span class="tok-kw">try</span> decode_state.prepare(block_reader, literals, sequences_header);</span>
<span class="line" id="L843"></span>
<span class="line" id="L844">            <span class="tok-kw">var</span> bytes_written: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L845">            {</span>
<span class="line" id="L846">                <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> block_reader.readAll(sequence_buffer);</span>
<span class="line" id="L847">                <span class="tok-kw">var</span> bit_stream: readers.ReverseBitReader = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L848">                <span class="tok-kw">try</span> bit_stream.init(sequence_buffer[<span class="tok-number">0</span>..size]);</span>
<span class="line" id="L849"></span>
<span class="line" id="L850">                <span class="tok-kw">if</span> (sequences_header.sequence_count &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L851">                    <span class="tok-kw">if</span> (sequence_buffer.len &lt; block_reader_limited.bytes_left)</span>
<span class="line" id="L852">                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SequenceBufferTooSmall;</span>
<span class="line" id="L853"></span>
<span class="line" id="L854">                    decode_state.readInitialFseState(&amp;bit_stream) <span class="tok-kw">catch</span></span>
<span class="line" id="L855">                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L856"></span>
<span class="line" id="L857">                    <span class="tok-kw">var</span> sequence_size_limit = block_size_max;</span>
<span class="line" id="L858">                    <span class="tok-kw">for</span> (<span class="tok-number">0</span>..sequences_header.sequence_count) |i| {</span>
<span class="line" id="L859">                        <span class="tok-kw">const</span> decompressed_size = decode_state.decodeSequenceRingBuffer(</span>
<span class="line" id="L860">                            dest,</span>
<span class="line" id="L861">                            &amp;bit_stream,</span>
<span class="line" id="L862">                            sequence_size_limit,</span>
<span class="line" id="L863">                            i == sequences_header.sequence_count - <span class="tok-number">1</span>,</span>
<span class="line" id="L864">                        ) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L865">                        sequence_size_limit -= decompressed_size;</span>
<span class="line" id="L866">                        bytes_written += decompressed_size;</span>
<span class="line" id="L867">                    }</span>
<span class="line" id="L868">                }</span>
<span class="line" id="L869"></span>
<span class="line" id="L870">                <span class="tok-kw">if</span> (!bit_stream.isEmpty()) {</span>
<span class="line" id="L871">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L872">                }</span>
<span class="line" id="L873">            }</span>
<span class="line" id="L874"></span>
<span class="line" id="L875">            <span class="tok-kw">if</span> (decode_state.literal_written_count &lt; literals.header.regenerated_size) {</span>
<span class="line" id="L876">                <span class="tok-kw">const</span> len = literals.header.regenerated_size - decode_state.literal_written_count;</span>
<span class="line" id="L877">                decode_state.decodeLiteralsRingBuffer(dest, len) <span class="tok-kw">catch</span></span>
<span class="line" id="L878">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L879">                bytes_written += len;</span>
<span class="line" id="L880">            }</span>
<span class="line" id="L881"></span>
<span class="line" id="L882">            <span class="tok-kw">switch</span> (decode_state.literal_header.block_type) {</span>
<span class="line" id="L883">                .treeless, .compressed =&gt; {</span>
<span class="line" id="L884">                    <span class="tok-kw">if</span> (!decode_state.isLiteralStreamEmpty()) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L885">                },</span>
<span class="line" id="L886">                .raw, .rle =&gt; {},</span>
<span class="line" id="L887">            }</span>
<span class="line" id="L888"></span>
<span class="line" id="L889">            <span class="tok-kw">if</span> (bytes_written &gt; block_size_max) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BlockSizeOverMaximum;</span>
<span class="line" id="L890">            <span class="tok-kw">if</span> (block_reader_limited.bytes_left != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L891">            decode_state.literal_written_count = <span class="tok-number">0</span>;</span>
<span class="line" id="L892">        },</span>
<span class="line" id="L893">        .reserved =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReservedBlock,</span>
<span class="line" id="L894">    }</span>
<span class="line" id="L895">}</span>
<span class="line" id="L896"></span>
<span class="line" id="L897"><span class="tok-comment">/// Decode the header of a block.</span></span>
<span class="line" id="L898"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeBlockHeader</span>(src: *<span class="tok-kw">const</span> [<span class="tok-number">3</span>]<span class="tok-type">u8</span>) frame.Zstandard.Block.Header {</span>
<span class="line" id="L899">    <span class="tok-kw">const</span> last_block = src[<span class="tok-number">0</span>] &amp; <span class="tok-number">1</span> == <span class="tok-number">1</span>;</span>
<span class="line" id="L900">    <span class="tok-kw">const</span> block_type = <span class="tok-builtin">@intToEnum</span>(frame.Zstandard.Block.Type, (src[<span class="tok-number">0</span>] &amp; <span class="tok-number">0b110</span>) &gt;&gt; <span class="tok-number">1</span>);</span>
<span class="line" id="L901">    <span class="tok-kw">const</span> block_size = ((src[<span class="tok-number">0</span>] &amp; <span class="tok-number">0b11111000</span>) &gt;&gt; <span class="tok-number">3</span>) + (<span class="tok-builtin">@as</span>(<span class="tok-type">u21</span>, src[<span class="tok-number">1</span>]) &lt;&lt; <span class="tok-number">5</span>) + (<span class="tok-builtin">@as</span>(<span class="tok-type">u21</span>, src[<span class="tok-number">2</span>]) &lt;&lt; <span class="tok-number">13</span>);</span>
<span class="line" id="L902">    <span class="tok-kw">return</span> .{</span>
<span class="line" id="L903">        .last_block = last_block,</span>
<span class="line" id="L904">        .block_type = block_type,</span>
<span class="line" id="L905">        .block_size = block_size,</span>
<span class="line" id="L906">    };</span>
<span class="line" id="L907">}</span>
<span class="line" id="L908"></span>
<span class="line" id="L909"><span class="tok-comment">/// Decode the header of a block.</span></span>
<span class="line" id="L910"><span class="tok-comment">///</span></span>
<span class="line" id="L911"><span class="tok-comment">/// Errors returned:</span></span>
<span class="line" id="L912"><span class="tok-comment">///   - `error.EndOfStream` if `src.len &lt; 3`</span></span>
<span class="line" id="L913"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeBlockHeaderSlice</span>(src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-kw">error</span>{EndOfStream}!frame.Zstandard.Block.Header {</span>
<span class="line" id="L914">    <span class="tok-kw">if</span> (src.len &lt; <span class="tok-number">3</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EndOfStream;</span>
<span class="line" id="L915">    <span class="tok-kw">return</span> decodeBlockHeader(src[<span class="tok-number">0</span>..<span class="tok-number">3</span>]);</span>
<span class="line" id="L916">}</span>
<span class="line" id="L917"></span>
<span class="line" id="L918"><span class="tok-comment">/// Decode a `LiteralsSection` from `src`, incrementing `consumed_count` by the</span></span>
<span class="line" id="L919"><span class="tok-comment">/// number of bytes the section uses.</span></span>
<span class="line" id="L920"><span class="tok-comment">///</span></span>
<span class="line" id="L921"><span class="tok-comment">/// Errors returned:</span></span>
<span class="line" id="L922"><span class="tok-comment">///   - `error.MalformedLiteralsHeader` if the header is invalid</span></span>
<span class="line" id="L923"><span class="tok-comment">///   - `error.MalformedLiteralsSection` if there are decoding errors</span></span>
<span class="line" id="L924"><span class="tok-comment">///   - `error.MalformedAccuracyLog` if compressed literals have invalid</span></span>
<span class="line" id="L925"><span class="tok-comment">///     accuracy</span></span>
<span class="line" id="L926"><span class="tok-comment">///   - `error.MalformedFseTable` if compressed literals have invalid FSE table</span></span>
<span class="line" id="L927"><span class="tok-comment">///   - `error.MalformedHuffmanTree` if there are errors decoding a Huffamn tree</span></span>
<span class="line" id="L928"><span class="tok-comment">///   - `error.EndOfStream` if there are not enough bytes in `src`</span></span>
<span class="line" id="L929"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeLiteralsSectionSlice</span>(</span>
<span class="line" id="L930">    src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L931">    consumed_count: *<span class="tok-type">usize</span>,</span>
<span class="line" id="L932">) (<span class="tok-kw">error</span>{ MalformedLiteralsHeader, MalformedLiteralsSection, EndOfStream } || huffman.Error)!LiteralsSection {</span>
<span class="line" id="L933">    <span class="tok-kw">var</span> bytes_read: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L934">    <span class="tok-kw">const</span> header = header: {</span>
<span class="line" id="L935">        <span class="tok-kw">var</span> fbs = std.io.fixedBufferStream(src);</span>
<span class="line" id="L936">        <span class="tok-kw">defer</span> bytes_read = fbs.pos;</span>
<span class="line" id="L937">        <span class="tok-kw">break</span> :header decodeLiteralsHeader(fbs.reader()) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedLiteralsHeader;</span>
<span class="line" id="L938">    };</span>
<span class="line" id="L939">    <span class="tok-kw">switch</span> (header.block_type) {</span>
<span class="line" id="L940">        .raw =&gt; {</span>
<span class="line" id="L941">            <span class="tok-kw">if</span> (src.len &lt; bytes_read + header.regenerated_size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedLiteralsSection;</span>
<span class="line" id="L942">            <span class="tok-kw">const</span> stream = src[bytes_read .. bytes_read + header.regenerated_size];</span>
<span class="line" id="L943">            consumed_count.* += header.regenerated_size + bytes_read;</span>
<span class="line" id="L944">            <span class="tok-kw">return</span> LiteralsSection{</span>
<span class="line" id="L945">                .header = header,</span>
<span class="line" id="L946">                .huffman_tree = <span class="tok-null">null</span>,</span>
<span class="line" id="L947">                .streams = .{ .one = stream },</span>
<span class="line" id="L948">            };</span>
<span class="line" id="L949">        },</span>
<span class="line" id="L950">        .rle =&gt; {</span>
<span class="line" id="L951">            <span class="tok-kw">if</span> (src.len &lt; bytes_read + <span class="tok-number">1</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedLiteralsSection;</span>
<span class="line" id="L952">            <span class="tok-kw">const</span> stream = src[bytes_read .. bytes_read + <span class="tok-number">1</span>];</span>
<span class="line" id="L953">            consumed_count.* += <span class="tok-number">1</span> + bytes_read;</span>
<span class="line" id="L954">            <span class="tok-kw">return</span> LiteralsSection{</span>
<span class="line" id="L955">                .header = header,</span>
<span class="line" id="L956">                .huffman_tree = <span class="tok-null">null</span>,</span>
<span class="line" id="L957">                .streams = .{ .one = stream },</span>
<span class="line" id="L958">            };</span>
<span class="line" id="L959">        },</span>
<span class="line" id="L960">        .compressed, .treeless =&gt; {</span>
<span class="line" id="L961">            <span class="tok-kw">const</span> huffman_tree_start = bytes_read;</span>
<span class="line" id="L962">            <span class="tok-kw">const</span> huffman_tree = <span class="tok-kw">if</span> (header.block_type == .compressed)</span>
<span class="line" id="L963">                <span class="tok-kw">try</span> huffman.decodeHuffmanTreeSlice(src[bytes_read..], &amp;bytes_read)</span>
<span class="line" id="L964">            <span class="tok-kw">else</span></span>
<span class="line" id="L965">                <span class="tok-null">null</span>;</span>
<span class="line" id="L966">            <span class="tok-kw">const</span> huffman_tree_size = bytes_read - huffman_tree_start;</span>
<span class="line" id="L967">            <span class="tok-kw">const</span> total_streams_size = std.math.sub(<span class="tok-type">usize</span>, header.compressed_size.?, huffman_tree_size) <span class="tok-kw">catch</span></span>
<span class="line" id="L968">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedLiteralsSection;</span>
<span class="line" id="L969"></span>
<span class="line" id="L970">            <span class="tok-kw">if</span> (src.len &lt; bytes_read + total_streams_size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedLiteralsSection;</span>
<span class="line" id="L971">            <span class="tok-kw">const</span> stream_data = src[bytes_read .. bytes_read + total_streams_size];</span>
<span class="line" id="L972"></span>
<span class="line" id="L973">            <span class="tok-kw">const</span> streams = <span class="tok-kw">try</span> decodeStreams(header.size_format, stream_data);</span>
<span class="line" id="L974">            consumed_count.* += bytes_read + total_streams_size;</span>
<span class="line" id="L975">            <span class="tok-kw">return</span> LiteralsSection{</span>
<span class="line" id="L976">                .header = header,</span>
<span class="line" id="L977">                .huffman_tree = huffman_tree,</span>
<span class="line" id="L978">                .streams = streams,</span>
<span class="line" id="L979">            };</span>
<span class="line" id="L980">        },</span>
<span class="line" id="L981">    }</span>
<span class="line" id="L982">}</span>
<span class="line" id="L983"></span>
<span class="line" id="L984"><span class="tok-comment">/// Decode a `LiteralsSection` from `src`, incrementing `consumed_count` by the</span></span>
<span class="line" id="L985"><span class="tok-comment">/// number of bytes the section uses. See `decodeLiterasSectionSlice()`.</span></span>
<span class="line" id="L986"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeLiteralsSection</span>(</span>
<span class="line" id="L987">    source: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L988">    buffer: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L989">) !LiteralsSection {</span>
<span class="line" id="L990">    <span class="tok-kw">const</span> header = <span class="tok-kw">try</span> decodeLiteralsHeader(source);</span>
<span class="line" id="L991">    <span class="tok-kw">switch</span> (header.block_type) {</span>
<span class="line" id="L992">        .raw =&gt; {</span>
<span class="line" id="L993">            <span class="tok-kw">try</span> source.readNoEof(buffer[<span class="tok-number">0</span>..header.regenerated_size]);</span>
<span class="line" id="L994">            <span class="tok-kw">return</span> LiteralsSection{</span>
<span class="line" id="L995">                .header = header,</span>
<span class="line" id="L996">                .huffman_tree = <span class="tok-null">null</span>,</span>
<span class="line" id="L997">                .streams = .{ .one = buffer },</span>
<span class="line" id="L998">            };</span>
<span class="line" id="L999">        },</span>
<span class="line" id="L1000">        .rle =&gt; {</span>
<span class="line" id="L1001">            buffer[<span class="tok-number">0</span>] = <span class="tok-kw">try</span> source.readByte();</span>
<span class="line" id="L1002">            <span class="tok-kw">return</span> LiteralsSection{</span>
<span class="line" id="L1003">                .header = header,</span>
<span class="line" id="L1004">                .huffman_tree = <span class="tok-null">null</span>,</span>
<span class="line" id="L1005">                .streams = .{ .one = buffer[<span class="tok-number">0</span>..<span class="tok-number">1</span>] },</span>
<span class="line" id="L1006">            };</span>
<span class="line" id="L1007">        },</span>
<span class="line" id="L1008">        .compressed, .treeless =&gt; {</span>
<span class="line" id="L1009">            <span class="tok-kw">var</span> counting_reader = std.io.countingReader(source);</span>
<span class="line" id="L1010">            <span class="tok-kw">const</span> huffman_tree = <span class="tok-kw">if</span> (header.block_type == .compressed)</span>
<span class="line" id="L1011">                <span class="tok-kw">try</span> huffman.decodeHuffmanTree(counting_reader.reader(), buffer)</span>
<span class="line" id="L1012">            <span class="tok-kw">else</span></span>
<span class="line" id="L1013">                <span class="tok-null">null</span>;</span>
<span class="line" id="L1014">            <span class="tok-kw">const</span> huffman_tree_size = <span class="tok-builtin">@intCast</span>(<span class="tok-type">usize</span>, counting_reader.bytes_read);</span>
<span class="line" id="L1015">            <span class="tok-kw">const</span> total_streams_size = std.math.sub(<span class="tok-type">usize</span>, header.compressed_size.?, huffman_tree_size) <span class="tok-kw">catch</span></span>
<span class="line" id="L1016">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedLiteralsSection;</span>
<span class="line" id="L1017"></span>
<span class="line" id="L1018">            <span class="tok-kw">if</span> (total_streams_size &gt; buffer.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LiteralsBufferTooSmall;</span>
<span class="line" id="L1019">            <span class="tok-kw">try</span> source.readNoEof(buffer[<span class="tok-number">0</span>..total_streams_size]);</span>
<span class="line" id="L1020">            <span class="tok-kw">const</span> stream_data = buffer[<span class="tok-number">0</span>..total_streams_size];</span>
<span class="line" id="L1021"></span>
<span class="line" id="L1022">            <span class="tok-kw">const</span> streams = <span class="tok-kw">try</span> decodeStreams(header.size_format, stream_data);</span>
<span class="line" id="L1023">            <span class="tok-kw">return</span> LiteralsSection{</span>
<span class="line" id="L1024">                .header = header,</span>
<span class="line" id="L1025">                .huffman_tree = huffman_tree,</span>
<span class="line" id="L1026">                .streams = streams,</span>
<span class="line" id="L1027">            };</span>
<span class="line" id="L1028">        },</span>
<span class="line" id="L1029">    }</span>
<span class="line" id="L1030">}</span>
<span class="line" id="L1031"></span>
<span class="line" id="L1032"><span class="tok-kw">fn</span> <span class="tok-fn">decodeStreams</span>(size_format: <span class="tok-type">u2</span>, stream_data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !LiteralsSection.Streams {</span>
<span class="line" id="L1033">    <span class="tok-kw">if</span> (size_format == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1034">        <span class="tok-kw">return</span> .{ .one = stream_data };</span>
<span class="line" id="L1035">    }</span>
<span class="line" id="L1036"></span>
<span class="line" id="L1037">    <span class="tok-kw">if</span> (stream_data.len &lt; <span class="tok-number">6</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedLiteralsSection;</span>
<span class="line" id="L1038"></span>
<span class="line" id="L1039">    <span class="tok-kw">const</span> stream_1_length = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, readInt(<span class="tok-type">u16</span>, stream_data[<span class="tok-number">0</span>..<span class="tok-number">2</span>]));</span>
<span class="line" id="L1040">    <span class="tok-kw">const</span> stream_2_length = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, readInt(<span class="tok-type">u16</span>, stream_data[<span class="tok-number">2</span>..<span class="tok-number">4</span>]));</span>
<span class="line" id="L1041">    <span class="tok-kw">const</span> stream_3_length = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, readInt(<span class="tok-type">u16</span>, stream_data[<span class="tok-number">4</span>..<span class="tok-number">6</span>]));</span>
<span class="line" id="L1042"></span>
<span class="line" id="L1043">    <span class="tok-kw">const</span> stream_1_start = <span class="tok-number">6</span>;</span>
<span class="line" id="L1044">    <span class="tok-kw">const</span> stream_2_start = stream_1_start + stream_1_length;</span>
<span class="line" id="L1045">    <span class="tok-kw">const</span> stream_3_start = stream_2_start + stream_2_length;</span>
<span class="line" id="L1046">    <span class="tok-kw">const</span> stream_4_start = stream_3_start + stream_3_length;</span>
<span class="line" id="L1047"></span>
<span class="line" id="L1048">    <span class="tok-kw">if</span> (stream_data.len &lt; stream_4_start) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedLiteralsSection;</span>
<span class="line" id="L1049"></span>
<span class="line" id="L1050">    <span class="tok-kw">return</span> .{ .four = .{</span>
<span class="line" id="L1051">        stream_data[stream_1_start .. stream_1_start + stream_1_length],</span>
<span class="line" id="L1052">        stream_data[stream_2_start .. stream_2_start + stream_2_length],</span>
<span class="line" id="L1053">        stream_data[stream_3_start .. stream_3_start + stream_3_length],</span>
<span class="line" id="L1054">        stream_data[stream_4_start..],</span>
<span class="line" id="L1055">    } };</span>
<span class="line" id="L1056">}</span>
<span class="line" id="L1057"></span>
<span class="line" id="L1058"><span class="tok-comment">/// Decode a literals section header.</span></span>
<span class="line" id="L1059"><span class="tok-comment">///</span></span>
<span class="line" id="L1060"><span class="tok-comment">/// Errors returned:</span></span>
<span class="line" id="L1061"><span class="tok-comment">///   - `error.EndOfStream` if there are not enough bytes in `source`</span></span>
<span class="line" id="L1062"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeLiteralsHeader</span>(source: <span class="tok-kw">anytype</span>) !LiteralsSection.Header {</span>
<span class="line" id="L1063">    <span class="tok-kw">const</span> byte0 = <span class="tok-kw">try</span> source.readByte();</span>
<span class="line" id="L1064">    <span class="tok-kw">const</span> block_type = <span class="tok-builtin">@intToEnum</span>(LiteralsSection.BlockType, byte0 &amp; <span class="tok-number">0b11</span>);</span>
<span class="line" id="L1065">    <span class="tok-kw">const</span> size_format = <span class="tok-builtin">@intCast</span>(<span class="tok-type">u2</span>, (byte0 &amp; <span class="tok-number">0b1100</span>) &gt;&gt; <span class="tok-number">2</span>);</span>
<span class="line" id="L1066">    <span class="tok-kw">var</span> regenerated_size: <span class="tok-type">u20</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1067">    <span class="tok-kw">var</span> compressed_size: ?<span class="tok-type">u18</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L1068">    <span class="tok-kw">switch</span> (block_type) {</span>
<span class="line" id="L1069">        .raw, .rle =&gt; {</span>
<span class="line" id="L1070">            <span class="tok-kw">switch</span> (size_format) {</span>
<span class="line" id="L1071">                <span class="tok-number">0</span>, <span class="tok-number">2</span> =&gt; {</span>
<span class="line" id="L1072">                    regenerated_size = byte0 &gt;&gt; <span class="tok-number">3</span>;</span>
<span class="line" id="L1073">                },</span>
<span class="line" id="L1074">                <span class="tok-number">1</span> =&gt; regenerated_size = (byte0 &gt;&gt; <span class="tok-number">4</span>) + (<span class="tok-builtin">@as</span>(<span class="tok-type">u20</span>, <span class="tok-kw">try</span> source.readByte()) &lt;&lt; <span class="tok-number">4</span>),</span>
<span class="line" id="L1075">                <span class="tok-number">3</span> =&gt; regenerated_size = (byte0 &gt;&gt; <span class="tok-number">4</span>) +</span>
<span class="line" id="L1076">                    (<span class="tok-builtin">@as</span>(<span class="tok-type">u20</span>, <span class="tok-kw">try</span> source.readByte()) &lt;&lt; <span class="tok-number">4</span>) +</span>
<span class="line" id="L1077">                    (<span class="tok-builtin">@as</span>(<span class="tok-type">u20</span>, <span class="tok-kw">try</span> source.readByte()) &lt;&lt; <span class="tok-number">12</span>),</span>
<span class="line" id="L1078">            }</span>
<span class="line" id="L1079">        },</span>
<span class="line" id="L1080">        .compressed, .treeless =&gt; {</span>
<span class="line" id="L1081">            <span class="tok-kw">const</span> byte1 = <span class="tok-kw">try</span> source.readByte();</span>
<span class="line" id="L1082">            <span class="tok-kw">const</span> byte2 = <span class="tok-kw">try</span> source.readByte();</span>
<span class="line" id="L1083">            <span class="tok-kw">switch</span> (size_format) {</span>
<span class="line" id="L1084">                <span class="tok-number">0</span>, <span class="tok-number">1</span> =&gt; {</span>
<span class="line" id="L1085">                    regenerated_size = (byte0 &gt;&gt; <span class="tok-number">4</span>) + ((<span class="tok-builtin">@as</span>(<span class="tok-type">u20</span>, byte1) &amp; <span class="tok-number">0b00111111</span>) &lt;&lt; <span class="tok-number">4</span>);</span>
<span class="line" id="L1086">                    compressed_size = ((byte1 &amp; <span class="tok-number">0b11000000</span>) &gt;&gt; <span class="tok-number">6</span>) + (<span class="tok-builtin">@as</span>(<span class="tok-type">u18</span>, byte2) &lt;&lt; <span class="tok-number">2</span>);</span>
<span class="line" id="L1087">                },</span>
<span class="line" id="L1088">                <span class="tok-number">2</span> =&gt; {</span>
<span class="line" id="L1089">                    <span class="tok-kw">const</span> byte3 = <span class="tok-kw">try</span> source.readByte();</span>
<span class="line" id="L1090">                    regenerated_size = (byte0 &gt;&gt; <span class="tok-number">4</span>) + (<span class="tok-builtin">@as</span>(<span class="tok-type">u20</span>, byte1) &lt;&lt; <span class="tok-number">4</span>) + ((<span class="tok-builtin">@as</span>(<span class="tok-type">u20</span>, byte2) &amp; <span class="tok-number">0b00000011</span>) &lt;&lt; <span class="tok-number">12</span>);</span>
<span class="line" id="L1091">                    compressed_size = ((byte2 &amp; <span class="tok-number">0b11111100</span>) &gt;&gt; <span class="tok-number">2</span>) + (<span class="tok-builtin">@as</span>(<span class="tok-type">u18</span>, byte3) &lt;&lt; <span class="tok-number">6</span>);</span>
<span class="line" id="L1092">                },</span>
<span class="line" id="L1093">                <span class="tok-number">3</span> =&gt; {</span>
<span class="line" id="L1094">                    <span class="tok-kw">const</span> byte3 = <span class="tok-kw">try</span> source.readByte();</span>
<span class="line" id="L1095">                    <span class="tok-kw">const</span> byte4 = <span class="tok-kw">try</span> source.readByte();</span>
<span class="line" id="L1096">                    regenerated_size = (byte0 &gt;&gt; <span class="tok-number">4</span>) + (<span class="tok-builtin">@as</span>(<span class="tok-type">u20</span>, byte1) &lt;&lt; <span class="tok-number">4</span>) + ((<span class="tok-builtin">@as</span>(<span class="tok-type">u20</span>, byte2) &amp; <span class="tok-number">0b00111111</span>) &lt;&lt; <span class="tok-number">12</span>);</span>
<span class="line" id="L1097">                    compressed_size = ((byte2 &amp; <span class="tok-number">0b11000000</span>) &gt;&gt; <span class="tok-number">6</span>) + (<span class="tok-builtin">@as</span>(<span class="tok-type">u18</span>, byte3) &lt;&lt; <span class="tok-number">2</span>) + (<span class="tok-builtin">@as</span>(<span class="tok-type">u18</span>, byte4) &lt;&lt; <span class="tok-number">10</span>);</span>
<span class="line" id="L1098">                },</span>
<span class="line" id="L1099">            }</span>
<span class="line" id="L1100">        },</span>
<span class="line" id="L1101">    }</span>
<span class="line" id="L1102">    <span class="tok-kw">return</span> LiteralsSection.Header{</span>
<span class="line" id="L1103">        .block_type = block_type,</span>
<span class="line" id="L1104">        .size_format = size_format,</span>
<span class="line" id="L1105">        .regenerated_size = regenerated_size,</span>
<span class="line" id="L1106">        .compressed_size = compressed_size,</span>
<span class="line" id="L1107">    };</span>
<span class="line" id="L1108">}</span>
<span class="line" id="L1109"></span>
<span class="line" id="L1110"><span class="tok-comment">/// Decode a sequences section header.</span></span>
<span class="line" id="L1111"><span class="tok-comment">///</span></span>
<span class="line" id="L1112"><span class="tok-comment">/// Errors returned:</span></span>
<span class="line" id="L1113"><span class="tok-comment">///   - `error.ReservedBitSet` if the reserved bit is set</span></span>
<span class="line" id="L1114"><span class="tok-comment">///   - `error.EndOfStream` if there are not enough bytes in `source`</span></span>
<span class="line" id="L1115"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeSequencesHeader</span>(</span>
<span class="line" id="L1116">    source: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L1117">) !SequencesSection.Header {</span>
<span class="line" id="L1118">    <span class="tok-kw">var</span> sequence_count: <span class="tok-type">u24</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1119"></span>
<span class="line" id="L1120">    <span class="tok-kw">const</span> byte0 = <span class="tok-kw">try</span> source.readByte();</span>
<span class="line" id="L1121">    <span class="tok-kw">if</span> (byte0 == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1122">        <span class="tok-kw">return</span> SequencesSection.Header{</span>
<span class="line" id="L1123">            .sequence_count = <span class="tok-number">0</span>,</span>
<span class="line" id="L1124">            .offsets = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L1125">            .match_lengths = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L1126">            .literal_lengths = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L1127">        };</span>
<span class="line" id="L1128">    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (byte0 &lt; <span class="tok-number">128</span>) {</span>
<span class="line" id="L1129">        sequence_count = byte0;</span>
<span class="line" id="L1130">    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (byte0 &lt; <span class="tok-number">255</span>) {</span>
<span class="line" id="L1131">        sequence_count = (<span class="tok-builtin">@as</span>(<span class="tok-type">u24</span>, (byte0 - <span class="tok-number">128</span>)) &lt;&lt; <span class="tok-number">8</span>) + <span class="tok-kw">try</span> source.readByte();</span>
<span class="line" id="L1132">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1133">        sequence_count = (<span class="tok-kw">try</span> source.readByte()) + (<span class="tok-builtin">@as</span>(<span class="tok-type">u24</span>, <span class="tok-kw">try</span> source.readByte()) &lt;&lt; <span class="tok-number">8</span>) + <span class="tok-number">0x7F00</span>;</span>
<span class="line" id="L1134">    }</span>
<span class="line" id="L1135"></span>
<span class="line" id="L1136">    <span class="tok-kw">const</span> compression_modes = <span class="tok-kw">try</span> source.readByte();</span>
<span class="line" id="L1137"></span>
<span class="line" id="L1138">    <span class="tok-kw">const</span> matches_mode = <span class="tok-builtin">@intToEnum</span>(SequencesSection.Header.Mode, (compression_modes &amp; <span class="tok-number">0b00001100</span>) &gt;&gt; <span class="tok-number">2</span>);</span>
<span class="line" id="L1139">    <span class="tok-kw">const</span> offsets_mode = <span class="tok-builtin">@intToEnum</span>(SequencesSection.Header.Mode, (compression_modes &amp; <span class="tok-number">0b00110000</span>) &gt;&gt; <span class="tok-number">4</span>);</span>
<span class="line" id="L1140">    <span class="tok-kw">const</span> literal_mode = <span class="tok-builtin">@intToEnum</span>(SequencesSection.Header.Mode, (compression_modes &amp; <span class="tok-number">0b11000000</span>) &gt;&gt; <span class="tok-number">6</span>);</span>
<span class="line" id="L1141">    <span class="tok-kw">if</span> (compression_modes &amp; <span class="tok-number">0b11</span> != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReservedBitSet;</span>
<span class="line" id="L1142"></span>
<span class="line" id="L1143">    <span class="tok-kw">return</span> SequencesSection.Header{</span>
<span class="line" id="L1144">        .sequence_count = sequence_count,</span>
<span class="line" id="L1145">        .offsets = offsets_mode,</span>
<span class="line" id="L1146">        .match_lengths = matches_mode,</span>
<span class="line" id="L1147">        .literal_lengths = literal_mode,</span>
<span class="line" id="L1148">    };</span>
<span class="line" id="L1149">}</span>
<span class="line" id="L1150"></span>
</code></pre></body>
</html>