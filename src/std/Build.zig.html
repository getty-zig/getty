<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Build.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg==">
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std.zig&quot;</span>);</span>
<span class="line" id="L2"><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);</span>
<span class="line" id="L3"><span class="tok-kw">const</span> io = std.io;</span>
<span class="line" id="L4"><span class="tok-kw">const</span> fs = std.fs;</span>
<span class="line" id="L5"><span class="tok-kw">const</span> mem = std.mem;</span>
<span class="line" id="L6"><span class="tok-kw">const</span> debug = std.debug;</span>
<span class="line" id="L7"><span class="tok-kw">const</span> panic = std.debug.panic;</span>
<span class="line" id="L8"><span class="tok-kw">const</span> assert = debug.assert;</span>
<span class="line" id="L9"><span class="tok-kw">const</span> log = std.log;</span>
<span class="line" id="L10"><span class="tok-kw">const</span> ArrayList = std.ArrayList;</span>
<span class="line" id="L11"><span class="tok-kw">const</span> StringHashMap = std.StringHashMap;</span>
<span class="line" id="L12"><span class="tok-kw">const</span> Allocator = mem.Allocator;</span>
<span class="line" id="L13"><span class="tok-kw">const</span> process = std.process;</span>
<span class="line" id="L14"><span class="tok-kw">const</span> EnvMap = std.process.EnvMap;</span>
<span class="line" id="L15"><span class="tok-kw">const</span> fmt_lib = std.fmt;</span>
<span class="line" id="L16"><span class="tok-kw">const</span> File = std.fs.File;</span>
<span class="line" id="L17"><span class="tok-kw">const</span> CrossTarget = std.zig.CrossTarget;</span>
<span class="line" id="L18"><span class="tok-kw">const</span> NativeTargetInfo = std.zig.system.NativeTargetInfo;</span>
<span class="line" id="L19"><span class="tok-kw">const</span> Sha256 = std.crypto.hash.sha2.Sha256;</span>
<span class="line" id="L20"><span class="tok-kw">const</span> Build = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L21"></span>
<span class="line" id="L22"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Cache = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Build/Cache.zig&quot;</span>);</span>
<span class="line" id="L23"></span>
<span class="line" id="L24"><span class="tok-comment">/// deprecated: use `Step.Compile`.</span></span>
<span class="line" id="L25"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> LibExeObjStep = Step.Compile;</span>
<span class="line" id="L26"><span class="tok-comment">/// deprecated: use `Build`.</span></span>
<span class="line" id="L27"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Builder = Build;</span>
<span class="line" id="L28"><span class="tok-comment">/// deprecated: use `Step.InstallDir.Options`</span></span>
<span class="line" id="L29"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> InstallDirectoryOptions = Step.InstallDir.Options;</span>
<span class="line" id="L30"></span>
<span class="line" id="L31"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Step = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Build/Step.zig&quot;</span>);</span>
<span class="line" id="L32"><span class="tok-comment">/// deprecated: use `Step.CheckFile`.</span></span>
<span class="line" id="L33"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CheckFileStep = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Build/Step/CheckFile.zig&quot;</span>);</span>
<span class="line" id="L34"><span class="tok-comment">/// deprecated: use `Step.CheckObject`.</span></span>
<span class="line" id="L35"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CheckObjectStep = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Build/Step/CheckObject.zig&quot;</span>);</span>
<span class="line" id="L36"><span class="tok-comment">/// deprecated: use `Step.ConfigHeader`.</span></span>
<span class="line" id="L37"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ConfigHeaderStep = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Build/Step/ConfigHeader.zig&quot;</span>);</span>
<span class="line" id="L38"><span class="tok-comment">/// deprecated: use `Step.Fmt`.</span></span>
<span class="line" id="L39"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FmtStep = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Build/Step/Fmt.zig&quot;</span>);</span>
<span class="line" id="L40"><span class="tok-comment">/// deprecated: use `Step.InstallArtifact`.</span></span>
<span class="line" id="L41"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> InstallArtifactStep = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Build/Step/InstallArtifact.zig&quot;</span>);</span>
<span class="line" id="L42"><span class="tok-comment">/// deprecated: use `Step.InstallDir`.</span></span>
<span class="line" id="L43"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> InstallDirStep = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Build/Step/InstallDir.zig&quot;</span>);</span>
<span class="line" id="L44"><span class="tok-comment">/// deprecated: use `Step.InstallFile`.</span></span>
<span class="line" id="L45"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> InstallFileStep = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Build/Step/InstallFile.zig&quot;</span>);</span>
<span class="line" id="L46"><span class="tok-comment">/// deprecated: use `Step.ObjCopy`.</span></span>
<span class="line" id="L47"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ObjCopyStep = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Build/Step/ObjCopy.zig&quot;</span>);</span>
<span class="line" id="L48"><span class="tok-comment">/// deprecated: use `Step.Compile`.</span></span>
<span class="line" id="L49"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CompileStep = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Build/Step/Compile.zig&quot;</span>);</span>
<span class="line" id="L50"><span class="tok-comment">/// deprecated: use `Step.Options`.</span></span>
<span class="line" id="L51"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> OptionsStep = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Build/Step/Options.zig&quot;</span>);</span>
<span class="line" id="L52"><span class="tok-comment">/// deprecated: use `Step.RemoveDir`.</span></span>
<span class="line" id="L53"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> RemoveDirStep = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Build/Step/RemoveDir.zig&quot;</span>);</span>
<span class="line" id="L54"><span class="tok-comment">/// deprecated: use `Step.Run`.</span></span>
<span class="line" id="L55"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> RunStep = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Build/Step/Run.zig&quot;</span>);</span>
<span class="line" id="L56"><span class="tok-comment">/// deprecated: use `Step.TranslateC`.</span></span>
<span class="line" id="L57"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> TranslateCStep = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Build/Step/TranslateC.zig&quot;</span>);</span>
<span class="line" id="L58"><span class="tok-comment">/// deprecated: use `Step.WriteFile`.</span></span>
<span class="line" id="L59"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> WriteFileStep = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Build/Step/WriteFile.zig&quot;</span>);</span>
<span class="line" id="L60"><span class="tok-comment">/// deprecated: use `LazyPath`.</span></span>
<span class="line" id="L61"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FileSource = LazyPath;</span>
<span class="line" id="L62"></span>
<span class="line" id="L63">install_tls: TopLevelStep,</span>
<span class="line" id="L64">uninstall_tls: TopLevelStep,</span>
<span class="line" id="L65">allocator: Allocator,</span>
<span class="line" id="L66">user_input_options: UserInputOptionsMap,</span>
<span class="line" id="L67">available_options_map: AvailableOptionsMap,</span>
<span class="line" id="L68">available_options_list: ArrayList(AvailableOption),</span>
<span class="line" id="L69">verbose: <span class="tok-type">bool</span>,</span>
<span class="line" id="L70">verbose_link: <span class="tok-type">bool</span>,</span>
<span class="line" id="L71">verbose_cc: <span class="tok-type">bool</span>,</span>
<span class="line" id="L72">verbose_air: <span class="tok-type">bool</span>,</span>
<span class="line" id="L73">verbose_llvm_ir: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L74">verbose_llvm_bc: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L75">verbose_cimport: <span class="tok-type">bool</span>,</span>
<span class="line" id="L76">verbose_llvm_cpu_features: <span class="tok-type">bool</span>,</span>
<span class="line" id="L77">reference_trace: ?<span class="tok-type">u32</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L78">invalid_user_input: <span class="tok-type">bool</span>,</span>
<span class="line" id="L79">zig_exe: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L80">default_step: *Step,</span>
<span class="line" id="L81">env_map: *EnvMap,</span>
<span class="line" id="L82">top_level_steps: std.StringArrayHashMapUnmanaged(*TopLevelStep),</span>
<span class="line" id="L83">install_prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L84">dest_dir: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L85">lib_dir: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L86">exe_dir: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L87">h_dir: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L88">install_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L89">sysroot: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L90">search_prefixes: ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>),</span>
<span class="line" id="L91">libc_file: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L92">installed_files: ArrayList(InstalledFile),</span>
<span class="line" id="L93"><span class="tok-comment">/// Path to the directory containing build.zig.</span></span>
<span class="line" id="L94">build_root: Cache.Directory,</span>
<span class="line" id="L95">cache_root: Cache.Directory,</span>
<span class="line" id="L96">global_cache_root: Cache.Directory,</span>
<span class="line" id="L97">cache: *Cache,</span>
<span class="line" id="L98">zig_lib_dir: ?LazyPath,</span>
<span class="line" id="L99">vcpkg_root: VcpkgRoot = .unattempted,</span>
<span class="line" id="L100">pkg_config_pkg_list: ?(PkgConfigError![]<span class="tok-kw">const</span> PkgConfigPkg) = <span class="tok-null">null</span>,</span>
<span class="line" id="L101">args: ?[][]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L102">debug_log_scopes: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;.{},</span>
<span class="line" id="L103">debug_compile_errors: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L104">debug_pkg_config: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L105"><span class="tok-comment">/// Number of stack frames captured when a `StackTrace` is recorded for debug purposes,</span></span>
<span class="line" id="L106"><span class="tok-comment">/// in particular at `Step` creation.</span></span>
<span class="line" id="L107"><span class="tok-comment">/// Set to 0 to disable stack collection.</span></span>
<span class="line" id="L108">debug_stack_frames_count: <span class="tok-type">u8</span> = <span class="tok-number">8</span>,</span>
<span class="line" id="L109"></span>
<span class="line" id="L110"><span class="tok-comment">/// Experimental. Use system Darling installation to run cross compiled macOS build artifacts.</span></span>
<span class="line" id="L111">enable_darling: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L112"><span class="tok-comment">/// Use system QEMU installation to run cross compiled foreign architecture build artifacts.</span></span>
<span class="line" id="L113">enable_qemu: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L114"><span class="tok-comment">/// Darwin. Use Rosetta to run x86_64 macOS build artifacts on arm64 macOS.</span></span>
<span class="line" id="L115">enable_rosetta: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L116"><span class="tok-comment">/// Use system Wasmtime installation to run cross compiled wasm/wasi build artifacts.</span></span>
<span class="line" id="L117">enable_wasmtime: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L118"><span class="tok-comment">/// Use system Wine installation to run cross compiled Windows build artifacts.</span></span>
<span class="line" id="L119">enable_wine: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L120"><span class="tok-comment">/// After following the steps in https://github.com/ziglang/zig/wiki/Updating-libc#glibc,</span></span>
<span class="line" id="L121"><span class="tok-comment">/// this will be the directory $glibc-build-dir/install/glibcs</span></span>
<span class="line" id="L122"><span class="tok-comment">/// Given the example of the aarch64 target, this is the directory</span></span>
<span class="line" id="L123"><span class="tok-comment">/// that contains the path `aarch64-linux-gnu/lib/ld-linux-aarch64.so.1`.</span></span>
<span class="line" id="L124">glibc_runtimes_dir: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L125"></span>
<span class="line" id="L126"><span class="tok-comment">/// Information about the native target. Computed before build() is invoked.</span></span>
<span class="line" id="L127">host: NativeTargetInfo,</span>
<span class="line" id="L128"></span>
<span class="line" id="L129">dep_prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;&quot;</span>,</span>
<span class="line" id="L130"></span>
<span class="line" id="L131">modules: std.StringArrayHashMap(*Module),</span>
<span class="line" id="L132"><span class="tok-comment">/// A map from build root dirs to the corresponding `*Dependency`. This is shared with all child</span></span>
<span class="line" id="L133"><span class="tok-comment">/// `Build`s.</span></span>
<span class="line" id="L134">initialized_deps: *InitializedDepMap,</span>
<span class="line" id="L135"><span class="tok-comment">/// A mapping from dependency names to package hashes.</span></span>
<span class="line" id="L136">available_deps: AvailableDeps,</span>
<span class="line" id="L137"></span>
<span class="line" id="L138"><span class="tok-kw">const</span> AvailableDeps = []<span class="tok-kw">const</span> <span class="tok-kw">struct</span> { []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, []<span class="tok-kw">const</span> <span class="tok-type">u8</span> };</span>
<span class="line" id="L139"></span>
<span class="line" id="L140"><span class="tok-kw">const</span> InitializedDepMap = std.HashMap(InitializedDepKey, *Dependency, InitializedDepContext, std.hash_map.default_max_load_percentage);</span>
<span class="line" id="L141"><span class="tok-kw">const</span> InitializedDepKey = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L142">    build_root_string: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L143">    user_input_options: UserInputOptionsMap,</span>
<span class="line" id="L144">};</span>
<span class="line" id="L145"></span>
<span class="line" id="L146"><span class="tok-kw">const</span> InitializedDepContext = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L147">    allocator: Allocator,</span>
<span class="line" id="L148"></span>
<span class="line" id="L149">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(self: <span class="tok-builtin">@This</span>(), k: InitializedDepKey) <span class="tok-type">u64</span> {</span>
<span class="line" id="L150">        <span class="tok-kw">var</span> hasher = std.hash.Wyhash.init(<span class="tok-number">0</span>);</span>
<span class="line" id="L151">        hasher.update(k.build_root_string);</span>
<span class="line" id="L152">        hashUserInputOptionsMap(self.allocator, k.user_input_options, &amp;hasher);</span>
<span class="line" id="L153">        <span class="tok-kw">return</span> hasher.final();</span>
<span class="line" id="L154">    }</span>
<span class="line" id="L155"></span>
<span class="line" id="L156">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(self: <span class="tok-builtin">@This</span>(), lhs: InitializedDepKey, rhs: InitializedDepKey) <span class="tok-type">bool</span> {</span>
<span class="line" id="L157">        _ = self;</span>
<span class="line" id="L158">        <span class="tok-kw">if</span> (!std.mem.eql(<span class="tok-type">u8</span>, lhs.build_root_string, rhs.build_root_string))</span>
<span class="line" id="L159">            <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L160"></span>
<span class="line" id="L161">        <span class="tok-kw">if</span> (lhs.user_input_options.count() != rhs.user_input_options.count())</span>
<span class="line" id="L162">            <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L163"></span>
<span class="line" id="L164">        <span class="tok-kw">var</span> it = lhs.user_input_options.iterator();</span>
<span class="line" id="L165">        <span class="tok-kw">while</span> (it.next()) |lhs_entry| {</span>
<span class="line" id="L166">            <span class="tok-kw">const</span> rhs_value = rhs.user_input_options.get(lhs_entry.key_ptr.*) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L167">            <span class="tok-kw">if</span> (!userValuesAreSame(lhs_entry.value_ptr.*.value, rhs_value.value))</span>
<span class="line" id="L168">                <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L169">        }</span>
<span class="line" id="L170"></span>
<span class="line" id="L171">        <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L172">    }</span>
<span class="line" id="L173">};</span>
<span class="line" id="L174"></span>
<span class="line" id="L175"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> RunError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L176">    ReadFailure,</span>
<span class="line" id="L177">    ExitCodeFailure,</span>
<span class="line" id="L178">    ProcessTerminated,</span>
<span class="line" id="L179">    ExecNotSupported,</span>
<span class="line" id="L180">} || std.ChildProcess.SpawnError;</span>
<span class="line" id="L181"></span>
<span class="line" id="L182"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> PkgConfigError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L183">    PkgConfigCrashed,</span>
<span class="line" id="L184">    PkgConfigFailed,</span>
<span class="line" id="L185">    PkgConfigNotInstalled,</span>
<span class="line" id="L186">    PkgConfigInvalidOutput,</span>
<span class="line" id="L187">};</span>
<span class="line" id="L188"></span>
<span class="line" id="L189"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> PkgConfigPkg = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L190">    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L191">    desc: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L192">};</span>
<span class="line" id="L193"></span>
<span class="line" id="L194"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CStd = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L195">    C89,</span>
<span class="line" id="L196">    C99,</span>
<span class="line" id="L197">    C11,</span>
<span class="line" id="L198">};</span>
<span class="line" id="L199"></span>
<span class="line" id="L200"><span class="tok-kw">const</span> UserInputOptionsMap = StringHashMap(UserInputOption);</span>
<span class="line" id="L201"><span class="tok-kw">const</span> AvailableOptionsMap = StringHashMap(AvailableOption);</span>
<span class="line" id="L202"></span>
<span class="line" id="L203"><span class="tok-kw">const</span> AvailableOption = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L204">    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L205">    type_id: TypeId,</span>
<span class="line" id="L206">    description: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L207">    <span class="tok-comment">/// If the `type_id` is `enum` this provides the list of enum options</span></span>
<span class="line" id="L208">    enum_options: ?[]<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L209">};</span>
<span class="line" id="L210"></span>
<span class="line" id="L211"><span class="tok-kw">const</span> UserInputOption = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L212">    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L213">    value: UserValue,</span>
<span class="line" id="L214">    used: <span class="tok-type">bool</span>,</span>
<span class="line" id="L215">};</span>
<span class="line" id="L216"></span>
<span class="line" id="L217"><span class="tok-kw">const</span> UserValue = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L218">    flag: <span class="tok-type">void</span>,</span>
<span class="line" id="L219">    scalar: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L220">    list: ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>),</span>
<span class="line" id="L221">    map: StringHashMap(*<span class="tok-kw">const</span> UserValue),</span>
<span class="line" id="L222">};</span>
<span class="line" id="L223"></span>
<span class="line" id="L224"><span class="tok-kw">const</span> TypeId = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L225">    <span class="tok-type">bool</span>,</span>
<span class="line" id="L226">    int,</span>
<span class="line" id="L227">    float,</span>
<span class="line" id="L228">    @&quot;enum&quot;,</span>
<span class="line" id="L229">    string,</span>
<span class="line" id="L230">    list,</span>
<span class="line" id="L231">    build_id,</span>
<span class="line" id="L232">};</span>
<span class="line" id="L233"></span>
<span class="line" id="L234"><span class="tok-kw">const</span> TopLevelStep = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L235">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> base_id = .top_level;</span>
<span class="line" id="L236"></span>
<span class="line" id="L237">    step: Step,</span>
<span class="line" id="L238">    description: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L239">};</span>
<span class="line" id="L240"></span>
<span class="line" id="L241"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DirList = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L242">    lib_dir: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L243">    exe_dir: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L244">    include_dir: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L245">};</span>
<span class="line" id="L246"></span>
<span class="line" id="L247"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">create</span>(</span>
<span class="line" id="L248">    allocator: Allocator,</span>
<span class="line" id="L249">    zig_exe: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L250">    build_root: Cache.Directory,</span>
<span class="line" id="L251">    cache_root: Cache.Directory,</span>
<span class="line" id="L252">    global_cache_root: Cache.Directory,</span>
<span class="line" id="L253">    host: NativeTargetInfo,</span>
<span class="line" id="L254">    cache: *Cache,</span>
<span class="line" id="L255">    available_deps: AvailableDeps,</span>
<span class="line" id="L256">) !*Build {</span>
<span class="line" id="L257">    <span class="tok-kw">const</span> env_map = <span class="tok-kw">try</span> allocator.create(EnvMap);</span>
<span class="line" id="L258">    env_map.* = <span class="tok-kw">try</span> process.getEnvMap(allocator);</span>
<span class="line" id="L259"></span>
<span class="line" id="L260">    <span class="tok-kw">const</span> initialized_deps = <span class="tok-kw">try</span> allocator.create(InitializedDepMap);</span>
<span class="line" id="L261">    initialized_deps.* = InitializedDepMap.initContext(allocator, .{ .allocator = allocator });</span>
<span class="line" id="L262"></span>
<span class="line" id="L263">    <span class="tok-kw">const</span> self = <span class="tok-kw">try</span> allocator.create(Build);</span>
<span class="line" id="L264">    self.* = .{</span>
<span class="line" id="L265">        .zig_exe = zig_exe,</span>
<span class="line" id="L266">        .build_root = build_root,</span>
<span class="line" id="L267">        .cache_root = cache_root,</span>
<span class="line" id="L268">        .global_cache_root = global_cache_root,</span>
<span class="line" id="L269">        .cache = cache,</span>
<span class="line" id="L270">        .verbose = <span class="tok-null">false</span>,</span>
<span class="line" id="L271">        .verbose_link = <span class="tok-null">false</span>,</span>
<span class="line" id="L272">        .verbose_cc = <span class="tok-null">false</span>,</span>
<span class="line" id="L273">        .verbose_air = <span class="tok-null">false</span>,</span>
<span class="line" id="L274">        .verbose_llvm_ir = <span class="tok-null">null</span>,</span>
<span class="line" id="L275">        .verbose_llvm_bc = <span class="tok-null">null</span>,</span>
<span class="line" id="L276">        .verbose_cimport = <span class="tok-null">false</span>,</span>
<span class="line" id="L277">        .verbose_llvm_cpu_features = <span class="tok-null">false</span>,</span>
<span class="line" id="L278">        .invalid_user_input = <span class="tok-null">false</span>,</span>
<span class="line" id="L279">        .allocator = allocator,</span>
<span class="line" id="L280">        .user_input_options = UserInputOptionsMap.init(allocator),</span>
<span class="line" id="L281">        .available_options_map = AvailableOptionsMap.init(allocator),</span>
<span class="line" id="L282">        .available_options_list = ArrayList(AvailableOption).init(allocator),</span>
<span class="line" id="L283">        .top_level_steps = .{},</span>
<span class="line" id="L284">        .default_step = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L285">        .env_map = env_map,</span>
<span class="line" id="L286">        .search_prefixes = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(allocator),</span>
<span class="line" id="L287">        .install_prefix = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L288">        .lib_dir = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L289">        .exe_dir = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L290">        .h_dir = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L291">        .dest_dir = env_map.get(<span class="tok-str">&quot;DESTDIR&quot;</span>),</span>
<span class="line" id="L292">        .installed_files = ArrayList(InstalledFile).init(allocator),</span>
<span class="line" id="L293">        .install_tls = .{</span>
<span class="line" id="L294">            .step = Step.init(.{</span>
<span class="line" id="L295">                .id = .top_level,</span>
<span class="line" id="L296">                .name = <span class="tok-str">&quot;install&quot;</span>,</span>
<span class="line" id="L297">                .owner = self,</span>
<span class="line" id="L298">            }),</span>
<span class="line" id="L299">            .description = <span class="tok-str">&quot;Copy build artifacts to prefix path&quot;</span>,</span>
<span class="line" id="L300">        },</span>
<span class="line" id="L301">        .uninstall_tls = .{</span>
<span class="line" id="L302">            .step = Step.init(.{</span>
<span class="line" id="L303">                .id = .top_level,</span>
<span class="line" id="L304">                .name = <span class="tok-str">&quot;uninstall&quot;</span>,</span>
<span class="line" id="L305">                .owner = self,</span>
<span class="line" id="L306">                .makeFn = makeUninstall,</span>
<span class="line" id="L307">            }),</span>
<span class="line" id="L308">            .description = <span class="tok-str">&quot;Remove build artifacts from prefix path&quot;</span>,</span>
<span class="line" id="L309">        },</span>
<span class="line" id="L310">        .zig_lib_dir = <span class="tok-null">null</span>,</span>
<span class="line" id="L311">        .install_path = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L312">        .args = <span class="tok-null">null</span>,</span>
<span class="line" id="L313">        .host = host,</span>
<span class="line" id="L314">        .modules = std.StringArrayHashMap(*Module).init(allocator),</span>
<span class="line" id="L315">        .initialized_deps = initialized_deps,</span>
<span class="line" id="L316">        .available_deps = available_deps,</span>
<span class="line" id="L317">    };</span>
<span class="line" id="L318">    <span class="tok-kw">try</span> self.top_level_steps.put(allocator, self.install_tls.step.name, &amp;self.install_tls);</span>
<span class="line" id="L319">    <span class="tok-kw">try</span> self.top_level_steps.put(allocator, self.uninstall_tls.step.name, &amp;self.uninstall_tls);</span>
<span class="line" id="L320">    self.default_step = &amp;self.install_tls.step;</span>
<span class="line" id="L321">    <span class="tok-kw">return</span> self;</span>
<span class="line" id="L322">}</span>
<span class="line" id="L323"></span>
<span class="line" id="L324"><span class="tok-kw">fn</span> <span class="tok-fn">createChild</span>(</span>
<span class="line" id="L325">    parent: *Build,</span>
<span class="line" id="L326">    dep_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L327">    build_root: Cache.Directory,</span>
<span class="line" id="L328">    pkg_deps: AvailableDeps,</span>
<span class="line" id="L329">    user_input_options: UserInputOptionsMap,</span>
<span class="line" id="L330">) !*Build {</span>
<span class="line" id="L331">    <span class="tok-kw">const</span> child = <span class="tok-kw">try</span> createChildOnly(parent, dep_name, build_root, pkg_deps, user_input_options);</span>
<span class="line" id="L332">    <span class="tok-kw">try</span> determineAndApplyInstallPrefix(child);</span>
<span class="line" id="L333">    <span class="tok-kw">return</span> child;</span>
<span class="line" id="L334">}</span>
<span class="line" id="L335"></span>
<span class="line" id="L336"><span class="tok-kw">fn</span> <span class="tok-fn">createChildOnly</span>(parent: *Build, dep_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, build_root: Cache.Directory, pkg_deps: AvailableDeps, user_input_options: UserInputOptionsMap) !*Build {</span>
<span class="line" id="L337">    <span class="tok-kw">const</span> allocator = parent.allocator;</span>
<span class="line" id="L338">    <span class="tok-kw">const</span> child = <span class="tok-kw">try</span> allocator.create(Build);</span>
<span class="line" id="L339">    child.* = .{</span>
<span class="line" id="L340">        .allocator = allocator,</span>
<span class="line" id="L341">        .install_tls = .{</span>
<span class="line" id="L342">            .step = Step.init(.{</span>
<span class="line" id="L343">                .id = .top_level,</span>
<span class="line" id="L344">                .name = <span class="tok-str">&quot;install&quot;</span>,</span>
<span class="line" id="L345">                .owner = child,</span>
<span class="line" id="L346">            }),</span>
<span class="line" id="L347">            .description = <span class="tok-str">&quot;Copy build artifacts to prefix path&quot;</span>,</span>
<span class="line" id="L348">        },</span>
<span class="line" id="L349">        .uninstall_tls = .{</span>
<span class="line" id="L350">            .step = Step.init(.{</span>
<span class="line" id="L351">                .id = .top_level,</span>
<span class="line" id="L352">                .name = <span class="tok-str">&quot;uninstall&quot;</span>,</span>
<span class="line" id="L353">                .owner = child,</span>
<span class="line" id="L354">                .makeFn = makeUninstall,</span>
<span class="line" id="L355">            }),</span>
<span class="line" id="L356">            .description = <span class="tok-str">&quot;Remove build artifacts from prefix path&quot;</span>,</span>
<span class="line" id="L357">        },</span>
<span class="line" id="L358">        .user_input_options = user_input_options,</span>
<span class="line" id="L359">        .available_options_map = AvailableOptionsMap.init(allocator),</span>
<span class="line" id="L360">        .available_options_list = ArrayList(AvailableOption).init(allocator),</span>
<span class="line" id="L361">        .verbose = parent.verbose,</span>
<span class="line" id="L362">        .verbose_link = parent.verbose_link,</span>
<span class="line" id="L363">        .verbose_cc = parent.verbose_cc,</span>
<span class="line" id="L364">        .verbose_air = parent.verbose_air,</span>
<span class="line" id="L365">        .verbose_llvm_ir = parent.verbose_llvm_ir,</span>
<span class="line" id="L366">        .verbose_llvm_bc = parent.verbose_llvm_bc,</span>
<span class="line" id="L367">        .verbose_cimport = parent.verbose_cimport,</span>
<span class="line" id="L368">        .verbose_llvm_cpu_features = parent.verbose_llvm_cpu_features,</span>
<span class="line" id="L369">        .reference_trace = parent.reference_trace,</span>
<span class="line" id="L370">        .invalid_user_input = <span class="tok-null">false</span>,</span>
<span class="line" id="L371">        .zig_exe = parent.zig_exe,</span>
<span class="line" id="L372">        .default_step = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L373">        .env_map = parent.env_map,</span>
<span class="line" id="L374">        .top_level_steps = .{},</span>
<span class="line" id="L375">        .install_prefix = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L376">        .dest_dir = parent.dest_dir,</span>
<span class="line" id="L377">        .lib_dir = parent.lib_dir,</span>
<span class="line" id="L378">        .exe_dir = parent.exe_dir,</span>
<span class="line" id="L379">        .h_dir = parent.h_dir,</span>
<span class="line" id="L380">        .install_path = parent.install_path,</span>
<span class="line" id="L381">        .sysroot = parent.sysroot,</span>
<span class="line" id="L382">        .search_prefixes = parent.search_prefixes,</span>
<span class="line" id="L383">        .libc_file = parent.libc_file,</span>
<span class="line" id="L384">        .installed_files = ArrayList(InstalledFile).init(allocator),</span>
<span class="line" id="L385">        .build_root = build_root,</span>
<span class="line" id="L386">        .cache_root = parent.cache_root,</span>
<span class="line" id="L387">        .global_cache_root = parent.global_cache_root,</span>
<span class="line" id="L388">        .cache = parent.cache,</span>
<span class="line" id="L389">        .zig_lib_dir = parent.zig_lib_dir,</span>
<span class="line" id="L390">        .debug_log_scopes = parent.debug_log_scopes,</span>
<span class="line" id="L391">        .debug_compile_errors = parent.debug_compile_errors,</span>
<span class="line" id="L392">        .debug_pkg_config = parent.debug_pkg_config,</span>
<span class="line" id="L393">        .enable_darling = parent.enable_darling,</span>
<span class="line" id="L394">        .enable_qemu = parent.enable_qemu,</span>
<span class="line" id="L395">        .enable_rosetta = parent.enable_rosetta,</span>
<span class="line" id="L396">        .enable_wasmtime = parent.enable_wasmtime,</span>
<span class="line" id="L397">        .enable_wine = parent.enable_wine,</span>
<span class="line" id="L398">        .glibc_runtimes_dir = parent.glibc_runtimes_dir,</span>
<span class="line" id="L399">        .host = parent.host,</span>
<span class="line" id="L400">        .dep_prefix = parent.fmt(<span class="tok-str">&quot;{s}{s}.&quot;</span>, .{ parent.dep_prefix, dep_name }),</span>
<span class="line" id="L401">        .modules = std.StringArrayHashMap(*Module).init(allocator),</span>
<span class="line" id="L402">        .initialized_deps = parent.initialized_deps,</span>
<span class="line" id="L403">        .available_deps = pkg_deps,</span>
<span class="line" id="L404">    };</span>
<span class="line" id="L405">    <span class="tok-kw">try</span> child.top_level_steps.put(allocator, child.install_tls.step.name, &amp;child.install_tls);</span>
<span class="line" id="L406">    <span class="tok-kw">try</span> child.top_level_steps.put(allocator, child.uninstall_tls.step.name, &amp;child.uninstall_tls);</span>
<span class="line" id="L407">    child.default_step = &amp;child.install_tls.step;</span>
<span class="line" id="L408">    <span class="tok-kw">return</span> child;</span>
<span class="line" id="L409">}</span>
<span class="line" id="L410"></span>
<span class="line" id="L411"><span class="tok-kw">fn</span> <span class="tok-fn">userInputOptionsFromArgs</span>(allocator: Allocator, args: <span class="tok-kw">anytype</span>) UserInputOptionsMap {</span>
<span class="line" id="L412">    <span class="tok-kw">var</span> user_input_options = UserInputOptionsMap.init(allocator);</span>
<span class="line" id="L413">    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(args)).Struct.fields) |field| {</span>
<span class="line" id="L414">        <span class="tok-kw">const</span> v = <span class="tok-builtin">@field</span>(args, field.name);</span>
<span class="line" id="L415">        <span class="tok-kw">const</span> T = <span class="tok-builtin">@TypeOf</span>(v);</span>
<span class="line" id="L416">        <span class="tok-kw">switch</span> (T) {</span>
<span class="line" id="L417">            CrossTarget =&gt; {</span>
<span class="line" id="L418">                user_input_options.put(field.name, .{</span>
<span class="line" id="L419">                    .name = field.name,</span>
<span class="line" id="L420">                    .value = .{ .scalar = v.zigTriple(allocator) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>) },</span>
<span class="line" id="L421">                    .used = <span class="tok-null">false</span>,</span>
<span class="line" id="L422">                }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L423">                user_input_options.put(<span class="tok-str">&quot;cpu&quot;</span>, .{</span>
<span class="line" id="L424">                    .name = <span class="tok-str">&quot;cpu&quot;</span>,</span>
<span class="line" id="L425">                    .value = .{</span>
<span class="line" id="L426">                        .scalar = <span class="tok-kw">if</span> (v.isNativeCpu())</span>
<span class="line" id="L427">                            <span class="tok-str">&quot;native&quot;</span></span>
<span class="line" id="L428">                        <span class="tok-kw">else</span></span>
<span class="line" id="L429">                            serializeCpu(allocator, v.getCpu()) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L430">                    },</span>
<span class="line" id="L431">                    .used = <span class="tok-null">false</span>,</span>
<span class="line" id="L432">                }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L433">            },</span>
<span class="line" id="L434">            []<span class="tok-kw">const</span> <span class="tok-type">u8</span> =&gt; {</span>
<span class="line" id="L435">                user_input_options.put(field.name, .{</span>
<span class="line" id="L436">                    .name = field.name,</span>
<span class="line" id="L437">                    .value = .{ .scalar = v },</span>
<span class="line" id="L438">                    .used = <span class="tok-null">false</span>,</span>
<span class="line" id="L439">                }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L440">            },</span>
<span class="line" id="L441">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {</span>
<span class="line" id="L442">                .Bool =&gt; {</span>
<span class="line" id="L443">                    user_input_options.put(field.name, .{</span>
<span class="line" id="L444">                        .name = field.name,</span>
<span class="line" id="L445">                        .value = .{ .scalar = <span class="tok-kw">if</span> (v) <span class="tok-str">&quot;true&quot;</span> <span class="tok-kw">else</span> <span class="tok-str">&quot;false&quot;</span> },</span>
<span class="line" id="L446">                        .used = <span class="tok-null">false</span>,</span>
<span class="line" id="L447">                    }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L448">                },</span>
<span class="line" id="L449">                .Enum, .EnumLiteral =&gt; {</span>
<span class="line" id="L450">                    user_input_options.put(field.name, .{</span>
<span class="line" id="L451">                        .name = field.name,</span>
<span class="line" id="L452">                        .value = .{ .scalar = <span class="tok-builtin">@tagName</span>(v) },</span>
<span class="line" id="L453">                        .used = <span class="tok-null">false</span>,</span>
<span class="line" id="L454">                    }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L455">                },</span>
<span class="line" id="L456">                .Int =&gt; {</span>
<span class="line" id="L457">                    user_input_options.put(field.name, .{</span>
<span class="line" id="L458">                        .name = field.name,</span>
<span class="line" id="L459">                        .value = .{ .scalar = std.fmt.allocPrint(allocator, <span class="tok-str">&quot;{d}&quot;</span>, .{v}) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>) },</span>
<span class="line" id="L460">                        .used = <span class="tok-null">false</span>,</span>
<span class="line" id="L461">                    }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L462">                },</span>
<span class="line" id="L463">                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;option '&quot;</span> ++ field.name ++ <span class="tok-str">&quot;' has unsupported type: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(T)),</span>
<span class="line" id="L464">            },</span>
<span class="line" id="L465">        }</span>
<span class="line" id="L466">    }</span>
<span class="line" id="L467"></span>
<span class="line" id="L468">    <span class="tok-kw">return</span> user_input_options;</span>
<span class="line" id="L469">}</span>
<span class="line" id="L470"></span>
<span class="line" id="L471"><span class="tok-kw">const</span> OrderedUserValue = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L472">    flag: <span class="tok-type">void</span>,</span>
<span class="line" id="L473">    scalar: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L474">    list: ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>),</span>
<span class="line" id="L475">    map: ArrayList(Pair),</span>
<span class="line" id="L476"></span>
<span class="line" id="L477">    <span class="tok-kw">const</span> Pair = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L478">        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L479">        value: OrderedUserValue,</span>
<span class="line" id="L480">        <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(_: <span class="tok-type">void</span>, lhs: Pair, rhs: Pair) <span class="tok-type">bool</span> {</span>
<span class="line" id="L481">            <span class="tok-kw">return</span> std.ascii.lessThanIgnoreCase(lhs.name, rhs.name);</span>
<span class="line" id="L482">        }</span>
<span class="line" id="L483">    };</span>
<span class="line" id="L484"></span>
<span class="line" id="L485">    <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(self: OrderedUserValue, hasher: *std.hash.Wyhash) <span class="tok-type">void</span> {</span>
<span class="line" id="L486">        <span class="tok-kw">switch</span> (self) {</span>
<span class="line" id="L487">            .flag =&gt; {},</span>
<span class="line" id="L488">            .scalar =&gt; |scalar| hasher.update(scalar),</span>
<span class="line" id="L489">            <span class="tok-comment">// lists are already ordered</span>
</span>
<span class="line" id="L490">            .list =&gt; |list| <span class="tok-kw">for</span> (list.items) |list_entry|</span>
<span class="line" id="L491">                hasher.update(list_entry),</span>
<span class="line" id="L492">            .map =&gt; |map| <span class="tok-kw">for</span> (map.items) |map_entry| {</span>
<span class="line" id="L493">                hasher.update(map_entry.name);</span>
<span class="line" id="L494">                map_entry.value.hash(hasher);</span>
<span class="line" id="L495">            },</span>
<span class="line" id="L496">        }</span>
<span class="line" id="L497">    }</span>
<span class="line" id="L498"></span>
<span class="line" id="L499">    <span class="tok-kw">fn</span> <span class="tok-fn">mapFromUnordered</span>(allocator: Allocator, unordered: std.StringHashMap(*<span class="tok-kw">const</span> UserValue)) ArrayList(Pair) {</span>
<span class="line" id="L500">        <span class="tok-kw">var</span> ordered = ArrayList(Pair).init(allocator);</span>
<span class="line" id="L501">        <span class="tok-kw">var</span> it = unordered.iterator();</span>
<span class="line" id="L502">        <span class="tok-kw">while</span> (it.next()) |entry| {</span>
<span class="line" id="L503">            ordered.append(.{</span>
<span class="line" id="L504">                .name = entry.key_ptr.*,</span>
<span class="line" id="L505">                .value = OrderedUserValue.fromUnordered(allocator, entry.value_ptr.*.*),</span>
<span class="line" id="L506">            }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L507">        }</span>
<span class="line" id="L508"></span>
<span class="line" id="L509">        std.mem.sortUnstable(Pair, ordered.items, {}, Pair.lessThan);</span>
<span class="line" id="L510">        <span class="tok-kw">return</span> ordered;</span>
<span class="line" id="L511">    }</span>
<span class="line" id="L512"></span>
<span class="line" id="L513">    <span class="tok-kw">fn</span> <span class="tok-fn">fromUnordered</span>(allocator: Allocator, unordered: UserValue) OrderedUserValue {</span>
<span class="line" id="L514">        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (unordered) {</span>
<span class="line" id="L515">            .flag =&gt; .{ .flag = {} },</span>
<span class="line" id="L516">            .scalar =&gt; |scalar| .{ .scalar = scalar },</span>
<span class="line" id="L517">            .list =&gt; |list| .{ .list = list },</span>
<span class="line" id="L518">            .map =&gt; |map| .{ .map = OrderedUserValue.mapFromUnordered(allocator, map) },</span>
<span class="line" id="L519">        };</span>
<span class="line" id="L520">    }</span>
<span class="line" id="L521">};</span>
<span class="line" id="L522"></span>
<span class="line" id="L523"><span class="tok-kw">const</span> OrderedUserInputOption = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L524">    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L525">    value: OrderedUserValue,</span>
<span class="line" id="L526">    used: <span class="tok-type">bool</span>,</span>
<span class="line" id="L527"></span>
<span class="line" id="L528">    <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(self: OrderedUserInputOption, hasher: *std.hash.Wyhash) <span class="tok-type">void</span> {</span>
<span class="line" id="L529">        hasher.update(self.name);</span>
<span class="line" id="L530">        self.value.hash(hasher);</span>
<span class="line" id="L531">    }</span>
<span class="line" id="L532"></span>
<span class="line" id="L533">    <span class="tok-kw">fn</span> <span class="tok-fn">fromUnordered</span>(allocator: Allocator, user_input_option: UserInputOption) OrderedUserInputOption {</span>
<span class="line" id="L534">        <span class="tok-kw">return</span> OrderedUserInputOption{</span>
<span class="line" id="L535">            .name = user_input_option.name,</span>
<span class="line" id="L536">            .used = user_input_option.used,</span>
<span class="line" id="L537">            .value = OrderedUserValue.fromUnordered(allocator, user_input_option.value),</span>
<span class="line" id="L538">        };</span>
<span class="line" id="L539">    }</span>
<span class="line" id="L540"></span>
<span class="line" id="L541">    <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(_: <span class="tok-type">void</span>, lhs: OrderedUserInputOption, rhs: OrderedUserInputOption) <span class="tok-type">bool</span> {</span>
<span class="line" id="L542">        <span class="tok-kw">return</span> std.ascii.lessThanIgnoreCase(lhs.name, rhs.name);</span>
<span class="line" id="L543">    }</span>
<span class="line" id="L544">};</span>
<span class="line" id="L545"></span>
<span class="line" id="L546"><span class="tok-comment">// The hash should be consistent with the same values given a different order.</span>
</span>
<span class="line" id="L547"><span class="tok-comment">// This function takes a user input map, orders it, then hashes the contents.</span>
</span>
<span class="line" id="L548"><span class="tok-kw">fn</span> <span class="tok-fn">hashUserInputOptionsMap</span>(allocator: Allocator, user_input_options: UserInputOptionsMap, hasher: *std.hash.Wyhash) <span class="tok-type">void</span> {</span>
<span class="line" id="L549">    <span class="tok-kw">var</span> ordered = ArrayList(OrderedUserInputOption).init(allocator);</span>
<span class="line" id="L550">    <span class="tok-kw">var</span> it = user_input_options.iterator();</span>
<span class="line" id="L551">    <span class="tok-kw">while</span> (it.next()) |entry|</span>
<span class="line" id="L552">        ordered.append(OrderedUserInputOption.fromUnordered(allocator, entry.value_ptr.*)) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L553"></span>
<span class="line" id="L554">    std.mem.sortUnstable(OrderedUserInputOption, ordered.items, {}, OrderedUserInputOption.lessThan);</span>
<span class="line" id="L555"></span>
<span class="line" id="L556">    <span class="tok-comment">// juice it</span>
</span>
<span class="line" id="L557">    <span class="tok-kw">for</span> (ordered.items) |user_option|</span>
<span class="line" id="L558">        user_option.hash(hasher);</span>
<span class="line" id="L559">}</span>
<span class="line" id="L560"></span>
<span class="line" id="L561"><span class="tok-kw">fn</span> <span class="tok-fn">determineAndApplyInstallPrefix</span>(b: *Build) !<span class="tok-type">void</span> {</span>
<span class="line" id="L562">    <span class="tok-comment">// Create an installation directory local to this package. This will be used when</span>
</span>
<span class="line" id="L563">    <span class="tok-comment">// dependant packages require a standard prefix, such as include directories for C headers.</span>
</span>
<span class="line" id="L564">    <span class="tok-kw">var</span> hash = b.cache.hash;</span>
<span class="line" id="L565">    <span class="tok-comment">// Random bytes to make unique. Refresh this with new random bytes when</span>
</span>
<span class="line" id="L566">    <span class="tok-comment">// implementation is modified in a non-backwards-compatible way.</span>
</span>
<span class="line" id="L567">    hash.add(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0xd8cb0055</span>));</span>
<span class="line" id="L568">    hash.addBytes(b.dep_prefix);</span>
<span class="line" id="L569"></span>
<span class="line" id="L570">    <span class="tok-kw">var</span> wyhash = std.hash.Wyhash.init(<span class="tok-number">0</span>);</span>
<span class="line" id="L571">    hashUserInputOptionsMap(b.allocator, b.user_input_options, &amp;wyhash);</span>
<span class="line" id="L572">    hash.add(wyhash.final());</span>
<span class="line" id="L573"></span>
<span class="line" id="L574">    <span class="tok-kw">const</span> digest = hash.final();</span>
<span class="line" id="L575">    <span class="tok-kw">const</span> install_prefix = <span class="tok-kw">try</span> b.cache_root.join(b.allocator, &amp;.{ <span class="tok-str">&quot;i&quot;</span>, &amp;digest });</span>
<span class="line" id="L576">    b.resolveInstallPrefix(install_prefix, .{});</span>
<span class="line" id="L577">}</span>
<span class="line" id="L578"></span>
<span class="line" id="L579"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">destroy</span>(b: *Build) <span class="tok-type">void</span> {</span>
<span class="line" id="L580">    b.env_map.deinit();</span>
<span class="line" id="L581">    b.top_level_steps.deinit(b.allocator);</span>
<span class="line" id="L582">    b.allocator.destroy(b);</span>
<span class="line" id="L583">}</span>
<span class="line" id="L584"></span>
<span class="line" id="L585"><span class="tok-comment">/// This function is intended to be called by lib/build_runner.zig, not a build.zig file.</span></span>
<span class="line" id="L586"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resolveInstallPrefix</span>(self: *Build, install_prefix: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, dir_list: DirList) <span class="tok-type">void</span> {</span>
<span class="line" id="L587">    <span class="tok-kw">if</span> (self.dest_dir) |dest_dir| {</span>
<span class="line" id="L588">        self.install_prefix = install_prefix <span class="tok-kw">orelse</span> <span class="tok-str">&quot;/usr&quot;</span>;</span>
<span class="line" id="L589">        self.install_path = self.pathJoin(&amp;.{ dest_dir, self.install_prefix });</span>
<span class="line" id="L590">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L591">        self.install_prefix = install_prefix <span class="tok-kw">orelse</span></span>
<span class="line" id="L592">            (self.build_root.join(self.allocator, &amp;.{<span class="tok-str">&quot;zig-out&quot;</span>}) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;unhandled error&quot;</span>));</span>
<span class="line" id="L593">        self.install_path = self.install_prefix;</span>
<span class="line" id="L594">    }</span>
<span class="line" id="L595"></span>
<span class="line" id="L596">    <span class="tok-kw">var</span> lib_list = [_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ self.install_path, <span class="tok-str">&quot;lib&quot;</span> };</span>
<span class="line" id="L597">    <span class="tok-kw">var</span> exe_list = [_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ self.install_path, <span class="tok-str">&quot;bin&quot;</span> };</span>
<span class="line" id="L598">    <span class="tok-kw">var</span> h_list = [_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ self.install_path, <span class="tok-str">&quot;include&quot;</span> };</span>
<span class="line" id="L599"></span>
<span class="line" id="L600">    <span class="tok-kw">if</span> (dir_list.lib_dir) |dir| {</span>
<span class="line" id="L601">        <span class="tok-kw">if</span> (std.fs.path.isAbsolute(dir)) lib_list[<span class="tok-number">0</span>] = self.dest_dir <span class="tok-kw">orelse</span> <span class="tok-str">&quot;&quot;</span>;</span>
<span class="line" id="L602">        lib_list[<span class="tok-number">1</span>] = dir;</span>
<span class="line" id="L603">    }</span>
<span class="line" id="L604"></span>
<span class="line" id="L605">    <span class="tok-kw">if</span> (dir_list.exe_dir) |dir| {</span>
<span class="line" id="L606">        <span class="tok-kw">if</span> (std.fs.path.isAbsolute(dir)) exe_list[<span class="tok-number">0</span>] = self.dest_dir <span class="tok-kw">orelse</span> <span class="tok-str">&quot;&quot;</span>;</span>
<span class="line" id="L607">        exe_list[<span class="tok-number">1</span>] = dir;</span>
<span class="line" id="L608">    }</span>
<span class="line" id="L609"></span>
<span class="line" id="L610">    <span class="tok-kw">if</span> (dir_list.include_dir) |dir| {</span>
<span class="line" id="L611">        <span class="tok-kw">if</span> (std.fs.path.isAbsolute(dir)) h_list[<span class="tok-number">0</span>] = self.dest_dir <span class="tok-kw">orelse</span> <span class="tok-str">&quot;&quot;</span>;</span>
<span class="line" id="L612">        h_list[<span class="tok-number">1</span>] = dir;</span>
<span class="line" id="L613">    }</span>
<span class="line" id="L614"></span>
<span class="line" id="L615">    self.lib_dir = self.pathJoin(&amp;lib_list);</span>
<span class="line" id="L616">    self.exe_dir = self.pathJoin(&amp;exe_list);</span>
<span class="line" id="L617">    self.h_dir = self.pathJoin(&amp;h_list);</span>
<span class="line" id="L618">}</span>
<span class="line" id="L619"></span>
<span class="line" id="L620"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOptions</span>(self: *Build) *Step.Options {</span>
<span class="line" id="L621">    <span class="tok-kw">return</span> Step.Options.create(self);</span>
<span class="line" id="L622">}</span>
<span class="line" id="L623"></span>
<span class="line" id="L624"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ExecutableOptions = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L625">    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L626">    root_source_file: ?LazyPath = <span class="tok-null">null</span>,</span>
<span class="line" id="L627">    version: ?std.SemanticVersion = <span class="tok-null">null</span>,</span>
<span class="line" id="L628">    target: CrossTarget = .{},</span>
<span class="line" id="L629">    optimize: std.builtin.OptimizeMode = .Debug,</span>
<span class="line" id="L630">    linkage: ?Step.Compile.Linkage = <span class="tok-null">null</span>,</span>
<span class="line" id="L631">    max_rss: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L632">    link_libc: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L633">    single_threaded: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L634">    use_llvm: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L635">    use_lld: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L636">    zig_lib_dir: ?LazyPath = <span class="tok-null">null</span>,</span>
<span class="line" id="L637">    main_mod_path: ?LazyPath = <span class="tok-null">null</span>,</span>
<span class="line" id="L638">    <span class="tok-comment">/// Embed a `.manifest` file in the compilation if the object format supports it.</span></span>
<span class="line" id="L639">    <span class="tok-comment">/// https://learn.microsoft.com/en-us/windows/win32/sbscs/manifest-files-reference</span></span>
<span class="line" id="L640">    <span class="tok-comment">/// Manifest files must have the extension `.manifest`.</span></span>
<span class="line" id="L641">    <span class="tok-comment">/// Can be set regardless of target. The `.manifest` file will be ignored</span></span>
<span class="line" id="L642">    <span class="tok-comment">/// if the target object format does not support embedded manifests.</span></span>
<span class="line" id="L643">    win32_manifest: ?LazyPath = <span class="tok-null">null</span>,</span>
<span class="line" id="L644"></span>
<span class="line" id="L645">    <span class="tok-comment">/// Deprecated; use `main_mod_path`.</span></span>
<span class="line" id="L646">    main_pkg_path: ?LazyPath = <span class="tok-null">null</span>,</span>
<span class="line" id="L647">};</span>
<span class="line" id="L648"></span>
<span class="line" id="L649"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addExecutable</span>(b: *Build, options: ExecutableOptions) *Step.Compile {</span>
<span class="line" id="L650">    <span class="tok-kw">return</span> Step.Compile.create(b, .{</span>
<span class="line" id="L651">        .name = options.name,</span>
<span class="line" id="L652">        .root_source_file = options.root_source_file,</span>
<span class="line" id="L653">        .version = options.version,</span>
<span class="line" id="L654">        .target = options.target,</span>
<span class="line" id="L655">        .optimize = options.optimize,</span>
<span class="line" id="L656">        .kind = .exe,</span>
<span class="line" id="L657">        .linkage = options.linkage,</span>
<span class="line" id="L658">        .max_rss = options.max_rss,</span>
<span class="line" id="L659">        .link_libc = options.link_libc,</span>
<span class="line" id="L660">        .single_threaded = options.single_threaded,</span>
<span class="line" id="L661">        .use_llvm = options.use_llvm,</span>
<span class="line" id="L662">        .use_lld = options.use_lld,</span>
<span class="line" id="L663">        .zig_lib_dir = options.zig_lib_dir <span class="tok-kw">orelse</span> b.zig_lib_dir,</span>
<span class="line" id="L664">        .main_mod_path = options.main_mod_path <span class="tok-kw">orelse</span> options.main_pkg_path,</span>
<span class="line" id="L665">        .win32_manifest = options.win32_manifest,</span>
<span class="line" id="L666">    });</span>
<span class="line" id="L667">}</span>
<span class="line" id="L668"></span>
<span class="line" id="L669"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ObjectOptions = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L670">    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L671">    root_source_file: ?LazyPath = <span class="tok-null">null</span>,</span>
<span class="line" id="L672">    target: CrossTarget,</span>
<span class="line" id="L673">    optimize: std.builtin.OptimizeMode,</span>
<span class="line" id="L674">    max_rss: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L675">    link_libc: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L676">    single_threaded: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L677">    use_llvm: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L678">    use_lld: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L679">    zig_lib_dir: ?LazyPath = <span class="tok-null">null</span>,</span>
<span class="line" id="L680">    main_mod_path: ?LazyPath = <span class="tok-null">null</span>,</span>
<span class="line" id="L681"></span>
<span class="line" id="L682">    <span class="tok-comment">/// Deprecated; use `main_mod_path`.</span></span>
<span class="line" id="L683">    main_pkg_path: ?LazyPath = <span class="tok-null">null</span>,</span>
<span class="line" id="L684">};</span>
<span class="line" id="L685"></span>
<span class="line" id="L686"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addObject</span>(b: *Build, options: ObjectOptions) *Step.Compile {</span>
<span class="line" id="L687">    <span class="tok-kw">return</span> Step.Compile.create(b, .{</span>
<span class="line" id="L688">        .name = options.name,</span>
<span class="line" id="L689">        .root_source_file = options.root_source_file,</span>
<span class="line" id="L690">        .target = options.target,</span>
<span class="line" id="L691">        .optimize = options.optimize,</span>
<span class="line" id="L692">        .kind = .obj,</span>
<span class="line" id="L693">        .max_rss = options.max_rss,</span>
<span class="line" id="L694">        .link_libc = options.link_libc,</span>
<span class="line" id="L695">        .single_threaded = options.single_threaded,</span>
<span class="line" id="L696">        .use_llvm = options.use_llvm,</span>
<span class="line" id="L697">        .use_lld = options.use_lld,</span>
<span class="line" id="L698">        .zig_lib_dir = options.zig_lib_dir <span class="tok-kw">orelse</span> b.zig_lib_dir,</span>
<span class="line" id="L699">        .main_mod_path = options.main_mod_path <span class="tok-kw">orelse</span> options.main_pkg_path,</span>
<span class="line" id="L700">    });</span>
<span class="line" id="L701">}</span>
<span class="line" id="L702"></span>
<span class="line" id="L703"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SharedLibraryOptions = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L704">    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L705">    root_source_file: ?LazyPath = <span class="tok-null">null</span>,</span>
<span class="line" id="L706">    version: ?std.SemanticVersion = <span class="tok-null">null</span>,</span>
<span class="line" id="L707">    target: CrossTarget,</span>
<span class="line" id="L708">    optimize: std.builtin.OptimizeMode,</span>
<span class="line" id="L709">    max_rss: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L710">    link_libc: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L711">    single_threaded: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L712">    use_llvm: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L713">    use_lld: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L714">    zig_lib_dir: ?LazyPath = <span class="tok-null">null</span>,</span>
<span class="line" id="L715">    main_mod_path: ?LazyPath = <span class="tok-null">null</span>,</span>
<span class="line" id="L716">    <span class="tok-comment">/// Embed a `.manifest` file in the compilation if the object format supports it.</span></span>
<span class="line" id="L717">    <span class="tok-comment">/// https://learn.microsoft.com/en-us/windows/win32/sbscs/manifest-files-reference</span></span>
<span class="line" id="L718">    <span class="tok-comment">/// Manifest files must have the extension `.manifest`.</span></span>
<span class="line" id="L719">    <span class="tok-comment">/// Can be set regardless of target. The `.manifest` file will be ignored</span></span>
<span class="line" id="L720">    <span class="tok-comment">/// if the target object format does not support embedded manifests.</span></span>
<span class="line" id="L721">    win32_manifest: ?LazyPath = <span class="tok-null">null</span>,</span>
<span class="line" id="L722"></span>
<span class="line" id="L723">    <span class="tok-comment">/// Deprecated; use `main_mod_path`.</span></span>
<span class="line" id="L724">    main_pkg_path: ?LazyPath = <span class="tok-null">null</span>,</span>
<span class="line" id="L725">};</span>
<span class="line" id="L726"></span>
<span class="line" id="L727"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSharedLibrary</span>(b: *Build, options: SharedLibraryOptions) *Step.Compile {</span>
<span class="line" id="L728">    <span class="tok-kw">return</span> Step.Compile.create(b, .{</span>
<span class="line" id="L729">        .name = options.name,</span>
<span class="line" id="L730">        .root_source_file = options.root_source_file,</span>
<span class="line" id="L731">        .kind = .lib,</span>
<span class="line" id="L732">        .linkage = .dynamic,</span>
<span class="line" id="L733">        .version = options.version,</span>
<span class="line" id="L734">        .target = options.target,</span>
<span class="line" id="L735">        .optimize = options.optimize,</span>
<span class="line" id="L736">        .max_rss = options.max_rss,</span>
<span class="line" id="L737">        .link_libc = options.link_libc,</span>
<span class="line" id="L738">        .single_threaded = options.single_threaded,</span>
<span class="line" id="L739">        .use_llvm = options.use_llvm,</span>
<span class="line" id="L740">        .use_lld = options.use_lld,</span>
<span class="line" id="L741">        .zig_lib_dir = options.zig_lib_dir <span class="tok-kw">orelse</span> b.zig_lib_dir,</span>
<span class="line" id="L742">        .main_mod_path = options.main_mod_path <span class="tok-kw">orelse</span> options.main_pkg_path,</span>
<span class="line" id="L743">        .win32_manifest = options.win32_manifest,</span>
<span class="line" id="L744">    });</span>
<span class="line" id="L745">}</span>
<span class="line" id="L746"></span>
<span class="line" id="L747"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> StaticLibraryOptions = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L748">    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L749">    root_source_file: ?LazyPath = <span class="tok-null">null</span>,</span>
<span class="line" id="L750">    target: CrossTarget,</span>
<span class="line" id="L751">    optimize: std.builtin.OptimizeMode,</span>
<span class="line" id="L752">    version: ?std.SemanticVersion = <span class="tok-null">null</span>,</span>
<span class="line" id="L753">    max_rss: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L754">    link_libc: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L755">    single_threaded: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L756">    use_llvm: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L757">    use_lld: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L758">    zig_lib_dir: ?LazyPath = <span class="tok-null">null</span>,</span>
<span class="line" id="L759">    main_mod_path: ?LazyPath = <span class="tok-null">null</span>,</span>
<span class="line" id="L760"></span>
<span class="line" id="L761">    <span class="tok-comment">/// Deprecated; use `main_mod_path`.</span></span>
<span class="line" id="L762">    main_pkg_path: ?LazyPath = <span class="tok-null">null</span>,</span>
<span class="line" id="L763">};</span>
<span class="line" id="L764"></span>
<span class="line" id="L765"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addStaticLibrary</span>(b: *Build, options: StaticLibraryOptions) *Step.Compile {</span>
<span class="line" id="L766">    <span class="tok-kw">return</span> Step.Compile.create(b, .{</span>
<span class="line" id="L767">        .name = options.name,</span>
<span class="line" id="L768">        .root_source_file = options.root_source_file,</span>
<span class="line" id="L769">        .kind = .lib,</span>
<span class="line" id="L770">        .linkage = .static,</span>
<span class="line" id="L771">        .version = options.version,</span>
<span class="line" id="L772">        .target = options.target,</span>
<span class="line" id="L773">        .optimize = options.optimize,</span>
<span class="line" id="L774">        .max_rss = options.max_rss,</span>
<span class="line" id="L775">        .link_libc = options.link_libc,</span>
<span class="line" id="L776">        .single_threaded = options.single_threaded,</span>
<span class="line" id="L777">        .use_llvm = options.use_llvm,</span>
<span class="line" id="L778">        .use_lld = options.use_lld,</span>
<span class="line" id="L779">        .zig_lib_dir = options.zig_lib_dir <span class="tok-kw">orelse</span> b.zig_lib_dir,</span>
<span class="line" id="L780">        .main_mod_path = options.main_mod_path <span class="tok-kw">orelse</span> options.main_pkg_path,</span>
<span class="line" id="L781">    });</span>
<span class="line" id="L782">}</span>
<span class="line" id="L783"></span>
<span class="line" id="L784"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> TestOptions = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L785">    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;test&quot;</span>,</span>
<span class="line" id="L786">    root_source_file: LazyPath,</span>
<span class="line" id="L787">    target: CrossTarget = .{},</span>
<span class="line" id="L788">    optimize: std.builtin.OptimizeMode = .Debug,</span>
<span class="line" id="L789">    version: ?std.SemanticVersion = <span class="tok-null">null</span>,</span>
<span class="line" id="L790">    max_rss: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L791">    filter: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L792">    test_runner: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L793">    link_libc: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L794">    single_threaded: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L795">    use_llvm: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L796">    use_lld: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L797">    zig_lib_dir: ?LazyPath = <span class="tok-null">null</span>,</span>
<span class="line" id="L798">    main_mod_path: ?LazyPath = <span class="tok-null">null</span>,</span>
<span class="line" id="L799"></span>
<span class="line" id="L800">    <span class="tok-comment">/// Deprecated; use `main_mod_path`.</span></span>
<span class="line" id="L801">    main_pkg_path: ?LazyPath = <span class="tok-null">null</span>,</span>
<span class="line" id="L802">};</span>
<span class="line" id="L803"></span>
<span class="line" id="L804"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addTest</span>(b: *Build, options: TestOptions) *Step.Compile {</span>
<span class="line" id="L805">    <span class="tok-kw">return</span> Step.Compile.create(b, .{</span>
<span class="line" id="L806">        .name = options.name,</span>
<span class="line" id="L807">        .kind = .@&quot;test&quot;,</span>
<span class="line" id="L808">        .root_source_file = options.root_source_file,</span>
<span class="line" id="L809">        .target = options.target,</span>
<span class="line" id="L810">        .optimize = options.optimize,</span>
<span class="line" id="L811">        .max_rss = options.max_rss,</span>
<span class="line" id="L812">        .filter = options.filter,</span>
<span class="line" id="L813">        .test_runner = options.test_runner,</span>
<span class="line" id="L814">        .link_libc = options.link_libc,</span>
<span class="line" id="L815">        .single_threaded = options.single_threaded,</span>
<span class="line" id="L816">        .use_llvm = options.use_llvm,</span>
<span class="line" id="L817">        .use_lld = options.use_lld,</span>
<span class="line" id="L818">        .zig_lib_dir = options.zig_lib_dir <span class="tok-kw">orelse</span> b.zig_lib_dir,</span>
<span class="line" id="L819">        .main_mod_path = options.main_mod_path <span class="tok-kw">orelse</span> options.main_pkg_path,</span>
<span class="line" id="L820">    });</span>
<span class="line" id="L821">}</span>
<span class="line" id="L822"></span>
<span class="line" id="L823"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> AssemblyOptions = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L824">    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L825">    source_file: LazyPath,</span>
<span class="line" id="L826">    target: CrossTarget,</span>
<span class="line" id="L827">    optimize: std.builtin.OptimizeMode,</span>
<span class="line" id="L828">    max_rss: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L829">    zig_lib_dir: ?LazyPath = <span class="tok-null">null</span>,</span>
<span class="line" id="L830">};</span>
<span class="line" id="L831"></span>
<span class="line" id="L832"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addAssembly</span>(b: *Build, options: AssemblyOptions) *Step.Compile {</span>
<span class="line" id="L833">    <span class="tok-kw">const</span> obj_step = Step.Compile.create(b, .{</span>
<span class="line" id="L834">        .name = options.name,</span>
<span class="line" id="L835">        .kind = .obj,</span>
<span class="line" id="L836">        .root_source_file = <span class="tok-null">null</span>,</span>
<span class="line" id="L837">        .target = options.target,</span>
<span class="line" id="L838">        .optimize = options.optimize,</span>
<span class="line" id="L839">        .max_rss = options.max_rss,</span>
<span class="line" id="L840">        .zig_lib_dir = options.zig_lib_dir <span class="tok-kw">orelse</span> b.zig_lib_dir,</span>
<span class="line" id="L841">    });</span>
<span class="line" id="L842">    obj_step.addAssemblyFile(options.source_file);</span>
<span class="line" id="L843">    <span class="tok-kw">return</span> obj_step;</span>
<span class="line" id="L844">}</span>
<span class="line" id="L845"></span>
<span class="line" id="L846"><span class="tok-comment">/// This function creates a module and adds it to the package's module set, making</span></span>
<span class="line" id="L847"><span class="tok-comment">/// it available to other packages which depend on this one.</span></span>
<span class="line" id="L848"><span class="tok-comment">/// `createModule` can be used instead to create a private module.</span></span>
<span class="line" id="L849"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addModule</span>(b: *Build, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, options: CreateModuleOptions) *Module {</span>
<span class="line" id="L850">    <span class="tok-kw">const</span> module = b.createModule(options);</span>
<span class="line" id="L851">    b.modules.put(b.dupe(name), module) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L852">    <span class="tok-kw">return</span> module;</span>
<span class="line" id="L853">}</span>
<span class="line" id="L854"></span>
<span class="line" id="L855"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ModuleDependency = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L856">    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L857">    module: *Module,</span>
<span class="line" id="L858">};</span>
<span class="line" id="L859"></span>
<span class="line" id="L860"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CreateModuleOptions = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L861">    source_file: LazyPath,</span>
<span class="line" id="L862">    dependencies: []<span class="tok-kw">const</span> ModuleDependency = &amp;.{},</span>
<span class="line" id="L863">};</span>
<span class="line" id="L864"></span>
<span class="line" id="L865"><span class="tok-comment">/// This function creates a private module, to be used by the current package,</span></span>
<span class="line" id="L866"><span class="tok-comment">/// but not exposed to other packages depending on this one.</span></span>
<span class="line" id="L867"><span class="tok-comment">/// `addModule` can be used instead to create a public module.</span></span>
<span class="line" id="L868"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createModule</span>(b: *Build, options: CreateModuleOptions) *Module {</span>
<span class="line" id="L869">    <span class="tok-kw">const</span> module = b.allocator.create(Module) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L870">    module.* = .{</span>
<span class="line" id="L871">        .builder = b,</span>
<span class="line" id="L872">        .source_file = options.source_file,</span>
<span class="line" id="L873">        .dependencies = moduleDependenciesToArrayHashMap(b.allocator, options.dependencies),</span>
<span class="line" id="L874">    };</span>
<span class="line" id="L875">    <span class="tok-kw">return</span> module;</span>
<span class="line" id="L876">}</span>
<span class="line" id="L877"></span>
<span class="line" id="L878"><span class="tok-kw">fn</span> <span class="tok-fn">moduleDependenciesToArrayHashMap</span>(arena: Allocator, deps: []<span class="tok-kw">const</span> ModuleDependency) std.StringArrayHashMap(*Module) {</span>
<span class="line" id="L879">    <span class="tok-kw">var</span> result = std.StringArrayHashMap(*Module).init(arena);</span>
<span class="line" id="L880">    <span class="tok-kw">for</span> (deps) |dep| {</span>
<span class="line" id="L881">        result.put(dep.name, dep.module) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L882">    }</span>
<span class="line" id="L883">    <span class="tok-kw">return</span> result;</span>
<span class="line" id="L884">}</span>
<span class="line" id="L885"></span>
<span class="line" id="L886"><span class="tok-comment">/// Initializes a `Step.Run` with argv, which must at least have the path to the</span></span>
<span class="line" id="L887"><span class="tok-comment">/// executable. More command line arguments can be added with `addArg`,</span></span>
<span class="line" id="L888"><span class="tok-comment">/// `addArgs`, and `addArtifactArg`.</span></span>
<span class="line" id="L889"><span class="tok-comment">/// Be careful using this function, as it introduces a system dependency.</span></span>
<span class="line" id="L890"><span class="tok-comment">/// To run an executable built with zig build, see `Step.Compile.run`.</span></span>
<span class="line" id="L891"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSystemCommand</span>(self: *Build, argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *Step.Run {</span>
<span class="line" id="L892">    assert(argv.len &gt;= <span class="tok-number">1</span>);</span>
<span class="line" id="L893">    <span class="tok-kw">const</span> run_step = Step.Run.create(self, self.fmt(<span class="tok-str">&quot;run {s}&quot;</span>, .{argv[<span class="tok-number">0</span>]}));</span>
<span class="line" id="L894">    run_step.addArgs(argv);</span>
<span class="line" id="L895">    <span class="tok-kw">return</span> run_step;</span>
<span class="line" id="L896">}</span>
<span class="line" id="L897"></span>
<span class="line" id="L898"><span class="tok-comment">/// Creates a `Step.Run` with an executable built with `addExecutable`.</span></span>
<span class="line" id="L899"><span class="tok-comment">/// Add command line arguments with methods of `Step.Run`.</span></span>
<span class="line" id="L900"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addRunArtifact</span>(b: *Build, exe: *Step.Compile) *Step.Run {</span>
<span class="line" id="L901">    <span class="tok-comment">// It doesn't have to be native. We catch that if you actually try to run it.</span>
</span>
<span class="line" id="L902">    <span class="tok-comment">// Consider that this is declarative; the run step may not be run unless a user</span>
</span>
<span class="line" id="L903">    <span class="tok-comment">// option is supplied.</span>
</span>
<span class="line" id="L904">    <span class="tok-kw">const</span> run_step = Step.Run.create(b, b.fmt(<span class="tok-str">&quot;run {s}&quot;</span>, .{exe.name}));</span>
<span class="line" id="L905">    run_step.addArtifactArg(exe);</span>
<span class="line" id="L906"></span>
<span class="line" id="L907">    <span class="tok-kw">if</span> (exe.kind == .@&quot;test&quot; <span class="tok-kw">and</span> exe.test_server_mode) {</span>
<span class="line" id="L908">        run_step.enableTestRunnerMode();</span>
<span class="line" id="L909">    }</span>
<span class="line" id="L910"></span>
<span class="line" id="L911">    <span class="tok-kw">if</span> (exe.vcpkg_bin_path) |path| {</span>
<span class="line" id="L912">        run_step.addPathDir(path);</span>
<span class="line" id="L913">    }</span>
<span class="line" id="L914"></span>
<span class="line" id="L915">    <span class="tok-kw">return</span> run_step;</span>
<span class="line" id="L916">}</span>
<span class="line" id="L917"></span>
<span class="line" id="L918"><span class="tok-comment">/// Using the `values` provided, produces a C header file, possibly based on a</span></span>
<span class="line" id="L919"><span class="tok-comment">/// template input file (e.g. config.h.in).</span></span>
<span class="line" id="L920"><span class="tok-comment">/// When an input template file is provided, this function will fail the build</span></span>
<span class="line" id="L921"><span class="tok-comment">/// when an option not found in the input file is provided in `values`, and</span></span>
<span class="line" id="L922"><span class="tok-comment">/// when an option found in the input file is missing from `values`.</span></span>
<span class="line" id="L923"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addConfigHeader</span>(</span>
<span class="line" id="L924">    b: *Build,</span>
<span class="line" id="L925">    options: Step.ConfigHeader.Options,</span>
<span class="line" id="L926">    values: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L927">) *Step.ConfigHeader {</span>
<span class="line" id="L928">    <span class="tok-kw">var</span> options_copy = options;</span>
<span class="line" id="L929">    <span class="tok-kw">if</span> (options_copy.first_ret_addr == <span class="tok-null">null</span>)</span>
<span class="line" id="L930">        options_copy.first_ret_addr = <span class="tok-builtin">@returnAddress</span>();</span>
<span class="line" id="L931"></span>
<span class="line" id="L932">    <span class="tok-kw">const</span> config_header_step = Step.ConfigHeader.create(b, options_copy);</span>
<span class="line" id="L933">    config_header_step.addValues(values);</span>
<span class="line" id="L934">    <span class="tok-kw">return</span> config_header_step;</span>
<span class="line" id="L935">}</span>
<span class="line" id="L936"></span>
<span class="line" id="L937"><span class="tok-comment">/// Allocator.dupe without the need to handle out of memory.</span></span>
<span class="line" id="L938"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupe</span>(self: *Build, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-type">u8</span> {</span>
<span class="line" id="L939">    <span class="tok-kw">return</span> self.allocator.dupe(<span class="tok-type">u8</span>, bytes) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L940">}</span>
<span class="line" id="L941"></span>
<span class="line" id="L942"><span class="tok-comment">/// Duplicates an array of strings without the need to handle out of memory.</span></span>
<span class="line" id="L943"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupeStrings</span>(self: *Build, strings: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) [][]<span class="tok-type">u8</span> {</span>
<span class="line" id="L944">    <span class="tok-kw">const</span> array = self.allocator.alloc([]<span class="tok-type">u8</span>, strings.len) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L945">    <span class="tok-kw">for</span> (strings, <span class="tok-number">0</span>..) |s, i| {</span>
<span class="line" id="L946">        array[i] = self.dupe(s);</span>
<span class="line" id="L947">    }</span>
<span class="line" id="L948">    <span class="tok-kw">return</span> array;</span>
<span class="line" id="L949">}</span>
<span class="line" id="L950"></span>
<span class="line" id="L951"><span class="tok-comment">/// Duplicates a path and converts all slashes to the OS's canonical path separator.</span></span>
<span class="line" id="L952"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupePath</span>(self: *Build, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-type">u8</span> {</span>
<span class="line" id="L953">    <span class="tok-kw">const</span> the_copy = self.dupe(bytes);</span>
<span class="line" id="L954">    <span class="tok-kw">for</span> (the_copy) |*byte| {</span>
<span class="line" id="L955">        <span class="tok-kw">switch</span> (byte.*) {</span>
<span class="line" id="L956">            <span class="tok-str">'/'</span>, <span class="tok-str">'\\'</span> =&gt; byte.* = fs.path.sep,</span>
<span class="line" id="L957">            <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L958">        }</span>
<span class="line" id="L959">    }</span>
<span class="line" id="L960">    <span class="tok-kw">return</span> the_copy;</span>
<span class="line" id="L961">}</span>
<span class="line" id="L962"></span>
<span class="line" id="L963"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addWriteFile</span>(self: *Build, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *Step.WriteFile {</span>
<span class="line" id="L964">    <span class="tok-kw">const</span> write_file_step = self.addWriteFiles();</span>
<span class="line" id="L965">    _ = write_file_step.add(file_path, data);</span>
<span class="line" id="L966">    <span class="tok-kw">return</span> write_file_step;</span>
<span class="line" id="L967">}</span>
<span class="line" id="L968"></span>
<span class="line" id="L969"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addWriteFiles</span>(b: *Build) *Step.WriteFile {</span>
<span class="line" id="L970">    <span class="tok-kw">return</span> Step.WriteFile.create(b);</span>
<span class="line" id="L971">}</span>
<span class="line" id="L972"></span>
<span class="line" id="L973"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addRemoveDirTree</span>(self: *Build, dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *Step.RemoveDir {</span>
<span class="line" id="L974">    <span class="tok-kw">return</span> Step.RemoveDir.create(self, dir_path);</span>
<span class="line" id="L975">}</span>
<span class="line" id="L976"></span>
<span class="line" id="L977"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFmt</span>(b: *Build, options: Step.Fmt.Options) *Step.Fmt {</span>
<span class="line" id="L978">    <span class="tok-kw">return</span> Step.Fmt.create(b, options);</span>
<span class="line" id="L979">}</span>
<span class="line" id="L980"></span>
<span class="line" id="L981"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addTranslateC</span>(self: *Build, options: Step.TranslateC.Options) *Step.TranslateC {</span>
<span class="line" id="L982">    <span class="tok-kw">return</span> Step.TranslateC.create(self, options);</span>
<span class="line" id="L983">}</span>
<span class="line" id="L984"></span>
<span class="line" id="L985"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getInstallStep</span>(self: *Build) *Step {</span>
<span class="line" id="L986">    <span class="tok-kw">return</span> &amp;self.install_tls.step;</span>
<span class="line" id="L987">}</span>
<span class="line" id="L988"></span>
<span class="line" id="L989"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getUninstallStep</span>(self: *Build) *Step {</span>
<span class="line" id="L990">    <span class="tok-kw">return</span> &amp;self.uninstall_tls.step;</span>
<span class="line" id="L991">}</span>
<span class="line" id="L992"></span>
<span class="line" id="L993"><span class="tok-kw">fn</span> <span class="tok-fn">makeUninstall</span>(uninstall_step: *Step, prog_node: *std.Progress.Node) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {</span>
<span class="line" id="L994">    _ = prog_node;</span>
<span class="line" id="L995">    <span class="tok-kw">const</span> uninstall_tls = <span class="tok-builtin">@fieldParentPtr</span>(TopLevelStep, <span class="tok-str">&quot;step&quot;</span>, uninstall_step);</span>
<span class="line" id="L996">    <span class="tok-kw">const</span> self = <span class="tok-builtin">@fieldParentPtr</span>(Build, <span class="tok-str">&quot;uninstall_tls&quot;</span>, uninstall_tls);</span>
<span class="line" id="L997"></span>
<span class="line" id="L998">    <span class="tok-kw">for</span> (self.installed_files.items) |installed_file| {</span>
<span class="line" id="L999">        <span class="tok-kw">const</span> full_path = self.getInstallPath(installed_file.dir, installed_file.path);</span>
<span class="line" id="L1000">        <span class="tok-kw">if</span> (self.verbose) {</span>
<span class="line" id="L1001">            log.info(<span class="tok-str">&quot;rm {s}&quot;</span>, .{full_path});</span>
<span class="line" id="L1002">        }</span>
<span class="line" id="L1003">        fs.cwd().deleteTree(full_path) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L1004">    }</span>
<span class="line" id="L1005"></span>
<span class="line" id="L1006">    <span class="tok-comment">// TODO remove empty directories</span>
</span>
<span class="line" id="L1007">}</span>
<span class="line" id="L1008"></span>
<span class="line" id="L1009"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">option</span>(self: *Build, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, name_raw: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, description_raw: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?T {</span>
<span class="line" id="L1010">    <span class="tok-kw">const</span> name = self.dupe(name_raw);</span>
<span class="line" id="L1011">    <span class="tok-kw">const</span> description = self.dupe(description_raw);</span>
<span class="line" id="L1012">    <span class="tok-kw">const</span> type_id = <span class="tok-kw">comptime</span> typeToEnum(T);</span>
<span class="line" id="L1013">    <span class="tok-kw">const</span> enum_options = <span class="tok-kw">if</span> (type_id == .@&quot;enum&quot;) blk: {</span>
<span class="line" id="L1014">        <span class="tok-kw">const</span> fields = <span class="tok-kw">comptime</span> std.meta.fields(T);</span>
<span class="line" id="L1015">        <span class="tok-kw">var</span> options = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).initCapacity(self.allocator, fields.len) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1016"></span>
<span class="line" id="L1017">        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (fields) |field| {</span>
<span class="line" id="L1018">            options.appendAssumeCapacity(field.name);</span>
<span class="line" id="L1019">        }</span>
<span class="line" id="L1020"></span>
<span class="line" id="L1021">        <span class="tok-kw">break</span> :blk options.toOwnedSlice() <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1022">    } <span class="tok-kw">else</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1023">    <span class="tok-kw">const</span> available_option = AvailableOption{</span>
<span class="line" id="L1024">        .name = name,</span>
<span class="line" id="L1025">        .type_id = type_id,</span>
<span class="line" id="L1026">        .description = description,</span>
<span class="line" id="L1027">        .enum_options = enum_options,</span>
<span class="line" id="L1028">    };</span>
<span class="line" id="L1029">    <span class="tok-kw">if</span> ((self.available_options_map.fetchPut(name, available_option) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>)) != <span class="tok-null">null</span>) {</span>
<span class="line" id="L1030">        panic(<span class="tok-str">&quot;Option '{s}' declared twice&quot;</span>, .{name});</span>
<span class="line" id="L1031">    }</span>
<span class="line" id="L1032">    self.available_options_list.append(available_option) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1033"></span>
<span class="line" id="L1034">    <span class="tok-kw">const</span> option_ptr = self.user_input_options.getPtr(name) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1035">    option_ptr.used = <span class="tok-null">true</span>;</span>
<span class="line" id="L1036">    <span class="tok-kw">switch</span> (type_id) {</span>
<span class="line" id="L1037">        .<span class="tok-type">bool</span> =&gt; <span class="tok-kw">switch</span> (option_ptr.value) {</span>
<span class="line" id="L1038">            .flag =&gt; <span class="tok-kw">return</span> <span class="tok-null">true</span>,</span>
<span class="line" id="L1039">            .scalar =&gt; |s| {</span>
<span class="line" id="L1040">                <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, s, <span class="tok-str">&quot;true&quot;</span>)) {</span>
<span class="line" id="L1041">                    <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L1042">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, s, <span class="tok-str">&quot;false&quot;</span>)) {</span>
<span class="line" id="L1043">                    <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L1044">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1045">                    log.err(<span class="tok-str">&quot;Expected -D{s} to be a boolean, but received '{s}'&quot;</span>, .{ name, s });</span>
<span class="line" id="L1046">                    self.markInvalidUserInput();</span>
<span class="line" id="L1047">                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1048">                }</span>
<span class="line" id="L1049">            },</span>
<span class="line" id="L1050">            .list, .map =&gt; {</span>
<span class="line" id="L1051">                log.err(<span class="tok-str">&quot;Expected -D{s} to be a boolean, but received a {s}.&quot;</span>, .{</span>
<span class="line" id="L1052">                    name, <span class="tok-builtin">@tagName</span>(option_ptr.value),</span>
<span class="line" id="L1053">                });</span>
<span class="line" id="L1054">                self.markInvalidUserInput();</span>
<span class="line" id="L1055">                <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1056">            },</span>
<span class="line" id="L1057">        },</span>
<span class="line" id="L1058">        .int =&gt; <span class="tok-kw">switch</span> (option_ptr.value) {</span>
<span class="line" id="L1059">            .flag, .list, .map =&gt; {</span>
<span class="line" id="L1060">                log.err(<span class="tok-str">&quot;Expected -D{s} to be an integer, but received a {s}.&quot;</span>, .{</span>
<span class="line" id="L1061">                    name, <span class="tok-builtin">@tagName</span>(option_ptr.value),</span>
<span class="line" id="L1062">                });</span>
<span class="line" id="L1063">                self.markInvalidUserInput();</span>
<span class="line" id="L1064">                <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1065">            },</span>
<span class="line" id="L1066">            .scalar =&gt; |s| {</span>
<span class="line" id="L1067">                <span class="tok-kw">const</span> n = std.fmt.parseInt(T, s, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1068">                    <span class="tok-kw">error</span>.Overflow =&gt; {</span>
<span class="line" id="L1069">                        log.err(<span class="tok-str">&quot;-D{s} value {s} cannot fit into type {s}.&quot;</span>, .{ name, s, <span class="tok-builtin">@typeName</span>(T) });</span>
<span class="line" id="L1070">                        self.markInvalidUserInput();</span>
<span class="line" id="L1071">                        <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1072">                    },</span>
<span class="line" id="L1073">                    <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L1074">                        log.err(<span class="tok-str">&quot;Expected -D{s} to be an integer of type {s}.&quot;</span>, .{ name, <span class="tok-builtin">@typeName</span>(T) });</span>
<span class="line" id="L1075">                        self.markInvalidUserInput();</span>
<span class="line" id="L1076">                        <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1077">                    },</span>
<span class="line" id="L1078">                };</span>
<span class="line" id="L1079">                <span class="tok-kw">return</span> n;</span>
<span class="line" id="L1080">            },</span>
<span class="line" id="L1081">        },</span>
<span class="line" id="L1082">        .float =&gt; <span class="tok-kw">switch</span> (option_ptr.value) {</span>
<span class="line" id="L1083">            .flag, .map, .list =&gt; {</span>
<span class="line" id="L1084">                log.err(<span class="tok-str">&quot;Expected -D{s} to be a float, but received a {s}.&quot;</span>, .{</span>
<span class="line" id="L1085">                    name, <span class="tok-builtin">@tagName</span>(option_ptr.value),</span>
<span class="line" id="L1086">                });</span>
<span class="line" id="L1087">                self.markInvalidUserInput();</span>
<span class="line" id="L1088">                <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1089">            },</span>
<span class="line" id="L1090">            .scalar =&gt; |s| {</span>
<span class="line" id="L1091">                <span class="tok-kw">const</span> n = std.fmt.parseFloat(T, s) <span class="tok-kw">catch</span> {</span>
<span class="line" id="L1092">                    log.err(<span class="tok-str">&quot;Expected -D{s} to be a float of type {s}.&quot;</span>, .{ name, <span class="tok-builtin">@typeName</span>(T) });</span>
<span class="line" id="L1093">                    self.markInvalidUserInput();</span>
<span class="line" id="L1094">                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1095">                };</span>
<span class="line" id="L1096">                <span class="tok-kw">return</span> n;</span>
<span class="line" id="L1097">            },</span>
<span class="line" id="L1098">        },</span>
<span class="line" id="L1099">        .@&quot;enum&quot; =&gt; <span class="tok-kw">switch</span> (option_ptr.value) {</span>
<span class="line" id="L1100">            .flag, .map, .list =&gt; {</span>
<span class="line" id="L1101">                log.err(<span class="tok-str">&quot;Expected -D{s} to be an enum, but received a {s}.&quot;</span>, .{</span>
<span class="line" id="L1102">                    name, <span class="tok-builtin">@tagName</span>(option_ptr.value),</span>
<span class="line" id="L1103">                });</span>
<span class="line" id="L1104">                self.markInvalidUserInput();</span>
<span class="line" id="L1105">                <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1106">            },</span>
<span class="line" id="L1107">            .scalar =&gt; |s| {</span>
<span class="line" id="L1108">                <span class="tok-kw">if</span> (std.meta.stringToEnum(T, s)) |enum_lit| {</span>
<span class="line" id="L1109">                    <span class="tok-kw">return</span> enum_lit;</span>
<span class="line" id="L1110">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1111">                    log.err(<span class="tok-str">&quot;Expected -D{s} to be of type {s}.&quot;</span>, .{ name, <span class="tok-builtin">@typeName</span>(T) });</span>
<span class="line" id="L1112">                    self.markInvalidUserInput();</span>
<span class="line" id="L1113">                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1114">                }</span>
<span class="line" id="L1115">            },</span>
<span class="line" id="L1116">        },</span>
<span class="line" id="L1117">        .string =&gt; <span class="tok-kw">switch</span> (option_ptr.value) {</span>
<span class="line" id="L1118">            .flag, .list, .map =&gt; {</span>
<span class="line" id="L1119">                log.err(<span class="tok-str">&quot;Expected -D{s} to be a string, but received a {s}.&quot;</span>, .{</span>
<span class="line" id="L1120">                    name, <span class="tok-builtin">@tagName</span>(option_ptr.value),</span>
<span class="line" id="L1121">                });</span>
<span class="line" id="L1122">                self.markInvalidUserInput();</span>
<span class="line" id="L1123">                <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1124">            },</span>
<span class="line" id="L1125">            .scalar =&gt; |s| <span class="tok-kw">return</span> s,</span>
<span class="line" id="L1126">        },</span>
<span class="line" id="L1127">        .build_id =&gt; <span class="tok-kw">switch</span> (option_ptr.value) {</span>
<span class="line" id="L1128">            .flag, .map, .list =&gt; {</span>
<span class="line" id="L1129">                log.err(<span class="tok-str">&quot;Expected -D{s} to be an enum, but received a {s}.&quot;</span>, .{</span>
<span class="line" id="L1130">                    name, <span class="tok-builtin">@tagName</span>(option_ptr.value),</span>
<span class="line" id="L1131">                });</span>
<span class="line" id="L1132">                self.markInvalidUserInput();</span>
<span class="line" id="L1133">                <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1134">            },</span>
<span class="line" id="L1135">            .scalar =&gt; |s| {</span>
<span class="line" id="L1136">                <span class="tok-kw">if</span> (Step.Compile.BuildId.parse(s)) |build_id| {</span>
<span class="line" id="L1137">                    <span class="tok-kw">return</span> build_id;</span>
<span class="line" id="L1138">                } <span class="tok-kw">else</span> |err| {</span>
<span class="line" id="L1139">                    log.err(<span class="tok-str">&quot;unable to parse option '-D{s}': {s}&quot;</span>, .{ name, <span class="tok-builtin">@errorName</span>(err) });</span>
<span class="line" id="L1140">                    self.markInvalidUserInput();</span>
<span class="line" id="L1141">                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1142">                }</span>
<span class="line" id="L1143">            },</span>
<span class="line" id="L1144">        },</span>
<span class="line" id="L1145">        .list =&gt; <span class="tok-kw">switch</span> (option_ptr.value) {</span>
<span class="line" id="L1146">            .flag, .map =&gt; {</span>
<span class="line" id="L1147">                log.err(<span class="tok-str">&quot;Expected -D{s} to be a list, but received a {s}.&quot;</span>, .{</span>
<span class="line" id="L1148">                    name, <span class="tok-builtin">@tagName</span>(option_ptr.value),</span>
<span class="line" id="L1149">                });</span>
<span class="line" id="L1150">                self.markInvalidUserInput();</span>
<span class="line" id="L1151">                <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1152">            },</span>
<span class="line" id="L1153">            .scalar =&gt; |s| {</span>
<span class="line" id="L1154">                <span class="tok-kw">return</span> self.allocator.dupe([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{s}) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1155">            },</span>
<span class="line" id="L1156">            .list =&gt; |lst| <span class="tok-kw">return</span> lst.items,</span>
<span class="line" id="L1157">        },</span>
<span class="line" id="L1158">    }</span>
<span class="line" id="L1159">}</span>
<span class="line" id="L1160"></span>
<span class="line" id="L1161"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">step</span>(self: *Build, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, description: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *Step {</span>
<span class="line" id="L1162">    <span class="tok-kw">const</span> step_info = self.allocator.create(TopLevelStep) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1163">    step_info.* = .{</span>
<span class="line" id="L1164">        .step = Step.init(.{</span>
<span class="line" id="L1165">            .id = .top_level,</span>
<span class="line" id="L1166">            .name = name,</span>
<span class="line" id="L1167">            .owner = self,</span>
<span class="line" id="L1168">        }),</span>
<span class="line" id="L1169">        .description = self.dupe(description),</span>
<span class="line" id="L1170">    };</span>
<span class="line" id="L1171">    <span class="tok-kw">const</span> gop = self.top_level_steps.getOrPut(self.allocator, name) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1172">    <span class="tok-kw">if</span> (gop.found_existing) std.debug.panic(<span class="tok-str">&quot;A top-level step with name \&quot;{s}\&quot; already exists&quot;</span>, .{name});</span>
<span class="line" id="L1173"></span>
<span class="line" id="L1174">    gop.key_ptr.* = step_info.step.name;</span>
<span class="line" id="L1175">    gop.value_ptr.* = step_info;</span>
<span class="line" id="L1176"></span>
<span class="line" id="L1177">    <span class="tok-kw">return</span> &amp;step_info.step;</span>
<span class="line" id="L1178">}</span>
<span class="line" id="L1179"></span>
<span class="line" id="L1180"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> StandardOptimizeOptionOptions = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1181">    preferred_optimize_mode: ?std.builtin.OptimizeMode = <span class="tok-null">null</span>,</span>
<span class="line" id="L1182">};</span>
<span class="line" id="L1183"></span>
<span class="line" id="L1184"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">standardOptimizeOption</span>(self: *Build, options: StandardOptimizeOptionOptions) std.builtin.OptimizeMode {</span>
<span class="line" id="L1185">    <span class="tok-kw">if</span> (options.preferred_optimize_mode) |mode| {</span>
<span class="line" id="L1186">        <span class="tok-kw">if</span> (self.option(<span class="tok-type">bool</span>, <span class="tok-str">&quot;release&quot;</span>, <span class="tok-str">&quot;optimize for end users&quot;</span>) <span class="tok-kw">orelse</span> <span class="tok-null">false</span>) {</span>
<span class="line" id="L1187">            <span class="tok-kw">return</span> mode;</span>
<span class="line" id="L1188">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1189">            <span class="tok-kw">return</span> .Debug;</span>
<span class="line" id="L1190">        }</span>
<span class="line" id="L1191">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1192">        <span class="tok-kw">return</span> self.option(</span>
<span class="line" id="L1193">            std.builtin.OptimizeMode,</span>
<span class="line" id="L1194">            <span class="tok-str">&quot;optimize&quot;</span>,</span>
<span class="line" id="L1195">            <span class="tok-str">&quot;Prioritize performance, safety, or binary size (-O flag)&quot;</span>,</span>
<span class="line" id="L1196">        ) <span class="tok-kw">orelse</span> .Debug;</span>
<span class="line" id="L1197">    }</span>
<span class="line" id="L1198">}</span>
<span class="line" id="L1199"></span>
<span class="line" id="L1200"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> StandardTargetOptionsArgs = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1201">    whitelist: ?[]<span class="tok-kw">const</span> CrossTarget = <span class="tok-null">null</span>,</span>
<span class="line" id="L1202"></span>
<span class="line" id="L1203">    default_target: CrossTarget = CrossTarget{},</span>
<span class="line" id="L1204">};</span>
<span class="line" id="L1205"></span>
<span class="line" id="L1206"><span class="tok-comment">/// Exposes standard `zig build` options for choosing a target.</span></span>
<span class="line" id="L1207"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">standardTargetOptions</span>(self: *Build, args: StandardTargetOptionsArgs) CrossTarget {</span>
<span class="line" id="L1208">    <span class="tok-kw">const</span> maybe_triple = self.option(</span>
<span class="line" id="L1209">        []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1210">        <span class="tok-str">&quot;target&quot;</span>,</span>
<span class="line" id="L1211">        <span class="tok-str">&quot;The CPU architecture, OS, and ABI to build for&quot;</span>,</span>
<span class="line" id="L1212">    );</span>
<span class="line" id="L1213">    <span class="tok-kw">const</span> mcpu = self.option([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-str">&quot;cpu&quot;</span>, <span class="tok-str">&quot;Target CPU features to add or subtract&quot;</span>);</span>
<span class="line" id="L1214"></span>
<span class="line" id="L1215">    <span class="tok-kw">if</span> (maybe_triple == <span class="tok-null">null</span> <span class="tok-kw">and</span> mcpu == <span class="tok-null">null</span>) {</span>
<span class="line" id="L1216">        <span class="tok-kw">return</span> args.default_target;</span>
<span class="line" id="L1217">    }</span>
<span class="line" id="L1218"></span>
<span class="line" id="L1219">    <span class="tok-kw">const</span> triple = maybe_triple <span class="tok-kw">orelse</span> <span class="tok-str">&quot;native&quot;</span>;</span>
<span class="line" id="L1220"></span>
<span class="line" id="L1221">    <span class="tok-kw">var</span> diags: CrossTarget.ParseOptions.Diagnostics = .{};</span>
<span class="line" id="L1222">    <span class="tok-kw">const</span> selected_target = CrossTarget.parse(.{</span>
<span class="line" id="L1223">        .arch_os_abi = triple,</span>
<span class="line" id="L1224">        .cpu_features = mcpu,</span>
<span class="line" id="L1225">        .diagnostics = &amp;diags,</span>
<span class="line" id="L1226">    }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1227">        <span class="tok-kw">error</span>.UnknownCpuModel =&gt; {</span>
<span class="line" id="L1228">            log.err(<span class="tok-str">&quot;Unknown CPU: '{s}'\nAvailable CPUs for architecture '{s}':&quot;</span>, .{</span>
<span class="line" id="L1229">                diags.cpu_name.?,</span>
<span class="line" id="L1230">                <span class="tok-builtin">@tagName</span>(diags.arch.?),</span>
<span class="line" id="L1231">            });</span>
<span class="line" id="L1232">            <span class="tok-kw">for</span> (diags.arch.?.allCpuModels()) |cpu| {</span>
<span class="line" id="L1233">                log.err(<span class="tok-str">&quot; {s}&quot;</span>, .{cpu.name});</span>
<span class="line" id="L1234">            }</span>
<span class="line" id="L1235">            self.markInvalidUserInput();</span>
<span class="line" id="L1236">            <span class="tok-kw">return</span> args.default_target;</span>
<span class="line" id="L1237">        },</span>
<span class="line" id="L1238">        <span class="tok-kw">error</span>.UnknownCpuFeature =&gt; {</span>
<span class="line" id="L1239">            log.err(</span>
<span class="line" id="L1240">                <span class="tok-str">\\Unknown CPU feature: '{s}'</span></span>

<span class="line" id="L1241">                <span class="tok-str">\\Available CPU features for architecture '{s}':</span></span>

<span class="line" id="L1242">                <span class="tok-str">\\</span></span>

<span class="line" id="L1243">            , .{</span>
<span class="line" id="L1244">                diags.unknown_feature_name.?,</span>
<span class="line" id="L1245">                <span class="tok-builtin">@tagName</span>(diags.arch.?),</span>
<span class="line" id="L1246">            });</span>
<span class="line" id="L1247">            <span class="tok-kw">for</span> (diags.arch.?.allFeaturesList()) |feature| {</span>
<span class="line" id="L1248">                log.err(<span class="tok-str">&quot; {s}: {s}&quot;</span>, .{ feature.name, feature.description });</span>
<span class="line" id="L1249">            }</span>
<span class="line" id="L1250">            self.markInvalidUserInput();</span>
<span class="line" id="L1251">            <span class="tok-kw">return</span> args.default_target;</span>
<span class="line" id="L1252">        },</span>
<span class="line" id="L1253">        <span class="tok-kw">error</span>.UnknownOperatingSystem =&gt; {</span>
<span class="line" id="L1254">            log.err(</span>
<span class="line" id="L1255">                <span class="tok-str">\\Unknown OS: '{s}'</span></span>

<span class="line" id="L1256">                <span class="tok-str">\\Available operating systems:</span></span>

<span class="line" id="L1257">                <span class="tok-str">\\</span></span>

<span class="line" id="L1258">            , .{diags.os_name.?});</span>
<span class="line" id="L1259">            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (std.meta.fields(std.Target.Os.Tag)) |field| {</span>
<span class="line" id="L1260">                log.err(<span class="tok-str">&quot; {s}&quot;</span>, .{field.name});</span>
<span class="line" id="L1261">            }</span>
<span class="line" id="L1262">            self.markInvalidUserInput();</span>
<span class="line" id="L1263">            <span class="tok-kw">return</span> args.default_target;</span>
<span class="line" id="L1264">        },</span>
<span class="line" id="L1265">        <span class="tok-kw">else</span> =&gt; |e| {</span>
<span class="line" id="L1266">            log.err(<span class="tok-str">&quot;Unable to parse target '{s}': {s}\n&quot;</span>, .{ triple, <span class="tok-builtin">@errorName</span>(e) });</span>
<span class="line" id="L1267">            self.markInvalidUserInput();</span>
<span class="line" id="L1268">            <span class="tok-kw">return</span> args.default_target;</span>
<span class="line" id="L1269">        },</span>
<span class="line" id="L1270">    };</span>
<span class="line" id="L1271"></span>
<span class="line" id="L1272">    <span class="tok-kw">const</span> selected_canonicalized_triple = selected_target.zigTriple(self.allocator) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1273"></span>
<span class="line" id="L1274">    <span class="tok-kw">if</span> (args.whitelist) |list| whitelist_check: {</span>
<span class="line" id="L1275">        <span class="tok-comment">// Make sure it's a match of one of the list.</span>
</span>
<span class="line" id="L1276">        <span class="tok-kw">var</span> mismatch_triple = <span class="tok-null">true</span>;</span>
<span class="line" id="L1277">        <span class="tok-kw">var</span> mismatch_cpu_features = <span class="tok-null">true</span>;</span>
<span class="line" id="L1278">        <span class="tok-kw">var</span> whitelist_item = CrossTarget{};</span>
<span class="line" id="L1279">        <span class="tok-kw">for</span> (list) |t| {</span>
<span class="line" id="L1280">            mismatch_cpu_features = <span class="tok-null">true</span>;</span>
<span class="line" id="L1281">            mismatch_triple = <span class="tok-null">true</span>;</span>
<span class="line" id="L1282"></span>
<span class="line" id="L1283">            <span class="tok-kw">const</span> t_triple = t.zigTriple(self.allocator) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1284">            <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, t_triple, selected_canonicalized_triple)) {</span>
<span class="line" id="L1285">                mismatch_triple = <span class="tok-null">false</span>;</span>
<span class="line" id="L1286">                whitelist_item = t;</span>
<span class="line" id="L1287">                <span class="tok-kw">if</span> (t.getCpuFeatures().isSuperSetOf(selected_target.getCpuFeatures())) {</span>
<span class="line" id="L1288">                    mismatch_cpu_features = <span class="tok-null">false</span>;</span>
<span class="line" id="L1289">                    <span class="tok-kw">break</span> :whitelist_check;</span>
<span class="line" id="L1290">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1291">                    <span class="tok-kw">break</span>;</span>
<span class="line" id="L1292">                }</span>
<span class="line" id="L1293">            }</span>
<span class="line" id="L1294">        }</span>
<span class="line" id="L1295">        <span class="tok-kw">if</span> (mismatch_triple) {</span>
<span class="line" id="L1296">            log.err(<span class="tok-str">&quot;Chosen target '{s}' does not match one of the supported targets:&quot;</span>, .{</span>
<span class="line" id="L1297">                selected_canonicalized_triple,</span>
<span class="line" id="L1298">            });</span>
<span class="line" id="L1299">            <span class="tok-kw">for</span> (list) |t| {</span>
<span class="line" id="L1300">                <span class="tok-kw">const</span> t_triple = t.zigTriple(self.allocator) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1301">                log.err(<span class="tok-str">&quot; {s}&quot;</span>, .{t_triple});</span>
<span class="line" id="L1302">            }</span>
<span class="line" id="L1303">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1304">            assert(mismatch_cpu_features);</span>
<span class="line" id="L1305">            <span class="tok-kw">const</span> whitelist_cpu = whitelist_item.getCpu();</span>
<span class="line" id="L1306">            <span class="tok-kw">const</span> selected_cpu = selected_target.getCpu();</span>
<span class="line" id="L1307">            log.err(<span class="tok-str">&quot;Chosen CPU model '{s}' does not match one of the supported targets:&quot;</span>, .{</span>
<span class="line" id="L1308">                selected_cpu.model.name,</span>
<span class="line" id="L1309">            });</span>
<span class="line" id="L1310">            log.err(<span class="tok-str">&quot;  Supported feature Set: &quot;</span>, .{});</span>
<span class="line" id="L1311">            <span class="tok-kw">const</span> all_features = whitelist_cpu.arch.allFeaturesList();</span>
<span class="line" id="L1312">            <span class="tok-kw">var</span> populated_cpu_features = whitelist_cpu.model.features;</span>
<span class="line" id="L1313">            populated_cpu_features.populateDependencies(all_features);</span>
<span class="line" id="L1314">            <span class="tok-kw">for</span> (all_features, <span class="tok-number">0</span>..) |feature, i_usize| {</span>
<span class="line" id="L1315">                <span class="tok-kw">const</span> i = <span class="tok-builtin">@as</span>(std.Target.Cpu.Feature.Set.Index, <span class="tok-builtin">@intCast</span>(i_usize));</span>
<span class="line" id="L1316">                <span class="tok-kw">const</span> in_cpu_set = populated_cpu_features.isEnabled(i);</span>
<span class="line" id="L1317">                <span class="tok-kw">if</span> (in_cpu_set) {</span>
<span class="line" id="L1318">                    log.err(<span class="tok-str">&quot;{s} &quot;</span>, .{feature.name});</span>
<span class="line" id="L1319">                }</span>
<span class="line" id="L1320">            }</span>
<span class="line" id="L1321">            log.err(<span class="tok-str">&quot;  Remove: &quot;</span>, .{});</span>
<span class="line" id="L1322">            <span class="tok-kw">for</span> (all_features, <span class="tok-number">0</span>..) |feature, i_usize| {</span>
<span class="line" id="L1323">                <span class="tok-kw">const</span> i = <span class="tok-builtin">@as</span>(std.Target.Cpu.Feature.Set.Index, <span class="tok-builtin">@intCast</span>(i_usize));</span>
<span class="line" id="L1324">                <span class="tok-kw">const</span> in_cpu_set = populated_cpu_features.isEnabled(i);</span>
<span class="line" id="L1325">                <span class="tok-kw">const</span> in_actual_set = selected_cpu.features.isEnabled(i);</span>
<span class="line" id="L1326">                <span class="tok-kw">if</span> (in_actual_set <span class="tok-kw">and</span> !in_cpu_set) {</span>
<span class="line" id="L1327">                    log.err(<span class="tok-str">&quot;{s} &quot;</span>, .{feature.name});</span>
<span class="line" id="L1328">                }</span>
<span class="line" id="L1329">            }</span>
<span class="line" id="L1330">        }</span>
<span class="line" id="L1331">        self.markInvalidUserInput();</span>
<span class="line" id="L1332">        <span class="tok-kw">return</span> args.default_target;</span>
<span class="line" id="L1333">    }</span>
<span class="line" id="L1334"></span>
<span class="line" id="L1335">    <span class="tok-kw">return</span> selected_target;</span>
<span class="line" id="L1336">}</span>
<span class="line" id="L1337"></span>
<span class="line" id="L1338"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addUserInputOption</span>(self: *Build, name_raw: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, value_raw: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">bool</span> {</span>
<span class="line" id="L1339">    <span class="tok-kw">const</span> name = self.dupe(name_raw);</span>
<span class="line" id="L1340">    <span class="tok-kw">const</span> value = self.dupe(value_raw);</span>
<span class="line" id="L1341">    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.user_input_options.getOrPut(name);</span>
<span class="line" id="L1342">    <span class="tok-kw">if</span> (!gop.found_existing) {</span>
<span class="line" id="L1343">        gop.value_ptr.* = UserInputOption{</span>
<span class="line" id="L1344">            .name = name,</span>
<span class="line" id="L1345">            .value = .{ .scalar = value },</span>
<span class="line" id="L1346">            .used = <span class="tok-null">false</span>,</span>
<span class="line" id="L1347">        };</span>
<span class="line" id="L1348">        <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L1349">    }</span>
<span class="line" id="L1350"></span>
<span class="line" id="L1351">    <span class="tok-comment">// option already exists</span>
</span>
<span class="line" id="L1352">    <span class="tok-kw">switch</span> (gop.value_ptr.value) {</span>
<span class="line" id="L1353">        .scalar =&gt; |s| {</span>
<span class="line" id="L1354">            <span class="tok-comment">// turn it into a list</span>
</span>
<span class="line" id="L1355">            <span class="tok-kw">var</span> list = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(self.allocator);</span>
<span class="line" id="L1356">            <span class="tok-kw">try</span> list.append(s);</span>
<span class="line" id="L1357">            <span class="tok-kw">try</span> list.append(value);</span>
<span class="line" id="L1358">            <span class="tok-kw">try</span> self.user_input_options.put(name, .{</span>
<span class="line" id="L1359">                .name = name,</span>
<span class="line" id="L1360">                .value = .{ .list = list },</span>
<span class="line" id="L1361">                .used = <span class="tok-null">false</span>,</span>
<span class="line" id="L1362">            });</span>
<span class="line" id="L1363">        },</span>
<span class="line" id="L1364">        .list =&gt; |*list| {</span>
<span class="line" id="L1365">            <span class="tok-comment">// append to the list</span>
</span>
<span class="line" id="L1366">            <span class="tok-kw">try</span> list.append(value);</span>
<span class="line" id="L1367">            <span class="tok-kw">try</span> self.user_input_options.put(name, .{</span>
<span class="line" id="L1368">                .name = name,</span>
<span class="line" id="L1369">                .value = .{ .list = list.* },</span>
<span class="line" id="L1370">                .used = <span class="tok-null">false</span>,</span>
<span class="line" id="L1371">            });</span>
<span class="line" id="L1372">        },</span>
<span class="line" id="L1373">        .flag =&gt; {</span>
<span class="line" id="L1374">            log.warn(<span class="tok-str">&quot;Option '-D{s}={s}' conflicts with flag '-D{s}'.&quot;</span>, .{ name, value, name });</span>
<span class="line" id="L1375">            <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L1376">        },</span>
<span class="line" id="L1377">        .map =&gt; |*map| {</span>
<span class="line" id="L1378">            _ = map;</span>
<span class="line" id="L1379">            log.warn(<span class="tok-str">&quot;TODO maps as command line arguments is not implemented yet.&quot;</span>, .{});</span>
<span class="line" id="L1380">            <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L1381">        },</span>
<span class="line" id="L1382">    }</span>
<span class="line" id="L1383">    <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L1384">}</span>
<span class="line" id="L1385"></span>
<span class="line" id="L1386"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addUserInputFlag</span>(self: *Build, name_raw: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">bool</span> {</span>
<span class="line" id="L1387">    <span class="tok-kw">const</span> name = self.dupe(name_raw);</span>
<span class="line" id="L1388">    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.user_input_options.getOrPut(name);</span>
<span class="line" id="L1389">    <span class="tok-kw">if</span> (!gop.found_existing) {</span>
<span class="line" id="L1390">        gop.value_ptr.* = .{</span>
<span class="line" id="L1391">            .name = name,</span>
<span class="line" id="L1392">            .value = .{ .flag = {} },</span>
<span class="line" id="L1393">            .used = <span class="tok-null">false</span>,</span>
<span class="line" id="L1394">        };</span>
<span class="line" id="L1395">        <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L1396">    }</span>
<span class="line" id="L1397"></span>
<span class="line" id="L1398">    <span class="tok-comment">// option already exists</span>
</span>
<span class="line" id="L1399">    <span class="tok-kw">switch</span> (gop.value_ptr.value) {</span>
<span class="line" id="L1400">        .scalar =&gt; |s| {</span>
<span class="line" id="L1401">            log.err(<span class="tok-str">&quot;Flag '-D{s}' conflicts with option '-D{s}={s}'.&quot;</span>, .{ name, name, s });</span>
<span class="line" id="L1402">            <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L1403">        },</span>
<span class="line" id="L1404">        .list, .map =&gt; {</span>
<span class="line" id="L1405">            log.err(<span class="tok-str">&quot;Flag '-D{s}' conflicts with multiple options of the same name.&quot;</span>, .{name});</span>
<span class="line" id="L1406">            <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L1407">        },</span>
<span class="line" id="L1408">        .flag =&gt; {},</span>
<span class="line" id="L1409">    }</span>
<span class="line" id="L1410">    <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L1411">}</span>
<span class="line" id="L1412"></span>
<span class="line" id="L1413"><span class="tok-kw">fn</span> <span class="tok-fn">typeToEnum</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) TypeId {</span>
<span class="line" id="L1414">    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (T) {</span>
<span class="line" id="L1415">        Step.Compile.BuildId =&gt; .build_id,</span>
<span class="line" id="L1416">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {</span>
<span class="line" id="L1417">            .Int =&gt; .int,</span>
<span class="line" id="L1418">            .Float =&gt; .float,</span>
<span class="line" id="L1419">            .Bool =&gt; .<span class="tok-type">bool</span>,</span>
<span class="line" id="L1420">            .Enum =&gt; .@&quot;enum&quot;,</span>
<span class="line" id="L1421">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">switch</span> (T) {</span>
<span class="line" id="L1422">                []<span class="tok-kw">const</span> <span class="tok-type">u8</span> =&gt; .string,</span>
<span class="line" id="L1423">                []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span> =&gt; .list,</span>
<span class="line" id="L1424">                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unsupported type: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(T)),</span>
<span class="line" id="L1425">            },</span>
<span class="line" id="L1426">        },</span>
<span class="line" id="L1427">    };</span>
<span class="line" id="L1428">}</span>
<span class="line" id="L1429"></span>
<span class="line" id="L1430"><span class="tok-kw">fn</span> <span class="tok-fn">markInvalidUserInput</span>(self: *Build) <span class="tok-type">void</span> {</span>
<span class="line" id="L1431">    self.invalid_user_input = <span class="tok-null">true</span>;</span>
<span class="line" id="L1432">}</span>
<span class="line" id="L1433"></span>
<span class="line" id="L1434"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">validateUserInputDidItFail</span>(self: *Build) <span class="tok-type">bool</span> {</span>
<span class="line" id="L1435">    <span class="tok-comment">// make sure all args are used</span>
</span>
<span class="line" id="L1436">    <span class="tok-kw">var</span> it = self.user_input_options.iterator();</span>
<span class="line" id="L1437">    <span class="tok-kw">while</span> (it.next()) |entry| {</span>
<span class="line" id="L1438">        <span class="tok-kw">if</span> (!entry.value_ptr.used) {</span>
<span class="line" id="L1439">            log.err(<span class="tok-str">&quot;Invalid option: -D{s}&quot;</span>, .{entry.key_ptr.*});</span>
<span class="line" id="L1440">            self.markInvalidUserInput();</span>
<span class="line" id="L1441">        }</span>
<span class="line" id="L1442">    }</span>
<span class="line" id="L1443"></span>
<span class="line" id="L1444">    <span class="tok-kw">return</span> self.invalid_user_input;</span>
<span class="line" id="L1445">}</span>
<span class="line" id="L1446"></span>
<span class="line" id="L1447"><span class="tok-kw">fn</span> <span class="tok-fn">allocPrintCmd</span>(ally: Allocator, opt_cwd: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L1448">    <span class="tok-kw">var</span> buf = ArrayList(<span class="tok-type">u8</span>).init(ally);</span>
<span class="line" id="L1449">    <span class="tok-kw">if</span> (opt_cwd) |cwd| <span class="tok-kw">try</span> buf.writer().print(<span class="tok-str">&quot;cd {s} &amp;&amp; &quot;</span>, .{cwd});</span>
<span class="line" id="L1450">    <span class="tok-kw">for</span> (argv) |arg| {</span>
<span class="line" id="L1451">        <span class="tok-kw">try</span> buf.writer().print(<span class="tok-str">&quot;{s} &quot;</span>, .{arg});</span>
<span class="line" id="L1452">    }</span>
<span class="line" id="L1453">    <span class="tok-kw">return</span> buf.toOwnedSlice();</span>
<span class="line" id="L1454">}</span>
<span class="line" id="L1455"></span>
<span class="line" id="L1456"><span class="tok-kw">fn</span> <span class="tok-fn">printCmd</span>(ally: Allocator, cwd: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L1457">    <span class="tok-kw">const</span> text = allocPrintCmd(ally, cwd, argv) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1458">    std.debug.print(<span class="tok-str">&quot;{s}\n&quot;</span>, .{text});</span>
<span class="line" id="L1459">}</span>
<span class="line" id="L1460"></span>
<span class="line" id="L1461"><span class="tok-comment">/// This creates the install step and adds it to the dependencies of the</span></span>
<span class="line" id="L1462"><span class="tok-comment">/// top-level install step, using all the default options.</span></span>
<span class="line" id="L1463"><span class="tok-comment">/// See `addInstallArtifact` for a more flexible function.</span></span>
<span class="line" id="L1464"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installArtifact</span>(self: *Build, artifact: *Step.Compile) <span class="tok-type">void</span> {</span>
<span class="line" id="L1465">    self.getInstallStep().dependOn(&amp;self.addInstallArtifact(artifact, .{}).step);</span>
<span class="line" id="L1466">}</span>
<span class="line" id="L1467"></span>
<span class="line" id="L1468"><span class="tok-comment">/// This merely creates the step; it does not add it to the dependencies of the</span></span>
<span class="line" id="L1469"><span class="tok-comment">/// top-level install step.</span></span>
<span class="line" id="L1470"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addInstallArtifact</span>(</span>
<span class="line" id="L1471">    self: *Build,</span>
<span class="line" id="L1472">    artifact: *Step.Compile,</span>
<span class="line" id="L1473">    options: Step.InstallArtifact.Options,</span>
<span class="line" id="L1474">) *Step.InstallArtifact {</span>
<span class="line" id="L1475">    <span class="tok-kw">return</span> Step.InstallArtifact.create(self, artifact, options);</span>
<span class="line" id="L1476">}</span>
<span class="line" id="L1477"></span>
<span class="line" id="L1478"><span class="tok-comment">///`dest_rel_path` is relative to prefix path</span></span>
<span class="line" id="L1479"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installFile</span>(self: *Build, src_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L1480">    self.getInstallStep().dependOn(&amp;self.addInstallFileWithDir(.{ .path = src_path }, .prefix, dest_rel_path).step);</span>
<span class="line" id="L1481">}</span>
<span class="line" id="L1482"></span>
<span class="line" id="L1483"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installDirectory</span>(self: *Build, options: InstallDirectoryOptions) <span class="tok-type">void</span> {</span>
<span class="line" id="L1484">    self.getInstallStep().dependOn(&amp;self.addInstallDirectory(options).step);</span>
<span class="line" id="L1485">}</span>
<span class="line" id="L1486"></span>
<span class="line" id="L1487"><span class="tok-comment">///`dest_rel_path` is relative to bin path</span></span>
<span class="line" id="L1488"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installBinFile</span>(self: *Build, src_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L1489">    self.getInstallStep().dependOn(&amp;self.addInstallFileWithDir(.{ .path = src_path }, .bin, dest_rel_path).step);</span>
<span class="line" id="L1490">}</span>
<span class="line" id="L1491"></span>
<span class="line" id="L1492"><span class="tok-comment">///`dest_rel_path` is relative to lib path</span></span>
<span class="line" id="L1493"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installLibFile</span>(self: *Build, src_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L1494">    self.getInstallStep().dependOn(&amp;self.addInstallFileWithDir(.{ .path = src_path }, .lib, dest_rel_path).step);</span>
<span class="line" id="L1495">}</span>
<span class="line" id="L1496"></span>
<span class="line" id="L1497"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addObjCopy</span>(b: *Build, source: LazyPath, options: Step.ObjCopy.Options) *Step.ObjCopy {</span>
<span class="line" id="L1498">    <span class="tok-kw">return</span> Step.ObjCopy.create(b, source, options);</span>
<span class="line" id="L1499">}</span>
<span class="line" id="L1500"></span>
<span class="line" id="L1501"><span class="tok-comment">///`dest_rel_path` is relative to install prefix path</span></span>
<span class="line" id="L1502"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addInstallFile</span>(self: *Build, source: LazyPath, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *Step.InstallFile {</span>
<span class="line" id="L1503">    <span class="tok-kw">return</span> self.addInstallFileWithDir(source.dupe(self), .prefix, dest_rel_path);</span>
<span class="line" id="L1504">}</span>
<span class="line" id="L1505"></span>
<span class="line" id="L1506"><span class="tok-comment">///`dest_rel_path` is relative to bin path</span></span>
<span class="line" id="L1507"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addInstallBinFile</span>(self: *Build, source: LazyPath, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *Step.InstallFile {</span>
<span class="line" id="L1508">    <span class="tok-kw">return</span> self.addInstallFileWithDir(source.dupe(self), .bin, dest_rel_path);</span>
<span class="line" id="L1509">}</span>
<span class="line" id="L1510"></span>
<span class="line" id="L1511"><span class="tok-comment">///`dest_rel_path` is relative to lib path</span></span>
<span class="line" id="L1512"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addInstallLibFile</span>(self: *Build, source: LazyPath, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *Step.InstallFile {</span>
<span class="line" id="L1513">    <span class="tok-kw">return</span> self.addInstallFileWithDir(source.dupe(self), .lib, dest_rel_path);</span>
<span class="line" id="L1514">}</span>
<span class="line" id="L1515"></span>
<span class="line" id="L1516"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addInstallHeaderFile</span>(b: *Build, src_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *Step.InstallFile {</span>
<span class="line" id="L1517">    <span class="tok-kw">return</span> b.addInstallFileWithDir(.{ .path = src_path }, .header, dest_rel_path);</span>
<span class="line" id="L1518">}</span>
<span class="line" id="L1519"></span>
<span class="line" id="L1520"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addInstallFileWithDir</span>(</span>
<span class="line" id="L1521">    self: *Build,</span>
<span class="line" id="L1522">    source: LazyPath,</span>
<span class="line" id="L1523">    install_dir: InstallDir,</span>
<span class="line" id="L1524">    dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1525">) *Step.InstallFile {</span>
<span class="line" id="L1526">    <span class="tok-kw">return</span> Step.InstallFile.create(self, source.dupe(self), install_dir, dest_rel_path);</span>
<span class="line" id="L1527">}</span>
<span class="line" id="L1528"></span>
<span class="line" id="L1529"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addInstallDirectory</span>(self: *Build, options: InstallDirectoryOptions) *Step.InstallDir {</span>
<span class="line" id="L1530">    <span class="tok-kw">return</span> Step.InstallDir.create(self, options);</span>
<span class="line" id="L1531">}</span>
<span class="line" id="L1532"></span>
<span class="line" id="L1533"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCheckFile</span>(</span>
<span class="line" id="L1534">    b: *Build,</span>
<span class="line" id="L1535">    file_source: LazyPath,</span>
<span class="line" id="L1536">    options: Step.CheckFile.Options,</span>
<span class="line" id="L1537">) *Step.CheckFile {</span>
<span class="line" id="L1538">    <span class="tok-kw">return</span> Step.CheckFile.create(b, file_source, options);</span>
<span class="line" id="L1539">}</span>
<span class="line" id="L1540"></span>
<span class="line" id="L1541"><span class="tok-comment">/// deprecated: https://github.com/ziglang/zig/issues/14943</span></span>
<span class="line" id="L1542"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pushInstalledFile</span>(self: *Build, dir: InstallDir, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L1543">    <span class="tok-kw">const</span> file = InstalledFile{</span>
<span class="line" id="L1544">        .dir = dir,</span>
<span class="line" id="L1545">        .path = dest_rel_path,</span>
<span class="line" id="L1546">    };</span>
<span class="line" id="L1547">    self.installed_files.append(file.dupe(self)) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1548">}</span>
<span class="line" id="L1549"></span>
<span class="line" id="L1550"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">truncateFile</span>(self: *Build, dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1551">    <span class="tok-kw">if</span> (self.verbose) {</span>
<span class="line" id="L1552">        log.info(<span class="tok-str">&quot;truncate {s}&quot;</span>, .{dest_path});</span>
<span class="line" id="L1553">    }</span>
<span class="line" id="L1554">    <span class="tok-kw">const</span> cwd = fs.cwd();</span>
<span class="line" id="L1555">    <span class="tok-kw">var</span> src_file = cwd.createFile(dest_path, .{}) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1556">        <span class="tok-kw">error</span>.FileNotFound =&gt; blk: {</span>
<span class="line" id="L1557">            <span class="tok-kw">if</span> (fs.path.dirname(dest_path)) |dirname| {</span>
<span class="line" id="L1558">                <span class="tok-kw">try</span> cwd.makePath(dirname);</span>
<span class="line" id="L1559">            }</span>
<span class="line" id="L1560">            <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> cwd.createFile(dest_path, .{});</span>
<span class="line" id="L1561">        },</span>
<span class="line" id="L1562">        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1563">    };</span>
<span class="line" id="L1564">    src_file.close();</span>
<span class="line" id="L1565">}</span>
<span class="line" id="L1566"></span>
<span class="line" id="L1567"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pathFromRoot</span>(b: *Build, p: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-type">u8</span> {</span>
<span class="line" id="L1568">    <span class="tok-kw">return</span> fs.path.resolve(b.allocator, &amp;.{ b.build_root.path <span class="tok-kw">orelse</span> <span class="tok-str">&quot;.&quot;</span>, p }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1569">}</span>
<span class="line" id="L1570"></span>
<span class="line" id="L1571"><span class="tok-kw">fn</span> <span class="tok-fn">pathFromCwd</span>(b: *Build, p: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-type">u8</span> {</span>
<span class="line" id="L1572">    <span class="tok-kw">const</span> cwd = process.getCwdAlloc(b.allocator) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1573">    <span class="tok-kw">return</span> fs.path.resolve(b.allocator, &amp;.{ cwd, p }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1574">}</span>
<span class="line" id="L1575"></span>
<span class="line" id="L1576"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pathJoin</span>(self: *Build, paths: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-type">u8</span> {</span>
<span class="line" id="L1577">    <span class="tok-kw">return</span> fs.path.join(self.allocator, paths) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1578">}</span>
<span class="line" id="L1579"></span>
<span class="line" id="L1580"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fmt</span>(self: *Build, <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) []<span class="tok-type">u8</span> {</span>
<span class="line" id="L1581">    <span class="tok-kw">return</span> fmt_lib.allocPrint(self.allocator, format, args) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1582">}</span>
<span class="line" id="L1583"></span>
<span class="line" id="L1584"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">findProgram</span>(self: *Build, names: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, paths: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1585">    <span class="tok-comment">// TODO report error for ambiguous situations</span>
</span>
<span class="line" id="L1586">    <span class="tok-kw">const</span> exe_extension = <span class="tok-builtin">@as</span>(CrossTarget, .{}).exeFileExt();</span>
<span class="line" id="L1587">    <span class="tok-kw">for</span> (self.search_prefixes.items) |search_prefix| {</span>
<span class="line" id="L1588">        <span class="tok-kw">for</span> (names) |name| {</span>
<span class="line" id="L1589">            <span class="tok-kw">if</span> (fs.path.isAbsolute(name)) {</span>
<span class="line" id="L1590">                <span class="tok-kw">return</span> name;</span>
<span class="line" id="L1591">            }</span>
<span class="line" id="L1592">            <span class="tok-kw">const</span> full_path = self.pathJoin(&amp;.{</span>
<span class="line" id="L1593">                search_prefix,</span>
<span class="line" id="L1594">                <span class="tok-str">&quot;bin&quot;</span>,</span>
<span class="line" id="L1595">                self.fmt(<span class="tok-str">&quot;{s}{s}&quot;</span>, .{ name, exe_extension }),</span>
<span class="line" id="L1596">            });</span>
<span class="line" id="L1597">            <span class="tok-kw">return</span> fs.realpathAlloc(self.allocator, full_path) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1598">        }</span>
<span class="line" id="L1599">    }</span>
<span class="line" id="L1600">    <span class="tok-kw">if</span> (self.env_map.get(<span class="tok-str">&quot;PATH&quot;</span>)) |PATH| {</span>
<span class="line" id="L1601">        <span class="tok-kw">for</span> (names) |name| {</span>
<span class="line" id="L1602">            <span class="tok-kw">if</span> (fs.path.isAbsolute(name)) {</span>
<span class="line" id="L1603">                <span class="tok-kw">return</span> name;</span>
<span class="line" id="L1604">            }</span>
<span class="line" id="L1605">            <span class="tok-kw">var</span> it = mem.tokenizeScalar(<span class="tok-type">u8</span>, PATH, fs.path.delimiter);</span>
<span class="line" id="L1606">            <span class="tok-kw">while</span> (it.next()) |path| {</span>
<span class="line" id="L1607">                <span class="tok-kw">const</span> full_path = self.pathJoin(&amp;.{</span>
<span class="line" id="L1608">                    path,</span>
<span class="line" id="L1609">                    self.fmt(<span class="tok-str">&quot;{s}{s}&quot;</span>, .{ name, exe_extension }),</span>
<span class="line" id="L1610">                });</span>
<span class="line" id="L1611">                <span class="tok-kw">return</span> fs.realpathAlloc(self.allocator, full_path) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1612">            }</span>
<span class="line" id="L1613">        }</span>
<span class="line" id="L1614">    }</span>
<span class="line" id="L1615">    <span class="tok-kw">for</span> (names) |name| {</span>
<span class="line" id="L1616">        <span class="tok-kw">if</span> (fs.path.isAbsolute(name)) {</span>
<span class="line" id="L1617">            <span class="tok-kw">return</span> name;</span>
<span class="line" id="L1618">        }</span>
<span class="line" id="L1619">        <span class="tok-kw">for</span> (paths) |path| {</span>
<span class="line" id="L1620">            <span class="tok-kw">const</span> full_path = self.pathJoin(&amp;.{</span>
<span class="line" id="L1621">                path,</span>
<span class="line" id="L1622">                self.fmt(<span class="tok-str">&quot;{s}{s}&quot;</span>, .{ name, exe_extension }),</span>
<span class="line" id="L1623">            });</span>
<span class="line" id="L1624">            <span class="tok-kw">return</span> fs.realpathAlloc(self.allocator, full_path) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1625">        }</span>
<span class="line" id="L1626">    }</span>
<span class="line" id="L1627">    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound;</span>
<span class="line" id="L1628">}</span>
<span class="line" id="L1629"></span>
<span class="line" id="L1630"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">runAllowFail</span>(</span>
<span class="line" id="L1631">    self: *Build,</span>
<span class="line" id="L1632">    argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1633">    out_code: *<span class="tok-type">u8</span>,</span>
<span class="line" id="L1634">    stderr_behavior: std.ChildProcess.StdIo,</span>
<span class="line" id="L1635">) RunError![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L1636">    assert(argv.len != <span class="tok-number">0</span>);</span>
<span class="line" id="L1637"></span>
<span class="line" id="L1638">    <span class="tok-kw">if</span> (!process.can_spawn)</span>
<span class="line" id="L1639">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ExecNotSupported;</span>
<span class="line" id="L1640"></span>
<span class="line" id="L1641">    <span class="tok-kw">const</span> max_output_size = <span class="tok-number">400</span> * <span class="tok-number">1024</span>;</span>
<span class="line" id="L1642">    <span class="tok-kw">var</span> child = std.ChildProcess.init(argv, self.allocator);</span>
<span class="line" id="L1643">    child.stdin_behavior = .Ignore;</span>
<span class="line" id="L1644">    child.stdout_behavior = .Pipe;</span>
<span class="line" id="L1645">    child.stderr_behavior = stderr_behavior;</span>
<span class="line" id="L1646">    child.env_map = self.env_map;</span>
<span class="line" id="L1647"></span>
<span class="line" id="L1648">    <span class="tok-kw">try</span> child.spawn();</span>
<span class="line" id="L1649"></span>
<span class="line" id="L1650">    <span class="tok-kw">const</span> stdout = child.stdout.?.reader().readAllAlloc(self.allocator, max_output_size) <span class="tok-kw">catch</span> {</span>
<span class="line" id="L1651">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadFailure;</span>
<span class="line" id="L1652">    };</span>
<span class="line" id="L1653">    <span class="tok-kw">errdefer</span> self.allocator.free(stdout);</span>
<span class="line" id="L1654"></span>
<span class="line" id="L1655">    <span class="tok-kw">const</span> term = <span class="tok-kw">try</span> child.wait();</span>
<span class="line" id="L1656">    <span class="tok-kw">switch</span> (term) {</span>
<span class="line" id="L1657">        .Exited =&gt; |code| {</span>
<span class="line" id="L1658">            <span class="tok-kw">if</span> (code != <span class="tok-number">0</span>) {</span>
<span class="line" id="L1659">                out_code.* = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(code));</span>
<span class="line" id="L1660">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ExitCodeFailure;</span>
<span class="line" id="L1661">            }</span>
<span class="line" id="L1662">            <span class="tok-kw">return</span> stdout;</span>
<span class="line" id="L1663">        },</span>
<span class="line" id="L1664">        .Signal, .Stopped, .Unknown =&gt; |code| {</span>
<span class="line" id="L1665">            out_code.* = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(code));</span>
<span class="line" id="L1666">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessTerminated;</span>
<span class="line" id="L1667">        },</span>
<span class="line" id="L1668">    }</span>
<span class="line" id="L1669">}</span>
<span class="line" id="L1670"></span>
<span class="line" id="L1671"><span class="tok-comment">/// This is a helper function to be called from build.zig scripts, *not* from</span></span>
<span class="line" id="L1672"><span class="tok-comment">/// inside step make() functions. If any errors occur, it fails the build with</span></span>
<span class="line" id="L1673"><span class="tok-comment">/// a helpful message.</span></span>
<span class="line" id="L1674"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">run</span>(b: *Build, argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-type">u8</span> {</span>
<span class="line" id="L1675">    <span class="tok-kw">if</span> (!process.can_spawn) {</span>
<span class="line" id="L1676">        std.debug.print(<span class="tok-str">&quot;unable to spawn the following command: cannot spawn child process\n{s}\n&quot;</span>, .{</span>
<span class="line" id="L1677">            <span class="tok-kw">try</span> allocPrintCmd(b.allocator, <span class="tok-null">null</span>, argv),</span>
<span class="line" id="L1678">        });</span>
<span class="line" id="L1679">        process.exit(<span class="tok-number">1</span>);</span>
<span class="line" id="L1680">    }</span>
<span class="line" id="L1681"></span>
<span class="line" id="L1682">    <span class="tok-kw">var</span> code: <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1683">    <span class="tok-kw">return</span> b.runAllowFail(argv, &amp;code, .Inherit) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L1684">        <span class="tok-kw">const</span> printed_cmd = allocPrintCmd(b.allocator, <span class="tok-null">null</span>, argv) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1685">        std.debug.print(<span class="tok-str">&quot;unable to spawn the following command: {s}\n{s}\n&quot;</span>, .{</span>
<span class="line" id="L1686">            <span class="tok-builtin">@errorName</span>(err), printed_cmd,</span>
<span class="line" id="L1687">        });</span>
<span class="line" id="L1688">        process.exit(<span class="tok-number">1</span>);</span>
<span class="line" id="L1689">    };</span>
<span class="line" id="L1690">}</span>
<span class="line" id="L1691"></span>
<span class="line" id="L1692"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSearchPrefix</span>(self: *Build, search_prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L1693">    self.search_prefixes.append(self.dupePath(search_prefix)) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1694">}</span>
<span class="line" id="L1695"></span>
<span class="line" id="L1696"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getInstallPath</span>(self: *Build, dir: InstallDir, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1697">    assert(!fs.path.isAbsolute(dest_rel_path)); <span class="tok-comment">// Install paths must be relative to the prefix</span>
</span>
<span class="line" id="L1698">    <span class="tok-kw">const</span> base_dir = <span class="tok-kw">switch</span> (dir) {</span>
<span class="line" id="L1699">        .prefix =&gt; self.install_path,</span>
<span class="line" id="L1700">        .bin =&gt; self.exe_dir,</span>
<span class="line" id="L1701">        .lib =&gt; self.lib_dir,</span>
<span class="line" id="L1702">        .header =&gt; self.h_dir,</span>
<span class="line" id="L1703">        .custom =&gt; |path| self.pathJoin(&amp;.{ self.install_path, path }),</span>
<span class="line" id="L1704">    };</span>
<span class="line" id="L1705">    <span class="tok-kw">return</span> fs.path.resolve(</span>
<span class="line" id="L1706">        self.allocator,</span>
<span class="line" id="L1707">        &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ base_dir, dest_rel_path },</span>
<span class="line" id="L1708">    ) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1709">}</span>
<span class="line" id="L1710"></span>
<span class="line" id="L1711"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Dependency = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1712">    builder: *Build,</span>
<span class="line" id="L1713"></span>
<span class="line" id="L1714">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">artifact</span>(d: *Dependency, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *Step.Compile {</span>
<span class="line" id="L1715">        <span class="tok-kw">var</span> found: ?*Step.Compile = <span class="tok-null">null</span>;</span>
<span class="line" id="L1716">        <span class="tok-kw">for</span> (d.builder.install_tls.step.dependencies.items) |dep_step| {</span>
<span class="line" id="L1717">            <span class="tok-kw">const</span> inst = dep_step.cast(Step.InstallArtifact) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1718">            <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, inst.artifact.name, name)) {</span>
<span class="line" id="L1719">                <span class="tok-kw">if</span> (found != <span class="tok-null">null</span>) panic(<span class="tok-str">&quot;artifact name '{s}' is ambiguous&quot;</span>, .{name});</span>
<span class="line" id="L1720">                found = inst.artifact;</span>
<span class="line" id="L1721">            }</span>
<span class="line" id="L1722">        }</span>
<span class="line" id="L1723">        <span class="tok-kw">return</span> found <span class="tok-kw">orelse</span> {</span>
<span class="line" id="L1724">            <span class="tok-kw">for</span> (d.builder.install_tls.step.dependencies.items) |dep_step| {</span>
<span class="line" id="L1725">                <span class="tok-kw">const</span> inst = dep_step.cast(Step.InstallArtifact) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1726">                log.info(<span class="tok-str">&quot;available artifact: '{s}'&quot;</span>, .{inst.artifact.name});</span>
<span class="line" id="L1727">            }</span>
<span class="line" id="L1728">            panic(<span class="tok-str">&quot;unable to find artifact '{s}'&quot;</span>, .{name});</span>
<span class="line" id="L1729">        };</span>
<span class="line" id="L1730">    }</span>
<span class="line" id="L1731"></span>
<span class="line" id="L1732">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">module</span>(d: *Dependency, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *Module {</span>
<span class="line" id="L1733">        <span class="tok-kw">return</span> d.builder.modules.get(name) <span class="tok-kw">orelse</span> {</span>
<span class="line" id="L1734">            panic(<span class="tok-str">&quot;unable to find module '{s}'&quot;</span>, .{name});</span>
<span class="line" id="L1735">        };</span>
<span class="line" id="L1736">    }</span>
<span class="line" id="L1737"></span>
<span class="line" id="L1738">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">path</span>(d: *Dependency, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) LazyPath {</span>
<span class="line" id="L1739">        <span class="tok-kw">return</span> .{</span>
<span class="line" id="L1740">            .dependency = .{</span>
<span class="line" id="L1741">                .dependency = d,</span>
<span class="line" id="L1742">                .sub_path = sub_path,</span>
<span class="line" id="L1743">            },</span>
<span class="line" id="L1744">        };</span>
<span class="line" id="L1745">    }</span>
<span class="line" id="L1746">};</span>
<span class="line" id="L1747"></span>
<span class="line" id="L1748"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dependency</span>(b: *Build, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) *Dependency {</span>
<span class="line" id="L1749">    <span class="tok-kw">const</span> build_runner = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;root&quot;</span>);</span>
<span class="line" id="L1750">    <span class="tok-kw">const</span> deps = build_runner.dependencies;</span>
<span class="line" id="L1751"></span>
<span class="line" id="L1752">    <span class="tok-kw">const</span> pkg_hash = <span class="tok-kw">for</span> (b.available_deps) |dep| {</span>
<span class="line" id="L1753">        <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, dep[<span class="tok-number">0</span>], name)) <span class="tok-kw">break</span> dep[<span class="tok-number">1</span>];</span>
<span class="line" id="L1754">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1755">        <span class="tok-kw">const</span> full_path = b.pathFromRoot(<span class="tok-str">&quot;build.zig.zon&quot;</span>);</span>
<span class="line" id="L1756">        std.debug.print(<span class="tok-str">&quot;no dependency named '{s}' in '{s}'. All packages used in build.zig must be declared in this file.\n&quot;</span>, .{ name, full_path });</span>
<span class="line" id="L1757">        process.exit(<span class="tok-number">1</span>);</span>
<span class="line" id="L1758">    };</span>
<span class="line" id="L1759"></span>
<span class="line" id="L1760">    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(deps.packages).Struct.decls) |decl| {</span>
<span class="line" id="L1761">        <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, decl.name, pkg_hash)) {</span>
<span class="line" id="L1762">            <span class="tok-kw">const</span> pkg = <span class="tok-builtin">@field</span>(deps.packages, decl.name);</span>
<span class="line" id="L1763">            <span class="tok-kw">return</span> dependencyInner(b, name, pkg.build_root, <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(pkg, <span class="tok-str">&quot;build_zig&quot;</span>)) pkg.build_zig <span class="tok-kw">else</span> <span class="tok-null">null</span>, pkg.deps, args);</span>
<span class="line" id="L1764">        }</span>
<span class="line" id="L1765">    }</span>
<span class="line" id="L1766"></span>
<span class="line" id="L1767">    <span class="tok-kw">unreachable</span>; <span class="tok-comment">// Bad @dependencies source</span>
</span>
<span class="line" id="L1768">}</span>
<span class="line" id="L1769"></span>
<span class="line" id="L1770"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">anonymousDependency</span>(</span>
<span class="line" id="L1771">    b: *Build,</span>
<span class="line" id="L1772">    <span class="tok-comment">/// The path to the directory containing the dependency's build.zig file,</span></span>
<span class="line" id="L1773">    <span class="tok-comment">/// relative to the current package's build.zig.</span></span>
<span class="line" id="L1774">    relative_build_root: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1775">    <span class="tok-comment">/// A direct `@import` of the build.zig of the dependency.</span></span>
<span class="line" id="L1776">    <span class="tok-kw">comptime</span> build_zig: <span class="tok-type">type</span>,</span>
<span class="line" id="L1777">    args: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L1778">) *Dependency {</span>
<span class="line" id="L1779">    <span class="tok-kw">const</span> arena = b.allocator;</span>
<span class="line" id="L1780">    <span class="tok-kw">const</span> build_root = b.build_root.join(arena, &amp;.{relative_build_root}) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1781">    <span class="tok-kw">const</span> name = arena.dupe(<span class="tok-type">u8</span>, relative_build_root) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1782">    <span class="tok-kw">for</span> (name) |*byte| <span class="tok-kw">switch</span> (byte.*) {</span>
<span class="line" id="L1783">        <span class="tok-str">'/'</span>, <span class="tok-str">'\\'</span> =&gt; byte.* = <span class="tok-str">'.'</span>,</span>
<span class="line" id="L1784">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L1785">    };</span>
<span class="line" id="L1786">    <span class="tok-kw">return</span> dependencyInner(b, name, build_root, build_zig, &amp;.{}, args);</span>
<span class="line" id="L1787">}</span>
<span class="line" id="L1788"></span>
<span class="line" id="L1789"><span class="tok-kw">fn</span> <span class="tok-fn">userValuesAreSame</span>(lhs: UserValue, rhs: UserValue) <span class="tok-type">bool</span> {</span>
<span class="line" id="L1790">    <span class="tok-kw">switch</span> (lhs) {</span>
<span class="line" id="L1791">        .flag =&gt; {},</span>
<span class="line" id="L1792">        .scalar =&gt; |lhs_scalar| {</span>
<span class="line" id="L1793">            <span class="tok-kw">const</span> rhs_scalar = <span class="tok-kw">switch</span> (rhs) {</span>
<span class="line" id="L1794">                .scalar =&gt; |scalar| scalar,</span>
<span class="line" id="L1795">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,</span>
<span class="line" id="L1796">            };</span>
<span class="line" id="L1797"></span>
<span class="line" id="L1798">            <span class="tok-kw">if</span> (!std.mem.eql(<span class="tok-type">u8</span>, lhs_scalar, rhs_scalar))</span>
<span class="line" id="L1799">                <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L1800">        },</span>
<span class="line" id="L1801">        .list =&gt; |lhs_list| {</span>
<span class="line" id="L1802">            <span class="tok-kw">const</span> rhs_list = <span class="tok-kw">switch</span> (rhs) {</span>
<span class="line" id="L1803">                .list =&gt; |list| list,</span>
<span class="line" id="L1804">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,</span>
<span class="line" id="L1805">            };</span>
<span class="line" id="L1806"></span>
<span class="line" id="L1807">            <span class="tok-kw">if</span> (lhs_list.items.len != rhs_list.items.len)</span>
<span class="line" id="L1808">                <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L1809"></span>
<span class="line" id="L1810">            <span class="tok-kw">for</span> (lhs_list.items, rhs_list.items) |lhs_list_entry, rhs_list_entry| {</span>
<span class="line" id="L1811">                <span class="tok-kw">if</span> (!std.mem.eql(<span class="tok-type">u8</span>, lhs_list_entry, rhs_list_entry))</span>
<span class="line" id="L1812">                    <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L1813">            }</span>
<span class="line" id="L1814">        },</span>
<span class="line" id="L1815">        .map =&gt; |lhs_map| {</span>
<span class="line" id="L1816">            <span class="tok-kw">const</span> rhs_map = <span class="tok-kw">switch</span> (rhs) {</span>
<span class="line" id="L1817">                .map =&gt; |map| map,</span>
<span class="line" id="L1818">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,</span>
<span class="line" id="L1819">            };</span>
<span class="line" id="L1820"></span>
<span class="line" id="L1821">            <span class="tok-kw">if</span> (lhs_map.count() != rhs_map.count())</span>
<span class="line" id="L1822">                <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L1823"></span>
<span class="line" id="L1824">            <span class="tok-kw">var</span> lhs_it = lhs_map.iterator();</span>
<span class="line" id="L1825">            <span class="tok-kw">while</span> (lhs_it.next()) |lhs_entry| {</span>
<span class="line" id="L1826">                <span class="tok-kw">const</span> rhs_value = rhs_map.get(lhs_entry.key_ptr.*) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L1827">                <span class="tok-kw">if</span> (!userValuesAreSame(lhs_entry.value_ptr.*.*, rhs_value.*))</span>
<span class="line" id="L1828">                    <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L1829">            }</span>
<span class="line" id="L1830">        },</span>
<span class="line" id="L1831">    }</span>
<span class="line" id="L1832"></span>
<span class="line" id="L1833">    <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L1834">}</span>
<span class="line" id="L1835"></span>
<span class="line" id="L1836"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dependencyInner</span>(</span>
<span class="line" id="L1837">    b: *Build,</span>
<span class="line" id="L1838">    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1839">    build_root_string: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1840">    <span class="tok-kw">comptime</span> build_zig: ?<span class="tok-type">type</span>,</span>
<span class="line" id="L1841">    pkg_deps: AvailableDeps,</span>
<span class="line" id="L1842">    args: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L1843">) *Dependency {</span>
<span class="line" id="L1844">    <span class="tok-kw">const</span> user_input_options = userInputOptionsFromArgs(b.allocator, args);</span>
<span class="line" id="L1845">    <span class="tok-kw">if</span> (b.initialized_deps.get(.{</span>
<span class="line" id="L1846">        .build_root_string = build_root_string,</span>
<span class="line" id="L1847">        .user_input_options = user_input_options,</span>
<span class="line" id="L1848">    })) |dep|</span>
<span class="line" id="L1849">        <span class="tok-kw">return</span> dep;</span>
<span class="line" id="L1850"></span>
<span class="line" id="L1851">    <span class="tok-kw">const</span> build_root: std.Build.Cache.Directory = .{</span>
<span class="line" id="L1852">        .path = build_root_string,</span>
<span class="line" id="L1853">        .handle = std.fs.cwd().openDir(build_root_string, .{}) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L1854">            std.debug.print(<span class="tok-str">&quot;unable to open '{s}': {s}\n&quot;</span>, .{</span>
<span class="line" id="L1855">                build_root_string, <span class="tok-builtin">@errorName</span>(err),</span>
<span class="line" id="L1856">            });</span>
<span class="line" id="L1857">            process.exit(<span class="tok-number">1</span>);</span>
<span class="line" id="L1858">        },</span>
<span class="line" id="L1859">    };</span>
<span class="line" id="L1860"></span>
<span class="line" id="L1861">    <span class="tok-kw">const</span> sub_builder = b.createChild(name, build_root, pkg_deps, user_input_options) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;unhandled error&quot;</span>);</span>
<span class="line" id="L1862">    <span class="tok-kw">if</span> (build_zig) |bz| {</span>
<span class="line" id="L1863">        sub_builder.runBuild(bz) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;unhandled error&quot;</span>);</span>
<span class="line" id="L1864"></span>
<span class="line" id="L1865">        <span class="tok-kw">if</span> (sub_builder.validateUserInputDidItFail()) {</span>
<span class="line" id="L1866">            std.debug.dumpCurrentStackTrace(<span class="tok-builtin">@returnAddress</span>());</span>
<span class="line" id="L1867">        }</span>
<span class="line" id="L1868">    }</span>
<span class="line" id="L1869"></span>
<span class="line" id="L1870">    <span class="tok-kw">const</span> dep = b.allocator.create(Dependency) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1871">    dep.* = .{ .builder = sub_builder };</span>
<span class="line" id="L1872"></span>
<span class="line" id="L1873">    b.initialized_deps.put(.{</span>
<span class="line" id="L1874">        .build_root_string = build_root_string,</span>
<span class="line" id="L1875">        .user_input_options = user_input_options,</span>
<span class="line" id="L1876">    }, dep) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1877">    <span class="tok-kw">return</span> dep;</span>
<span class="line" id="L1878">}</span>
<span class="line" id="L1879"></span>
<span class="line" id="L1880"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">runBuild</span>(b: *Build, build_zig: <span class="tok-kw">anytype</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {</span>
<span class="line" id="L1881">    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(build_zig.build)).Fn.return_type.?)) {</span>
<span class="line" id="L1882">        .Void =&gt; build_zig.build(b),</span>
<span class="line" id="L1883">        .ErrorUnion =&gt; <span class="tok-kw">try</span> build_zig.build(b),</span>
<span class="line" id="L1884">        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;expected return type of build to be 'void' or '!void'&quot;</span>),</span>
<span class="line" id="L1885">    }</span>
<span class="line" id="L1886">}</span>
<span class="line" id="L1887"></span>
<span class="line" id="L1888"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Module = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1889">    builder: *Build,</span>
<span class="line" id="L1890">    <span class="tok-comment">/// This could either be a generated file, in which case the module</span></span>
<span class="line" id="L1891">    <span class="tok-comment">/// contains exactly one file, or it could be a path to the root source</span></span>
<span class="line" id="L1892">    <span class="tok-comment">/// file of directory of files which constitute the module.</span></span>
<span class="line" id="L1893">    source_file: LazyPath,</span>
<span class="line" id="L1894">    dependencies: std.StringArrayHashMap(*Module),</span>
<span class="line" id="L1895">};</span>
<span class="line" id="L1896"></span>
<span class="line" id="L1897"><span class="tok-comment">/// A file that is generated by a build step.</span></span>
<span class="line" id="L1898"><span class="tok-comment">/// This struct is an interface that is meant to be used with `@fieldParentPtr` to implement the actual path logic.</span></span>
<span class="line" id="L1899"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> GeneratedFile = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1900">    <span class="tok-comment">/// The step that generates the file</span></span>
<span class="line" id="L1901">    step: *Step,</span>
<span class="line" id="L1902"></span>
<span class="line" id="L1903">    <span class="tok-comment">/// The path to the generated file. Must be either absolute or relative to the build root.</span></span>
<span class="line" id="L1904">    <span class="tok-comment">/// This value must be set in the `fn make()` of the `step` and must not be `null` afterwards.</span></span>
<span class="line" id="L1905">    path: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L1906"></span>
<span class="line" id="L1907">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPath</span>(self: GeneratedFile) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1908">        <span class="tok-kw">return</span> self.path <span class="tok-kw">orelse</span> std.debug.panic(</span>
<span class="line" id="L1909">            <span class="tok-str">&quot;getPath() was called on a GeneratedFile that wasn't built yet. Is there a missing Step dependency on step '{s}'?&quot;</span>,</span>
<span class="line" id="L1910">            .{self.step.name},</span>
<span class="line" id="L1911">        );</span>
<span class="line" id="L1912">    }</span>
<span class="line" id="L1913">};</span>
<span class="line" id="L1914"></span>
<span class="line" id="L1915"><span class="tok-comment">/// A reference to an existing or future path.</span></span>
<span class="line" id="L1916"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> LazyPath = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L1917">    <span class="tok-comment">/// A source file path relative to build root.</span></span>
<span class="line" id="L1918">    <span class="tok-comment">/// This should not be an absolute path, but in an older iteration of the zig build</span></span>
<span class="line" id="L1919">    <span class="tok-comment">/// system API, it was allowed to be absolute. Absolute paths should use `cwd_relative`.</span></span>
<span class="line" id="L1920">    path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1921"></span>
<span class="line" id="L1922">    <span class="tok-comment">/// A file that is generated by an interface. Those files usually are</span></span>
<span class="line" id="L1923">    <span class="tok-comment">/// not available until built by a build step.</span></span>
<span class="line" id="L1924">    generated: *<span class="tok-kw">const</span> GeneratedFile,</span>
<span class="line" id="L1925"></span>
<span class="line" id="L1926">    <span class="tok-comment">/// An absolute path or a path relative to the current working directory of</span></span>
<span class="line" id="L1927">    <span class="tok-comment">/// the build runner process.</span></span>
<span class="line" id="L1928">    <span class="tok-comment">/// This is uncommon but used for system environment paths such as `--zig-lib-dir` which</span></span>
<span class="line" id="L1929">    <span class="tok-comment">/// ignore the file system path of build.zig and instead are relative to the directory from</span></span>
<span class="line" id="L1930">    <span class="tok-comment">/// which `zig build` was invoked.</span></span>
<span class="line" id="L1931">    <span class="tok-comment">/// Use of this tag indicates a dependency on the host system.</span></span>
<span class="line" id="L1932">    cwd_relative: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1933"></span>
<span class="line" id="L1934">    dependency: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1935">        dependency: *Dependency,</span>
<span class="line" id="L1936">        sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1937">    },</span>
<span class="line" id="L1938"></span>
<span class="line" id="L1939">    <span class="tok-comment">/// Returns a new file source that will have a relative path to the build root guaranteed.</span></span>
<span class="line" id="L1940">    <span class="tok-comment">/// Asserts the parameter is not an absolute path.</span></span>
<span class="line" id="L1941">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">relative</span>(path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) LazyPath {</span>
<span class="line" id="L1942">        std.debug.assert(!std.fs.path.isAbsolute(path));</span>
<span class="line" id="L1943">        <span class="tok-kw">return</span> LazyPath{ .path = path };</span>
<span class="line" id="L1944">    }</span>
<span class="line" id="L1945"></span>
<span class="line" id="L1946">    <span class="tok-comment">/// Returns a string that can be shown to represent the file source.</span></span>
<span class="line" id="L1947">    <span class="tok-comment">/// Either returns the path or `&quot;generated&quot;`.</span></span>
<span class="line" id="L1948">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getDisplayName</span>(self: LazyPath) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1949">        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self) {</span>
<span class="line" id="L1950">            .path, .cwd_relative =&gt; self.path,</span>
<span class="line" id="L1951">            .generated =&gt; <span class="tok-str">&quot;generated&quot;</span>,</span>
<span class="line" id="L1952">            .dependency =&gt; <span class="tok-str">&quot;dependency&quot;</span>,</span>
<span class="line" id="L1953">        };</span>
<span class="line" id="L1954">    }</span>
<span class="line" id="L1955"></span>
<span class="line" id="L1956">    <span class="tok-comment">/// Adds dependencies this file source implies to the given step.</span></span>
<span class="line" id="L1957">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addStepDependencies</span>(self: LazyPath, other_step: *Step) <span class="tok-type">void</span> {</span>
<span class="line" id="L1958">        <span class="tok-kw">switch</span> (self) {</span>
<span class="line" id="L1959">            .path, .cwd_relative, .dependency =&gt; {},</span>
<span class="line" id="L1960">            .generated =&gt; |gen| other_step.dependOn(gen.step),</span>
<span class="line" id="L1961">        }</span>
<span class="line" id="L1962">    }</span>
<span class="line" id="L1963"></span>
<span class="line" id="L1964">    <span class="tok-comment">/// Returns an absolute path.</span></span>
<span class="line" id="L1965">    <span class="tok-comment">/// Intended to be used during the make phase only.</span></span>
<span class="line" id="L1966">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPath</span>(self: LazyPath, src_builder: *Build) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1967">        <span class="tok-kw">return</span> getPath2(self, src_builder, <span class="tok-null">null</span>);</span>
<span class="line" id="L1968">    }</span>
<span class="line" id="L1969"></span>
<span class="line" id="L1970">    <span class="tok-comment">/// Returns an absolute path.</span></span>
<span class="line" id="L1971">    <span class="tok-comment">/// Intended to be used during the make phase only.</span></span>
<span class="line" id="L1972">    <span class="tok-comment">///</span></span>
<span class="line" id="L1973">    <span class="tok-comment">/// `asking_step` is only used for debugging purposes; it's the step being</span></span>
<span class="line" id="L1974">    <span class="tok-comment">/// run that is asking for the path.</span></span>
<span class="line" id="L1975">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPath2</span>(self: LazyPath, src_builder: *Build, asking_step: ?*Step) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1976">        <span class="tok-kw">switch</span> (self) {</span>
<span class="line" id="L1977">            .path =&gt; |p| <span class="tok-kw">return</span> src_builder.pathFromRoot(p),</span>
<span class="line" id="L1978">            .cwd_relative =&gt; |p| <span class="tok-kw">return</span> src_builder.pathFromCwd(p),</span>
<span class="line" id="L1979">            .generated =&gt; |gen| <span class="tok-kw">return</span> gen.path <span class="tok-kw">orelse</span> {</span>
<span class="line" id="L1980">                std.debug.getStderrMutex().lock();</span>
<span class="line" id="L1981">                <span class="tok-kw">const</span> stderr = std.io.getStdErr();</span>
<span class="line" id="L1982">                dumpBadGetPathHelp(gen.step, stderr, src_builder, asking_step) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L1983">                <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;misconfigured build script&quot;</span>);</span>
<span class="line" id="L1984">            },</span>
<span class="line" id="L1985">            .dependency =&gt; |dep| {</span>
<span class="line" id="L1986">                <span class="tok-kw">return</span> dep.dependency.builder.pathJoin(&amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{</span>
<span class="line" id="L1987">                    dep.dependency.builder.build_root.path.?,</span>
<span class="line" id="L1988">                    dep.sub_path,</span>
<span class="line" id="L1989">                });</span>
<span class="line" id="L1990">            },</span>
<span class="line" id="L1991">        }</span>
<span class="line" id="L1992">    }</span>
<span class="line" id="L1993"></span>
<span class="line" id="L1994">    <span class="tok-comment">/// Duplicates the file source for a given builder.</span></span>
<span class="line" id="L1995">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupe</span>(self: LazyPath, b: *Build) LazyPath {</span>
<span class="line" id="L1996">        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self) {</span>
<span class="line" id="L1997">            .path =&gt; |p| .{ .path = b.dupePath(p) },</span>
<span class="line" id="L1998">            .cwd_relative =&gt; |p| .{ .cwd_relative = b.dupePath(p) },</span>
<span class="line" id="L1999">            .generated =&gt; |gen| .{ .generated = gen },</span>
<span class="line" id="L2000">            .dependency =&gt; |dep| .{ .dependency = dep },</span>
<span class="line" id="L2001">        };</span>
<span class="line" id="L2002">    }</span>
<span class="line" id="L2003">};</span>
<span class="line" id="L2004"></span>
<span class="line" id="L2005"><span class="tok-comment">/// In this function the stderr mutex has already been locked.</span></span>
<span class="line" id="L2006"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpBadGetPathHelp</span>(</span>
<span class="line" id="L2007">    s: *Step,</span>
<span class="line" id="L2008">    stderr: fs.File,</span>
<span class="line" id="L2009">    src_builder: *Build,</span>
<span class="line" id="L2010">    asking_step: ?*Step,</span>
<span class="line" id="L2011">) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {</span>
<span class="line" id="L2012">    <span class="tok-kw">const</span> w = stderr.writer();</span>
<span class="line" id="L2013">    <span class="tok-kw">try</span> w.print(</span>
<span class="line" id="L2014">        <span class="tok-str">\\getPath() was called on a GeneratedFile that wasn't built yet.</span></span>

<span class="line" id="L2015">        <span class="tok-str">\\  source package path: {s}</span></span>

<span class="line" id="L2016">        <span class="tok-str">\\  Is there a missing Step dependency on step '{s}'?</span></span>

<span class="line" id="L2017">        <span class="tok-str">\\</span></span>

<span class="line" id="L2018">    , .{</span>
<span class="line" id="L2019">        src_builder.build_root.path <span class="tok-kw">orelse</span> <span class="tok-str">&quot;.&quot;</span>,</span>
<span class="line" id="L2020">        s.name,</span>
<span class="line" id="L2021">    });</span>
<span class="line" id="L2022"></span>
<span class="line" id="L2023">    <span class="tok-kw">const</span> tty_config = std.io.tty.detectConfig(stderr);</span>
<span class="line" id="L2024">    tty_config.setColor(w, .red) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L2025">    <span class="tok-kw">try</span> stderr.writeAll(<span class="tok-str">&quot;    The step was created by this stack trace:\n&quot;</span>);</span>
<span class="line" id="L2026">    tty_config.setColor(w, .reset) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L2027"></span>
<span class="line" id="L2028">    s.dump(stderr);</span>
<span class="line" id="L2029">    <span class="tok-kw">if</span> (asking_step) |as| {</span>
<span class="line" id="L2030">        tty_config.setColor(w, .red) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L2031">        <span class="tok-kw">try</span> stderr.writer().print(<span class="tok-str">&quot;    The step '{s}' that is missing a dependency on the above step was created by this stack trace:\n&quot;</span>, .{as.name});</span>
<span class="line" id="L2032">        tty_config.setColor(w, .reset) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L2033"></span>
<span class="line" id="L2034">        as.dump(stderr);</span>
<span class="line" id="L2035">    }</span>
<span class="line" id="L2036">    tty_config.setColor(w, .red) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L2037">    <span class="tok-kw">try</span> stderr.writeAll(<span class="tok-str">&quot;    Hope that helps. Proceeding to panic.\n&quot;</span>);</span>
<span class="line" id="L2038">    tty_config.setColor(w, .reset) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L2039">}</span>
<span class="line" id="L2040"></span>
<span class="line" id="L2041"><span class="tok-comment">/// Allocates a new string for assigning a value to a named macro.</span></span>
<span class="line" id="L2042"><span class="tok-comment">/// If the value is omitted, it is set to 1.</span></span>
<span class="line" id="L2043"><span class="tok-comment">/// `name` and `value` need not live longer than the function call.</span></span>
<span class="line" id="L2044"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">constructCMacro</span>(allocator: Allocator, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, value: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L2045">    <span class="tok-kw">var</span> macro = allocator.alloc(</span>
<span class="line" id="L2046">        <span class="tok-type">u8</span>,</span>
<span class="line" id="L2047">        name.len + <span class="tok-kw">if</span> (value) |value_slice| value_slice.len + <span class="tok-number">1</span> <span class="tok-kw">else</span> <span class="tok-number">0</span>,</span>
<span class="line" id="L2048">    ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">if</span> (err == <span class="tok-kw">error</span>.OutOfMemory) <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;Out of memory&quot;</span>) <span class="tok-kw">else</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L2049">    <span class="tok-builtin">@memcpy</span>(macro[<span class="tok-number">0</span>..name.len], name);</span>
<span class="line" id="L2050">    <span class="tok-kw">if</span> (value) |value_slice| {</span>
<span class="line" id="L2051">        macro[name.len] = <span class="tok-str">'='</span>;</span>
<span class="line" id="L2052">        <span class="tok-builtin">@memcpy</span>(macro[name.len + <span class="tok-number">1</span> ..][<span class="tok-number">0</span>..value_slice.len], value_slice);</span>
<span class="line" id="L2053">    }</span>
<span class="line" id="L2054">    <span class="tok-kw">return</span> macro;</span>
<span class="line" id="L2055">}</span>
<span class="line" id="L2056"></span>
<span class="line" id="L2057"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> VcpkgRoot = <span class="tok-kw">union</span>(VcpkgRootStatus) {</span>
<span class="line" id="L2058">    unattempted: <span class="tok-type">void</span>,</span>
<span class="line" id="L2059">    not_found: <span class="tok-type">void</span>,</span>
<span class="line" id="L2060">    found: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2061">};</span>
<span class="line" id="L2062"></span>
<span class="line" id="L2063"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> VcpkgRootStatus = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L2064">    unattempted,</span>
<span class="line" id="L2065">    not_found,</span>
<span class="line" id="L2066">    found,</span>
<span class="line" id="L2067">};</span>
<span class="line" id="L2068"></span>
<span class="line" id="L2069"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> InstallDir = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L2070">    prefix: <span class="tok-type">void</span>,</span>
<span class="line" id="L2071">    lib: <span class="tok-type">void</span>,</span>
<span class="line" id="L2072">    bin: <span class="tok-type">void</span>,</span>
<span class="line" id="L2073">    header: <span class="tok-type">void</span>,</span>
<span class="line" id="L2074">    <span class="tok-comment">/// A path relative to the prefix</span></span>
<span class="line" id="L2075">    custom: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2076"></span>
<span class="line" id="L2077">    <span class="tok-comment">/// Duplicates the install directory including the path if set to custom.</span></span>
<span class="line" id="L2078">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupe</span>(self: InstallDir, builder: *Build) InstallDir {</span>
<span class="line" id="L2079">        <span class="tok-kw">if</span> (self == .custom) {</span>
<span class="line" id="L2080">            <span class="tok-kw">return</span> .{ .custom = builder.dupe(self.custom) };</span>
<span class="line" id="L2081">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2082">            <span class="tok-kw">return</span> self;</span>
<span class="line" id="L2083">        }</span>
<span class="line" id="L2084">    }</span>
<span class="line" id="L2085">};</span>
<span class="line" id="L2086"></span>
<span class="line" id="L2087"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> InstalledFile = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2088">    dir: InstallDir,</span>
<span class="line" id="L2089">    path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2090"></span>
<span class="line" id="L2091">    <span class="tok-comment">/// Duplicates the installed file path and directory.</span></span>
<span class="line" id="L2092">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupe</span>(self: InstalledFile, builder: *Build) InstalledFile {</span>
<span class="line" id="L2093">        <span class="tok-kw">return</span> .{</span>
<span class="line" id="L2094">            .dir = self.dir.dupe(builder),</span>
<span class="line" id="L2095">            .path = builder.dupe(self.path),</span>
<span class="line" id="L2096">        };</span>
<span class="line" id="L2097">    }</span>
<span class="line" id="L2098">};</span>
<span class="line" id="L2099"></span>
<span class="line" id="L2100"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">serializeCpu</span>(allocator: Allocator, cpu: std.Target.Cpu) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L2101">    <span class="tok-comment">// TODO this logic can disappear if cpu model + features becomes part of the target triple</span>
</span>
<span class="line" id="L2102">    <span class="tok-kw">const</span> all_features = cpu.arch.allFeaturesList();</span>
<span class="line" id="L2103">    <span class="tok-kw">var</span> populated_cpu_features = cpu.model.features;</span>
<span class="line" id="L2104">    populated_cpu_features.populateDependencies(all_features);</span>
<span class="line" id="L2105"></span>
<span class="line" id="L2106">    <span class="tok-kw">if</span> (populated_cpu_features.eql(cpu.features)) {</span>
<span class="line" id="L2107">        <span class="tok-comment">// The CPU name alone is sufficient.</span>
</span>
<span class="line" id="L2108">        <span class="tok-kw">return</span> cpu.model.name;</span>
<span class="line" id="L2109">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2110">        <span class="tok-kw">var</span> mcpu_buffer = ArrayList(<span class="tok-type">u8</span>).init(allocator);</span>
<span class="line" id="L2111">        <span class="tok-kw">try</span> mcpu_buffer.appendSlice(cpu.model.name);</span>
<span class="line" id="L2112"></span>
<span class="line" id="L2113">        <span class="tok-kw">for</span> (all_features, <span class="tok-number">0</span>..) |feature, i_usize| {</span>
<span class="line" id="L2114">            <span class="tok-kw">const</span> i = <span class="tok-builtin">@as</span>(std.Target.Cpu.Feature.Set.Index, <span class="tok-builtin">@intCast</span>(i_usize));</span>
<span class="line" id="L2115">            <span class="tok-kw">const</span> in_cpu_set = populated_cpu_features.isEnabled(i);</span>
<span class="line" id="L2116">            <span class="tok-kw">const</span> in_actual_set = cpu.features.isEnabled(i);</span>
<span class="line" id="L2117">            <span class="tok-kw">if</span> (in_cpu_set <span class="tok-kw">and</span> !in_actual_set) {</span>
<span class="line" id="L2118">                <span class="tok-kw">try</span> mcpu_buffer.writer().print(<span class="tok-str">&quot;-{s}&quot;</span>, .{feature.name});</span>
<span class="line" id="L2119">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (!in_cpu_set <span class="tok-kw">and</span> in_actual_set) {</span>
<span class="line" id="L2120">                <span class="tok-kw">try</span> mcpu_buffer.writer().print(<span class="tok-str">&quot;+{s}&quot;</span>, .{feature.name});</span>
<span class="line" id="L2121">            }</span>
<span class="line" id="L2122">        }</span>
<span class="line" id="L2123"></span>
<span class="line" id="L2124">        <span class="tok-kw">return</span> <span class="tok-kw">try</span> mcpu_buffer.toOwnedSlice();</span>
<span class="line" id="L2125">    }</span>
<span class="line" id="L2126">}</span>
<span class="line" id="L2127"></span>
<span class="line" id="L2128"><span class="tok-comment">/// This function is intended to be called in the `configure` phase only.</span></span>
<span class="line" id="L2129"><span class="tok-comment">/// It returns an absolute directory path, which is potentially going to be a</span></span>
<span class="line" id="L2130"><span class="tok-comment">/// source of API breakage in the future, so keep that in mind when using this</span></span>
<span class="line" id="L2131"><span class="tok-comment">/// function.</span></span>
<span class="line" id="L2132"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeTempPath</span>(b: *Build) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L2133">    <span class="tok-kw">const</span> rand_int = std.crypto.random.int(<span class="tok-type">u64</span>);</span>
<span class="line" id="L2134">    <span class="tok-kw">const</span> tmp_dir_sub_path = <span class="tok-str">&quot;tmp&quot;</span> ++ fs.path.sep_str ++ hex64(rand_int);</span>
<span class="line" id="L2135">    <span class="tok-kw">const</span> result_path = b.cache_root.join(b.allocator, &amp;.{tmp_dir_sub_path}) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L2136">    b.cache_root.handle.makePath(tmp_dir_sub_path) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L2137">        std.debug.print(<span class="tok-str">&quot;unable to make tmp path '{s}': {s}\n&quot;</span>, .{</span>
<span class="line" id="L2138">            result_path, <span class="tok-builtin">@errorName</span>(err),</span>
<span class="line" id="L2139">        });</span>
<span class="line" id="L2140">    };</span>
<span class="line" id="L2141">    <span class="tok-kw">return</span> result_path;</span>
<span class="line" id="L2142">}</span>
<span class="line" id="L2143"></span>
<span class="line" id="L2144"><span class="tok-comment">/// There are a few copies of this function in miscellaneous places. Would be nice to find</span></span>
<span class="line" id="L2145"><span class="tok-comment">/// a home for them.</span></span>
<span class="line" id="L2146"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hex64</span>(x: <span class="tok-type">u64</span>) [<span class="tok-number">16</span>]<span class="tok-type">u8</span> {</span>
<span class="line" id="L2147">    <span class="tok-kw">const</span> hex_charset = <span class="tok-str">&quot;0123456789abcdef&quot;</span>;</span>
<span class="line" id="L2148">    <span class="tok-kw">var</span> result: [<span class="tok-number">16</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L2149">    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2150">    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">8</span>) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L2151">        <span class="tok-kw">const</span> byte: <span class="tok-type">u8</span> = <span class="tok-builtin">@truncate</span>(x &gt;&gt; <span class="tok-builtin">@as</span>(<span class="tok-type">u6</span>, <span class="tok-builtin">@intCast</span>(<span class="tok-number">8</span> * i)));</span>
<span class="line" id="L2152">        result[i * <span class="tok-number">2</span> + <span class="tok-number">0</span>] = hex_charset[byte &gt;&gt; <span class="tok-number">4</span>];</span>
<span class="line" id="L2153">        result[i * <span class="tok-number">2</span> + <span class="tok-number">1</span>] = hex_charset[byte &amp; <span class="tok-number">15</span>];</span>
<span class="line" id="L2154">    }</span>
<span class="line" id="L2155">    <span class="tok-kw">return</span> result;</span>
<span class="line" id="L2156">}</span>
<span class="line" id="L2157"></span>
<span class="line" id="L2158"><span class="tok-kw">test</span> {</span>
<span class="line" id="L2159">    _ = Cache;</span>
<span class="line" id="L2160">    _ = Step;</span>
<span class="line" id="L2161">}</span>
<span class="line" id="L2162"></span>
</code></pre></body>
</html>