<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Build/Cache.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg==">
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-comment">//! Manages `zig-cache` directories.</span></span>
<span class="line" id="L2"><span class="tok-comment">//! This is not a general-purpose cache. It is designed to be fast and simple,</span></span>
<span class="line" id="L3"><span class="tok-comment">//! not to withstand attacks using specially-crafted input.</span></span>
<span class="line" id="L4"></span>
<span class="line" id="L5"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Directory = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L6">    <span class="tok-comment">/// This field is redundant for operations that can act on the open directory handle</span></span>
<span class="line" id="L7">    <span class="tok-comment">/// directly, but it is needed when passing the directory to a child process.</span></span>
<span class="line" id="L8">    <span class="tok-comment">/// `null` means cwd.</span></span>
<span class="line" id="L9">    path: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L10">    handle: fs.Dir,</span>
<span class="line" id="L11"></span>
<span class="line" id="L12">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(d: Directory, arena: Allocator) Allocator.Error!Directory {</span>
<span class="line" id="L13">        <span class="tok-kw">return</span> .{</span>
<span class="line" id="L14">            .path = <span class="tok-kw">if</span> (d.path) |p| <span class="tok-kw">try</span> arena.dupe(<span class="tok-type">u8</span>, p) <span class="tok-kw">else</span> <span class="tok-null">null</span>,</span>
<span class="line" id="L15">            .handle = d.handle,</span>
<span class="line" id="L16">        };</span>
<span class="line" id="L17">    }</span>
<span class="line" id="L18"></span>
<span class="line" id="L19">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cwd</span>() Directory {</span>
<span class="line" id="L20">        <span class="tok-kw">return</span> .{</span>
<span class="line" id="L21">            .path = <span class="tok-null">null</span>,</span>
<span class="line" id="L22">            .handle = fs.cwd(),</span>
<span class="line" id="L23">        };</span>
<span class="line" id="L24">    }</span>
<span class="line" id="L25"></span>
<span class="line" id="L26">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">join</span>(self: Directory, allocator: Allocator, paths: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L27">        <span class="tok-kw">if</span> (self.path) |p| {</span>
<span class="line" id="L28">            <span class="tok-comment">// TODO clean way to do this with only 1 allocation</span>
</span>
<span class="line" id="L29">            <span class="tok-kw">const</span> part2 = <span class="tok-kw">try</span> fs.path.join(allocator, paths);</span>
<span class="line" id="L30">            <span class="tok-kw">defer</span> allocator.free(part2);</span>
<span class="line" id="L31">            <span class="tok-kw">return</span> fs.path.join(allocator, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ p, part2 });</span>
<span class="line" id="L32">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L33">            <span class="tok-kw">return</span> fs.path.join(allocator, paths);</span>
<span class="line" id="L34">        }</span>
<span class="line" id="L35">    }</span>
<span class="line" id="L36"></span>
<span class="line" id="L37">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">joinZ</span>(self: Directory, allocator: Allocator, paths: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![:<span class="tok-number">0</span>]<span class="tok-type">u8</span> {</span>
<span class="line" id="L38">        <span class="tok-kw">if</span> (self.path) |p| {</span>
<span class="line" id="L39">            <span class="tok-comment">// TODO clean way to do this with only 1 allocation</span>
</span>
<span class="line" id="L40">            <span class="tok-kw">const</span> part2 = <span class="tok-kw">try</span> fs.path.join(allocator, paths);</span>
<span class="line" id="L41">            <span class="tok-kw">defer</span> allocator.free(part2);</span>
<span class="line" id="L42">            <span class="tok-kw">return</span> fs.path.joinZ(allocator, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ p, part2 });</span>
<span class="line" id="L43">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L44">            <span class="tok-kw">return</span> fs.path.joinZ(allocator, paths);</span>
<span class="line" id="L45">        }</span>
<span class="line" id="L46">    }</span>
<span class="line" id="L47"></span>
<span class="line" id="L48">    <span class="tok-comment">/// Whether or not the handle should be closed, or the path should be freed</span></span>
<span class="line" id="L49">    <span class="tok-comment">/// is determined by usage, however this function is provided for convenience</span></span>
<span class="line" id="L50">    <span class="tok-comment">/// if it happens to be what the caller needs.</span></span>
<span class="line" id="L51">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">closeAndFree</span>(self: *Directory, gpa: Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L52">        self.handle.close();</span>
<span class="line" id="L53">        <span class="tok-kw">if</span> (self.path) |p| gpa.free(p);</span>
<span class="line" id="L54">        self.* = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L55">    }</span>
<span class="line" id="L56"></span>
<span class="line" id="L57">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(</span>
<span class="line" id="L58">        self: Directory,</span>
<span class="line" id="L59">        <span class="tok-kw">comptime</span> fmt_string: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L60">        options: fmt.FormatOptions,</span>
<span class="line" id="L61">        writer: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L62">    ) !<span class="tok-type">void</span> {</span>
<span class="line" id="L63">        _ = options;</span>
<span class="line" id="L64">        <span class="tok-kw">if</span> (fmt_string.len != <span class="tok-number">0</span>) fmt.invalidFmtError(fmt_string, self);</span>
<span class="line" id="L65">        <span class="tok-kw">if</span> (self.path) |p| {</span>
<span class="line" id="L66">            <span class="tok-kw">try</span> writer.writeAll(p);</span>
<span class="line" id="L67">            <span class="tok-kw">try</span> writer.writeAll(fs.path.sep_str);</span>
<span class="line" id="L68">        }</span>
<span class="line" id="L69">    }</span>
<span class="line" id="L70"></span>
<span class="line" id="L71">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(self: Directory, other: Directory) <span class="tok-type">bool</span> {</span>
<span class="line" id="L72">        <span class="tok-kw">return</span> self.handle.fd == other.handle.fd;</span>
<span class="line" id="L73">    }</span>
<span class="line" id="L74">};</span>
<span class="line" id="L75"></span>
<span class="line" id="L76">gpa: Allocator,</span>
<span class="line" id="L77">manifest_dir: fs.Dir,</span>
<span class="line" id="L78">hash: HashHelper = .{},</span>
<span class="line" id="L79"><span class="tok-comment">/// This value is accessed from multiple threads, protected by mutex.</span></span>
<span class="line" id="L80">recent_problematic_timestamp: <span class="tok-type">i128</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L81">mutex: std.Thread.Mutex = .{},</span>
<span class="line" id="L82"></span>
<span class="line" id="L83"><span class="tok-comment">/// A set of strings such as the zig library directory or project source root, which</span></span>
<span class="line" id="L84"><span class="tok-comment">/// are stripped from the file paths before putting into the cache. They</span></span>
<span class="line" id="L85"><span class="tok-comment">/// are replaced with single-character indicators. This is not to save</span></span>
<span class="line" id="L86"><span class="tok-comment">/// space but to eliminate absolute file paths. This improves portability</span></span>
<span class="line" id="L87"><span class="tok-comment">/// and usefulness of the cache for advanced use cases.</span></span>
<span class="line" id="L88">prefixes_buffer: [<span class="tok-number">4</span>]Directory = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L89">prefixes_len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L90"></span>
<span class="line" id="L91"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DepTokenizer = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Cache/DepTokenizer.zig&quot;</span>);</span>
<span class="line" id="L92"></span>
<span class="line" id="L93"><span class="tok-kw">const</span> Cache = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L94"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);</span>
<span class="line" id="L95"><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);</span>
<span class="line" id="L96"><span class="tok-kw">const</span> crypto = std.crypto;</span>
<span class="line" id="L97"><span class="tok-kw">const</span> fs = std.fs;</span>
<span class="line" id="L98"><span class="tok-kw">const</span> assert = std.debug.assert;</span>
<span class="line" id="L99"><span class="tok-kw">const</span> testing = std.testing;</span>
<span class="line" id="L100"><span class="tok-kw">const</span> mem = std.mem;</span>
<span class="line" id="L101"><span class="tok-kw">const</span> fmt = std.fmt;</span>
<span class="line" id="L102"><span class="tok-kw">const</span> Allocator = std.mem.Allocator;</span>
<span class="line" id="L103"><span class="tok-kw">const</span> log = std.log.scoped(.cache);</span>
<span class="line" id="L104"></span>
<span class="line" id="L105"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addPrefix</span>(cache: *Cache, directory: Directory) <span class="tok-type">void</span> {</span>
<span class="line" id="L106">    cache.prefixes_buffer[cache.prefixes_len] = directory;</span>
<span class="line" id="L107">    cache.prefixes_len += <span class="tok-number">1</span>;</span>
<span class="line" id="L108">}</span>
<span class="line" id="L109"></span>
<span class="line" id="L110"><span class="tok-comment">/// Be sure to call `Manifest.deinit` after successful initialization.</span></span>
<span class="line" id="L111"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">obtain</span>(cache: *Cache) Manifest {</span>
<span class="line" id="L112">    <span class="tok-kw">return</span> Manifest{</span>
<span class="line" id="L113">        .cache = cache,</span>
<span class="line" id="L114">        .hash = cache.hash,</span>
<span class="line" id="L115">        .manifest_file = <span class="tok-null">null</span>,</span>
<span class="line" id="L116">        .manifest_dirty = <span class="tok-null">false</span>,</span>
<span class="line" id="L117">        .hex_digest = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L118">    };</span>
<span class="line" id="L119">}</span>
<span class="line" id="L120"></span>
<span class="line" id="L121"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">prefixes</span>(cache: *<span class="tok-kw">const</span> Cache) []<span class="tok-kw">const</span> Directory {</span>
<span class="line" id="L122">    <span class="tok-kw">return</span> cache.prefixes_buffer[<span class="tok-number">0</span>..cache.prefixes_len];</span>
<span class="line" id="L123">}</span>
<span class="line" id="L124"></span>
<span class="line" id="L125"><span class="tok-kw">const</span> PrefixedPath = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L126">    prefix: <span class="tok-type">u8</span>,</span>
<span class="line" id="L127">    sub_path: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L128">};</span>
<span class="line" id="L129"></span>
<span class="line" id="L130"><span class="tok-kw">fn</span> <span class="tok-fn">findPrefix</span>(cache: *<span class="tok-kw">const</span> Cache, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !PrefixedPath {</span>
<span class="line" id="L131">    <span class="tok-kw">const</span> gpa = cache.gpa;</span>
<span class="line" id="L132">    <span class="tok-kw">const</span> resolved_path = <span class="tok-kw">try</span> fs.path.resolve(gpa, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{file_path});</span>
<span class="line" id="L133">    <span class="tok-kw">errdefer</span> gpa.free(resolved_path);</span>
<span class="line" id="L134">    <span class="tok-kw">return</span> findPrefixResolved(cache, resolved_path);</span>
<span class="line" id="L135">}</span>
<span class="line" id="L136"></span>
<span class="line" id="L137"><span class="tok-comment">/// Takes ownership of `resolved_path` on success.</span></span>
<span class="line" id="L138"><span class="tok-kw">fn</span> <span class="tok-fn">findPrefixResolved</span>(cache: *<span class="tok-kw">const</span> Cache, resolved_path: []<span class="tok-type">u8</span>) !PrefixedPath {</span>
<span class="line" id="L139">    <span class="tok-kw">const</span> gpa = cache.gpa;</span>
<span class="line" id="L140">    <span class="tok-kw">const</span> prefixes_slice = cache.prefixes();</span>
<span class="line" id="L141">    <span class="tok-kw">var</span> i: <span class="tok-type">u8</span> = <span class="tok-number">1</span>; <span class="tok-comment">// Start at 1 to skip over checking the null prefix.</span>
</span>
<span class="line" id="L142">    <span class="tok-kw">while</span> (i &lt; prefixes_slice.len) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L143">        <span class="tok-kw">const</span> p = prefixes_slice[i].path.?;</span>
<span class="line" id="L144">        <span class="tok-kw">var</span> sub_path = getPrefixSubpath(gpa, p, resolved_path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L145">            <span class="tok-kw">error</span>.NotASubPath =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L146">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L147">        };</span>
<span class="line" id="L148">        <span class="tok-comment">// Free the resolved path since we're not going to return it</span>
</span>
<span class="line" id="L149">        gpa.free(resolved_path);</span>
<span class="line" id="L150">        <span class="tok-kw">return</span> PrefixedPath{</span>
<span class="line" id="L151">            .prefix = i,</span>
<span class="line" id="L152">            .sub_path = sub_path,</span>
<span class="line" id="L153">        };</span>
<span class="line" id="L154">    }</span>
<span class="line" id="L155"></span>
<span class="line" id="L156">    <span class="tok-kw">return</span> PrefixedPath{</span>
<span class="line" id="L157">        .prefix = <span class="tok-number">0</span>,</span>
<span class="line" id="L158">        .sub_path = resolved_path,</span>
<span class="line" id="L159">    };</span>
<span class="line" id="L160">}</span>
<span class="line" id="L161"></span>
<span class="line" id="L162"><span class="tok-kw">fn</span> <span class="tok-fn">getPrefixSubpath</span>(allocator: Allocator, prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, path: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L163">    <span class="tok-kw">const</span> relative = <span class="tok-kw">try</span> std.fs.path.relative(allocator, prefix, path);</span>
<span class="line" id="L164">    <span class="tok-kw">errdefer</span> allocator.free(relative);</span>
<span class="line" id="L165">    <span class="tok-kw">var</span> component_iterator = std.fs.path.NativeUtf8ComponentIterator.init(relative) <span class="tok-kw">catch</span> {</span>
<span class="line" id="L166">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotASubPath;</span>
<span class="line" id="L167">    };</span>
<span class="line" id="L168">    <span class="tok-kw">if</span> (component_iterator.root() != <span class="tok-null">null</span>) {</span>
<span class="line" id="L169">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotASubPath;</span>
<span class="line" id="L170">    }</span>
<span class="line" id="L171">    <span class="tok-kw">const</span> first_component = component_iterator.first();</span>
<span class="line" id="L172">    <span class="tok-kw">if</span> (first_component != <span class="tok-null">null</span> <span class="tok-kw">and</span> std.mem.eql(<span class="tok-type">u8</span>, first_component.?.name, <span class="tok-str">&quot;..&quot;</span>)) {</span>
<span class="line" id="L173">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotASubPath;</span>
<span class="line" id="L174">    }</span>
<span class="line" id="L175">    <span class="tok-kw">return</span> relative;</span>
<span class="line" id="L176">}</span>
<span class="line" id="L177"></span>
<span class="line" id="L178"><span class="tok-comment">/// This is 128 bits - Even with 2^54 cache entries, the probably of a collision would be under 10^-6</span></span>
<span class="line" id="L179"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> bin_digest_len = <span class="tok-number">16</span>;</span>
<span class="line" id="L180"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> hex_digest_len = bin_digest_len * <span class="tok-number">2</span>;</span>
<span class="line" id="L181"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> BinDigest = [bin_digest_len]<span class="tok-type">u8</span>;</span>
<span class="line" id="L182"></span>
<span class="line" id="L183"><span class="tok-comment">/// This is currently just an arbitrary non-empty string that can't match another manifest line.</span></span>
<span class="line" id="L184"><span class="tok-kw">const</span> manifest_header = <span class="tok-str">&quot;0&quot;</span>;</span>
<span class="line" id="L185"><span class="tok-kw">const</span> manifest_file_size_max = <span class="tok-number">50</span> * <span class="tok-number">1024</span> * <span class="tok-number">1024</span>;</span>
<span class="line" id="L186"></span>
<span class="line" id="L187"><span class="tok-comment">/// The type used for hashing file contents. Currently, this is SipHash128(1, 3), because it</span></span>
<span class="line" id="L188"><span class="tok-comment">/// provides enough collision resistance for the Manifest use cases, while being one of our</span></span>
<span class="line" id="L189"><span class="tok-comment">/// fastest options right now.</span></span>
<span class="line" id="L190"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hasher = crypto.auth.siphash.SipHash128(<span class="tok-number">1</span>, <span class="tok-number">3</span>);</span>
<span class="line" id="L191"></span>
<span class="line" id="L192"><span class="tok-comment">/// Initial state with random bytes, that can be copied.</span></span>
<span class="line" id="L193"><span class="tok-comment">/// Refresh this with new random bytes when the manifest</span></span>
<span class="line" id="L194"><span class="tok-comment">/// format is modified in a non-backwards-compatible way.</span></span>
<span class="line" id="L195"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> hasher_init: Hasher = Hasher.init(&amp;[_]<span class="tok-type">u8</span>{</span>
<span class="line" id="L196">    <span class="tok-number">0x33</span>, <span class="tok-number">0x52</span>, <span class="tok-number">0xa2</span>, <span class="tok-number">0x84</span>,</span>
<span class="line" id="L197">    <span class="tok-number">0xcf</span>, <span class="tok-number">0x17</span>, <span class="tok-number">0x56</span>, <span class="tok-number">0x57</span>,</span>
<span class="line" id="L198">    <span class="tok-number">0x01</span>, <span class="tok-number">0xbb</span>, <span class="tok-number">0xcd</span>, <span class="tok-number">0xe4</span>,</span>
<span class="line" id="L199">    <span class="tok-number">0x77</span>, <span class="tok-number">0xd6</span>, <span class="tok-number">0xf0</span>, <span class="tok-number">0x60</span>,</span>
<span class="line" id="L200">});</span>
<span class="line" id="L201"></span>
<span class="line" id="L202"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> File = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L203">    prefixed_path: ?PrefixedPath,</span>
<span class="line" id="L204">    max_file_size: ?<span class="tok-type">usize</span>,</span>
<span class="line" id="L205">    stat: Stat,</span>
<span class="line" id="L206">    bin_digest: BinDigest,</span>
<span class="line" id="L207">    contents: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L208"></span>
<span class="line" id="L209">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Stat = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L210">        inode: fs.File.INode,</span>
<span class="line" id="L211">        size: <span class="tok-type">u64</span>,</span>
<span class="line" id="L212">        mtime: <span class="tok-type">i128</span>,</span>
<span class="line" id="L213">    };</span>
<span class="line" id="L214"></span>
<span class="line" id="L215">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *File, gpa: Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L216">        <span class="tok-kw">if</span> (self.prefixed_path) |pp| {</span>
<span class="line" id="L217">            gpa.free(pp.sub_path);</span>
<span class="line" id="L218">            self.prefixed_path = <span class="tok-null">null</span>;</span>
<span class="line" id="L219">        }</span>
<span class="line" id="L220">        <span class="tok-kw">if</span> (self.contents) |contents| {</span>
<span class="line" id="L221">            gpa.free(contents);</span>
<span class="line" id="L222">            self.contents = <span class="tok-null">null</span>;</span>
<span class="line" id="L223">        }</span>
<span class="line" id="L224">        self.* = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L225">    }</span>
<span class="line" id="L226">};</span>
<span class="line" id="L227"></span>
<span class="line" id="L228"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> HashHelper = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L229">    hasher: Hasher = hasher_init,</span>
<span class="line" id="L230"></span>
<span class="line" id="L231">    <span class="tok-comment">/// Record a slice of bytes as a dependency of the process being cached.</span></span>
<span class="line" id="L232">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addBytes</span>(hh: *HashHelper, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L233">        hh.hasher.update(mem.asBytes(&amp;bytes.len));</span>
<span class="line" id="L234">        hh.hasher.update(bytes);</span>
<span class="line" id="L235">    }</span>
<span class="line" id="L236"></span>
<span class="line" id="L237">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOptionalBytes</span>(hh: *HashHelper, optional_bytes: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L238">        hh.add(optional_bytes != <span class="tok-null">null</span>);</span>
<span class="line" id="L239">        hh.addBytes(optional_bytes <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>);</span>
<span class="line" id="L240">    }</span>
<span class="line" id="L241"></span>
<span class="line" id="L242">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addListOfBytes</span>(hh: *HashHelper, list_of_bytes: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L243">        hh.add(list_of_bytes.len);</span>
<span class="line" id="L244">        <span class="tok-kw">for</span> (list_of_bytes) |bytes| hh.addBytes(bytes);</span>
<span class="line" id="L245">    }</span>
<span class="line" id="L246"></span>
<span class="line" id="L247">    <span class="tok-comment">/// Convert the input value into bytes and record it as a dependency of the process being cached.</span></span>
<span class="line" id="L248">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(hh: *HashHelper, x: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L249">        <span class="tok-kw">switch</span> (<span class="tok-builtin">@TypeOf</span>(x)) {</span>
<span class="line" id="L250">            std.SemanticVersion =&gt; {</span>
<span class="line" id="L251">                hh.add(x.major);</span>
<span class="line" id="L252">                hh.add(x.minor);</span>
<span class="line" id="L253">                hh.add(x.patch);</span>
<span class="line" id="L254">            },</span>
<span class="line" id="L255">            std.Target.Os.TaggedVersionRange =&gt; {</span>
<span class="line" id="L256">                <span class="tok-kw">switch</span> (x) {</span>
<span class="line" id="L257">                    .linux =&gt; |linux| {</span>
<span class="line" id="L258">                        hh.add(linux.range.min);</span>
<span class="line" id="L259">                        hh.add(linux.range.max);</span>
<span class="line" id="L260">                        hh.add(linux.glibc);</span>
<span class="line" id="L261">                    },</span>
<span class="line" id="L262">                    .windows =&gt; |windows| {</span>
<span class="line" id="L263">                        hh.add(windows.min);</span>
<span class="line" id="L264">                        hh.add(windows.max);</span>
<span class="line" id="L265">                    },</span>
<span class="line" id="L266">                    .semver =&gt; |semver| {</span>
<span class="line" id="L267">                        hh.add(semver.min);</span>
<span class="line" id="L268">                        hh.add(semver.max);</span>
<span class="line" id="L269">                    },</span>
<span class="line" id="L270">                    .none =&gt; {},</span>
<span class="line" id="L271">                }</span>
<span class="line" id="L272">            },</span>
<span class="line" id="L273">            std.Build.Step.Compile.BuildId =&gt; <span class="tok-kw">switch</span> (x) {</span>
<span class="line" id="L274">                .none, .fast, .uuid, .sha1, .md5 =&gt; hh.add(std.meta.activeTag(x)),</span>
<span class="line" id="L275">                .hexstring =&gt; |hex_string| hh.addBytes(hex_string.toSlice()),</span>
<span class="line" id="L276">            },</span>
<span class="line" id="L277">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(x))) {</span>
<span class="line" id="L278">                .Bool, .Int, .Enum, .Array =&gt; hh.addBytes(mem.asBytes(&amp;x)),</span>
<span class="line" id="L279">                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unable to hash type &quot;</span> ++ <span class="tok-builtin">@typeName</span>(<span class="tok-builtin">@TypeOf</span>(x))),</span>
<span class="line" id="L280">            },</span>
<span class="line" id="L281">        }</span>
<span class="line" id="L282">    }</span>
<span class="line" id="L283"></span>
<span class="line" id="L284">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOptional</span>(hh: *HashHelper, optional: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L285">        hh.add(optional != <span class="tok-null">null</span>);</span>
<span class="line" id="L286">        hh.add(optional <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>);</span>
<span class="line" id="L287">    }</span>
<span class="line" id="L288"></span>
<span class="line" id="L289">    <span class="tok-comment">/// Returns a hex encoded hash of the inputs, without modifying state.</span></span>
<span class="line" id="L290">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peek</span>(hh: HashHelper) [hex_digest_len]<span class="tok-type">u8</span> {</span>
<span class="line" id="L291">        <span class="tok-kw">var</span> copy = hh;</span>
<span class="line" id="L292">        <span class="tok-kw">return</span> copy.final();</span>
<span class="line" id="L293">    }</span>
<span class="line" id="L294"></span>
<span class="line" id="L295">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peekBin</span>(hh: HashHelper) BinDigest {</span>
<span class="line" id="L296">        <span class="tok-kw">var</span> copy = hh;</span>
<span class="line" id="L297">        <span class="tok-kw">var</span> bin_digest: BinDigest = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L298">        copy.hasher.final(&amp;bin_digest);</span>
<span class="line" id="L299">        <span class="tok-kw">return</span> bin_digest;</span>
<span class="line" id="L300">    }</span>
<span class="line" id="L301"></span>
<span class="line" id="L302">    <span class="tok-comment">/// Returns a hex encoded hash of the inputs, mutating the state of the hasher.</span></span>
<span class="line" id="L303">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">final</span>(hh: *HashHelper) [hex_digest_len]<span class="tok-type">u8</span> {</span>
<span class="line" id="L304">        <span class="tok-kw">var</span> bin_digest: BinDigest = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L305">        hh.hasher.final(&amp;bin_digest);</span>
<span class="line" id="L306"></span>
<span class="line" id="L307">        <span class="tok-kw">var</span> out_digest: [hex_digest_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L308">        _ = fmt.bufPrint(</span>
<span class="line" id="L309">            &amp;out_digest,</span>
<span class="line" id="L310">            <span class="tok-str">&quot;{s}&quot;</span>,</span>
<span class="line" id="L311">            .{fmt.fmtSliceHexLower(&amp;bin_digest)},</span>
<span class="line" id="L312">        ) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L313">        <span class="tok-kw">return</span> out_digest;</span>
<span class="line" id="L314">    }</span>
<span class="line" id="L315">};</span>
<span class="line" id="L316"></span>
<span class="line" id="L317"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Lock = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L318">    manifest_file: fs.File,</span>
<span class="line" id="L319"></span>
<span class="line" id="L320">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">release</span>(lock: *Lock) <span class="tok-type">void</span> {</span>
<span class="line" id="L321">        <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L322">            <span class="tok-comment">// Windows does not guarantee that locks are immediately unlocked when</span>
</span>
<span class="line" id="L323">            <span class="tok-comment">// the file handle is closed. See LockFileEx documentation.</span>
</span>
<span class="line" id="L324">            lock.manifest_file.unlock();</span>
<span class="line" id="L325">        }</span>
<span class="line" id="L326"></span>
<span class="line" id="L327">        lock.manifest_file.close();</span>
<span class="line" id="L328">        lock.* = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L329">    }</span>
<span class="line" id="L330">};</span>
<span class="line" id="L331"></span>
<span class="line" id="L332"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Manifest = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L333">    cache: *Cache,</span>
<span class="line" id="L334">    <span class="tok-comment">/// Current state for incremental hashing.</span></span>
<span class="line" id="L335">    hash: HashHelper,</span>
<span class="line" id="L336">    manifest_file: ?fs.File,</span>
<span class="line" id="L337">    manifest_dirty: <span class="tok-type">bool</span>,</span>
<span class="line" id="L338">    <span class="tok-comment">/// Set this flag to true before calling hit() in order to indicate that</span></span>
<span class="line" id="L339">    <span class="tok-comment">/// upon a cache hit, the code using the cache will not modify the files</span></span>
<span class="line" id="L340">    <span class="tok-comment">/// within the cache directory. This allows multiple processes to utilize</span></span>
<span class="line" id="L341">    <span class="tok-comment">/// the same cache directory at the same time.</span></span>
<span class="line" id="L342">    want_shared_lock: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,</span>
<span class="line" id="L343">    have_exclusive_lock: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L344">    <span class="tok-comment">// Indicate that we want isProblematicTimestamp to perform a filesystem write in</span>
</span>
<span class="line" id="L345">    <span class="tok-comment">// order to obtain a problematic timestamp for the next call. Calls after that</span>
</span>
<span class="line" id="L346">    <span class="tok-comment">// will then use the same timestamp, to avoid unnecessary filesystem writes.</span>
</span>
<span class="line" id="L347">    want_refresh_timestamp: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,</span>
<span class="line" id="L348">    files: std.ArrayListUnmanaged(File) = .{},</span>
<span class="line" id="L349">    hex_digest: [hex_digest_len]<span class="tok-type">u8</span>,</span>
<span class="line" id="L350">    <span class="tok-comment">/// Populated when hit() returns an error because of one</span></span>
<span class="line" id="L351">    <span class="tok-comment">/// of the files listed in the manifest.</span></span>
<span class="line" id="L352">    failed_file_index: ?<span class="tok-type">usize</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L353">    <span class="tok-comment">/// Keeps track of the last time we performed a file system write to observe</span></span>
<span class="line" id="L354">    <span class="tok-comment">/// what time the file system thinks it is, according to its own granularity.</span></span>
<span class="line" id="L355">    recent_problematic_timestamp: <span class="tok-type">i128</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L356"></span>
<span class="line" id="L357">    <span class="tok-comment">/// Add a file as a dependency of process being cached. When `hit` is</span></span>
<span class="line" id="L358">    <span class="tok-comment">/// called, the file's contents will be checked to ensure that it matches</span></span>
<span class="line" id="L359">    <span class="tok-comment">/// the contents from previous times.</span></span>
<span class="line" id="L360">    <span class="tok-comment">///</span></span>
<span class="line" id="L361">    <span class="tok-comment">/// Max file size will be used to determine the amount of space the file contents</span></span>
<span class="line" id="L362">    <span class="tok-comment">/// are allowed to take up in memory. If max_file_size is null, then the contents</span></span>
<span class="line" id="L363">    <span class="tok-comment">/// will not be loaded into memory.</span></span>
<span class="line" id="L364">    <span class="tok-comment">///</span></span>
<span class="line" id="L365">    <span class="tok-comment">/// Returns the index of the entry in the `files` array list. You can use it</span></span>
<span class="line" id="L366">    <span class="tok-comment">/// to access the contents of the file after calling `hit()` like so:</span></span>
<span class="line" id="L367">    <span class="tok-comment">///</span></span>
<span class="line" id="L368">    <span class="tok-comment">/// ```</span></span>
<span class="line" id="L369">    <span class="tok-comment">/// var file_contents = cache_hash.files.items[file_index].contents.?;</span></span>
<span class="line" id="L370">    <span class="tok-comment">/// ```</span></span>
<span class="line" id="L371">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFile</span>(self: *Manifest, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, max_file_size: ?<span class="tok-type">usize</span>) !<span class="tok-type">usize</span> {</span>
<span class="line" id="L372">        assert(self.manifest_file == <span class="tok-null">null</span>);</span>
<span class="line" id="L373"></span>
<span class="line" id="L374">        <span class="tok-kw">const</span> gpa = self.cache.gpa;</span>
<span class="line" id="L375">        <span class="tok-kw">try</span> self.files.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L376">        <span class="tok-kw">const</span> prefixed_path = <span class="tok-kw">try</span> self.cache.findPrefix(file_path);</span>
<span class="line" id="L377">        <span class="tok-kw">errdefer</span> gpa.free(prefixed_path.sub_path);</span>
<span class="line" id="L378"></span>
<span class="line" id="L379">        self.files.addOneAssumeCapacity().* = .{</span>
<span class="line" id="L380">            .prefixed_path = prefixed_path,</span>
<span class="line" id="L381">            .contents = <span class="tok-null">null</span>,</span>
<span class="line" id="L382">            .max_file_size = max_file_size,</span>
<span class="line" id="L383">            .stat = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L384">            .bin_digest = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L385">        };</span>
<span class="line" id="L386"></span>
<span class="line" id="L387">        self.hash.add(prefixed_path.prefix);</span>
<span class="line" id="L388">        self.hash.addBytes(prefixed_path.sub_path);</span>
<span class="line" id="L389"></span>
<span class="line" id="L390">        <span class="tok-kw">return</span> self.files.items.len - <span class="tok-number">1</span>;</span>
<span class="line" id="L391">    }</span>
<span class="line" id="L392"></span>
<span class="line" id="L393">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOptionalFile</span>(self: *Manifest, optional_file_path: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L394">        self.hash.add(optional_file_path != <span class="tok-null">null</span>);</span>
<span class="line" id="L395">        <span class="tok-kw">const</span> file_path = optional_file_path <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L396">        _ = <span class="tok-kw">try</span> self.addFile(file_path, <span class="tok-null">null</span>);</span>
<span class="line" id="L397">    }</span>
<span class="line" id="L398"></span>
<span class="line" id="L399">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addListOfFiles</span>(self: *Manifest, list_of_files: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L400">        self.hash.add(list_of_files.len);</span>
<span class="line" id="L401">        <span class="tok-kw">for</span> (list_of_files) |file_path| {</span>
<span class="line" id="L402">            _ = <span class="tok-kw">try</span> self.addFile(file_path, <span class="tok-null">null</span>);</span>
<span class="line" id="L403">        }</span>
<span class="line" id="L404">    }</span>
<span class="line" id="L405"></span>
<span class="line" id="L406">    <span class="tok-comment">/// Check the cache to see if the input exists in it. If it exists, returns `true`.</span></span>
<span class="line" id="L407">    <span class="tok-comment">/// A hex encoding of its hash is available by calling `final`.</span></span>
<span class="line" id="L408">    <span class="tok-comment">///</span></span>
<span class="line" id="L409">    <span class="tok-comment">/// This function will also acquire an exclusive lock to the manifest file. This means</span></span>
<span class="line" id="L410">    <span class="tok-comment">/// that a process holding a Manifest will block any other process attempting to</span></span>
<span class="line" id="L411">    <span class="tok-comment">/// acquire the lock. If `want_shared_lock` is `true`, a cache hit guarantees the</span></span>
<span class="line" id="L412">    <span class="tok-comment">/// manifest file to be locked in shared mode, and a cache miss guarantees the manifest</span></span>
<span class="line" id="L413">    <span class="tok-comment">/// file to be locked in exclusive mode.</span></span>
<span class="line" id="L414">    <span class="tok-comment">///</span></span>
<span class="line" id="L415">    <span class="tok-comment">/// The lock on the manifest file is released when `deinit` is called. As another</span></span>
<span class="line" id="L416">    <span class="tok-comment">/// option, one may call `toOwnedLock` to obtain a smaller object which can represent</span></span>
<span class="line" id="L417">    <span class="tok-comment">/// the lock. `deinit` is safe to call whether or not `toOwnedLock` has been called.</span></span>
<span class="line" id="L418">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hit</span>(self: *Manifest) !<span class="tok-type">bool</span> {</span>
<span class="line" id="L419">        <span class="tok-kw">const</span> gpa = self.cache.gpa;</span>
<span class="line" id="L420">        assert(self.manifest_file == <span class="tok-null">null</span>);</span>
<span class="line" id="L421"></span>
<span class="line" id="L422">        self.failed_file_index = <span class="tok-null">null</span>;</span>
<span class="line" id="L423"></span>
<span class="line" id="L424">        <span class="tok-kw">const</span> ext = <span class="tok-str">&quot;.txt&quot;</span>;</span>
<span class="line" id="L425">        <span class="tok-kw">var</span> manifest_file_path: [hex_digest_len + ext.len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L426"></span>
<span class="line" id="L427">        <span class="tok-kw">var</span> bin_digest: BinDigest = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L428">        self.hash.hasher.final(&amp;bin_digest);</span>
<span class="line" id="L429"></span>
<span class="line" id="L430">        _ = fmt.bufPrint(</span>
<span class="line" id="L431">            &amp;self.hex_digest,</span>
<span class="line" id="L432">            <span class="tok-str">&quot;{s}&quot;</span>,</span>
<span class="line" id="L433">            .{fmt.fmtSliceHexLower(&amp;bin_digest)},</span>
<span class="line" id="L434">        ) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L435"></span>
<span class="line" id="L436">        self.hash.hasher = hasher_init;</span>
<span class="line" id="L437">        self.hash.hasher.update(&amp;bin_digest);</span>
<span class="line" id="L438"></span>
<span class="line" id="L439">        <span class="tok-builtin">@memcpy</span>(manifest_file_path[<span class="tok-number">0</span>..self.hex_digest.len], &amp;self.hex_digest);</span>
<span class="line" id="L440">        manifest_file_path[hex_digest_len..][<span class="tok-number">0</span>..ext.len].* = ext.*;</span>
<span class="line" id="L441"></span>
<span class="line" id="L442">        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L443">            <span class="tok-kw">if</span> (self.cache.manifest_dir.createFile(&amp;manifest_file_path, .{</span>
<span class="line" id="L444">                .read = <span class="tok-null">true</span>,</span>
<span class="line" id="L445">                .truncate = <span class="tok-null">false</span>,</span>
<span class="line" id="L446">                .lock = .exclusive,</span>
<span class="line" id="L447">                .lock_nonblocking = self.want_shared_lock,</span>
<span class="line" id="L448">            })) |manifest_file| {</span>
<span class="line" id="L449">                self.manifest_file = manifest_file;</span>
<span class="line" id="L450">                self.have_exclusive_lock = <span class="tok-null">true</span>;</span>
<span class="line" id="L451">                <span class="tok-kw">break</span>;</span>
<span class="line" id="L452">            } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L453">                <span class="tok-kw">error</span>.WouldBlock =&gt; {</span>
<span class="line" id="L454">                    self.manifest_file = <span class="tok-kw">try</span> self.cache.manifest_dir.openFile(&amp;manifest_file_path, .{</span>
<span class="line" id="L455">                        .mode = .read_write,</span>
<span class="line" id="L456">                        .lock = .shared,</span>
<span class="line" id="L457">                    });</span>
<span class="line" id="L458">                    <span class="tok-kw">break</span>;</span>
<span class="line" id="L459">                },</span>
<span class="line" id="L460">                <span class="tok-comment">// There are no dir components, so you would think that this was</span>
</span>
<span class="line" id="L461">                <span class="tok-comment">// unreachable, however we have observed on macOS two processes racing</span>
</span>
<span class="line" id="L462">                <span class="tok-comment">// to do openat() with O_CREAT manifest in ENOENT.</span>
</span>
<span class="line" id="L463">                <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L464">                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L465">            }</span>
<span class="line" id="L466">        }</span>
<span class="line" id="L467"></span>
<span class="line" id="L468">        self.want_refresh_timestamp = <span class="tok-null">true</span>;</span>
<span class="line" id="L469"></span>
<span class="line" id="L470">        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L471">            <span class="tok-kw">const</span> file_contents = <span class="tok-kw">try</span> self.manifest_file.?.reader().readAllAlloc(gpa, manifest_file_size_max);</span>
<span class="line" id="L472">            <span class="tok-kw">defer</span> gpa.free(file_contents);</span>
<span class="line" id="L473"></span>
<span class="line" id="L474">            <span class="tok-kw">const</span> input_file_count = self.files.items.len;</span>
<span class="line" id="L475">            <span class="tok-kw">var</span> any_file_changed = <span class="tok-null">false</span>;</span>
<span class="line" id="L476">            <span class="tok-kw">var</span> line_iter = mem.tokenizeScalar(<span class="tok-type">u8</span>, file_contents, <span class="tok-str">'\n'</span>);</span>
<span class="line" id="L477">            <span class="tok-kw">var</span> idx: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L478">            <span class="tok-kw">if</span> (<span class="tok-kw">if</span> (line_iter.next()) |line| !std.mem.eql(<span class="tok-type">u8</span>, line, manifest_header) <span class="tok-kw">else</span> <span class="tok-null">true</span>) {</span>
<span class="line" id="L479">                <span class="tok-kw">if</span> (<span class="tok-kw">try</span> self.upgradeToExclusiveLock()) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L480">                self.manifest_dirty = <span class="tok-null">true</span>;</span>
<span class="line" id="L481">                <span class="tok-kw">while</span> (idx &lt; input_file_count) : (idx += <span class="tok-number">1</span>) {</span>
<span class="line" id="L482">                    <span class="tok-kw">const</span> ch_file = &amp;self.files.items[idx];</span>
<span class="line" id="L483">                    self.populateFileHash(ch_file) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L484">                        self.failed_file_index = idx;</span>
<span class="line" id="L485">                        <span class="tok-kw">return</span> err;</span>
<span class="line" id="L486">                    };</span>
<span class="line" id="L487">                }</span>
<span class="line" id="L488">                <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L489">            }</span>
<span class="line" id="L490">            <span class="tok-kw">while</span> (line_iter.next()) |line| {</span>
<span class="line" id="L491">                <span class="tok-kw">defer</span> idx += <span class="tok-number">1</span>;</span>
<span class="line" id="L492"></span>
<span class="line" id="L493">                <span class="tok-kw">const</span> cache_hash_file = <span class="tok-kw">if</span> (idx &lt; input_file_count) &amp;self.files.items[idx] <span class="tok-kw">else</span> blk: {</span>
<span class="line" id="L494">                    <span class="tok-kw">const</span> new = <span class="tok-kw">try</span> self.files.addOne(gpa);</span>
<span class="line" id="L495">                    new.* = .{</span>
<span class="line" id="L496">                        .prefixed_path = <span class="tok-null">null</span>,</span>
<span class="line" id="L497">                        .contents = <span class="tok-null">null</span>,</span>
<span class="line" id="L498">                        .max_file_size = <span class="tok-null">null</span>,</span>
<span class="line" id="L499">                        .stat = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L500">                        .bin_digest = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L501">                    };</span>
<span class="line" id="L502">                    <span class="tok-kw">break</span> :blk new;</span>
<span class="line" id="L503">                };</span>
<span class="line" id="L504"></span>
<span class="line" id="L505">                <span class="tok-kw">var</span> iter = mem.tokenizeScalar(<span class="tok-type">u8</span>, line, <span class="tok-str">' '</span>);</span>
<span class="line" id="L506">                <span class="tok-kw">const</span> size = iter.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L507">                <span class="tok-kw">const</span> inode = iter.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L508">                <span class="tok-kw">const</span> mtime_nsec_str = iter.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L509">                <span class="tok-kw">const</span> digest_str = iter.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L510">                <span class="tok-kw">const</span> prefix_str = iter.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L511">                <span class="tok-kw">const</span> file_path = iter.rest();</span>
<span class="line" id="L512"></span>
<span class="line" id="L513">                cache_hash_file.stat.size = fmt.parseInt(<span class="tok-type">u64</span>, size, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L514">                cache_hash_file.stat.inode = fmt.parseInt(fs.File.INode, inode, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L515">                cache_hash_file.stat.mtime = fmt.parseInt(<span class="tok-type">i64</span>, mtime_nsec_str, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L516">                _ = fmt.hexToBytes(&amp;cache_hash_file.bin_digest, digest_str) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L517">                <span class="tok-kw">const</span> prefix = fmt.parseInt(<span class="tok-type">u8</span>, prefix_str, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L518">                <span class="tok-kw">if</span> (prefix &gt;= self.cache.prefixes_len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L519"></span>
<span class="line" id="L520">                <span class="tok-kw">if</span> (file_path.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L521">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L522">                }</span>
<span class="line" id="L523">                <span class="tok-kw">if</span> (cache_hash_file.prefixed_path) |pp| {</span>
<span class="line" id="L524">                    <span class="tok-kw">if</span> (pp.prefix != prefix <span class="tok-kw">or</span> !mem.eql(<span class="tok-type">u8</span>, file_path, pp.sub_path)) {</span>
<span class="line" id="L525">                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;</span>
<span class="line" id="L526">                    }</span>
<span class="line" id="L527">                }</span>
<span class="line" id="L528"></span>
<span class="line" id="L529">                <span class="tok-kw">if</span> (cache_hash_file.prefixed_path == <span class="tok-null">null</span>) {</span>
<span class="line" id="L530">                    cache_hash_file.prefixed_path = .{</span>
<span class="line" id="L531">                        .prefix = prefix,</span>
<span class="line" id="L532">                        .sub_path = <span class="tok-kw">try</span> gpa.dupe(<span class="tok-type">u8</span>, file_path),</span>
<span class="line" id="L533">                    };</span>
<span class="line" id="L534">                }</span>
<span class="line" id="L535"></span>
<span class="line" id="L536">                <span class="tok-kw">const</span> pp = cache_hash_file.prefixed_path.?;</span>
<span class="line" id="L537">                <span class="tok-kw">const</span> dir = self.cache.prefixes()[pp.prefix].handle;</span>
<span class="line" id="L538">                <span class="tok-kw">const</span> this_file = dir.openFile(pp.sub_path, .{ .mode = .read_only }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L539">                    <span class="tok-kw">error</span>.FileNotFound =&gt; {</span>
<span class="line" id="L540">                        <span class="tok-kw">if</span> (<span class="tok-kw">try</span> self.upgradeToExclusiveLock()) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L541">                        <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L542">                    },</span>
<span class="line" id="L543">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheUnavailable,</span>
<span class="line" id="L544">                };</span>
<span class="line" id="L545">                <span class="tok-kw">defer</span> this_file.close();</span>
<span class="line" id="L546"></span>
<span class="line" id="L547">                <span class="tok-kw">const</span> actual_stat = this_file.stat() <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L548">                    self.failed_file_index = idx;</span>
<span class="line" id="L549">                    <span class="tok-kw">return</span> err;</span>
<span class="line" id="L550">                };</span>
<span class="line" id="L551">                <span class="tok-kw">const</span> size_match = actual_stat.size == cache_hash_file.stat.size;</span>
<span class="line" id="L552">                <span class="tok-kw">const</span> mtime_match = actual_stat.mtime == cache_hash_file.stat.mtime;</span>
<span class="line" id="L553">                <span class="tok-kw">const</span> inode_match = actual_stat.inode == cache_hash_file.stat.inode;</span>
<span class="line" id="L554"></span>
<span class="line" id="L555">                <span class="tok-kw">if</span> (!size_match <span class="tok-kw">or</span> !mtime_match <span class="tok-kw">or</span> !inode_match) {</span>
<span class="line" id="L556">                    self.manifest_dirty = <span class="tok-null">true</span>;</span>
<span class="line" id="L557"></span>
<span class="line" id="L558">                    cache_hash_file.stat = .{</span>
<span class="line" id="L559">                        .size = actual_stat.size,</span>
<span class="line" id="L560">                        .mtime = actual_stat.mtime,</span>
<span class="line" id="L561">                        .inode = actual_stat.inode,</span>
<span class="line" id="L562">                    };</span>
<span class="line" id="L563"></span>
<span class="line" id="L564">                    <span class="tok-kw">if</span> (self.isProblematicTimestamp(cache_hash_file.stat.mtime)) {</span>
<span class="line" id="L565">                        <span class="tok-comment">// The actual file has an unreliable timestamp, force it to be hashed</span>
</span>
<span class="line" id="L566">                        cache_hash_file.stat.mtime = <span class="tok-number">0</span>;</span>
<span class="line" id="L567">                        cache_hash_file.stat.inode = <span class="tok-number">0</span>;</span>
<span class="line" id="L568">                    }</span>
<span class="line" id="L569"></span>
<span class="line" id="L570">                    <span class="tok-kw">var</span> actual_digest: BinDigest = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L571">                    hashFile(this_file, &amp;actual_digest) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L572">                        self.failed_file_index = idx;</span>
<span class="line" id="L573">                        <span class="tok-kw">return</span> err;</span>
<span class="line" id="L574">                    };</span>
<span class="line" id="L575"></span>
<span class="line" id="L576">                    <span class="tok-kw">if</span> (!mem.eql(<span class="tok-type">u8</span>, &amp;cache_hash_file.bin_digest, &amp;actual_digest)) {</span>
<span class="line" id="L577">                        cache_hash_file.bin_digest = actual_digest;</span>
<span class="line" id="L578">                        <span class="tok-comment">// keep going until we have the input file digests</span>
</span>
<span class="line" id="L579">                        any_file_changed = <span class="tok-null">true</span>;</span>
<span class="line" id="L580">                    }</span>
<span class="line" id="L581">                }</span>
<span class="line" id="L582"></span>
<span class="line" id="L583">                <span class="tok-kw">if</span> (!any_file_changed) {</span>
<span class="line" id="L584">                    self.hash.hasher.update(&amp;cache_hash_file.bin_digest);</span>
<span class="line" id="L585">                }</span>
<span class="line" id="L586">            }</span>
<span class="line" id="L587"></span>
<span class="line" id="L588">            <span class="tok-kw">if</span> (any_file_changed) {</span>
<span class="line" id="L589">                <span class="tok-kw">if</span> (<span class="tok-kw">try</span> self.upgradeToExclusiveLock()) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L590">                <span class="tok-comment">// cache miss</span>
</span>
<span class="line" id="L591">                <span class="tok-comment">// keep the manifest file open</span>
</span>
<span class="line" id="L592">                self.unhit(bin_digest, input_file_count);</span>
<span class="line" id="L593">                <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L594">            }</span>
<span class="line" id="L595"></span>
<span class="line" id="L596">            <span class="tok-kw">if</span> (idx &lt; input_file_count) {</span>
<span class="line" id="L597">                <span class="tok-kw">if</span> (<span class="tok-kw">try</span> self.upgradeToExclusiveLock()) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L598">                self.manifest_dirty = <span class="tok-null">true</span>;</span>
<span class="line" id="L599">                <span class="tok-kw">while</span> (idx &lt; input_file_count) : (idx += <span class="tok-number">1</span>) {</span>
<span class="line" id="L600">                    <span class="tok-kw">const</span> ch_file = &amp;self.files.items[idx];</span>
<span class="line" id="L601">                    self.populateFileHash(ch_file) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L602">                        self.failed_file_index = idx;</span>
<span class="line" id="L603">                        <span class="tok-kw">return</span> err;</span>
<span class="line" id="L604">                    };</span>
<span class="line" id="L605">                }</span>
<span class="line" id="L606">                <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L607">            }</span>
<span class="line" id="L608"></span>
<span class="line" id="L609">            <span class="tok-kw">if</span> (self.want_shared_lock) {</span>
<span class="line" id="L610">                <span class="tok-kw">try</span> self.downgradeToSharedLock();</span>
<span class="line" id="L611">            }</span>
<span class="line" id="L612"></span>
<span class="line" id="L613">            <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L614">        }</span>
<span class="line" id="L615">    }</span>
<span class="line" id="L616"></span>
<span class="line" id="L617">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unhit</span>(self: *Manifest, bin_digest: BinDigest, input_file_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L618">        <span class="tok-comment">// Reset the hash.</span>
</span>
<span class="line" id="L619">        self.hash.hasher = hasher_init;</span>
<span class="line" id="L620">        self.hash.hasher.update(&amp;bin_digest);</span>
<span class="line" id="L621"></span>
<span class="line" id="L622">        <span class="tok-comment">// Remove files not in the initial hash.</span>
</span>
<span class="line" id="L623">        <span class="tok-kw">for</span> (self.files.items[input_file_count..]) |*file| {</span>
<span class="line" id="L624">            file.deinit(self.cache.gpa);</span>
<span class="line" id="L625">        }</span>
<span class="line" id="L626">        self.files.shrinkRetainingCapacity(input_file_count);</span>
<span class="line" id="L627"></span>
<span class="line" id="L628">        <span class="tok-kw">for</span> (self.files.items) |file| {</span>
<span class="line" id="L629">            self.hash.hasher.update(&amp;file.bin_digest);</span>
<span class="line" id="L630">        }</span>
<span class="line" id="L631">    }</span>
<span class="line" id="L632"></span>
<span class="line" id="L633">    <span class="tok-kw">fn</span> <span class="tok-fn">isProblematicTimestamp</span>(man: *Manifest, file_time: <span class="tok-type">i128</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L634">        <span class="tok-comment">// If the file_time is prior to the most recent problematic timestamp</span>
</span>
<span class="line" id="L635">        <span class="tok-comment">// then we don't need to access the filesystem.</span>
</span>
<span class="line" id="L636">        <span class="tok-kw">if</span> (file_time &lt; man.recent_problematic_timestamp)</span>
<span class="line" id="L637">            <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L638"></span>
<span class="line" id="L639">        <span class="tok-comment">// Next we will check the globally shared Cache timestamp, which is accessed</span>
</span>
<span class="line" id="L640">        <span class="tok-comment">// from multiple threads.</span>
</span>
<span class="line" id="L641">        man.cache.mutex.lock();</span>
<span class="line" id="L642">        <span class="tok-kw">defer</span> man.cache.mutex.unlock();</span>
<span class="line" id="L643"></span>
<span class="line" id="L644">        <span class="tok-comment">// Save the global one to our local one to avoid locking next time.</span>
</span>
<span class="line" id="L645">        man.recent_problematic_timestamp = man.cache.recent_problematic_timestamp;</span>
<span class="line" id="L646">        <span class="tok-kw">if</span> (file_time &lt; man.recent_problematic_timestamp)</span>
<span class="line" id="L647">            <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L648"></span>
<span class="line" id="L649">        <span class="tok-comment">// This flag prevents multiple filesystem writes for the same hit() call.</span>
</span>
<span class="line" id="L650">        <span class="tok-kw">if</span> (man.want_refresh_timestamp) {</span>
<span class="line" id="L651">            man.want_refresh_timestamp = <span class="tok-null">false</span>;</span>
<span class="line" id="L652"></span>
<span class="line" id="L653">            <span class="tok-kw">var</span> file = man.cache.manifest_dir.createFile(<span class="tok-str">&quot;timestamp&quot;</span>, .{</span>
<span class="line" id="L654">                .read = <span class="tok-null">true</span>,</span>
<span class="line" id="L655">                .truncate = <span class="tok-null">true</span>,</span>
<span class="line" id="L656">            }) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L657">            <span class="tok-kw">defer</span> file.close();</span>
<span class="line" id="L658"></span>
<span class="line" id="L659">            <span class="tok-comment">// Save locally and also save globally (we still hold the global lock).</span>
</span>
<span class="line" id="L660">            man.recent_problematic_timestamp = (file.stat() <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">true</span>).mtime;</span>
<span class="line" id="L661">            man.cache.recent_problematic_timestamp = man.recent_problematic_timestamp;</span>
<span class="line" id="L662">        }</span>
<span class="line" id="L663"></span>
<span class="line" id="L664">        <span class="tok-kw">return</span> file_time &gt;= man.recent_problematic_timestamp;</span>
<span class="line" id="L665">    }</span>
<span class="line" id="L666"></span>
<span class="line" id="L667">    <span class="tok-kw">fn</span> <span class="tok-fn">populateFileHash</span>(self: *Manifest, ch_file: *File) !<span class="tok-type">void</span> {</span>
<span class="line" id="L668">        <span class="tok-kw">const</span> pp = ch_file.prefixed_path.?;</span>
<span class="line" id="L669">        <span class="tok-kw">const</span> dir = self.cache.prefixes()[pp.prefix].handle;</span>
<span class="line" id="L670">        <span class="tok-kw">const</span> file = <span class="tok-kw">try</span> dir.openFile(pp.sub_path, .{});</span>
<span class="line" id="L671">        <span class="tok-kw">defer</span> file.close();</span>
<span class="line" id="L672"></span>
<span class="line" id="L673">        <span class="tok-kw">const</span> actual_stat = <span class="tok-kw">try</span> file.stat();</span>
<span class="line" id="L674">        ch_file.stat = .{</span>
<span class="line" id="L675">            .size = actual_stat.size,</span>
<span class="line" id="L676">            .mtime = actual_stat.mtime,</span>
<span class="line" id="L677">            .inode = actual_stat.inode,</span>
<span class="line" id="L678">        };</span>
<span class="line" id="L679"></span>
<span class="line" id="L680">        <span class="tok-kw">if</span> (self.isProblematicTimestamp(ch_file.stat.mtime)) {</span>
<span class="line" id="L681">            <span class="tok-comment">// The actual file has an unreliable timestamp, force it to be hashed</span>
</span>
<span class="line" id="L682">            ch_file.stat.mtime = <span class="tok-number">0</span>;</span>
<span class="line" id="L683">            ch_file.stat.inode = <span class="tok-number">0</span>;</span>
<span class="line" id="L684">        }</span>
<span class="line" id="L685"></span>
<span class="line" id="L686">        <span class="tok-kw">if</span> (ch_file.max_file_size) |max_file_size| {</span>
<span class="line" id="L687">            <span class="tok-kw">if</span> (ch_file.stat.size &gt; max_file_size) {</span>
<span class="line" id="L688">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig;</span>
<span class="line" id="L689">            }</span>
<span class="line" id="L690"></span>
<span class="line" id="L691">            <span class="tok-kw">const</span> contents = <span class="tok-kw">try</span> self.cache.gpa.alloc(<span class="tok-type">u8</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(ch_file.stat.size)));</span>
<span class="line" id="L692">            <span class="tok-kw">errdefer</span> self.cache.gpa.free(contents);</span>
<span class="line" id="L693"></span>
<span class="line" id="L694">            <span class="tok-comment">// Hash while reading from disk, to keep the contents in the cpu cache while</span>
</span>
<span class="line" id="L695">            <span class="tok-comment">// doing hashing.</span>
</span>
<span class="line" id="L696">            <span class="tok-kw">var</span> hasher = hasher_init;</span>
<span class="line" id="L697">            <span class="tok-kw">var</span> off: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L698">            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L699">                <span class="tok-comment">// give me everything you've got, captain</span>
</span>
<span class="line" id="L700">                <span class="tok-kw">const</span> bytes_read = <span class="tok-kw">try</span> file.read(contents[off..]);</span>
<span class="line" id="L701">                <span class="tok-kw">if</span> (bytes_read == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;</span>
<span class="line" id="L702">                hasher.update(contents[off..][<span class="tok-number">0</span>..bytes_read]);</span>
<span class="line" id="L703">                off += bytes_read;</span>
<span class="line" id="L704">            }</span>
<span class="line" id="L705">            hasher.final(&amp;ch_file.bin_digest);</span>
<span class="line" id="L706"></span>
<span class="line" id="L707">            ch_file.contents = contents;</span>
<span class="line" id="L708">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L709">            <span class="tok-kw">try</span> hashFile(file, &amp;ch_file.bin_digest);</span>
<span class="line" id="L710">        }</span>
<span class="line" id="L711"></span>
<span class="line" id="L712">        self.hash.hasher.update(&amp;ch_file.bin_digest);</span>
<span class="line" id="L713">    }</span>
<span class="line" id="L714"></span>
<span class="line" id="L715">    <span class="tok-comment">/// Add a file as a dependency of process being cached, after the initial hash has been</span></span>
<span class="line" id="L716">    <span class="tok-comment">/// calculated. This is useful for processes that don't know all the files that</span></span>
<span class="line" id="L717">    <span class="tok-comment">/// are depended on ahead of time. For example, a source file that can import other files</span></span>
<span class="line" id="L718">    <span class="tok-comment">/// will need to be recompiled if the imported file is changed.</span></span>
<span class="line" id="L719">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFilePostFetch</span>(self: *Manifest, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, max_file_size: <span class="tok-type">usize</span>) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L720">        assert(self.manifest_file != <span class="tok-null">null</span>);</span>
<span class="line" id="L721"></span>
<span class="line" id="L722">        <span class="tok-kw">const</span> gpa = self.cache.gpa;</span>
<span class="line" id="L723">        <span class="tok-kw">const</span> prefixed_path = <span class="tok-kw">try</span> self.cache.findPrefix(file_path);</span>
<span class="line" id="L724">        <span class="tok-kw">errdefer</span> gpa.free(prefixed_path.sub_path);</span>
<span class="line" id="L725"></span>
<span class="line" id="L726">        <span class="tok-kw">const</span> new_ch_file = <span class="tok-kw">try</span> self.files.addOne(gpa);</span>
<span class="line" id="L727">        new_ch_file.* = .{</span>
<span class="line" id="L728">            .prefixed_path = prefixed_path,</span>
<span class="line" id="L729">            .max_file_size = max_file_size,</span>
<span class="line" id="L730">            .stat = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L731">            .bin_digest = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L732">            .contents = <span class="tok-null">null</span>,</span>
<span class="line" id="L733">        };</span>
<span class="line" id="L734">        <span class="tok-kw">errdefer</span> self.files.shrinkRetainingCapacity(self.files.items.len - <span class="tok-number">1</span>);</span>
<span class="line" id="L735"></span>
<span class="line" id="L736">        <span class="tok-kw">try</span> self.populateFileHash(new_ch_file);</span>
<span class="line" id="L737"></span>
<span class="line" id="L738">        <span class="tok-kw">return</span> new_ch_file.contents.?;</span>
<span class="line" id="L739">    }</span>
<span class="line" id="L740"></span>
<span class="line" id="L741">    <span class="tok-comment">/// Add a file as a dependency of process being cached, after the initial hash has been</span></span>
<span class="line" id="L742">    <span class="tok-comment">/// calculated. This is useful for processes that don't know the all the files that</span></span>
<span class="line" id="L743">    <span class="tok-comment">/// are depended on ahead of time. For example, a source file that can import other files</span></span>
<span class="line" id="L744">    <span class="tok-comment">/// will need to be recompiled if the imported file is changed.</span></span>
<span class="line" id="L745">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFilePost</span>(self: *Manifest, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L746">        assert(self.manifest_file != <span class="tok-null">null</span>);</span>
<span class="line" id="L747"></span>
<span class="line" id="L748">        <span class="tok-kw">const</span> gpa = self.cache.gpa;</span>
<span class="line" id="L749">        <span class="tok-kw">const</span> prefixed_path = <span class="tok-kw">try</span> self.cache.findPrefix(file_path);</span>
<span class="line" id="L750">        <span class="tok-kw">errdefer</span> gpa.free(prefixed_path.sub_path);</span>
<span class="line" id="L751"></span>
<span class="line" id="L752">        <span class="tok-kw">const</span> new_ch_file = <span class="tok-kw">try</span> self.files.addOne(gpa);</span>
<span class="line" id="L753">        new_ch_file.* = .{</span>
<span class="line" id="L754">            .prefixed_path = prefixed_path,</span>
<span class="line" id="L755">            .max_file_size = <span class="tok-null">null</span>,</span>
<span class="line" id="L756">            .stat = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L757">            .bin_digest = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L758">            .contents = <span class="tok-null">null</span>,</span>
<span class="line" id="L759">        };</span>
<span class="line" id="L760">        <span class="tok-kw">errdefer</span> self.files.shrinkRetainingCapacity(self.files.items.len - <span class="tok-number">1</span>);</span>
<span class="line" id="L761"></span>
<span class="line" id="L762">        <span class="tok-kw">try</span> self.populateFileHash(new_ch_file);</span>
<span class="line" id="L763">    }</span>
<span class="line" id="L764"></span>
<span class="line" id="L765">    <span class="tok-comment">/// Like `addFilePost` but when the file contents have already been loaded from disk.</span></span>
<span class="line" id="L766">    <span class="tok-comment">/// On success, cache takes ownership of `resolved_path`.</span></span>
<span class="line" id="L767">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFilePostContents</span>(</span>
<span class="line" id="L768">        self: *Manifest,</span>
<span class="line" id="L769">        resolved_path: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L770">        bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L771">        stat: File.Stat,</span>
<span class="line" id="L772">    ) !<span class="tok-type">void</span> {</span>
<span class="line" id="L773">        assert(self.manifest_file != <span class="tok-null">null</span>);</span>
<span class="line" id="L774">        <span class="tok-kw">const</span> gpa = self.cache.gpa;</span>
<span class="line" id="L775"></span>
<span class="line" id="L776">        <span class="tok-kw">const</span> ch_file = <span class="tok-kw">try</span> self.files.addOne(gpa);</span>
<span class="line" id="L777">        <span class="tok-kw">errdefer</span> self.files.shrinkRetainingCapacity(self.files.items.len - <span class="tok-number">1</span>);</span>
<span class="line" id="L778"></span>
<span class="line" id="L779">        <span class="tok-kw">const</span> prefixed_path = <span class="tok-kw">try</span> self.cache.findPrefixResolved(resolved_path);</span>
<span class="line" id="L780">        <span class="tok-kw">errdefer</span> gpa.free(prefixed_path.sub_path);</span>
<span class="line" id="L781"></span>
<span class="line" id="L782">        ch_file.* = .{</span>
<span class="line" id="L783">            .prefixed_path = prefixed_path,</span>
<span class="line" id="L784">            .max_file_size = <span class="tok-null">null</span>,</span>
<span class="line" id="L785">            .stat = stat,</span>
<span class="line" id="L786">            .bin_digest = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L787">            .contents = <span class="tok-null">null</span>,</span>
<span class="line" id="L788">        };</span>
<span class="line" id="L789"></span>
<span class="line" id="L790">        <span class="tok-kw">if</span> (self.isProblematicTimestamp(ch_file.stat.mtime)) {</span>
<span class="line" id="L791">            <span class="tok-comment">// The actual file has an unreliable timestamp, force it to be hashed</span>
</span>
<span class="line" id="L792">            ch_file.stat.mtime = <span class="tok-number">0</span>;</span>
<span class="line" id="L793">            ch_file.stat.inode = <span class="tok-number">0</span>;</span>
<span class="line" id="L794">        }</span>
<span class="line" id="L795"></span>
<span class="line" id="L796">        {</span>
<span class="line" id="L797">            <span class="tok-kw">var</span> hasher = hasher_init;</span>
<span class="line" id="L798">            hasher.update(bytes);</span>
<span class="line" id="L799">            hasher.final(&amp;ch_file.bin_digest);</span>
<span class="line" id="L800">        }</span>
<span class="line" id="L801"></span>
<span class="line" id="L802">        self.hash.hasher.update(&amp;ch_file.bin_digest);</span>
<span class="line" id="L803">    }</span>
<span class="line" id="L804"></span>
<span class="line" id="L805">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addDepFilePost</span>(self: *Manifest, dir: fs.Dir, dep_file_basename: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L806">        assert(self.manifest_file != <span class="tok-null">null</span>);</span>
<span class="line" id="L807"></span>
<span class="line" id="L808">        <span class="tok-kw">const</span> dep_file_contents = <span class="tok-kw">try</span> dir.readFileAlloc(self.cache.gpa, dep_file_basename, manifest_file_size_max);</span>
<span class="line" id="L809">        <span class="tok-kw">defer</span> self.cache.gpa.free(dep_file_contents);</span>
<span class="line" id="L810"></span>
<span class="line" id="L811">        <span class="tok-kw">var</span> error_buf = std.ArrayList(<span class="tok-type">u8</span>).init(self.cache.gpa);</span>
<span class="line" id="L812">        <span class="tok-kw">defer</span> error_buf.deinit();</span>
<span class="line" id="L813"></span>
<span class="line" id="L814">        <span class="tok-kw">var</span> it: DepTokenizer = .{ .bytes = dep_file_contents };</span>
<span class="line" id="L815"></span>
<span class="line" id="L816">        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L817">            <span class="tok-kw">switch</span> (it.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>) {</span>
<span class="line" id="L818">                <span class="tok-comment">// We don't care about targets, we only want the prereqs</span>
</span>
<span class="line" id="L819">                <span class="tok-comment">// Clang is invoked in single-source mode but other programs may not</span>
</span>
<span class="line" id="L820">                .target, .target_must_resolve =&gt; {},</span>
<span class="line" id="L821">                .prereq =&gt; |file_path| <span class="tok-kw">try</span> self.addFilePost(file_path),</span>
<span class="line" id="L822">                <span class="tok-kw">else</span> =&gt; |err| {</span>
<span class="line" id="L823">                    <span class="tok-kw">try</span> err.printError(error_buf.writer());</span>
<span class="line" id="L824">                    log.err(<span class="tok-str">&quot;failed parsing {s}: {s}&quot;</span>, .{ dep_file_basename, error_buf.items });</span>
<span class="line" id="L825">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDepFile;</span>
<span class="line" id="L826">                },</span>
<span class="line" id="L827">            }</span>
<span class="line" id="L828">        }</span>
<span class="line" id="L829">    }</span>
<span class="line" id="L830"></span>
<span class="line" id="L831">    <span class="tok-comment">/// Returns a hex encoded hash of the inputs.</span></span>
<span class="line" id="L832">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">final</span>(self: *Manifest) [hex_digest_len]<span class="tok-type">u8</span> {</span>
<span class="line" id="L833">        assert(self.manifest_file != <span class="tok-null">null</span>);</span>
<span class="line" id="L834"></span>
<span class="line" id="L835">        <span class="tok-comment">// We don't close the manifest file yet, because we want to</span>
</span>
<span class="line" id="L836">        <span class="tok-comment">// keep it locked until the API user is done using it.</span>
</span>
<span class="line" id="L837">        <span class="tok-comment">// We also don't write out the manifest yet, because until</span>
</span>
<span class="line" id="L838">        <span class="tok-comment">// cache_release is called we still might be working on creating</span>
</span>
<span class="line" id="L839">        <span class="tok-comment">// the artifacts to cache.</span>
</span>
<span class="line" id="L840"></span>
<span class="line" id="L841">        <span class="tok-kw">var</span> bin_digest: BinDigest = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L842">        self.hash.hasher.final(&amp;bin_digest);</span>
<span class="line" id="L843"></span>
<span class="line" id="L844">        <span class="tok-kw">var</span> out_digest: [hex_digest_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L845">        _ = fmt.bufPrint(</span>
<span class="line" id="L846">            &amp;out_digest,</span>
<span class="line" id="L847">            <span class="tok-str">&quot;{s}&quot;</span>,</span>
<span class="line" id="L848">            .{fmt.fmtSliceHexLower(&amp;bin_digest)},</span>
<span class="line" id="L849">        ) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L850"></span>
<span class="line" id="L851">        <span class="tok-kw">return</span> out_digest;</span>
<span class="line" id="L852">    }</span>
<span class="line" id="L853"></span>
<span class="line" id="L854">    <span class="tok-comment">/// If `want_shared_lock` is true, this function automatically downgrades the</span></span>
<span class="line" id="L855">    <span class="tok-comment">/// lock from exclusive to shared.</span></span>
<span class="line" id="L856">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeManifest</span>(self: *Manifest) !<span class="tok-type">void</span> {</span>
<span class="line" id="L857">        assert(self.have_exclusive_lock);</span>
<span class="line" id="L858"></span>
<span class="line" id="L859">        <span class="tok-kw">const</span> manifest_file = self.manifest_file.?;</span>
<span class="line" id="L860">        <span class="tok-kw">if</span> (self.manifest_dirty) {</span>
<span class="line" id="L861">            self.manifest_dirty = <span class="tok-null">false</span>;</span>
<span class="line" id="L862"></span>
<span class="line" id="L863">            <span class="tok-kw">var</span> contents = std.ArrayList(<span class="tok-type">u8</span>).init(self.cache.gpa);</span>
<span class="line" id="L864">            <span class="tok-kw">defer</span> contents.deinit();</span>
<span class="line" id="L865"></span>
<span class="line" id="L866">            <span class="tok-kw">const</span> writer = contents.writer();</span>
<span class="line" id="L867">            <span class="tok-kw">try</span> writer.writeAll(manifest_header ++ <span class="tok-str">&quot;\n&quot;</span>);</span>
<span class="line" id="L868">            <span class="tok-kw">for</span> (self.files.items) |file| {</span>
<span class="line" id="L869">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{d} {d} {d} {} {d} {s}\n&quot;</span>, .{</span>
<span class="line" id="L870">                    file.stat.size,</span>
<span class="line" id="L871">                    file.stat.inode,</span>
<span class="line" id="L872">                    file.stat.mtime,</span>
<span class="line" id="L873">                    fmt.fmtSliceHexLower(&amp;file.bin_digest),</span>
<span class="line" id="L874">                    file.prefixed_path.?.prefix,</span>
<span class="line" id="L875">                    file.prefixed_path.?.sub_path,</span>
<span class="line" id="L876">                });</span>
<span class="line" id="L877">            }</span>
<span class="line" id="L878"></span>
<span class="line" id="L879">            <span class="tok-kw">try</span> manifest_file.setEndPos(contents.items.len);</span>
<span class="line" id="L880">            <span class="tok-kw">try</span> manifest_file.pwriteAll(contents.items, <span class="tok-number">0</span>);</span>
<span class="line" id="L881">        }</span>
<span class="line" id="L882"></span>
<span class="line" id="L883">        <span class="tok-kw">if</span> (self.want_shared_lock) {</span>
<span class="line" id="L884">            <span class="tok-kw">try</span> self.downgradeToSharedLock();</span>
<span class="line" id="L885">        }</span>
<span class="line" id="L886">    }</span>
<span class="line" id="L887"></span>
<span class="line" id="L888">    <span class="tok-kw">fn</span> <span class="tok-fn">downgradeToSharedLock</span>(self: *Manifest) !<span class="tok-type">void</span> {</span>
<span class="line" id="L889">        <span class="tok-kw">if</span> (!self.have_exclusive_lock) <span class="tok-kw">return</span>;</span>
<span class="line" id="L890"></span>
<span class="line" id="L891">        <span class="tok-comment">// WASI does not currently support flock, so we bypass it here.</span>
</span>
<span class="line" id="L892">        <span class="tok-comment">// TODO: If/when flock is supported on WASI, this check should be removed.</span>
</span>
<span class="line" id="L893">        <span class="tok-comment">//       See https://github.com/WebAssembly/wasi-filesystem/issues/2</span>
</span>
<span class="line" id="L894">        <span class="tok-kw">if</span> (builtin.os.tag != .wasi <span class="tok-kw">or</span> std.process.can_spawn <span class="tok-kw">or</span> !builtin.single_threaded) {</span>
<span class="line" id="L895">            <span class="tok-kw">const</span> manifest_file = self.manifest_file.?;</span>
<span class="line" id="L896">            <span class="tok-kw">try</span> manifest_file.downgradeLock();</span>
<span class="line" id="L897">        }</span>
<span class="line" id="L898"></span>
<span class="line" id="L899">        self.have_exclusive_lock = <span class="tok-null">false</span>;</span>
<span class="line" id="L900">    }</span>
<span class="line" id="L901"></span>
<span class="line" id="L902">    <span class="tok-kw">fn</span> <span class="tok-fn">upgradeToExclusiveLock</span>(self: *Manifest) !<span class="tok-type">bool</span> {</span>
<span class="line" id="L903">        <span class="tok-kw">if</span> (self.have_exclusive_lock) <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L904">        assert(self.manifest_file != <span class="tok-null">null</span>);</span>
<span class="line" id="L905"></span>
<span class="line" id="L906">        <span class="tok-comment">// WASI does not currently support flock, so we bypass it here.</span>
</span>
<span class="line" id="L907">        <span class="tok-comment">// TODO: If/when flock is supported on WASI, this check should be removed.</span>
</span>
<span class="line" id="L908">        <span class="tok-comment">//       See https://github.com/WebAssembly/wasi-filesystem/issues/2</span>
</span>
<span class="line" id="L909">        <span class="tok-kw">if</span> (builtin.os.tag != .wasi <span class="tok-kw">or</span> std.process.can_spawn <span class="tok-kw">or</span> !builtin.single_threaded) {</span>
<span class="line" id="L910">            <span class="tok-kw">const</span> manifest_file = self.manifest_file.?;</span>
<span class="line" id="L911">            <span class="tok-comment">// Here we intentionally have a period where the lock is released, in case there are</span>
</span>
<span class="line" id="L912">            <span class="tok-comment">// other processes holding a shared lock.</span>
</span>
<span class="line" id="L913">            manifest_file.unlock();</span>
<span class="line" id="L914">            <span class="tok-kw">try</span> manifest_file.lock(.exclusive);</span>
<span class="line" id="L915">        }</span>
<span class="line" id="L916">        self.have_exclusive_lock = <span class="tok-null">true</span>;</span>
<span class="line" id="L917">        <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L918">    }</span>
<span class="line" id="L919"></span>
<span class="line" id="L920">    <span class="tok-comment">/// Obtain only the data needed to maintain a lock on the manifest file.</span></span>
<span class="line" id="L921">    <span class="tok-comment">/// The `Manifest` remains safe to deinit.</span></span>
<span class="line" id="L922">    <span class="tok-comment">/// Don't forget to call `writeManifest` before this!</span></span>
<span class="line" id="L923">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toOwnedLock</span>(self: *Manifest) Lock {</span>
<span class="line" id="L924">        <span class="tok-kw">const</span> lock: Lock = .{</span>
<span class="line" id="L925">            .manifest_file = self.manifest_file.?,</span>
<span class="line" id="L926">        };</span>
<span class="line" id="L927"></span>
<span class="line" id="L928">        self.manifest_file = <span class="tok-null">null</span>;</span>
<span class="line" id="L929">        <span class="tok-kw">return</span> lock;</span>
<span class="line" id="L930">    }</span>
<span class="line" id="L931"></span>
<span class="line" id="L932">    <span class="tok-comment">/// Releases the manifest file and frees any memory the Manifest was using.</span></span>
<span class="line" id="L933">    <span class="tok-comment">/// `Manifest.hit` must be called first.</span></span>
<span class="line" id="L934">    <span class="tok-comment">/// Don't forget to call `writeManifest` before this!</span></span>
<span class="line" id="L935">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *Manifest) <span class="tok-type">void</span> {</span>
<span class="line" id="L936">        <span class="tok-kw">if</span> (self.manifest_file) |file| {</span>
<span class="line" id="L937">            <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L938">                <span class="tok-comment">// See Lock.release for why this is required on Windows</span>
</span>
<span class="line" id="L939">                file.unlock();</span>
<span class="line" id="L940">            }</span>
<span class="line" id="L941"></span>
<span class="line" id="L942">            file.close();</span>
<span class="line" id="L943">        }</span>
<span class="line" id="L944">        <span class="tok-kw">for</span> (self.files.items) |*file| {</span>
<span class="line" id="L945">            file.deinit(self.cache.gpa);</span>
<span class="line" id="L946">        }</span>
<span class="line" id="L947">        self.files.deinit(self.cache.gpa);</span>
<span class="line" id="L948">    }</span>
<span class="line" id="L949">};</span>
<span class="line" id="L950"></span>
<span class="line" id="L951"><span class="tok-comment">/// On operating systems that support symlinks, does a readlink. On other operating systems,</span></span>
<span class="line" id="L952"><span class="tok-comment">/// uses the file contents. Windows supports symlinks but only with elevated privileges, so</span></span>
<span class="line" id="L953"><span class="tok-comment">/// it is treated as not supporting symlinks.</span></span>
<span class="line" id="L954"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readSmallFile</span>(dir: fs.Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L955">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L956">        <span class="tok-kw">return</span> dir.readFile(sub_path, buffer);</span>
<span class="line" id="L957">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L958">        <span class="tok-kw">return</span> dir.readLink(sub_path, buffer);</span>
<span class="line" id="L959">    }</span>
<span class="line" id="L960">}</span>
<span class="line" id="L961"></span>
<span class="line" id="L962"><span class="tok-comment">/// On operating systems that support symlinks, does a symlink. On other operating systems,</span></span>
<span class="line" id="L963"><span class="tok-comment">/// uses the file contents. Windows supports symlinks but only with elevated privileges, so</span></span>
<span class="line" id="L964"><span class="tok-comment">/// it is treated as not supporting symlinks.</span></span>
<span class="line" id="L965"><span class="tok-comment">/// `data` must be a valid UTF-8 encoded file path and 255 bytes or fewer.</span></span>
<span class="line" id="L966"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeSmallFile</span>(dir: fs.Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L967">    assert(data.len &lt;= <span class="tok-number">255</span>);</span>
<span class="line" id="L968">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L969">        <span class="tok-kw">return</span> dir.writeFile(sub_path, data);</span>
<span class="line" id="L970">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L971">        <span class="tok-kw">return</span> dir.symLink(data, sub_path, .{});</span>
<span class="line" id="L972">    }</span>
<span class="line" id="L973">}</span>
<span class="line" id="L974"></span>
<span class="line" id="L975"><span class="tok-kw">fn</span> <span class="tok-fn">hashFile</span>(file: fs.File, bin_digest: *[Hasher.mac_length]<span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L976">    <span class="tok-kw">var</span> buf: [<span class="tok-number">1024</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L977"></span>
<span class="line" id="L978">    <span class="tok-kw">var</span> hasher = hasher_init;</span>
<span class="line" id="L979">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L980">        <span class="tok-kw">const</span> bytes_read = <span class="tok-kw">try</span> file.read(&amp;buf);</span>
<span class="line" id="L981">        <span class="tok-kw">if</span> (bytes_read == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;</span>
<span class="line" id="L982">        hasher.update(buf[<span class="tok-number">0</span>..bytes_read]);</span>
<span class="line" id="L983">    }</span>
<span class="line" id="L984"></span>
<span class="line" id="L985">    hasher.final(bin_digest);</span>
<span class="line" id="L986">}</span>
<span class="line" id="L987"></span>
<span class="line" id="L988"><span class="tok-comment">// Create/Write a file, close it, then grab its stat.mtime timestamp.</span>
</span>
<span class="line" id="L989"><span class="tok-kw">fn</span> <span class="tok-fn">testGetCurrentFileTimestamp</span>(dir: fs.Dir) !<span class="tok-type">i128</span> {</span>
<span class="line" id="L990">    <span class="tok-kw">const</span> test_out_file = <span class="tok-str">&quot;test-filetimestamp.tmp&quot;</span>;</span>
<span class="line" id="L991"></span>
<span class="line" id="L992">    <span class="tok-kw">var</span> file = <span class="tok-kw">try</span> dir.createFile(test_out_file, .{</span>
<span class="line" id="L993">        .read = <span class="tok-null">true</span>,</span>
<span class="line" id="L994">        .truncate = <span class="tok-null">true</span>,</span>
<span class="line" id="L995">    });</span>
<span class="line" id="L996">    <span class="tok-kw">defer</span> {</span>
<span class="line" id="L997">        file.close();</span>
<span class="line" id="L998">        dir.deleteFile(test_out_file) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L999">    }</span>
<span class="line" id="L1000"></span>
<span class="line" id="L1001">    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> file.stat()).mtime;</span>
<span class="line" id="L1002">}</span>
<span class="line" id="L1003"></span>
<span class="line" id="L1004"><span class="tok-kw">test</span> <span class="tok-str">&quot;cache file and then recall it&quot;</span> {</span>
<span class="line" id="L1005">    <span class="tok-kw">if</span> (builtin.os.tag == .wasi) {</span>
<span class="line" id="L1006">        <span class="tok-comment">// https://github.com/ziglang/zig/issues/5437</span>
</span>
<span class="line" id="L1007">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;</span>
<span class="line" id="L1008">    }</span>
<span class="line" id="L1009"></span>
<span class="line" id="L1010">    <span class="tok-kw">var</span> tmp = testing.tmpDir(.{});</span>
<span class="line" id="L1011">    <span class="tok-kw">defer</span> tmp.cleanup();</span>
<span class="line" id="L1012"></span>
<span class="line" id="L1013">    <span class="tok-kw">const</span> temp_file = <span class="tok-str">&quot;test.txt&quot;</span>;</span>
<span class="line" id="L1014">    <span class="tok-kw">const</span> temp_manifest_dir = <span class="tok-str">&quot;temp_manifest_dir&quot;</span>;</span>
<span class="line" id="L1015"></span>
<span class="line" id="L1016">    <span class="tok-kw">try</span> tmp.dir.writeFile(temp_file, <span class="tok-str">&quot;Hello, world!\n&quot;</span>);</span>
<span class="line" id="L1017"></span>
<span class="line" id="L1018">    <span class="tok-comment">// Wait for file timestamps to tick</span>
</span>
<span class="line" id="L1019">    <span class="tok-kw">const</span> initial_time = <span class="tok-kw">try</span> testGetCurrentFileTimestamp(tmp.dir);</span>
<span class="line" id="L1020">    <span class="tok-kw">while</span> ((<span class="tok-kw">try</span> testGetCurrentFileTimestamp(tmp.dir)) == initial_time) {</span>
<span class="line" id="L1021">        std.time.sleep(<span class="tok-number">1</span>);</span>
<span class="line" id="L1022">    }</span>
<span class="line" id="L1023"></span>
<span class="line" id="L1024">    <span class="tok-kw">var</span> digest1: [hex_digest_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1025">    <span class="tok-kw">var</span> digest2: [hex_digest_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1026"></span>
<span class="line" id="L1027">    {</span>
<span class="line" id="L1028">        <span class="tok-kw">var</span> cache = Cache{</span>
<span class="line" id="L1029">            .gpa = testing.allocator,</span>
<span class="line" id="L1030">            .manifest_dir = <span class="tok-kw">try</span> tmp.dir.makeOpenPath(temp_manifest_dir, .{}),</span>
<span class="line" id="L1031">        };</span>
<span class="line" id="L1032">        cache.addPrefix(.{ .path = <span class="tok-null">null</span>, .handle = tmp.dir });</span>
<span class="line" id="L1033">        <span class="tok-kw">defer</span> cache.manifest_dir.close();</span>
<span class="line" id="L1034"></span>
<span class="line" id="L1035">        {</span>
<span class="line" id="L1036">            <span class="tok-kw">var</span> ch = cache.obtain();</span>
<span class="line" id="L1037">            <span class="tok-kw">defer</span> ch.deinit();</span>
<span class="line" id="L1038"></span>
<span class="line" id="L1039">            ch.hash.add(<span class="tok-null">true</span>);</span>
<span class="line" id="L1040">            ch.hash.add(<span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-number">1234</span>));</span>
<span class="line" id="L1041">            ch.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);</span>
<span class="line" id="L1042">            _ = <span class="tok-kw">try</span> ch.addFile(temp_file, <span class="tok-null">null</span>);</span>
<span class="line" id="L1043"></span>
<span class="line" id="L1044">            <span class="tok-comment">// There should be nothing in the cache</span>
</span>
<span class="line" id="L1045">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-null">false</span>, <span class="tok-kw">try</span> ch.hit());</span>
<span class="line" id="L1046"></span>
<span class="line" id="L1047">            digest1 = ch.final();</span>
<span class="line" id="L1048">            <span class="tok-kw">try</span> ch.writeManifest();</span>
<span class="line" id="L1049">        }</span>
<span class="line" id="L1050">        {</span>
<span class="line" id="L1051">            <span class="tok-kw">var</span> ch = cache.obtain();</span>
<span class="line" id="L1052">            <span class="tok-kw">defer</span> ch.deinit();</span>
<span class="line" id="L1053"></span>
<span class="line" id="L1054">            ch.hash.add(<span class="tok-null">true</span>);</span>
<span class="line" id="L1055">            ch.hash.add(<span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-number">1234</span>));</span>
<span class="line" id="L1056">            ch.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);</span>
<span class="line" id="L1057">            _ = <span class="tok-kw">try</span> ch.addFile(temp_file, <span class="tok-null">null</span>);</span>
<span class="line" id="L1058"></span>
<span class="line" id="L1059">            <span class="tok-comment">// Cache hit! We just &quot;built&quot; the same file</span>
</span>
<span class="line" id="L1060">            <span class="tok-kw">try</span> testing.expect(<span class="tok-kw">try</span> ch.hit());</span>
<span class="line" id="L1061">            digest2 = ch.final();</span>
<span class="line" id="L1062"></span>
<span class="line" id="L1063">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-null">false</span>, ch.have_exclusive_lock);</span>
<span class="line" id="L1064">        }</span>
<span class="line" id="L1065"></span>
<span class="line" id="L1066">        <span class="tok-kw">try</span> testing.expectEqual(digest1, digest2);</span>
<span class="line" id="L1067">    }</span>
<span class="line" id="L1068">}</span>
<span class="line" id="L1069"></span>
<span class="line" id="L1070"><span class="tok-kw">test</span> <span class="tok-str">&quot;check that changing a file makes cache fail&quot;</span> {</span>
<span class="line" id="L1071">    <span class="tok-kw">if</span> (builtin.os.tag == .wasi) {</span>
<span class="line" id="L1072">        <span class="tok-comment">// https://github.com/ziglang/zig/issues/5437</span>
</span>
<span class="line" id="L1073">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;</span>
<span class="line" id="L1074">    }</span>
<span class="line" id="L1075"></span>
<span class="line" id="L1076">    <span class="tok-kw">var</span> tmp = testing.tmpDir(.{});</span>
<span class="line" id="L1077">    <span class="tok-kw">defer</span> tmp.cleanup();</span>
<span class="line" id="L1078"></span>
<span class="line" id="L1079">    <span class="tok-kw">const</span> temp_file = <span class="tok-str">&quot;cache_hash_change_file_test.txt&quot;</span>;</span>
<span class="line" id="L1080">    <span class="tok-kw">const</span> temp_manifest_dir = <span class="tok-str">&quot;cache_hash_change_file_manifest_dir&quot;</span>;</span>
<span class="line" id="L1081">    <span class="tok-kw">const</span> original_temp_file_contents = <span class="tok-str">&quot;Hello, world!\n&quot;</span>;</span>
<span class="line" id="L1082">    <span class="tok-kw">const</span> updated_temp_file_contents = <span class="tok-str">&quot;Hello, world; but updated!\n&quot;</span>;</span>
<span class="line" id="L1083"></span>
<span class="line" id="L1084">    <span class="tok-kw">try</span> tmp.dir.writeFile(temp_file, original_temp_file_contents);</span>
<span class="line" id="L1085"></span>
<span class="line" id="L1086">    <span class="tok-comment">// Wait for file timestamps to tick</span>
</span>
<span class="line" id="L1087">    <span class="tok-kw">const</span> initial_time = <span class="tok-kw">try</span> testGetCurrentFileTimestamp(tmp.dir);</span>
<span class="line" id="L1088">    <span class="tok-kw">while</span> ((<span class="tok-kw">try</span> testGetCurrentFileTimestamp(tmp.dir)) == initial_time) {</span>
<span class="line" id="L1089">        std.time.sleep(<span class="tok-number">1</span>);</span>
<span class="line" id="L1090">    }</span>
<span class="line" id="L1091"></span>
<span class="line" id="L1092">    <span class="tok-kw">var</span> digest1: [hex_digest_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1093">    <span class="tok-kw">var</span> digest2: [hex_digest_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1094"></span>
<span class="line" id="L1095">    {</span>
<span class="line" id="L1096">        <span class="tok-kw">var</span> cache = Cache{</span>
<span class="line" id="L1097">            .gpa = testing.allocator,</span>
<span class="line" id="L1098">            .manifest_dir = <span class="tok-kw">try</span> tmp.dir.makeOpenPath(temp_manifest_dir, .{}),</span>
<span class="line" id="L1099">        };</span>
<span class="line" id="L1100">        cache.addPrefix(.{ .path = <span class="tok-null">null</span>, .handle = tmp.dir });</span>
<span class="line" id="L1101">        <span class="tok-kw">defer</span> cache.manifest_dir.close();</span>
<span class="line" id="L1102"></span>
<span class="line" id="L1103">        {</span>
<span class="line" id="L1104">            <span class="tok-kw">var</span> ch = cache.obtain();</span>
<span class="line" id="L1105">            <span class="tok-kw">defer</span> ch.deinit();</span>
<span class="line" id="L1106"></span>
<span class="line" id="L1107">            ch.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);</span>
<span class="line" id="L1108">            <span class="tok-kw">const</span> temp_file_idx = <span class="tok-kw">try</span> ch.addFile(temp_file, <span class="tok-number">100</span>);</span>
<span class="line" id="L1109"></span>
<span class="line" id="L1110">            <span class="tok-comment">// There should be nothing in the cache</span>
</span>
<span class="line" id="L1111">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-null">false</span>, <span class="tok-kw">try</span> ch.hit());</span>
<span class="line" id="L1112"></span>
<span class="line" id="L1113">            <span class="tok-kw">try</span> testing.expect(mem.eql(<span class="tok-type">u8</span>, original_temp_file_contents, ch.files.items[temp_file_idx].contents.?));</span>
<span class="line" id="L1114"></span>
<span class="line" id="L1115">            digest1 = ch.final();</span>
<span class="line" id="L1116"></span>
<span class="line" id="L1117">            <span class="tok-kw">try</span> ch.writeManifest();</span>
<span class="line" id="L1118">        }</span>
<span class="line" id="L1119"></span>
<span class="line" id="L1120">        <span class="tok-kw">try</span> tmp.dir.writeFile(temp_file, updated_temp_file_contents);</span>
<span class="line" id="L1121"></span>
<span class="line" id="L1122">        {</span>
<span class="line" id="L1123">            <span class="tok-kw">var</span> ch = cache.obtain();</span>
<span class="line" id="L1124">            <span class="tok-kw">defer</span> ch.deinit();</span>
<span class="line" id="L1125"></span>
<span class="line" id="L1126">            ch.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);</span>
<span class="line" id="L1127">            <span class="tok-kw">const</span> temp_file_idx = <span class="tok-kw">try</span> ch.addFile(temp_file, <span class="tok-number">100</span>);</span>
<span class="line" id="L1128"></span>
<span class="line" id="L1129">            <span class="tok-comment">// A file that we depend on has been updated, so the cache should not contain an entry for it</span>
</span>
<span class="line" id="L1130">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-null">false</span>, <span class="tok-kw">try</span> ch.hit());</span>
<span class="line" id="L1131"></span>
<span class="line" id="L1132">            <span class="tok-comment">// The cache system does not keep the contents of re-hashed input files.</span>
</span>
<span class="line" id="L1133">            <span class="tok-kw">try</span> testing.expect(ch.files.items[temp_file_idx].contents == <span class="tok-null">null</span>);</span>
<span class="line" id="L1134"></span>
<span class="line" id="L1135">            digest2 = ch.final();</span>
<span class="line" id="L1136"></span>
<span class="line" id="L1137">            <span class="tok-kw">try</span> ch.writeManifest();</span>
<span class="line" id="L1138">        }</span>
<span class="line" id="L1139"></span>
<span class="line" id="L1140">        <span class="tok-kw">try</span> testing.expect(!mem.eql(<span class="tok-type">u8</span>, digest1[<span class="tok-number">0</span>..], digest2[<span class="tok-number">0</span>..]));</span>
<span class="line" id="L1141">    }</span>
<span class="line" id="L1142">}</span>
<span class="line" id="L1143"></span>
<span class="line" id="L1144"><span class="tok-kw">test</span> <span class="tok-str">&quot;no file inputs&quot;</span> {</span>
<span class="line" id="L1145">    <span class="tok-kw">if</span> (builtin.os.tag == .wasi) {</span>
<span class="line" id="L1146">        <span class="tok-comment">// https://github.com/ziglang/zig/issues/5437</span>
</span>
<span class="line" id="L1147">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;</span>
<span class="line" id="L1148">    }</span>
<span class="line" id="L1149"></span>
<span class="line" id="L1150">    <span class="tok-kw">var</span> tmp = testing.tmpDir(.{});</span>
<span class="line" id="L1151">    <span class="tok-kw">defer</span> tmp.cleanup();</span>
<span class="line" id="L1152"></span>
<span class="line" id="L1153">    <span class="tok-kw">const</span> temp_manifest_dir = <span class="tok-str">&quot;no_file_inputs_manifest_dir&quot;</span>;</span>
<span class="line" id="L1154"></span>
<span class="line" id="L1155">    <span class="tok-kw">var</span> digest1: [hex_digest_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1156">    <span class="tok-kw">var</span> digest2: [hex_digest_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1157"></span>
<span class="line" id="L1158">    <span class="tok-kw">var</span> cache = Cache{</span>
<span class="line" id="L1159">        .gpa = testing.allocator,</span>
<span class="line" id="L1160">        .manifest_dir = <span class="tok-kw">try</span> tmp.dir.makeOpenPath(temp_manifest_dir, .{}),</span>
<span class="line" id="L1161">    };</span>
<span class="line" id="L1162">    cache.addPrefix(.{ .path = <span class="tok-null">null</span>, .handle = tmp.dir });</span>
<span class="line" id="L1163">    <span class="tok-kw">defer</span> cache.manifest_dir.close();</span>
<span class="line" id="L1164"></span>
<span class="line" id="L1165">    {</span>
<span class="line" id="L1166">        <span class="tok-kw">var</span> man = cache.obtain();</span>
<span class="line" id="L1167">        <span class="tok-kw">defer</span> man.deinit();</span>
<span class="line" id="L1168"></span>
<span class="line" id="L1169">        man.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);</span>
<span class="line" id="L1170"></span>
<span class="line" id="L1171">        <span class="tok-comment">// There should be nothing in the cache</span>
</span>
<span class="line" id="L1172">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-null">false</span>, <span class="tok-kw">try</span> man.hit());</span>
<span class="line" id="L1173"></span>
<span class="line" id="L1174">        digest1 = man.final();</span>
<span class="line" id="L1175"></span>
<span class="line" id="L1176">        <span class="tok-kw">try</span> man.writeManifest();</span>
<span class="line" id="L1177">    }</span>
<span class="line" id="L1178">    {</span>
<span class="line" id="L1179">        <span class="tok-kw">var</span> man = cache.obtain();</span>
<span class="line" id="L1180">        <span class="tok-kw">defer</span> man.deinit();</span>
<span class="line" id="L1181"></span>
<span class="line" id="L1182">        man.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);</span>
<span class="line" id="L1183"></span>
<span class="line" id="L1184">        <span class="tok-kw">try</span> testing.expect(<span class="tok-kw">try</span> man.hit());</span>
<span class="line" id="L1185">        digest2 = man.final();</span>
<span class="line" id="L1186">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-null">false</span>, man.have_exclusive_lock);</span>
<span class="line" id="L1187">    }</span>
<span class="line" id="L1188"></span>
<span class="line" id="L1189">    <span class="tok-kw">try</span> testing.expectEqual(digest1, digest2);</span>
<span class="line" id="L1190">}</span>
<span class="line" id="L1191"></span>
<span class="line" id="L1192"><span class="tok-kw">test</span> <span class="tok-str">&quot;Manifest with files added after initial hash work&quot;</span> {</span>
<span class="line" id="L1193">    <span class="tok-kw">if</span> (builtin.os.tag == .wasi) {</span>
<span class="line" id="L1194">        <span class="tok-comment">// https://github.com/ziglang/zig/issues/5437</span>
</span>
<span class="line" id="L1195">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;</span>
<span class="line" id="L1196">    }</span>
<span class="line" id="L1197"></span>
<span class="line" id="L1198">    <span class="tok-kw">var</span> tmp = testing.tmpDir(.{});</span>
<span class="line" id="L1199">    <span class="tok-kw">defer</span> tmp.cleanup();</span>
<span class="line" id="L1200"></span>
<span class="line" id="L1201">    <span class="tok-kw">const</span> temp_file1 = <span class="tok-str">&quot;cache_hash_post_file_test1.txt&quot;</span>;</span>
<span class="line" id="L1202">    <span class="tok-kw">const</span> temp_file2 = <span class="tok-str">&quot;cache_hash_post_file_test2.txt&quot;</span>;</span>
<span class="line" id="L1203">    <span class="tok-kw">const</span> temp_manifest_dir = <span class="tok-str">&quot;cache_hash_post_file_manifest_dir&quot;</span>;</span>
<span class="line" id="L1204"></span>
<span class="line" id="L1205">    <span class="tok-kw">try</span> tmp.dir.writeFile(temp_file1, <span class="tok-str">&quot;Hello, world!\n&quot;</span>);</span>
<span class="line" id="L1206">    <span class="tok-kw">try</span> tmp.dir.writeFile(temp_file2, <span class="tok-str">&quot;Hello world the second!\n&quot;</span>);</span>
<span class="line" id="L1207"></span>
<span class="line" id="L1208">    <span class="tok-comment">// Wait for file timestamps to tick</span>
</span>
<span class="line" id="L1209">    <span class="tok-kw">const</span> initial_time = <span class="tok-kw">try</span> testGetCurrentFileTimestamp(tmp.dir);</span>
<span class="line" id="L1210">    <span class="tok-kw">while</span> ((<span class="tok-kw">try</span> testGetCurrentFileTimestamp(tmp.dir)) == initial_time) {</span>
<span class="line" id="L1211">        std.time.sleep(<span class="tok-number">1</span>);</span>
<span class="line" id="L1212">    }</span>
<span class="line" id="L1213"></span>
<span class="line" id="L1214">    <span class="tok-kw">var</span> digest1: [hex_digest_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1215">    <span class="tok-kw">var</span> digest2: [hex_digest_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1216">    <span class="tok-kw">var</span> digest3: [hex_digest_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1217"></span>
<span class="line" id="L1218">    {</span>
<span class="line" id="L1219">        <span class="tok-kw">var</span> cache = Cache{</span>
<span class="line" id="L1220">            .gpa = testing.allocator,</span>
<span class="line" id="L1221">            .manifest_dir = <span class="tok-kw">try</span> tmp.dir.makeOpenPath(temp_manifest_dir, .{}),</span>
<span class="line" id="L1222">        };</span>
<span class="line" id="L1223">        cache.addPrefix(.{ .path = <span class="tok-null">null</span>, .handle = tmp.dir });</span>
<span class="line" id="L1224">        <span class="tok-kw">defer</span> cache.manifest_dir.close();</span>
<span class="line" id="L1225"></span>
<span class="line" id="L1226">        {</span>
<span class="line" id="L1227">            <span class="tok-kw">var</span> ch = cache.obtain();</span>
<span class="line" id="L1228">            <span class="tok-kw">defer</span> ch.deinit();</span>
<span class="line" id="L1229"></span>
<span class="line" id="L1230">            ch.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);</span>
<span class="line" id="L1231">            _ = <span class="tok-kw">try</span> ch.addFile(temp_file1, <span class="tok-null">null</span>);</span>
<span class="line" id="L1232"></span>
<span class="line" id="L1233">            <span class="tok-comment">// There should be nothing in the cache</span>
</span>
<span class="line" id="L1234">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-null">false</span>, <span class="tok-kw">try</span> ch.hit());</span>
<span class="line" id="L1235"></span>
<span class="line" id="L1236">            _ = <span class="tok-kw">try</span> ch.addFilePost(temp_file2);</span>
<span class="line" id="L1237"></span>
<span class="line" id="L1238">            digest1 = ch.final();</span>
<span class="line" id="L1239">            <span class="tok-kw">try</span> ch.writeManifest();</span>
<span class="line" id="L1240">        }</span>
<span class="line" id="L1241">        {</span>
<span class="line" id="L1242">            <span class="tok-kw">var</span> ch = cache.obtain();</span>
<span class="line" id="L1243">            <span class="tok-kw">defer</span> ch.deinit();</span>
<span class="line" id="L1244"></span>
<span class="line" id="L1245">            ch.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);</span>
<span class="line" id="L1246">            _ = <span class="tok-kw">try</span> ch.addFile(temp_file1, <span class="tok-null">null</span>);</span>
<span class="line" id="L1247"></span>
<span class="line" id="L1248">            <span class="tok-kw">try</span> testing.expect(<span class="tok-kw">try</span> ch.hit());</span>
<span class="line" id="L1249">            digest2 = ch.final();</span>
<span class="line" id="L1250"></span>
<span class="line" id="L1251">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-null">false</span>, ch.have_exclusive_lock);</span>
<span class="line" id="L1252">        }</span>
<span class="line" id="L1253">        <span class="tok-kw">try</span> testing.expect(mem.eql(<span class="tok-type">u8</span>, &amp;digest1, &amp;digest2));</span>
<span class="line" id="L1254"></span>
<span class="line" id="L1255">        <span class="tok-comment">// Modify the file added after initial hash</span>
</span>
<span class="line" id="L1256">        <span class="tok-kw">try</span> tmp.dir.writeFile(temp_file2, <span class="tok-str">&quot;Hello world the second, updated\n&quot;</span>);</span>
<span class="line" id="L1257"></span>
<span class="line" id="L1258">        <span class="tok-comment">// Wait for file timestamps to tick</span>
</span>
<span class="line" id="L1259">        <span class="tok-kw">const</span> initial_time2 = <span class="tok-kw">try</span> testGetCurrentFileTimestamp(tmp.dir);</span>
<span class="line" id="L1260">        <span class="tok-kw">while</span> ((<span class="tok-kw">try</span> testGetCurrentFileTimestamp(tmp.dir)) == initial_time2) {</span>
<span class="line" id="L1261">            std.time.sleep(<span class="tok-number">1</span>);</span>
<span class="line" id="L1262">        }</span>
<span class="line" id="L1263"></span>
<span class="line" id="L1264">        {</span>
<span class="line" id="L1265">            <span class="tok-kw">var</span> ch = cache.obtain();</span>
<span class="line" id="L1266">            <span class="tok-kw">defer</span> ch.deinit();</span>
<span class="line" id="L1267"></span>
<span class="line" id="L1268">            ch.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);</span>
<span class="line" id="L1269">            _ = <span class="tok-kw">try</span> ch.addFile(temp_file1, <span class="tok-null">null</span>);</span>
<span class="line" id="L1270"></span>
<span class="line" id="L1271">            <span class="tok-comment">// A file that we depend on has been updated, so the cache should not contain an entry for it</span>
</span>
<span class="line" id="L1272">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-null">false</span>, <span class="tok-kw">try</span> ch.hit());</span>
<span class="line" id="L1273"></span>
<span class="line" id="L1274">            _ = <span class="tok-kw">try</span> ch.addFilePost(temp_file2);</span>
<span class="line" id="L1275"></span>
<span class="line" id="L1276">            digest3 = ch.final();</span>
<span class="line" id="L1277"></span>
<span class="line" id="L1278">            <span class="tok-kw">try</span> ch.writeManifest();</span>
<span class="line" id="L1279">        }</span>
<span class="line" id="L1280"></span>
<span class="line" id="L1281">        <span class="tok-kw">try</span> testing.expect(!mem.eql(<span class="tok-type">u8</span>, &amp;digest1, &amp;digest3));</span>
<span class="line" id="L1282">    }</span>
<span class="line" id="L1283">}</span>
<span class="line" id="L1284"></span>
</code></pre></body>
</html>