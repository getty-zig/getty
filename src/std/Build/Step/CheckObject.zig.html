<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Build/Step/CheckObject.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg==">
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);</span>
<span class="line" id="L2"><span class="tok-kw">const</span> assert = std.debug.assert;</span>
<span class="line" id="L3"><span class="tok-kw">const</span> elf = std.elf;</span>
<span class="line" id="L4"><span class="tok-kw">const</span> fs = std.fs;</span>
<span class="line" id="L5"><span class="tok-kw">const</span> macho = std.macho;</span>
<span class="line" id="L6"><span class="tok-kw">const</span> math = std.math;</span>
<span class="line" id="L7"><span class="tok-kw">const</span> mem = std.mem;</span>
<span class="line" id="L8"><span class="tok-kw">const</span> testing = std.testing;</span>
<span class="line" id="L9"></span>
<span class="line" id="L10"><span class="tok-kw">const</span> CheckObject = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L11"></span>
<span class="line" id="L12"><span class="tok-kw">const</span> Allocator = mem.Allocator;</span>
<span class="line" id="L13"><span class="tok-kw">const</span> Step = std.Build.Step;</span>
<span class="line" id="L14"></span>
<span class="line" id="L15"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> base_id = .check_object;</span>
<span class="line" id="L16"></span>
<span class="line" id="L17">step: Step,</span>
<span class="line" id="L18">source: std.Build.LazyPath,</span>
<span class="line" id="L19">max_bytes: <span class="tok-type">usize</span> = <span class="tok-number">20</span> * <span class="tok-number">1024</span> * <span class="tok-number">1024</span>,</span>
<span class="line" id="L20">checks: std.ArrayList(Check),</span>
<span class="line" id="L21">obj_format: std.Target.ObjectFormat,</span>
<span class="line" id="L22"></span>
<span class="line" id="L23"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">create</span>(</span>
<span class="line" id="L24">    owner: *std.Build,</span>
<span class="line" id="L25">    source: std.Build.LazyPath,</span>
<span class="line" id="L26">    obj_format: std.Target.ObjectFormat,</span>
<span class="line" id="L27">) *CheckObject {</span>
<span class="line" id="L28">    <span class="tok-kw">const</span> gpa = owner.allocator;</span>
<span class="line" id="L29">    <span class="tok-kw">const</span> self = gpa.create(CheckObject) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L30">    self.* = .{</span>
<span class="line" id="L31">        .step = Step.init(.{</span>
<span class="line" id="L32">            .id = .check_file,</span>
<span class="line" id="L33">            .name = <span class="tok-str">&quot;CheckObject&quot;</span>,</span>
<span class="line" id="L34">            .owner = owner,</span>
<span class="line" id="L35">            .makeFn = make,</span>
<span class="line" id="L36">        }),</span>
<span class="line" id="L37">        .source = source.dupe(owner),</span>
<span class="line" id="L38">        .checks = std.ArrayList(Check).init(gpa),</span>
<span class="line" id="L39">        .obj_format = obj_format,</span>
<span class="line" id="L40">    };</span>
<span class="line" id="L41">    self.source.addStepDependencies(&amp;self.step);</span>
<span class="line" id="L42">    <span class="tok-kw">return</span> self;</span>
<span class="line" id="L43">}</span>
<span class="line" id="L44"></span>
<span class="line" id="L45"><span class="tok-kw">const</span> SearchPhrase = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L46">    string: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L47">    file_source: ?std.Build.LazyPath = <span class="tok-null">null</span>,</span>
<span class="line" id="L48"></span>
<span class="line" id="L49">    <span class="tok-kw">fn</span> <span class="tok-fn">resolve</span>(phrase: SearchPhrase, b: *std.Build, step: *Step) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L50">        <span class="tok-kw">const</span> file_source = phrase.file_source <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> phrase.string;</span>
<span class="line" id="L51">        <span class="tok-kw">return</span> b.fmt(<span class="tok-str">&quot;{s} {s}&quot;</span>, .{ phrase.string, file_source.getPath2(b, step) });</span>
<span class="line" id="L52">    }</span>
<span class="line" id="L53">};</span>
<span class="line" id="L54"></span>
<span class="line" id="L55"><span class="tok-comment">/// There five types of actions currently supported:</span></span>
<span class="line" id="L56"><span class="tok-comment">/// .exact - will do an exact match against the haystack</span></span>
<span class="line" id="L57"><span class="tok-comment">/// .contains - will check for existence within the haystack</span></span>
<span class="line" id="L58"><span class="tok-comment">/// .not_present - will check for non-existence within the haystack</span></span>
<span class="line" id="L59"><span class="tok-comment">/// .extract - will do an exact match and extract into a variable enclosed within `{name}` braces</span></span>
<span class="line" id="L60"><span class="tok-comment">/// .compute_cmp - will perform an operation on the extracted global variables</span></span>
<span class="line" id="L61"><span class="tok-comment">/// using the MatchAction. It currently only supports an addition. The operation is required</span></span>
<span class="line" id="L62"><span class="tok-comment">/// to be specified in Reverse Polish Notation to ease in operator-precedence parsing (well,</span></span>
<span class="line" id="L63"><span class="tok-comment">/// to avoid any parsing really).</span></span>
<span class="line" id="L64"><span class="tok-comment">/// For example, if the two extracted values were saved as `vmaddr` and `entryoff` respectively</span></span>
<span class="line" id="L65"><span class="tok-comment">/// they could then be added with this simple program `vmaddr entryoff +`.</span></span>
<span class="line" id="L66"><span class="tok-kw">const</span> Action = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L67">    tag: <span class="tok-kw">enum</span> { exact, contains, not_present, extract, compute_cmp },</span>
<span class="line" id="L68">    phrase: SearchPhrase,</span>
<span class="line" id="L69">    expected: ?ComputeCompareExpected = <span class="tok-null">null</span>,</span>
<span class="line" id="L70"></span>
<span class="line" id="L71">    <span class="tok-comment">/// Returns true if the `phrase` is an exact match with the haystack and variable was successfully extracted.</span></span>
<span class="line" id="L72">    <span class="tok-kw">fn</span> <span class="tok-fn">extract</span>(</span>
<span class="line" id="L73">        act: Action,</span>
<span class="line" id="L74">        b: *std.Build,</span>
<span class="line" id="L75">        step: *Step,</span>
<span class="line" id="L76">        haystack: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L77">        global_vars: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L78">    ) !<span class="tok-type">bool</span> {</span>
<span class="line" id="L79">        assert(act.tag == .extract);</span>
<span class="line" id="L80">        <span class="tok-kw">const</span> hay = mem.trim(<span class="tok-type">u8</span>, haystack, <span class="tok-str">&quot; &quot;</span>);</span>
<span class="line" id="L81">        <span class="tok-kw">const</span> phrase = mem.trim(<span class="tok-type">u8</span>, act.phrase.resolve(b, step), <span class="tok-str">&quot; &quot;</span>);</span>
<span class="line" id="L82"></span>
<span class="line" id="L83">        <span class="tok-kw">var</span> candidate_vars = std.ArrayList(<span class="tok-kw">struct</span> { name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, value: <span class="tok-type">u64</span> }).init(b.allocator);</span>
<span class="line" id="L84">        <span class="tok-kw">var</span> hay_it = mem.tokenizeScalar(<span class="tok-type">u8</span>, hay, <span class="tok-str">' '</span>);</span>
<span class="line" id="L85">        <span class="tok-kw">var</span> needle_it = mem.tokenizeScalar(<span class="tok-type">u8</span>, phrase, <span class="tok-str">' '</span>);</span>
<span class="line" id="L86"></span>
<span class="line" id="L87">        <span class="tok-kw">while</span> (needle_it.next()) |needle_tok| {</span>
<span class="line" id="L88">            <span class="tok-kw">const</span> hay_tok = hay_it.next() <span class="tok-kw">orelse</span> <span class="tok-kw">break</span>;</span>
<span class="line" id="L89">            <span class="tok-kw">if</span> (mem.startsWith(<span class="tok-type">u8</span>, needle_tok, <span class="tok-str">&quot;{&quot;</span>)) {</span>
<span class="line" id="L90">                <span class="tok-kw">const</span> closing_brace = mem.indexOf(<span class="tok-type">u8</span>, needle_tok, <span class="tok-str">&quot;}&quot;</span>) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingClosingBrace;</span>
<span class="line" id="L91">                <span class="tok-kw">if</span> (closing_brace != needle_tok.len - <span class="tok-number">1</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ClosingBraceNotLast;</span>
<span class="line" id="L92"></span>
<span class="line" id="L93">                <span class="tok-kw">const</span> name = needle_tok[<span class="tok-number">1</span>..closing_brace];</span>
<span class="line" id="L94">                <span class="tok-kw">if</span> (name.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingBraceValue;</span>
<span class="line" id="L95">                <span class="tok-kw">const</span> value = std.fmt.parseInt(<span class="tok-type">u64</span>, hay_tok, <span class="tok-number">16</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L96">                <span class="tok-kw">try</span> candidate_vars.append(.{</span>
<span class="line" id="L97">                    .name = name,</span>
<span class="line" id="L98">                    .value = value,</span>
<span class="line" id="L99">                });</span>
<span class="line" id="L100">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L101">                <span class="tok-kw">if</span> (!mem.eql(<span class="tok-type">u8</span>, hay_tok, needle_tok)) <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L102">            }</span>
<span class="line" id="L103">        }</span>
<span class="line" id="L104"></span>
<span class="line" id="L105">        <span class="tok-kw">if</span> (candidate_vars.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L106"></span>
<span class="line" id="L107">        <span class="tok-kw">for</span> (candidate_vars.items) |cv| <span class="tok-kw">try</span> global_vars.putNoClobber(cv.name, cv.value);</span>
<span class="line" id="L108"></span>
<span class="line" id="L109">        <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L110">    }</span>
<span class="line" id="L111"></span>
<span class="line" id="L112">    <span class="tok-comment">/// Returns true if the `phrase` is an exact match with the haystack.</span></span>
<span class="line" id="L113">    <span class="tok-kw">fn</span> <span class="tok-fn">exact</span>(</span>
<span class="line" id="L114">        act: Action,</span>
<span class="line" id="L115">        b: *std.Build,</span>
<span class="line" id="L116">        step: *Step,</span>
<span class="line" id="L117">        haystack: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L118">    ) <span class="tok-type">bool</span> {</span>
<span class="line" id="L119">        assert(act.tag == .exact);</span>
<span class="line" id="L120">        <span class="tok-kw">const</span> hay = mem.trim(<span class="tok-type">u8</span>, haystack, <span class="tok-str">&quot; &quot;</span>);</span>
<span class="line" id="L121">        <span class="tok-kw">const</span> phrase = mem.trim(<span class="tok-type">u8</span>, act.phrase.resolve(b, step), <span class="tok-str">&quot; &quot;</span>);</span>
<span class="line" id="L122">        <span class="tok-kw">return</span> mem.eql(<span class="tok-type">u8</span>, hay, phrase);</span>
<span class="line" id="L123">    }</span>
<span class="line" id="L124"></span>
<span class="line" id="L125">    <span class="tok-comment">/// Returns true if the `phrase` exists within the haystack.</span></span>
<span class="line" id="L126">    <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(</span>
<span class="line" id="L127">        act: Action,</span>
<span class="line" id="L128">        b: *std.Build,</span>
<span class="line" id="L129">        step: *Step,</span>
<span class="line" id="L130">        haystack: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L131">    ) <span class="tok-type">bool</span> {</span>
<span class="line" id="L132">        assert(act.tag == .contains);</span>
<span class="line" id="L133">        <span class="tok-kw">const</span> hay = mem.trim(<span class="tok-type">u8</span>, haystack, <span class="tok-str">&quot; &quot;</span>);</span>
<span class="line" id="L134">        <span class="tok-kw">const</span> phrase = mem.trim(<span class="tok-type">u8</span>, act.phrase.resolve(b, step), <span class="tok-str">&quot; &quot;</span>);</span>
<span class="line" id="L135">        <span class="tok-kw">return</span> mem.indexOf(<span class="tok-type">u8</span>, hay, phrase) != <span class="tok-null">null</span>;</span>
<span class="line" id="L136">    }</span>
<span class="line" id="L137"></span>
<span class="line" id="L138">    <span class="tok-comment">/// Returns true if the `phrase` does not exist within the haystack.</span></span>
<span class="line" id="L139">    <span class="tok-kw">fn</span> <span class="tok-fn">notPresent</span>(</span>
<span class="line" id="L140">        act: Action,</span>
<span class="line" id="L141">        b: *std.Build,</span>
<span class="line" id="L142">        step: *Step,</span>
<span class="line" id="L143">        haystack: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L144">    ) <span class="tok-type">bool</span> {</span>
<span class="line" id="L145">        assert(act.tag == .not_present);</span>
<span class="line" id="L146">        <span class="tok-kw">return</span> !contains(.{</span>
<span class="line" id="L147">            .tag = .contains,</span>
<span class="line" id="L148">            .phrase = act.phrase,</span>
<span class="line" id="L149">            .expected = act.expected,</span>
<span class="line" id="L150">        }, b, step, haystack);</span>
<span class="line" id="L151">    }</span>
<span class="line" id="L152"></span>
<span class="line" id="L153">    <span class="tok-comment">/// Will return true if the `phrase` is correctly parsed into an RPN program and</span></span>
<span class="line" id="L154">    <span class="tok-comment">/// its reduced, computed value compares using `op` with the expected value, either</span></span>
<span class="line" id="L155">    <span class="tok-comment">/// a literal or another extracted variable.</span></span>
<span class="line" id="L156">    <span class="tok-kw">fn</span> <span class="tok-fn">computeCmp</span>(act: Action, b: *std.Build, step: *Step, global_vars: <span class="tok-kw">anytype</span>) !<span class="tok-type">bool</span> {</span>
<span class="line" id="L157">        <span class="tok-kw">const</span> gpa = step.owner.allocator;</span>
<span class="line" id="L158">        <span class="tok-kw">const</span> phrase = act.phrase.resolve(b, step);</span>
<span class="line" id="L159">        <span class="tok-kw">var</span> op_stack = std.ArrayList(<span class="tok-kw">enum</span> { add, sub, mod, mul }).init(gpa);</span>
<span class="line" id="L160">        <span class="tok-kw">var</span> values = std.ArrayList(<span class="tok-type">u64</span>).init(gpa);</span>
<span class="line" id="L161"></span>
<span class="line" id="L162">        <span class="tok-kw">var</span> it = mem.tokenizeScalar(<span class="tok-type">u8</span>, phrase, <span class="tok-str">' '</span>);</span>
<span class="line" id="L163">        <span class="tok-kw">while</span> (it.next()) |next| {</span>
<span class="line" id="L164">            <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, next, <span class="tok-str">&quot;+&quot;</span>)) {</span>
<span class="line" id="L165">                <span class="tok-kw">try</span> op_stack.append(.add);</span>
<span class="line" id="L166">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, next, <span class="tok-str">&quot;-&quot;</span>)) {</span>
<span class="line" id="L167">                <span class="tok-kw">try</span> op_stack.append(.sub);</span>
<span class="line" id="L168">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, next, <span class="tok-str">&quot;%&quot;</span>)) {</span>
<span class="line" id="L169">                <span class="tok-kw">try</span> op_stack.append(.mod);</span>
<span class="line" id="L170">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, next, <span class="tok-str">&quot;*&quot;</span>)) {</span>
<span class="line" id="L171">                <span class="tok-kw">try</span> op_stack.append(.mul);</span>
<span class="line" id="L172">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L173">                <span class="tok-kw">const</span> val = std.fmt.parseInt(<span class="tok-type">u64</span>, next, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> blk: {</span>
<span class="line" id="L174">                    <span class="tok-kw">break</span> :blk global_vars.get(next) <span class="tok-kw">orelse</span> {</span>
<span class="line" id="L175">                        <span class="tok-kw">try</span> step.addError(</span>
<span class="line" id="L176">                            <span class="tok-str">\\</span></span>

<span class="line" id="L177">                            <span class="tok-str">\\========= variable was not extracted: ===========</span></span>

<span class="line" id="L178">                            <span class="tok-str">\\{s}</span></span>

<span class="line" id="L179">                            <span class="tok-str">\\=================================================</span></span>

<span class="line" id="L180">                        , .{next});</span>
<span class="line" id="L181">                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownVariable;</span>
<span class="line" id="L182">                    };</span>
<span class="line" id="L183">                };</span>
<span class="line" id="L184">                <span class="tok-kw">try</span> values.append(val);</span>
<span class="line" id="L185">            }</span>
<span class="line" id="L186">        }</span>
<span class="line" id="L187"></span>
<span class="line" id="L188">        <span class="tok-kw">var</span> op_i: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;</span>
<span class="line" id="L189">        <span class="tok-kw">var</span> reduced: <span class="tok-type">u64</span> = values.items[<span class="tok-number">0</span>];</span>
<span class="line" id="L190">        <span class="tok-kw">for</span> (op_stack.items) |op| {</span>
<span class="line" id="L191">            <span class="tok-kw">const</span> other = values.items[op_i];</span>
<span class="line" id="L192">            <span class="tok-kw">switch</span> (op) {</span>
<span class="line" id="L193">                .add =&gt; {</span>
<span class="line" id="L194">                    reduced += other;</span>
<span class="line" id="L195">                },</span>
<span class="line" id="L196">                .sub =&gt; {</span>
<span class="line" id="L197">                    reduced -= other;</span>
<span class="line" id="L198">                },</span>
<span class="line" id="L199">                .mod =&gt; {</span>
<span class="line" id="L200">                    reduced %= other;</span>
<span class="line" id="L201">                },</span>
<span class="line" id="L202">                .mul =&gt; {</span>
<span class="line" id="L203">                    reduced *= other;</span>
<span class="line" id="L204">                },</span>
<span class="line" id="L205">            }</span>
<span class="line" id="L206">            op_i += <span class="tok-number">1</span>;</span>
<span class="line" id="L207">        }</span>
<span class="line" id="L208"></span>
<span class="line" id="L209">        <span class="tok-kw">const</span> exp_value = <span class="tok-kw">switch</span> (act.expected.?.value) {</span>
<span class="line" id="L210">            .variable =&gt; |name| global_vars.get(name) <span class="tok-kw">orelse</span> {</span>
<span class="line" id="L211">                <span class="tok-kw">try</span> step.addError(</span>
<span class="line" id="L212">                    <span class="tok-str">\\</span></span>

<span class="line" id="L213">                    <span class="tok-str">\\========= variable was not extracted: ===========</span></span>

<span class="line" id="L214">                    <span class="tok-str">\\{s}</span></span>

<span class="line" id="L215">                    <span class="tok-str">\\=================================================</span></span>

<span class="line" id="L216">                , .{name});</span>
<span class="line" id="L217">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownVariable;</span>
<span class="line" id="L218">            },</span>
<span class="line" id="L219">            .literal =&gt; |x| x,</span>
<span class="line" id="L220">        };</span>
<span class="line" id="L221">        <span class="tok-kw">return</span> math.compare(reduced, act.expected.?.op, exp_value);</span>
<span class="line" id="L222">    }</span>
<span class="line" id="L223">};</span>
<span class="line" id="L224"></span>
<span class="line" id="L225"><span class="tok-kw">const</span> ComputeCompareExpected = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L226">    op: math.CompareOperator,</span>
<span class="line" id="L227">    value: <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L228">        variable: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L229">        literal: <span class="tok-type">u64</span>,</span>
<span class="line" id="L230">    },</span>
<span class="line" id="L231"></span>
<span class="line" id="L232">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(</span>
<span class="line" id="L233">        value: <span class="tok-builtin">@This</span>(),</span>
<span class="line" id="L234">        <span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L235">        options: std.fmt.FormatOptions,</span>
<span class="line" id="L236">        writer: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L237">    ) !<span class="tok-type">void</span> {</span>
<span class="line" id="L238">        <span class="tok-kw">if</span> (fmt.len != <span class="tok-number">0</span>) std.fmt.invalidFmtError(fmt, value);</span>
<span class="line" id="L239">        _ = options;</span>
<span class="line" id="L240">        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{s} &quot;</span>, .{<span class="tok-builtin">@tagName</span>(value.op)});</span>
<span class="line" id="L241">        <span class="tok-kw">switch</span> (value.value) {</span>
<span class="line" id="L242">            .variable =&gt; |name| <span class="tok-kw">try</span> writer.writeAll(name),</span>
<span class="line" id="L243">            .literal =&gt; |x| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{x}&quot;</span>, .{x}),</span>
<span class="line" id="L244">        }</span>
<span class="line" id="L245">    }</span>
<span class="line" id="L246">};</span>
<span class="line" id="L247"></span>
<span class="line" id="L248"><span class="tok-kw">const</span> Check = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L249">    kind: Kind,</span>
<span class="line" id="L250">    actions: std.ArrayList(Action),</span>
<span class="line" id="L251"></span>
<span class="line" id="L252">    <span class="tok-kw">fn</span> <span class="tok-fn">create</span>(allocator: Allocator, kind: Kind) Check {</span>
<span class="line" id="L253">        <span class="tok-kw">return</span> .{</span>
<span class="line" id="L254">            .kind = kind,</span>
<span class="line" id="L255">            .actions = std.ArrayList(Action).init(allocator),</span>
<span class="line" id="L256">        };</span>
<span class="line" id="L257">    }</span>
<span class="line" id="L258"></span>
<span class="line" id="L259">    <span class="tok-kw">fn</span> <span class="tok-fn">extract</span>(self: *Check, phrase: SearchPhrase) <span class="tok-type">void</span> {</span>
<span class="line" id="L260">        self.actions.append(.{</span>
<span class="line" id="L261">            .tag = .extract,</span>
<span class="line" id="L262">            .phrase = phrase,</span>
<span class="line" id="L263">        }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L264">    }</span>
<span class="line" id="L265"></span>
<span class="line" id="L266">    <span class="tok-kw">fn</span> <span class="tok-fn">exact</span>(self: *Check, phrase: SearchPhrase) <span class="tok-type">void</span> {</span>
<span class="line" id="L267">        self.actions.append(.{</span>
<span class="line" id="L268">            .tag = .exact,</span>
<span class="line" id="L269">            .phrase = phrase,</span>
<span class="line" id="L270">        }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L271">    }</span>
<span class="line" id="L272"></span>
<span class="line" id="L273">    <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: *Check, phrase: SearchPhrase) <span class="tok-type">void</span> {</span>
<span class="line" id="L274">        self.actions.append(.{</span>
<span class="line" id="L275">            .tag = .contains,</span>
<span class="line" id="L276">            .phrase = phrase,</span>
<span class="line" id="L277">        }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L278">    }</span>
<span class="line" id="L279"></span>
<span class="line" id="L280">    <span class="tok-kw">fn</span> <span class="tok-fn">notPresent</span>(self: *Check, phrase: SearchPhrase) <span class="tok-type">void</span> {</span>
<span class="line" id="L281">        self.actions.append(.{</span>
<span class="line" id="L282">            .tag = .not_present,</span>
<span class="line" id="L283">            .phrase = phrase,</span>
<span class="line" id="L284">        }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L285">    }</span>
<span class="line" id="L286"></span>
<span class="line" id="L287">    <span class="tok-kw">fn</span> <span class="tok-fn">computeCmp</span>(self: *Check, phrase: SearchPhrase, expected: ComputeCompareExpected) <span class="tok-type">void</span> {</span>
<span class="line" id="L288">        self.actions.append(.{</span>
<span class="line" id="L289">            .tag = .compute_cmp,</span>
<span class="line" id="L290">            .phrase = phrase,</span>
<span class="line" id="L291">            .expected = expected,</span>
<span class="line" id="L292">        }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L293">    }</span>
<span class="line" id="L294"></span>
<span class="line" id="L295">    <span class="tok-kw">const</span> Kind = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L296">        headers,</span>
<span class="line" id="L297">        symtab,</span>
<span class="line" id="L298">        indirect_symtab,</span>
<span class="line" id="L299">        dynamic_symtab,</span>
<span class="line" id="L300">        archive_symtab,</span>
<span class="line" id="L301">        dynamic_section,</span>
<span class="line" id="L302">        dyld_rebase,</span>
<span class="line" id="L303">        dyld_bind,</span>
<span class="line" id="L304">        dyld_weak_bind,</span>
<span class="line" id="L305">        dyld_lazy_bind,</span>
<span class="line" id="L306">        exports,</span>
<span class="line" id="L307">        compute_compare,</span>
<span class="line" id="L308">    };</span>
<span class="line" id="L309">};</span>
<span class="line" id="L310"></span>
<span class="line" id="L311"><span class="tok-comment">/// Creates a new empty sequence of actions.</span></span>
<span class="line" id="L312"><span class="tok-kw">fn</span> <span class="tok-fn">checkStart</span>(self: *CheckObject, kind: Check.Kind) <span class="tok-type">void</span> {</span>
<span class="line" id="L313">    <span class="tok-kw">const</span> new_check = Check.create(self.step.owner.allocator, kind);</span>
<span class="line" id="L314">    self.checks.append(new_check) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L315">}</span>
<span class="line" id="L316"></span>
<span class="line" id="L317"><span class="tok-comment">/// Adds an exact match phrase to the latest created Check.</span></span>
<span class="line" id="L318"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkExact</span>(self: *CheckObject, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L319">    self.checkExactInner(phrase, <span class="tok-null">null</span>);</span>
<span class="line" id="L320">}</span>
<span class="line" id="L321"></span>
<span class="line" id="L322"><span class="tok-comment">/// Like `checkExact()` but takes an additional argument `LazyPath` which will be</span></span>
<span class="line" id="L323"><span class="tok-comment">/// resolved to a full search query in `make()`.</span></span>
<span class="line" id="L324"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkExactPath</span>(self: *CheckObject, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, file_source: std.Build.LazyPath) <span class="tok-type">void</span> {</span>
<span class="line" id="L325">    self.checkExactInner(phrase, file_source);</span>
<span class="line" id="L326">}</span>
<span class="line" id="L327"></span>
<span class="line" id="L328"><span class="tok-kw">fn</span> <span class="tok-fn">checkExactInner</span>(self: *CheckObject, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, file_source: ?std.Build.LazyPath) <span class="tok-type">void</span> {</span>
<span class="line" id="L329">    assert(self.checks.items.len &gt; <span class="tok-number">0</span>);</span>
<span class="line" id="L330">    <span class="tok-kw">const</span> last = &amp;self.checks.items[self.checks.items.len - <span class="tok-number">1</span>];</span>
<span class="line" id="L331">    last.exact(.{ .string = self.step.owner.dupe(phrase), .file_source = file_source });</span>
<span class="line" id="L332">}</span>
<span class="line" id="L333"></span>
<span class="line" id="L334"><span class="tok-comment">/// Adds a fuzzy match phrase to the latest created Check.</span></span>
<span class="line" id="L335"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkContains</span>(self: *CheckObject, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L336">    self.checkContainsInner(phrase, <span class="tok-null">null</span>);</span>
<span class="line" id="L337">}</span>
<span class="line" id="L338"></span>
<span class="line" id="L339"><span class="tok-comment">/// Like `checkContains()` but takes an additional argument `FileSource` which will be</span></span>
<span class="line" id="L340"><span class="tok-comment">/// resolved to a full search query in `make()`.</span></span>
<span class="line" id="L341"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkContainsPath</span>(self: *CheckObject, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, file_source: std.Build.LazyPath) <span class="tok-type">void</span> {</span>
<span class="line" id="L342">    self.checkContainsInner(phrase, file_source);</span>
<span class="line" id="L343">}</span>
<span class="line" id="L344"></span>
<span class="line" id="L345"><span class="tok-kw">fn</span> <span class="tok-fn">checkContainsInner</span>(self: *CheckObject, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, file_source: ?std.Build.FileSource) <span class="tok-type">void</span> {</span>
<span class="line" id="L346">    assert(self.checks.items.len &gt; <span class="tok-number">0</span>);</span>
<span class="line" id="L347">    <span class="tok-kw">const</span> last = &amp;self.checks.items[self.checks.items.len - <span class="tok-number">1</span>];</span>
<span class="line" id="L348">    last.contains(.{ .string = self.step.owner.dupe(phrase), .file_source = file_source });</span>
<span class="line" id="L349">}</span>
<span class="line" id="L350"></span>
<span class="line" id="L351"><span class="tok-comment">/// Adds an exact match phrase with variable extractor to the latest created Check.</span></span>
<span class="line" id="L352"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkExtract</span>(self: *CheckObject, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L353">    self.checkExtractInner(phrase, <span class="tok-null">null</span>);</span>
<span class="line" id="L354">}</span>
<span class="line" id="L355"></span>
<span class="line" id="L356"><span class="tok-comment">/// Like `checkExtract()` but takes an additional argument `FileSource` which will be</span></span>
<span class="line" id="L357"><span class="tok-comment">/// resolved to a full search query in `make()`.</span></span>
<span class="line" id="L358"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkExtractFileSource</span>(self: *CheckObject, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, file_source: std.Build.FileSource) <span class="tok-type">void</span> {</span>
<span class="line" id="L359">    self.checkExtractInner(phrase, file_source);</span>
<span class="line" id="L360">}</span>
<span class="line" id="L361"></span>
<span class="line" id="L362"><span class="tok-kw">fn</span> <span class="tok-fn">checkExtractInner</span>(self: *CheckObject, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, file_source: ?std.Build.FileSource) <span class="tok-type">void</span> {</span>
<span class="line" id="L363">    assert(self.checks.items.len &gt; <span class="tok-number">0</span>);</span>
<span class="line" id="L364">    <span class="tok-kw">const</span> last = &amp;self.checks.items[self.checks.items.len - <span class="tok-number">1</span>];</span>
<span class="line" id="L365">    last.extract(.{ .string = self.step.owner.dupe(phrase), .file_source = file_source });</span>
<span class="line" id="L366">}</span>
<span class="line" id="L367"></span>
<span class="line" id="L368"><span class="tok-comment">/// Adds another searched phrase to the latest created Check</span></span>
<span class="line" id="L369"><span class="tok-comment">/// however ensures there is no matching phrase in the output.</span></span>
<span class="line" id="L370"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkNotPresent</span>(self: *CheckObject, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L371">    self.checkNotPresentInner(phrase, <span class="tok-null">null</span>);</span>
<span class="line" id="L372">}</span>
<span class="line" id="L373"></span>
<span class="line" id="L374"><span class="tok-comment">/// Like `checkExtract()` but takes an additional argument `FileSource` which will be</span></span>
<span class="line" id="L375"><span class="tok-comment">/// resolved to a full search query in `make()`.</span></span>
<span class="line" id="L376"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkNotPresentFileSource</span>(self: *CheckObject, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, file_source: std.Build.FileSource) <span class="tok-type">void</span> {</span>
<span class="line" id="L377">    self.checkNotPresentInner(phrase, file_source);</span>
<span class="line" id="L378">}</span>
<span class="line" id="L379"></span>
<span class="line" id="L380"><span class="tok-kw">fn</span> <span class="tok-fn">checkNotPresentInner</span>(self: *CheckObject, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, file_source: ?std.Build.FileSource) <span class="tok-type">void</span> {</span>
<span class="line" id="L381">    assert(self.checks.items.len &gt; <span class="tok-number">0</span>);</span>
<span class="line" id="L382">    <span class="tok-kw">const</span> last = &amp;self.checks.items[self.checks.items.len - <span class="tok-number">1</span>];</span>
<span class="line" id="L383">    last.notPresent(.{ .string = self.step.owner.dupe(phrase), .file_source = file_source });</span>
<span class="line" id="L384">}</span>
<span class="line" id="L385"></span>
<span class="line" id="L386"><span class="tok-comment">/// Creates a new check checking in the file headers (section, program headers, etc.).</span></span>
<span class="line" id="L387"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInHeaders</span>(self: *CheckObject) <span class="tok-type">void</span> {</span>
<span class="line" id="L388">    self.checkStart(.headers);</span>
<span class="line" id="L389">}</span>
<span class="line" id="L390"></span>
<span class="line" id="L391"><span class="tok-comment">/// Creates a new check checking specifically symbol table parsed and dumped from the object</span></span>
<span class="line" id="L392"><span class="tok-comment">/// file.</span></span>
<span class="line" id="L393"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInSymtab</span>(self: *CheckObject) <span class="tok-type">void</span> {</span>
<span class="line" id="L394">    <span class="tok-kw">const</span> label = <span class="tok-kw">switch</span> (self.obj_format) {</span>
<span class="line" id="L395">        .macho =&gt; MachODumper.symtab_label,</span>
<span class="line" id="L396">        .elf =&gt; ElfDumper.symtab_label,</span>
<span class="line" id="L397">        .wasm =&gt; WasmDumper.symtab_label,</span>
<span class="line" id="L398">        .coff =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;TODO symtab for coff&quot;</span>),</span>
<span class="line" id="L399">        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;TODO other file formats&quot;</span>),</span>
<span class="line" id="L400">    };</span>
<span class="line" id="L401">    self.checkStart(.symtab);</span>
<span class="line" id="L402">    self.checkExact(label);</span>
<span class="line" id="L403">}</span>
<span class="line" id="L404"></span>
<span class="line" id="L405"><span class="tok-comment">/// Creates a new check checking specifically dyld rebase opcodes contents parsed and dumped</span></span>
<span class="line" id="L406"><span class="tok-comment">/// from the object file.</span></span>
<span class="line" id="L407"><span class="tok-comment">/// This check is target-dependent and applicable to MachO only.</span></span>
<span class="line" id="L408"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInDyldRebase</span>(self: *CheckObject) <span class="tok-type">void</span> {</span>
<span class="line" id="L409">    <span class="tok-kw">const</span> label = <span class="tok-kw">switch</span> (self.obj_format) {</span>
<span class="line" id="L410">        .macho =&gt; MachODumper.dyld_rebase_label,</span>
<span class="line" id="L411">        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;Unsupported target platform&quot;</span>),</span>
<span class="line" id="L412">    };</span>
<span class="line" id="L413">    self.checkStart(.dyld_rebase);</span>
<span class="line" id="L414">    self.checkExact(label);</span>
<span class="line" id="L415">}</span>
<span class="line" id="L416"></span>
<span class="line" id="L417"><span class="tok-comment">/// Creates a new check checking specifically dyld bind opcodes contents parsed and dumped</span></span>
<span class="line" id="L418"><span class="tok-comment">/// from the object file.</span></span>
<span class="line" id="L419"><span class="tok-comment">/// This check is target-dependent and applicable to MachO only.</span></span>
<span class="line" id="L420"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInDyldBind</span>(self: *CheckObject) <span class="tok-type">void</span> {</span>
<span class="line" id="L421">    <span class="tok-kw">const</span> label = <span class="tok-kw">switch</span> (self.obj_format) {</span>
<span class="line" id="L422">        .macho =&gt; MachODumper.dyld_bind_label,</span>
<span class="line" id="L423">        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;Unsupported target platform&quot;</span>),</span>
<span class="line" id="L424">    };</span>
<span class="line" id="L425">    self.checkStart(.dyld_bind);</span>
<span class="line" id="L426">    self.checkExact(label);</span>
<span class="line" id="L427">}</span>
<span class="line" id="L428"></span>
<span class="line" id="L429"><span class="tok-comment">/// Creates a new check checking specifically dyld weak bind opcodes contents parsed and dumped</span></span>
<span class="line" id="L430"><span class="tok-comment">/// from the object file.</span></span>
<span class="line" id="L431"><span class="tok-comment">/// This check is target-dependent and applicable to MachO only.</span></span>
<span class="line" id="L432"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInDyldWeakBind</span>(self: *CheckObject) <span class="tok-type">void</span> {</span>
<span class="line" id="L433">    <span class="tok-kw">const</span> label = <span class="tok-kw">switch</span> (self.obj_format) {</span>
<span class="line" id="L434">        .macho =&gt; MachODumper.dyld_weak_bind_label,</span>
<span class="line" id="L435">        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;Unsupported target platform&quot;</span>),</span>
<span class="line" id="L436">    };</span>
<span class="line" id="L437">    self.checkStart(.dyld_weak_bind);</span>
<span class="line" id="L438">    self.checkExact(label);</span>
<span class="line" id="L439">}</span>
<span class="line" id="L440"></span>
<span class="line" id="L441"><span class="tok-comment">/// Creates a new check checking specifically dyld lazy bind opcodes contents parsed and dumped</span></span>
<span class="line" id="L442"><span class="tok-comment">/// from the object file.</span></span>
<span class="line" id="L443"><span class="tok-comment">/// This check is target-dependent and applicable to MachO only.</span></span>
<span class="line" id="L444"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInDyldLazyBind</span>(self: *CheckObject) <span class="tok-type">void</span> {</span>
<span class="line" id="L445">    <span class="tok-kw">const</span> label = <span class="tok-kw">switch</span> (self.obj_format) {</span>
<span class="line" id="L446">        .macho =&gt; MachODumper.dyld_lazy_bind_label,</span>
<span class="line" id="L447">        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;Unsupported target platform&quot;</span>),</span>
<span class="line" id="L448">    };</span>
<span class="line" id="L449">    self.checkStart(.dyld_lazy_bind);</span>
<span class="line" id="L450">    self.checkExact(label);</span>
<span class="line" id="L451">}</span>
<span class="line" id="L452"></span>
<span class="line" id="L453"><span class="tok-comment">/// Creates a new check checking specifically exports info contents parsed and dumped</span></span>
<span class="line" id="L454"><span class="tok-comment">/// from the object file.</span></span>
<span class="line" id="L455"><span class="tok-comment">/// This check is target-dependent and applicable to MachO only.</span></span>
<span class="line" id="L456"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInExports</span>(self: *CheckObject) <span class="tok-type">void</span> {</span>
<span class="line" id="L457">    <span class="tok-kw">const</span> label = <span class="tok-kw">switch</span> (self.obj_format) {</span>
<span class="line" id="L458">        .macho =&gt; MachODumper.exports_label,</span>
<span class="line" id="L459">        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;Unsupported target platform&quot;</span>),</span>
<span class="line" id="L460">    };</span>
<span class="line" id="L461">    self.checkStart(.exports);</span>
<span class="line" id="L462">    self.checkExact(label);</span>
<span class="line" id="L463">}</span>
<span class="line" id="L464"></span>
<span class="line" id="L465"><span class="tok-comment">/// Creates a new check checking specifically indirect symbol table parsed and dumped</span></span>
<span class="line" id="L466"><span class="tok-comment">/// from the object file.</span></span>
<span class="line" id="L467"><span class="tok-comment">/// This check is target-dependent and applicable to MachO only.</span></span>
<span class="line" id="L468"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInIndirectSymtab</span>(self: *CheckObject) <span class="tok-type">void</span> {</span>
<span class="line" id="L469">    <span class="tok-kw">const</span> label = <span class="tok-kw">switch</span> (self.obj_format) {</span>
<span class="line" id="L470">        .macho =&gt; MachODumper.indirect_symtab_label,</span>
<span class="line" id="L471">        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;Unsupported target platform&quot;</span>),</span>
<span class="line" id="L472">    };</span>
<span class="line" id="L473">    self.checkStart(.indirect_symtab);</span>
<span class="line" id="L474">    self.checkExact(label);</span>
<span class="line" id="L475">}</span>
<span class="line" id="L476"></span>
<span class="line" id="L477"><span class="tok-comment">/// Creates a new check checking specifically dynamic symbol table parsed and dumped from the object</span></span>
<span class="line" id="L478"><span class="tok-comment">/// file.</span></span>
<span class="line" id="L479"><span class="tok-comment">/// This check is target-dependent and applicable to ELF only.</span></span>
<span class="line" id="L480"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInDynamicSymtab</span>(self: *CheckObject) <span class="tok-type">void</span> {</span>
<span class="line" id="L481">    <span class="tok-kw">const</span> label = <span class="tok-kw">switch</span> (self.obj_format) {</span>
<span class="line" id="L482">        .elf =&gt; ElfDumper.dynamic_symtab_label,</span>
<span class="line" id="L483">        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;Unsupported target platform&quot;</span>),</span>
<span class="line" id="L484">    };</span>
<span class="line" id="L485">    self.checkStart(.dynamic_symtab);</span>
<span class="line" id="L486">    self.checkExact(label);</span>
<span class="line" id="L487">}</span>
<span class="line" id="L488"></span>
<span class="line" id="L489"><span class="tok-comment">/// Creates a new check checking specifically dynamic section parsed and dumped from the object</span></span>
<span class="line" id="L490"><span class="tok-comment">/// file.</span></span>
<span class="line" id="L491"><span class="tok-comment">/// This check is target-dependent and applicable to ELF only.</span></span>
<span class="line" id="L492"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInDynamicSection</span>(self: *CheckObject) <span class="tok-type">void</span> {</span>
<span class="line" id="L493">    <span class="tok-kw">const</span> label = <span class="tok-kw">switch</span> (self.obj_format) {</span>
<span class="line" id="L494">        .elf =&gt; ElfDumper.dynamic_section_label,</span>
<span class="line" id="L495">        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;Unsupported target platform&quot;</span>),</span>
<span class="line" id="L496">    };</span>
<span class="line" id="L497">    self.checkStart(.dynamic_section);</span>
<span class="line" id="L498">    self.checkExact(label);</span>
<span class="line" id="L499">}</span>
<span class="line" id="L500"></span>
<span class="line" id="L501"><span class="tok-comment">/// Creates a new check checking specifically symbol table parsed and dumped from the archive</span></span>
<span class="line" id="L502"><span class="tok-comment">/// file.</span></span>
<span class="line" id="L503"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInArchiveSymtab</span>(self: *CheckObject) <span class="tok-type">void</span> {</span>
<span class="line" id="L504">    <span class="tok-kw">const</span> label = <span class="tok-kw">switch</span> (self.obj_format) {</span>
<span class="line" id="L505">        .elf =&gt; ElfDumper.archive_symtab_label,</span>
<span class="line" id="L506">        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;TODO other file formats&quot;</span>),</span>
<span class="line" id="L507">    };</span>
<span class="line" id="L508">    self.checkStart(.archive_symtab);</span>
<span class="line" id="L509">    self.checkExact(label);</span>
<span class="line" id="L510">}</span>
<span class="line" id="L511"></span>
<span class="line" id="L512"><span class="tok-comment">/// Creates a new standalone, singular check which allows running simple binary operations</span></span>
<span class="line" id="L513"><span class="tok-comment">/// on the extracted variables. It will then compare the reduced program with the value of</span></span>
<span class="line" id="L514"><span class="tok-comment">/// the expected variable.</span></span>
<span class="line" id="L515"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkComputeCompare</span>(</span>
<span class="line" id="L516">    self: *CheckObject,</span>
<span class="line" id="L517">    program: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L518">    expected: ComputeCompareExpected,</span>
<span class="line" id="L519">) <span class="tok-type">void</span> {</span>
<span class="line" id="L520">    <span class="tok-kw">var</span> new_check = Check.create(self.step.owner.allocator, .compute_compare);</span>
<span class="line" id="L521">    new_check.computeCmp(.{ .string = self.step.owner.dupe(program) }, expected);</span>
<span class="line" id="L522">    self.checks.append(new_check) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L523">}</span>
<span class="line" id="L524"></span>
<span class="line" id="L525"><span class="tok-kw">fn</span> <span class="tok-fn">make</span>(step: *Step, prog_node: *std.Progress.Node) !<span class="tok-type">void</span> {</span>
<span class="line" id="L526">    _ = prog_node;</span>
<span class="line" id="L527">    <span class="tok-kw">const</span> b = step.owner;</span>
<span class="line" id="L528">    <span class="tok-kw">const</span> gpa = b.allocator;</span>
<span class="line" id="L529">    <span class="tok-kw">const</span> self = <span class="tok-builtin">@fieldParentPtr</span>(CheckObject, <span class="tok-str">&quot;step&quot;</span>, step);</span>
<span class="line" id="L530"></span>
<span class="line" id="L531">    <span class="tok-kw">const</span> src_path = self.source.getPath(b);</span>
<span class="line" id="L532">    <span class="tok-kw">const</span> contents = fs.cwd().readFileAllocOptions(</span>
<span class="line" id="L533">        gpa,</span>
<span class="line" id="L534">        src_path,</span>
<span class="line" id="L535">        self.max_bytes,</span>
<span class="line" id="L536">        <span class="tok-null">null</span>,</span>
<span class="line" id="L537">        <span class="tok-builtin">@alignOf</span>(<span class="tok-type">u64</span>),</span>
<span class="line" id="L538">        <span class="tok-null">null</span>,</span>
<span class="line" id="L539">    ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;unable to read '{s}': {s}&quot;</span>, .{ src_path, <span class="tok-builtin">@errorName</span>(err) });</span>
<span class="line" id="L540"></span>
<span class="line" id="L541">    <span class="tok-kw">var</span> vars = std.StringHashMap(<span class="tok-type">u64</span>).init(gpa);</span>
<span class="line" id="L542">    <span class="tok-kw">for</span> (self.checks.items) |chk| {</span>
<span class="line" id="L543">        <span class="tok-kw">if</span> (chk.kind == .compute_compare) {</span>
<span class="line" id="L544">            assert(chk.actions.items.len == <span class="tok-number">1</span>);</span>
<span class="line" id="L545">            <span class="tok-kw">const</span> act = chk.actions.items[<span class="tok-number">0</span>];</span>
<span class="line" id="L546">            assert(act.tag == .compute_cmp);</span>
<span class="line" id="L547">            <span class="tok-kw">const</span> res = act.computeCmp(b, step, vars) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L548">                <span class="tok-kw">error</span>.UnknownVariable =&gt; <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;Unknown variable&quot;</span>, .{}),</span>
<span class="line" id="L549">                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L550">            };</span>
<span class="line" id="L551">            <span class="tok-kw">if</span> (!res) {</span>
<span class="line" id="L552">                <span class="tok-kw">return</span> step.fail(</span>
<span class="line" id="L553">                    <span class="tok-str">\\</span></span>

<span class="line" id="L554">                    <span class="tok-str">\\========= comparison failed for action: ===========</span></span>

<span class="line" id="L555">                    <span class="tok-str">\\{s} {}</span></span>

<span class="line" id="L556">                    <span class="tok-str">\\===================================================</span></span>

<span class="line" id="L557">                , .{ act.phrase.resolve(b, step), act.expected.? });</span>
<span class="line" id="L558">            }</span>
<span class="line" id="L559">            <span class="tok-kw">continue</span>;</span>
<span class="line" id="L560">        }</span>
<span class="line" id="L561"></span>
<span class="line" id="L562">        <span class="tok-kw">const</span> output = <span class="tok-kw">switch</span> (self.obj_format) {</span>
<span class="line" id="L563">            .macho =&gt; <span class="tok-kw">try</span> MachODumper.parseAndDump(step, chk.kind, contents),</span>
<span class="line" id="L564">            .elf =&gt; <span class="tok-kw">try</span> ElfDumper.parseAndDump(step, chk.kind, contents),</span>
<span class="line" id="L565">            .coff =&gt; <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;TODO coff parser&quot;</span>, .{}),</span>
<span class="line" id="L566">            .wasm =&gt; <span class="tok-kw">try</span> WasmDumper.parseAndDump(step, chk.kind, contents),</span>
<span class="line" id="L567">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L568">        };</span>
<span class="line" id="L569"></span>
<span class="line" id="L570">        <span class="tok-kw">var</span> it = mem.tokenizeAny(<span class="tok-type">u8</span>, output, <span class="tok-str">&quot;\r\n&quot;</span>);</span>
<span class="line" id="L571">        <span class="tok-kw">for</span> (chk.actions.items) |act| {</span>
<span class="line" id="L572">            <span class="tok-kw">switch</span> (act.tag) {</span>
<span class="line" id="L573">                .exact =&gt; {</span>
<span class="line" id="L574">                    <span class="tok-kw">while</span> (it.next()) |line| {</span>
<span class="line" id="L575">                        <span class="tok-kw">if</span> (act.exact(b, step, line)) <span class="tok-kw">break</span>;</span>
<span class="line" id="L576">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L577">                        <span class="tok-kw">return</span> step.fail(</span>
<span class="line" id="L578">                            <span class="tok-str">\\</span></span>

<span class="line" id="L579">                            <span class="tok-str">\\========= expected to find: ==========================</span></span>

<span class="line" id="L580">                            <span class="tok-str">\\{s}</span></span>

<span class="line" id="L581">                            <span class="tok-str">\\========= but parsed file does not contain it: =======</span></span>

<span class="line" id="L582">                            <span class="tok-str">\\{s}</span></span>

<span class="line" id="L583">                            <span class="tok-str">\\======================================================</span></span>

<span class="line" id="L584">                        , .{ act.phrase.resolve(b, step), output });</span>
<span class="line" id="L585">                    }</span>
<span class="line" id="L586">                },</span>
<span class="line" id="L587"></span>
<span class="line" id="L588">                .contains =&gt; {</span>
<span class="line" id="L589">                    <span class="tok-kw">while</span> (it.next()) |line| {</span>
<span class="line" id="L590">                        <span class="tok-kw">if</span> (act.contains(b, step, line)) <span class="tok-kw">break</span>;</span>
<span class="line" id="L591">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L592">                        <span class="tok-kw">return</span> step.fail(</span>
<span class="line" id="L593">                            <span class="tok-str">\\</span></span>

<span class="line" id="L594">                            <span class="tok-str">\\========= expected to find: ==========================</span></span>

<span class="line" id="L595">                            <span class="tok-str">\\*{s}*</span></span>

<span class="line" id="L596">                            <span class="tok-str">\\========= but parsed file does not contain it: =======</span></span>

<span class="line" id="L597">                            <span class="tok-str">\\{s}</span></span>

<span class="line" id="L598">                            <span class="tok-str">\\======================================================</span></span>

<span class="line" id="L599">                        , .{ act.phrase.resolve(b, step), output });</span>
<span class="line" id="L600">                    }</span>
<span class="line" id="L601">                },</span>
<span class="line" id="L602"></span>
<span class="line" id="L603">                .not_present =&gt; {</span>
<span class="line" id="L604">                    <span class="tok-kw">while</span> (it.next()) |line| {</span>
<span class="line" id="L605">                        <span class="tok-kw">if</span> (act.notPresent(b, step, line)) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L606">                        <span class="tok-kw">return</span> step.fail(</span>
<span class="line" id="L607">                            <span class="tok-str">\\</span></span>

<span class="line" id="L608">                            <span class="tok-str">\\========= expected not to find: ===================</span></span>

<span class="line" id="L609">                            <span class="tok-str">\\{s}</span></span>

<span class="line" id="L610">                            <span class="tok-str">\\========= but parsed file does contain it: ========</span></span>

<span class="line" id="L611">                            <span class="tok-str">\\{s}</span></span>

<span class="line" id="L612">                            <span class="tok-str">\\===================================================</span></span>

<span class="line" id="L613">                        , .{ act.phrase.resolve(b, step), output });</span>
<span class="line" id="L614">                    }</span>
<span class="line" id="L615">                },</span>
<span class="line" id="L616"></span>
<span class="line" id="L617">                .extract =&gt; {</span>
<span class="line" id="L618">                    <span class="tok-kw">while</span> (it.next()) |line| {</span>
<span class="line" id="L619">                        <span class="tok-kw">if</span> (<span class="tok-kw">try</span> act.extract(b, step, line, &amp;vars)) <span class="tok-kw">break</span>;</span>
<span class="line" id="L620">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L621">                        <span class="tok-kw">return</span> step.fail(</span>
<span class="line" id="L622">                            <span class="tok-str">\\</span></span>

<span class="line" id="L623">                            <span class="tok-str">\\========= expected to find and extract: ==============</span></span>

<span class="line" id="L624">                            <span class="tok-str">\\{s}</span></span>

<span class="line" id="L625">                            <span class="tok-str">\\========= but parsed file does not contain it: =======</span></span>

<span class="line" id="L626">                            <span class="tok-str">\\{s}</span></span>

<span class="line" id="L627">                            <span class="tok-str">\\======================================================</span></span>

<span class="line" id="L628">                        , .{ act.phrase.resolve(b, step), output });</span>
<span class="line" id="L629">                    }</span>
<span class="line" id="L630">                },</span>
<span class="line" id="L631"></span>
<span class="line" id="L632">                .compute_cmp =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L633">            }</span>
<span class="line" id="L634">        }</span>
<span class="line" id="L635">    }</span>
<span class="line" id="L636">}</span>
<span class="line" id="L637"></span>
<span class="line" id="L638"><span class="tok-kw">const</span> MachODumper = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L639">    <span class="tok-kw">const</span> LoadCommandIterator = macho.LoadCommandIterator;</span>
<span class="line" id="L640">    <span class="tok-kw">const</span> dyld_rebase_label = <span class="tok-str">&quot;dyld rebase data&quot;</span>;</span>
<span class="line" id="L641">    <span class="tok-kw">const</span> dyld_bind_label = <span class="tok-str">&quot;dyld bind data&quot;</span>;</span>
<span class="line" id="L642">    <span class="tok-kw">const</span> dyld_weak_bind_label = <span class="tok-str">&quot;dyld weak bind data&quot;</span>;</span>
<span class="line" id="L643">    <span class="tok-kw">const</span> dyld_lazy_bind_label = <span class="tok-str">&quot;dyld lazy bind data&quot;</span>;</span>
<span class="line" id="L644">    <span class="tok-kw">const</span> exports_label = <span class="tok-str">&quot;exports data&quot;</span>;</span>
<span class="line" id="L645">    <span class="tok-kw">const</span> symtab_label = <span class="tok-str">&quot;symbol table&quot;</span>;</span>
<span class="line" id="L646">    <span class="tok-kw">const</span> indirect_symtab_label = <span class="tok-str">&quot;indirect symbol table&quot;</span>;</span>
<span class="line" id="L647"></span>
<span class="line" id="L648">    <span class="tok-kw">const</span> Symtab = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L649">        symbols: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> macho.nlist_64 = &amp;[<span class="tok-number">0</span>]macho.nlist_64{},</span>
<span class="line" id="L650">        strings: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;[<span class="tok-number">0</span>]<span class="tok-type">u8</span>{},</span>
<span class="line" id="L651">        indirect_symbols: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> <span class="tok-type">u32</span> = &amp;[<span class="tok-number">0</span>]<span class="tok-type">u32</span>{},</span>
<span class="line" id="L652"></span>
<span class="line" id="L653">        <span class="tok-kw">fn</span> <span class="tok-fn">getString</span>(symtab: Symtab, off: <span class="tok-type">u32</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L654">            assert(off &lt; symtab.strings.len);</span>
<span class="line" id="L655">            <span class="tok-kw">return</span> mem.sliceTo(<span class="tok-builtin">@as</span>([*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(symtab.strings.ptr + off)), <span class="tok-number">0</span>);</span>
<span class="line" id="L656">        }</span>
<span class="line" id="L657">    };</span>
<span class="line" id="L658"></span>
<span class="line" id="L659">    <span class="tok-kw">fn</span> <span class="tok-fn">parseAndDump</span>(step: *Step, kind: Check.Kind, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L660">        <span class="tok-kw">const</span> gpa = step.owner.allocator;</span>
<span class="line" id="L661">        <span class="tok-kw">var</span> stream = std.io.fixedBufferStream(bytes);</span>
<span class="line" id="L662">        <span class="tok-kw">const</span> reader = stream.reader();</span>
<span class="line" id="L663"></span>
<span class="line" id="L664">        <span class="tok-kw">const</span> hdr = <span class="tok-kw">try</span> reader.readStruct(macho.mach_header_64);</span>
<span class="line" id="L665">        <span class="tok-kw">if</span> (hdr.magic != macho.MH_MAGIC_64) {</span>
<span class="line" id="L666">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidMagicNumber;</span>
<span class="line" id="L667">        }</span>
<span class="line" id="L668"></span>
<span class="line" id="L669">        <span class="tok-kw">var</span> output = std.ArrayList(<span class="tok-type">u8</span>).init(gpa);</span>
<span class="line" id="L670">        <span class="tok-kw">const</span> writer = output.writer();</span>
<span class="line" id="L671"></span>
<span class="line" id="L672">        <span class="tok-kw">var</span> symtab: Symtab = .{};</span>
<span class="line" id="L673">        <span class="tok-kw">var</span> segments = std.ArrayList(macho.segment_command_64).init(gpa);</span>
<span class="line" id="L674">        <span class="tok-kw">defer</span> segments.deinit();</span>
<span class="line" id="L675">        <span class="tok-kw">var</span> sections = std.ArrayList(macho.section_64).init(gpa);</span>
<span class="line" id="L676">        <span class="tok-kw">defer</span> sections.deinit();</span>
<span class="line" id="L677">        <span class="tok-kw">var</span> imports = std.ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(gpa);</span>
<span class="line" id="L678">        <span class="tok-kw">defer</span> imports.deinit();</span>
<span class="line" id="L679">        <span class="tok-kw">var</span> text_seg: ?<span class="tok-type">u8</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L680">        <span class="tok-kw">var</span> dyld_info_lc: ?macho.dyld_info_command = <span class="tok-null">null</span>;</span>
<span class="line" id="L681"></span>
<span class="line" id="L682">        {</span>
<span class="line" id="L683">            <span class="tok-kw">var</span> it: LoadCommandIterator = .{</span>
<span class="line" id="L684">                .ncmds = hdr.ncmds,</span>
<span class="line" id="L685">                .buffer = bytes[<span class="tok-builtin">@sizeOf</span>(macho.mach_header_64)..][<span class="tok-number">0</span>..hdr.sizeofcmds],</span>
<span class="line" id="L686">            };</span>
<span class="line" id="L687">            <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L688">            <span class="tok-kw">while</span> (it.next()) |cmd| {</span>
<span class="line" id="L689">                <span class="tok-kw">switch</span> (cmd.cmd()) {</span>
<span class="line" id="L690">                    .SEGMENT_64 =&gt; {</span>
<span class="line" id="L691">                        <span class="tok-kw">const</span> seg = cmd.cast(macho.segment_command_64).?;</span>
<span class="line" id="L692">                        <span class="tok-kw">try</span> sections.ensureUnusedCapacity(seg.nsects);</span>
<span class="line" id="L693">                        <span class="tok-kw">for</span> (cmd.getSections()) |sect| {</span>
<span class="line" id="L694">                            sections.appendAssumeCapacity(sect);</span>
<span class="line" id="L695">                        }</span>
<span class="line" id="L696">                        <span class="tok-kw">const</span> seg_id: <span class="tok-type">u8</span> = <span class="tok-builtin">@intCast</span>(segments.items.len);</span>
<span class="line" id="L697">                        <span class="tok-kw">try</span> segments.append(seg);</span>
<span class="line" id="L698">                        <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, seg.segName(), <span class="tok-str">&quot;__TEXT&quot;</span>)) {</span>
<span class="line" id="L699">                            text_seg = seg_id;</span>
<span class="line" id="L700">                        }</span>
<span class="line" id="L701">                    },</span>
<span class="line" id="L702">                    .SYMTAB =&gt; {</span>
<span class="line" id="L703">                        <span class="tok-kw">const</span> lc = cmd.cast(macho.symtab_command).?;</span>
<span class="line" id="L704">                        <span class="tok-kw">const</span> symbols = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> macho.nlist_64, <span class="tok-builtin">@ptrCast</span>(bytes.ptr + lc.symoff))[<span class="tok-number">0</span>..lc.nsyms];</span>
<span class="line" id="L705">                        <span class="tok-kw">const</span> strings = bytes[lc.stroff..][<span class="tok-number">0</span>..lc.strsize];</span>
<span class="line" id="L706">                        symtab.symbols = symbols;</span>
<span class="line" id="L707">                        symtab.strings = strings;</span>
<span class="line" id="L708">                    },</span>
<span class="line" id="L709">                    .DYSYMTAB =&gt; {</span>
<span class="line" id="L710">                        <span class="tok-kw">const</span> lc = cmd.cast(macho.dysymtab_command).?;</span>
<span class="line" id="L711">                        <span class="tok-kw">const</span> indexes = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> <span class="tok-type">u32</span>, <span class="tok-builtin">@ptrCast</span>(bytes.ptr + lc.indirectsymoff))[<span class="tok-number">0</span>..lc.nindirectsyms];</span>
<span class="line" id="L712">                        symtab.indirect_symbols = indexes;</span>
<span class="line" id="L713">                    },</span>
<span class="line" id="L714">                    .LOAD_DYLIB,</span>
<span class="line" id="L715">                    .LOAD_WEAK_DYLIB,</span>
<span class="line" id="L716">                    .REEXPORT_DYLIB,</span>
<span class="line" id="L717">                    =&gt; {</span>
<span class="line" id="L718">                        <span class="tok-kw">try</span> imports.append(cmd.getDylibPathName());</span>
<span class="line" id="L719">                    },</span>
<span class="line" id="L720">                    .DYLD_INFO_ONLY =&gt; {</span>
<span class="line" id="L721">                        dyld_info_lc = cmd.cast(macho.dyld_info_command).?;</span>
<span class="line" id="L722">                    },</span>
<span class="line" id="L723">                    <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L724">                }</span>
<span class="line" id="L725"></span>
<span class="line" id="L726">                i += <span class="tok-number">1</span>;</span>
<span class="line" id="L727">            }</span>
<span class="line" id="L728">        }</span>
<span class="line" id="L729"></span>
<span class="line" id="L730">        <span class="tok-kw">switch</span> (kind) {</span>
<span class="line" id="L731">            .headers =&gt; {</span>
<span class="line" id="L732">                <span class="tok-kw">try</span> dumpHeader(hdr, writer);</span>
<span class="line" id="L733"></span>
<span class="line" id="L734">                <span class="tok-kw">var</span> it: LoadCommandIterator = .{</span>
<span class="line" id="L735">                    .ncmds = hdr.ncmds,</span>
<span class="line" id="L736">                    .buffer = bytes[<span class="tok-builtin">@sizeOf</span>(macho.mach_header_64)..][<span class="tok-number">0</span>..hdr.sizeofcmds],</span>
<span class="line" id="L737">                };</span>
<span class="line" id="L738">                <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L739">                <span class="tok-kw">while</span> (it.next()) |cmd| {</span>
<span class="line" id="L740">                    <span class="tok-kw">try</span> dumpLoadCommand(cmd, i, writer);</span>
<span class="line" id="L741">                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);</span>
<span class="line" id="L742"></span>
<span class="line" id="L743">                    i += <span class="tok-number">1</span>;</span>
<span class="line" id="L744">                }</span>
<span class="line" id="L745">            },</span>
<span class="line" id="L746"></span>
<span class="line" id="L747">            .symtab =&gt; <span class="tok-kw">if</span> (symtab.symbols.len &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L748">                <span class="tok-kw">try</span> dumpSymtab(sections.items, imports.items, symtab, writer);</span>
<span class="line" id="L749">            } <span class="tok-kw">else</span> <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;no symbol table found&quot;</span>, .{}),</span>
<span class="line" id="L750"></span>
<span class="line" id="L751">            .indirect_symtab =&gt; <span class="tok-kw">if</span> (symtab.symbols.len &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> symtab.indirect_symbols.len &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L752">                <span class="tok-kw">try</span> dumpIndirectSymtab(gpa, sections.items, symtab, writer);</span>
<span class="line" id="L753">            } <span class="tok-kw">else</span> <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;no indirect symbol table found&quot;</span>, .{}),</span>
<span class="line" id="L754"></span>
<span class="line" id="L755">            .dyld_rebase,</span>
<span class="line" id="L756">            .dyld_bind,</span>
<span class="line" id="L757">            .dyld_weak_bind,</span>
<span class="line" id="L758">            .dyld_lazy_bind,</span>
<span class="line" id="L759">            =&gt; {</span>
<span class="line" id="L760">                <span class="tok-kw">if</span> (dyld_info_lc == <span class="tok-null">null</span>) <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;no dyld info found&quot;</span>, .{});</span>
<span class="line" id="L761">                <span class="tok-kw">const</span> lc = dyld_info_lc.?;</span>
<span class="line" id="L762"></span>
<span class="line" id="L763">                <span class="tok-kw">switch</span> (kind) {</span>
<span class="line" id="L764">                    .dyld_rebase =&gt; <span class="tok-kw">if</span> (lc.rebase_size &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L765">                        <span class="tok-kw">const</span> data = bytes[lc.rebase_off..][<span class="tok-number">0</span>..lc.rebase_size];</span>
<span class="line" id="L766">                        <span class="tok-kw">try</span> writer.writeAll(dyld_rebase_label ++ <span class="tok-str">&quot;\n&quot;</span>);</span>
<span class="line" id="L767">                        <span class="tok-kw">try</span> dumpRebaseInfo(gpa, data, segments.items, writer);</span>
<span class="line" id="L768">                    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;no rebase data found&quot;</span>, .{}),</span>
<span class="line" id="L769"></span>
<span class="line" id="L770">                    .dyld_bind =&gt; <span class="tok-kw">if</span> (lc.bind_size &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L771">                        <span class="tok-kw">const</span> data = bytes[lc.bind_off..][<span class="tok-number">0</span>..lc.bind_size];</span>
<span class="line" id="L772">                        <span class="tok-kw">try</span> writer.writeAll(dyld_bind_label ++ <span class="tok-str">&quot;\n&quot;</span>);</span>
<span class="line" id="L773">                        <span class="tok-kw">try</span> dumpBindInfo(gpa, data, segments.items, imports.items, writer);</span>
<span class="line" id="L774">                    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;no bind data found&quot;</span>, .{}),</span>
<span class="line" id="L775"></span>
<span class="line" id="L776">                    .dyld_weak_bind =&gt; <span class="tok-kw">if</span> (lc.weak_bind_size &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L777">                        <span class="tok-kw">const</span> data = bytes[lc.weak_bind_off..][<span class="tok-number">0</span>..lc.weak_bind_size];</span>
<span class="line" id="L778">                        <span class="tok-kw">try</span> writer.writeAll(dyld_weak_bind_label ++ <span class="tok-str">&quot;\n&quot;</span>);</span>
<span class="line" id="L779">                        <span class="tok-kw">try</span> dumpBindInfo(gpa, data, segments.items, imports.items, writer);</span>
<span class="line" id="L780">                    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;no weak bind data found&quot;</span>, .{}),</span>
<span class="line" id="L781"></span>
<span class="line" id="L782">                    .dyld_lazy_bind =&gt; <span class="tok-kw">if</span> (lc.lazy_bind_size &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L783">                        <span class="tok-kw">const</span> data = bytes[lc.lazy_bind_off..][<span class="tok-number">0</span>..lc.lazy_bind_size];</span>
<span class="line" id="L784">                        <span class="tok-kw">try</span> writer.writeAll(dyld_lazy_bind_label ++ <span class="tok-str">&quot;\n&quot;</span>);</span>
<span class="line" id="L785">                        <span class="tok-kw">try</span> dumpBindInfo(gpa, data, segments.items, imports.items, writer);</span>
<span class="line" id="L786">                    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;no lazy bind data found&quot;</span>, .{}),</span>
<span class="line" id="L787"></span>
<span class="line" id="L788">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L789">                }</span>
<span class="line" id="L790">            },</span>
<span class="line" id="L791"></span>
<span class="line" id="L792">            .exports =&gt; blk: {</span>
<span class="line" id="L793">                <span class="tok-kw">if</span> (dyld_info_lc) |lc| {</span>
<span class="line" id="L794">                    <span class="tok-kw">if</span> (lc.export_size &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L795">                        <span class="tok-kw">const</span> data = bytes[lc.export_off..][<span class="tok-number">0</span>..lc.export_size];</span>
<span class="line" id="L796">                        <span class="tok-kw">try</span> writer.writeAll(exports_label ++ <span class="tok-str">&quot;\n&quot;</span>);</span>
<span class="line" id="L797">                        <span class="tok-kw">try</span> dumpExportsTrie(gpa, data, segments.items[text_seg.?], writer);</span>
<span class="line" id="L798">                        <span class="tok-kw">break</span> :blk;</span>
<span class="line" id="L799">                    }</span>
<span class="line" id="L800">                }</span>
<span class="line" id="L801">                <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;no exports data found&quot;</span>, .{});</span>
<span class="line" id="L802">            },</span>
<span class="line" id="L803"></span>
<span class="line" id="L804">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;invalid check kind for MachO file format: {s}&quot;</span>, .{<span class="tok-builtin">@tagName</span>(kind)}),</span>
<span class="line" id="L805">        }</span>
<span class="line" id="L806"></span>
<span class="line" id="L807">        <span class="tok-kw">return</span> output.toOwnedSlice();</span>
<span class="line" id="L808">    }</span>
<span class="line" id="L809"></span>
<span class="line" id="L810">    <span class="tok-kw">fn</span> <span class="tok-fn">dumpHeader</span>(hdr: macho.mach_header_64, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L811">        <span class="tok-kw">const</span> cputype = <span class="tok-kw">switch</span> (hdr.cputype) {</span>
<span class="line" id="L812">            macho.CPU_TYPE_ARM64 =&gt; <span class="tok-str">&quot;ARM64&quot;</span>,</span>
<span class="line" id="L813">            macho.CPU_TYPE_X86_64 =&gt; <span class="tok-str">&quot;X86_64&quot;</span>,</span>
<span class="line" id="L814">            <span class="tok-kw">else</span> =&gt; <span class="tok-str">&quot;Unknown&quot;</span>,</span>
<span class="line" id="L815">        };</span>
<span class="line" id="L816">        <span class="tok-kw">const</span> filetype = <span class="tok-kw">switch</span> (hdr.filetype) {</span>
<span class="line" id="L817">            macho.MH_OBJECT =&gt; <span class="tok-str">&quot;MH_OBJECT&quot;</span>,</span>
<span class="line" id="L818">            macho.MH_EXECUTE =&gt; <span class="tok-str">&quot;MH_EXECUTE&quot;</span>,</span>
<span class="line" id="L819">            macho.MH_FVMLIB =&gt; <span class="tok-str">&quot;MH_FVMLIB&quot;</span>,</span>
<span class="line" id="L820">            macho.MH_CORE =&gt; <span class="tok-str">&quot;MH_CORE&quot;</span>,</span>
<span class="line" id="L821">            macho.MH_PRELOAD =&gt; <span class="tok-str">&quot;MH_PRELOAD&quot;</span>,</span>
<span class="line" id="L822">            macho.MH_DYLIB =&gt; <span class="tok-str">&quot;MH_DYLIB&quot;</span>,</span>
<span class="line" id="L823">            macho.MH_DYLINKER =&gt; <span class="tok-str">&quot;MH_DYLINKER&quot;</span>,</span>
<span class="line" id="L824">            macho.MH_BUNDLE =&gt; <span class="tok-str">&quot;MH_BUNDLE&quot;</span>,</span>
<span class="line" id="L825">            macho.MH_DYLIB_STUB =&gt; <span class="tok-str">&quot;MH_DYLIB_STUB&quot;</span>,</span>
<span class="line" id="L826">            macho.MH_DSYM =&gt; <span class="tok-str">&quot;MH_DSYM&quot;</span>,</span>
<span class="line" id="L827">            macho.MH_KEXT_BUNDLE =&gt; <span class="tok-str">&quot;MH_KEXT_BUNDLE&quot;</span>,</span>
<span class="line" id="L828">            <span class="tok-kw">else</span> =&gt; <span class="tok-str">&quot;Unknown&quot;</span>,</span>
<span class="line" id="L829">        };</span>
<span class="line" id="L830"></span>
<span class="line" id="L831">        <span class="tok-kw">try</span> writer.print(</span>
<span class="line" id="L832">            <span class="tok-str">\\header</span></span>

<span class="line" id="L833">            <span class="tok-str">\\cputype {s}</span></span>

<span class="line" id="L834">            <span class="tok-str">\\filetype {s}</span></span>

<span class="line" id="L835">            <span class="tok-str">\\ncmds {d}</span></span>

<span class="line" id="L836">            <span class="tok-str">\\sizeofcmds {x}</span></span>

<span class="line" id="L837">            <span class="tok-str">\\flags</span></span>

<span class="line" id="L838">        , .{</span>
<span class="line" id="L839">            cputype,</span>
<span class="line" id="L840">            filetype,</span>
<span class="line" id="L841">            hdr.ncmds,</span>
<span class="line" id="L842">            hdr.sizeofcmds,</span>
<span class="line" id="L843">        });</span>
<span class="line" id="L844"></span>
<span class="line" id="L845">        <span class="tok-kw">if</span> (hdr.flags &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L846">            <span class="tok-kw">if</span> (hdr.flags &amp; macho.MH_NOUNDEFS != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; NOUNDEFS&quot;</span>);</span>
<span class="line" id="L847">            <span class="tok-kw">if</span> (hdr.flags &amp; macho.MH_INCRLINK != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; INCRLINK&quot;</span>);</span>
<span class="line" id="L848">            <span class="tok-kw">if</span> (hdr.flags &amp; macho.MH_DYLDLINK != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; DYLDLINK&quot;</span>);</span>
<span class="line" id="L849">            <span class="tok-kw">if</span> (hdr.flags &amp; macho.MH_BINDATLOAD != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; BINDATLOAD&quot;</span>);</span>
<span class="line" id="L850">            <span class="tok-kw">if</span> (hdr.flags &amp; macho.MH_PREBOUND != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; PREBOUND&quot;</span>);</span>
<span class="line" id="L851">            <span class="tok-kw">if</span> (hdr.flags &amp; macho.MH_SPLIT_SEGS != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; SPLIT_SEGS&quot;</span>);</span>
<span class="line" id="L852">            <span class="tok-kw">if</span> (hdr.flags &amp; macho.MH_LAZY_INIT != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; LAZY_INIT&quot;</span>);</span>
<span class="line" id="L853">            <span class="tok-kw">if</span> (hdr.flags &amp; macho.MH_TWOLEVEL != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; TWOLEVEL&quot;</span>);</span>
<span class="line" id="L854">            <span class="tok-kw">if</span> (hdr.flags &amp; macho.MH_FORCE_FLAT != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; FORCE_FLAT&quot;</span>);</span>
<span class="line" id="L855">            <span class="tok-kw">if</span> (hdr.flags &amp; macho.MH_NOMULTIDEFS != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; NOMULTIDEFS&quot;</span>);</span>
<span class="line" id="L856">            <span class="tok-kw">if</span> (hdr.flags &amp; macho.MH_NOFIXPREBINDING != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; NOFIXPREBINDING&quot;</span>);</span>
<span class="line" id="L857">            <span class="tok-kw">if</span> (hdr.flags &amp; macho.MH_PREBINDABLE != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; PREBINDABLE&quot;</span>);</span>
<span class="line" id="L858">            <span class="tok-kw">if</span> (hdr.flags &amp; macho.MH_ALLMODSBOUND != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; ALLMODSBOUND&quot;</span>);</span>
<span class="line" id="L859">            <span class="tok-kw">if</span> (hdr.flags &amp; macho.MH_SUBSECTIONS_VIA_SYMBOLS != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; SUBSECTIONS_VIA_SYMBOLS&quot;</span>);</span>
<span class="line" id="L860">            <span class="tok-kw">if</span> (hdr.flags &amp; macho.MH_CANONICAL != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; CANONICAL&quot;</span>);</span>
<span class="line" id="L861">            <span class="tok-kw">if</span> (hdr.flags &amp; macho.MH_WEAK_DEFINES != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; WEAK_DEFINES&quot;</span>);</span>
<span class="line" id="L862">            <span class="tok-kw">if</span> (hdr.flags &amp; macho.MH_BINDS_TO_WEAK != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; BINDS_TO_WEAK&quot;</span>);</span>
<span class="line" id="L863">            <span class="tok-kw">if</span> (hdr.flags &amp; macho.MH_ALLOW_STACK_EXECUTION != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; ALLOW_STACK_EXECUTION&quot;</span>);</span>
<span class="line" id="L864">            <span class="tok-kw">if</span> (hdr.flags &amp; macho.MH_ROOT_SAFE != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; ROOT_SAFE&quot;</span>);</span>
<span class="line" id="L865">            <span class="tok-kw">if</span> (hdr.flags &amp; macho.MH_SETUID_SAFE != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; SETUID_SAFE&quot;</span>);</span>
<span class="line" id="L866">            <span class="tok-kw">if</span> (hdr.flags &amp; macho.MH_NO_REEXPORTED_DYLIBS != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; NO_REEXPORTED_DYLIBS&quot;</span>);</span>
<span class="line" id="L867">            <span class="tok-kw">if</span> (hdr.flags &amp; macho.MH_PIE != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; PIE&quot;</span>);</span>
<span class="line" id="L868">            <span class="tok-kw">if</span> (hdr.flags &amp; macho.MH_DEAD_STRIPPABLE_DYLIB != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; DEAD_STRIPPABLE_DYLIB&quot;</span>);</span>
<span class="line" id="L869">            <span class="tok-kw">if</span> (hdr.flags &amp; macho.MH_HAS_TLV_DESCRIPTORS != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; HAS_TLV_DESCRIPTORS&quot;</span>);</span>
<span class="line" id="L870">            <span class="tok-kw">if</span> (hdr.flags &amp; macho.MH_NO_HEAP_EXECUTION != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; NO_HEAP_EXECUTION&quot;</span>);</span>
<span class="line" id="L871">            <span class="tok-kw">if</span> (hdr.flags &amp; macho.MH_APP_EXTENSION_SAFE != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; APP_EXTENSION_SAFE&quot;</span>);</span>
<span class="line" id="L872">            <span class="tok-kw">if</span> (hdr.flags &amp; macho.MH_NLIST_OUTOFSYNC_WITH_DYLDINFO != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; NLIST_OUTOFSYNC_WITH_DYLDINFO&quot;</span>);</span>
<span class="line" id="L873">        }</span>
<span class="line" id="L874"></span>
<span class="line" id="L875">        <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);</span>
<span class="line" id="L876">    }</span>
<span class="line" id="L877"></span>
<span class="line" id="L878">    <span class="tok-kw">fn</span> <span class="tok-fn">dumpLoadCommand</span>(lc: macho.LoadCommandIterator.LoadCommand, index: <span class="tok-type">usize</span>, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L879">        <span class="tok-comment">// print header first</span>
</span>
<span class="line" id="L880">        <span class="tok-kw">try</span> writer.print(</span>
<span class="line" id="L881">            <span class="tok-str">\\LC {d}</span></span>

<span class="line" id="L882">            <span class="tok-str">\\cmd {s}</span></span>

<span class="line" id="L883">            <span class="tok-str">\\cmdsize {d}</span></span>

<span class="line" id="L884">        , .{ index, <span class="tok-builtin">@tagName</span>(lc.cmd()), lc.cmdsize() });</span>
<span class="line" id="L885"></span>
<span class="line" id="L886">        <span class="tok-kw">switch</span> (lc.cmd()) {</span>
<span class="line" id="L887">            .SEGMENT_64 =&gt; {</span>
<span class="line" id="L888">                <span class="tok-kw">const</span> seg = lc.cast(macho.segment_command_64).?;</span>
<span class="line" id="L889">                <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);</span>
<span class="line" id="L890">                <span class="tok-kw">try</span> writer.print(</span>
<span class="line" id="L891">                    <span class="tok-str">\\segname {s}</span></span>

<span class="line" id="L892">                    <span class="tok-str">\\vmaddr {x}</span></span>

<span class="line" id="L893">                    <span class="tok-str">\\vmsize {x}</span></span>

<span class="line" id="L894">                    <span class="tok-str">\\fileoff {x}</span></span>

<span class="line" id="L895">                    <span class="tok-str">\\filesz {x}</span></span>

<span class="line" id="L896">                , .{</span>
<span class="line" id="L897">                    seg.segName(),</span>
<span class="line" id="L898">                    seg.vmaddr,</span>
<span class="line" id="L899">                    seg.vmsize,</span>
<span class="line" id="L900">                    seg.fileoff,</span>
<span class="line" id="L901">                    seg.filesize,</span>
<span class="line" id="L902">                });</span>
<span class="line" id="L903"></span>
<span class="line" id="L904">                <span class="tok-kw">for</span> (lc.getSections()) |sect| {</span>
<span class="line" id="L905">                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);</span>
<span class="line" id="L906">                    <span class="tok-kw">try</span> writer.print(</span>
<span class="line" id="L907">                        <span class="tok-str">\\sectname {s}</span></span>

<span class="line" id="L908">                        <span class="tok-str">\\addr {x}</span></span>

<span class="line" id="L909">                        <span class="tok-str">\\size {x}</span></span>

<span class="line" id="L910">                        <span class="tok-str">\\offset {x}</span></span>

<span class="line" id="L911">                        <span class="tok-str">\\align {x}</span></span>

<span class="line" id="L912">                    , .{</span>
<span class="line" id="L913">                        sect.sectName(),</span>
<span class="line" id="L914">                        sect.addr,</span>
<span class="line" id="L915">                        sect.size,</span>
<span class="line" id="L916">                        sect.offset,</span>
<span class="line" id="L917">                        sect.@&quot;align&quot;,</span>
<span class="line" id="L918">                    });</span>
<span class="line" id="L919">                }</span>
<span class="line" id="L920">            },</span>
<span class="line" id="L921"></span>
<span class="line" id="L922">            .ID_DYLIB,</span>
<span class="line" id="L923">            .LOAD_DYLIB,</span>
<span class="line" id="L924">            .LOAD_WEAK_DYLIB,</span>
<span class="line" id="L925">            .REEXPORT_DYLIB,</span>
<span class="line" id="L926">            =&gt; {</span>
<span class="line" id="L927">                <span class="tok-kw">const</span> dylib = lc.cast(macho.dylib_command).?;</span>
<span class="line" id="L928">                <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);</span>
<span class="line" id="L929">                <span class="tok-kw">try</span> writer.print(</span>
<span class="line" id="L930">                    <span class="tok-str">\\name {s}</span></span>

<span class="line" id="L931">                    <span class="tok-str">\\timestamp {d}</span></span>

<span class="line" id="L932">                    <span class="tok-str">\\current version {x}</span></span>

<span class="line" id="L933">                    <span class="tok-str">\\compatibility version {x}</span></span>

<span class="line" id="L934">                , .{</span>
<span class="line" id="L935">                    lc.getDylibPathName(),</span>
<span class="line" id="L936">                    dylib.dylib.timestamp,</span>
<span class="line" id="L937">                    dylib.dylib.current_version,</span>
<span class="line" id="L938">                    dylib.dylib.compatibility_version,</span>
<span class="line" id="L939">                });</span>
<span class="line" id="L940">            },</span>
<span class="line" id="L941"></span>
<span class="line" id="L942">            .MAIN =&gt; {</span>
<span class="line" id="L943">                <span class="tok-kw">const</span> main = lc.cast(macho.entry_point_command).?;</span>
<span class="line" id="L944">                <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);</span>
<span class="line" id="L945">                <span class="tok-kw">try</span> writer.print(</span>
<span class="line" id="L946">                    <span class="tok-str">\\entryoff {x}</span></span>

<span class="line" id="L947">                    <span class="tok-str">\\stacksize {x}</span></span>

<span class="line" id="L948">                , .{ main.entryoff, main.stacksize });</span>
<span class="line" id="L949">            },</span>
<span class="line" id="L950"></span>
<span class="line" id="L951">            .RPATH =&gt; {</span>
<span class="line" id="L952">                <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);</span>
<span class="line" id="L953">                <span class="tok-kw">try</span> writer.print(</span>
<span class="line" id="L954">                    <span class="tok-str">\\path {s}</span></span>

<span class="line" id="L955">                , .{</span>
<span class="line" id="L956">                    lc.getRpathPathName(),</span>
<span class="line" id="L957">                });</span>
<span class="line" id="L958">            },</span>
<span class="line" id="L959"></span>
<span class="line" id="L960">            .UUID =&gt; {</span>
<span class="line" id="L961">                <span class="tok-kw">const</span> uuid = lc.cast(macho.uuid_command).?;</span>
<span class="line" id="L962">                <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);</span>
<span class="line" id="L963">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;uuid {x}&quot;</span>, .{std.fmt.fmtSliceHexLower(&amp;uuid.uuid)});</span>
<span class="line" id="L964">            },</span>
<span class="line" id="L965"></span>
<span class="line" id="L966">            .DATA_IN_CODE,</span>
<span class="line" id="L967">            .FUNCTION_STARTS,</span>
<span class="line" id="L968">            .CODE_SIGNATURE,</span>
<span class="line" id="L969">            =&gt; {</span>
<span class="line" id="L970">                <span class="tok-kw">const</span> llc = lc.cast(macho.linkedit_data_command).?;</span>
<span class="line" id="L971">                <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);</span>
<span class="line" id="L972">                <span class="tok-kw">try</span> writer.print(</span>
<span class="line" id="L973">                    <span class="tok-str">\\dataoff {x}</span></span>

<span class="line" id="L974">                    <span class="tok-str">\\datasize {x}</span></span>

<span class="line" id="L975">                , .{ llc.dataoff, llc.datasize });</span>
<span class="line" id="L976">            },</span>
<span class="line" id="L977"></span>
<span class="line" id="L978">            .DYLD_INFO_ONLY =&gt; {</span>
<span class="line" id="L979">                <span class="tok-kw">const</span> dlc = lc.cast(macho.dyld_info_command).?;</span>
<span class="line" id="L980">                <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);</span>
<span class="line" id="L981">                <span class="tok-kw">try</span> writer.print(</span>
<span class="line" id="L982">                    <span class="tok-str">\\rebaseoff {x}</span></span>

<span class="line" id="L983">                    <span class="tok-str">\\rebasesize {x}</span></span>

<span class="line" id="L984">                    <span class="tok-str">\\bindoff {x}</span></span>

<span class="line" id="L985">                    <span class="tok-str">\\bindsize {x}</span></span>

<span class="line" id="L986">                    <span class="tok-str">\\weakbindoff {x}</span></span>

<span class="line" id="L987">                    <span class="tok-str">\\weakbindsize {x}</span></span>

<span class="line" id="L988">                    <span class="tok-str">\\lazybindoff {x}</span></span>

<span class="line" id="L989">                    <span class="tok-str">\\lazybindsize {x}</span></span>

<span class="line" id="L990">                    <span class="tok-str">\\exportoff {x}</span></span>

<span class="line" id="L991">                    <span class="tok-str">\\exportsize {x}</span></span>

<span class="line" id="L992">                , .{</span>
<span class="line" id="L993">                    dlc.rebase_off,</span>
<span class="line" id="L994">                    dlc.rebase_size,</span>
<span class="line" id="L995">                    dlc.bind_off,</span>
<span class="line" id="L996">                    dlc.bind_size,</span>
<span class="line" id="L997">                    dlc.weak_bind_off,</span>
<span class="line" id="L998">                    dlc.weak_bind_size,</span>
<span class="line" id="L999">                    dlc.lazy_bind_off,</span>
<span class="line" id="L1000">                    dlc.lazy_bind_size,</span>
<span class="line" id="L1001">                    dlc.export_off,</span>
<span class="line" id="L1002">                    dlc.export_size,</span>
<span class="line" id="L1003">                });</span>
<span class="line" id="L1004">            },</span>
<span class="line" id="L1005"></span>
<span class="line" id="L1006">            .SYMTAB =&gt; {</span>
<span class="line" id="L1007">                <span class="tok-kw">const</span> slc = lc.cast(macho.symtab_command).?;</span>
<span class="line" id="L1008">                <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);</span>
<span class="line" id="L1009">                <span class="tok-kw">try</span> writer.print(</span>
<span class="line" id="L1010">                    <span class="tok-str">\\symoff {x}</span></span>

<span class="line" id="L1011">                    <span class="tok-str">\\nsyms {x}</span></span>

<span class="line" id="L1012">                    <span class="tok-str">\\stroff {x}</span></span>

<span class="line" id="L1013">                    <span class="tok-str">\\strsize {x}</span></span>

<span class="line" id="L1014">                , .{</span>
<span class="line" id="L1015">                    slc.symoff,</span>
<span class="line" id="L1016">                    slc.nsyms,</span>
<span class="line" id="L1017">                    slc.stroff,</span>
<span class="line" id="L1018">                    slc.strsize,</span>
<span class="line" id="L1019">                });</span>
<span class="line" id="L1020">            },</span>
<span class="line" id="L1021"></span>
<span class="line" id="L1022">            .DYSYMTAB =&gt; {</span>
<span class="line" id="L1023">                <span class="tok-kw">const</span> dlc = lc.cast(macho.dysymtab_command).?;</span>
<span class="line" id="L1024">                <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);</span>
<span class="line" id="L1025">                <span class="tok-kw">try</span> writer.print(</span>
<span class="line" id="L1026">                    <span class="tok-str">\\ilocalsym {x}</span></span>

<span class="line" id="L1027">                    <span class="tok-str">\\nlocalsym {x}</span></span>

<span class="line" id="L1028">                    <span class="tok-str">\\iextdefsym {x}</span></span>

<span class="line" id="L1029">                    <span class="tok-str">\\nextdefsym {x}</span></span>

<span class="line" id="L1030">                    <span class="tok-str">\\iundefsym {x}</span></span>

<span class="line" id="L1031">                    <span class="tok-str">\\nundefsym {x}</span></span>

<span class="line" id="L1032">                    <span class="tok-str">\\indirectsymoff {x}</span></span>

<span class="line" id="L1033">                    <span class="tok-str">\\nindirectsyms {x}</span></span>

<span class="line" id="L1034">                , .{</span>
<span class="line" id="L1035">                    dlc.ilocalsym,</span>
<span class="line" id="L1036">                    dlc.nlocalsym,</span>
<span class="line" id="L1037">                    dlc.iextdefsym,</span>
<span class="line" id="L1038">                    dlc.nextdefsym,</span>
<span class="line" id="L1039">                    dlc.iundefsym,</span>
<span class="line" id="L1040">                    dlc.nundefsym,</span>
<span class="line" id="L1041">                    dlc.indirectsymoff,</span>
<span class="line" id="L1042">                    dlc.nindirectsyms,</span>
<span class="line" id="L1043">                });</span>
<span class="line" id="L1044">            },</span>
<span class="line" id="L1045"></span>
<span class="line" id="L1046">            .BUILD_VERSION =&gt; {</span>
<span class="line" id="L1047">                <span class="tok-kw">const</span> blc = lc.cast(macho.build_version_command).?;</span>
<span class="line" id="L1048">                <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);</span>
<span class="line" id="L1049">                <span class="tok-kw">try</span> writer.print(</span>
<span class="line" id="L1050">                    <span class="tok-str">\\platform {s}</span></span>

<span class="line" id="L1051">                    <span class="tok-str">\\minos {d}.{d}.{d}</span></span>

<span class="line" id="L1052">                    <span class="tok-str">\\sdk {d}.{d}.{d}</span></span>

<span class="line" id="L1053">                    <span class="tok-str">\\ntools {d}</span></span>

<span class="line" id="L1054">                , .{</span>
<span class="line" id="L1055">                    <span class="tok-builtin">@tagName</span>(blc.platform),</span>
<span class="line" id="L1056">                    blc.minos &gt;&gt; <span class="tok-number">16</span>,</span>
<span class="line" id="L1057">                    <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(blc.minos &gt;&gt; <span class="tok-number">8</span>)),</span>
<span class="line" id="L1058">                    <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(blc.minos)),</span>
<span class="line" id="L1059">                    blc.sdk &gt;&gt; <span class="tok-number">16</span>,</span>
<span class="line" id="L1060">                    <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(blc.sdk &gt;&gt; <span class="tok-number">8</span>)),</span>
<span class="line" id="L1061">                    <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(blc.sdk)),</span>
<span class="line" id="L1062">                    blc.ntools,</span>
<span class="line" id="L1063">                });</span>
<span class="line" id="L1064">                <span class="tok-kw">for</span> (lc.getBuildVersionTools()) |tool| {</span>
<span class="line" id="L1065">                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);</span>
<span class="line" id="L1066">                    <span class="tok-kw">switch</span> (tool.tool) {</span>
<span class="line" id="L1067">                        .CLANG, .SWIFT, .LD, .LLD, .ZIG =&gt; <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;tool {s}\n&quot;</span>, .{<span class="tok-builtin">@tagName</span>(tool.tool)}),</span>
<span class="line" id="L1068">                        <span class="tok-kw">else</span> =&gt; |x| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;tool {d}\n&quot;</span>, .{<span class="tok-builtin">@intFromEnum</span>(x)}),</span>
<span class="line" id="L1069">                    }</span>
<span class="line" id="L1070">                    <span class="tok-kw">try</span> writer.print(</span>
<span class="line" id="L1071">                        <span class="tok-str">\\version {d}.{d}.{d}</span></span>

<span class="line" id="L1072">                    , .{</span>
<span class="line" id="L1073">                        tool.version &gt;&gt; <span class="tok-number">16</span>,</span>
<span class="line" id="L1074">                        <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(tool.version &gt;&gt; <span class="tok-number">8</span>)),</span>
<span class="line" id="L1075">                        <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(tool.version)),</span>
<span class="line" id="L1076">                    });</span>
<span class="line" id="L1077">                }</span>
<span class="line" id="L1078">            },</span>
<span class="line" id="L1079"></span>
<span class="line" id="L1080">            .VERSION_MIN_MACOSX,</span>
<span class="line" id="L1081">            .VERSION_MIN_IPHONEOS,</span>
<span class="line" id="L1082">            .VERSION_MIN_WATCHOS,</span>
<span class="line" id="L1083">            .VERSION_MIN_TVOS,</span>
<span class="line" id="L1084">            =&gt; {</span>
<span class="line" id="L1085">                <span class="tok-kw">const</span> vlc = lc.cast(macho.version_min_command).?;</span>
<span class="line" id="L1086">                <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);</span>
<span class="line" id="L1087">                <span class="tok-kw">try</span> writer.print(</span>
<span class="line" id="L1088">                    <span class="tok-str">\\version {d}.{d}.{d}</span></span>

<span class="line" id="L1089">                    <span class="tok-str">\\sdk {d}.{d}.{d}</span></span>

<span class="line" id="L1090">                , .{</span>
<span class="line" id="L1091">                    vlc.version &gt;&gt; <span class="tok-number">16</span>,</span>
<span class="line" id="L1092">                    <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(vlc.version &gt;&gt; <span class="tok-number">8</span>)),</span>
<span class="line" id="L1093">                    <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(vlc.version)),</span>
<span class="line" id="L1094">                    vlc.sdk &gt;&gt; <span class="tok-number">16</span>,</span>
<span class="line" id="L1095">                    <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(vlc.sdk &gt;&gt; <span class="tok-number">8</span>)),</span>
<span class="line" id="L1096">                    <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(vlc.sdk)),</span>
<span class="line" id="L1097">                });</span>
<span class="line" id="L1098">            },</span>
<span class="line" id="L1099"></span>
<span class="line" id="L1100">            <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L1101">        }</span>
<span class="line" id="L1102">    }</span>
<span class="line" id="L1103"></span>
<span class="line" id="L1104">    <span class="tok-kw">fn</span> <span class="tok-fn">dumpSymtab</span>(</span>
<span class="line" id="L1105">        sections: []<span class="tok-kw">const</span> macho.section_64,</span>
<span class="line" id="L1106">        imports: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1107">        symtab: Symtab,</span>
<span class="line" id="L1108">        writer: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L1109">    ) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1110">        <span class="tok-kw">try</span> writer.writeAll(symtab_label ++ <span class="tok-str">&quot;\n&quot;</span>);</span>
<span class="line" id="L1111"></span>
<span class="line" id="L1112">        <span class="tok-kw">for</span> (symtab.symbols) |sym| {</span>
<span class="line" id="L1113">            <span class="tok-kw">if</span> (sym.stab()) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1114">            <span class="tok-kw">const</span> sym_name = symtab.getString(sym.n_strx);</span>
<span class="line" id="L1115">            <span class="tok-kw">if</span> (sym.sect()) {</span>
<span class="line" id="L1116">                <span class="tok-kw">const</span> sect = sections[sym.n_sect - <span class="tok-number">1</span>];</span>
<span class="line" id="L1117">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{x} ({s},{s})&quot;</span>, .{</span>
<span class="line" id="L1118">                    sym.n_value,</span>
<span class="line" id="L1119">                    sect.segName(),</span>
<span class="line" id="L1120">                    sect.sectName(),</span>
<span class="line" id="L1121">                });</span>
<span class="line" id="L1122">                <span class="tok-kw">if</span> (sym.n_desc &amp; macho.REFERENCED_DYNAMICALLY != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; [referenced dynamically]&quot;</span>);</span>
<span class="line" id="L1123">                <span class="tok-kw">if</span> (sym.weakDef()) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; weak&quot;</span>);</span>
<span class="line" id="L1124">                <span class="tok-kw">if</span> (sym.weakRef()) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; weakref&quot;</span>);</span>
<span class="line" id="L1125">                <span class="tok-kw">if</span> (sym.ext()) {</span>
<span class="line" id="L1126">                    <span class="tok-kw">if</span> (sym.pext()) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; private&quot;</span>);</span>
<span class="line" id="L1127">                    <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; external&quot;</span>);</span>
<span class="line" id="L1128">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (sym.pext()) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; (was private external)&quot;</span>);</span>
<span class="line" id="L1129">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {s}\n&quot;</span>, .{sym_name});</span>
<span class="line" id="L1130">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (sym.tentative()) {</span>
<span class="line" id="L1131">                <span class="tok-kw">const</span> alignment = (sym.n_desc &gt;&gt; <span class="tok-number">8</span>) &amp; <span class="tok-number">0x0F</span>;</span>
<span class="line" id="L1132">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  0x{x:0&gt;16} (common) (alignment 2^{d})&quot;</span>, .{ sym.n_value, alignment });</span>
<span class="line" id="L1133">                <span class="tok-kw">if</span> (sym.ext()) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; external&quot;</span>);</span>
<span class="line" id="L1134">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {s}\n&quot;</span>, .{sym_name});</span>
<span class="line" id="L1135">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (sym.undf()) {</span>
<span class="line" id="L1136">                <span class="tok-kw">const</span> ordinal = <span class="tok-builtin">@divFloor</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">i16</span>, <span class="tok-builtin">@bitCast</span>(sym.n_desc)), macho.N_SYMBOL_RESOLVER);</span>
<span class="line" id="L1137">                <span class="tok-kw">const</span> import_name = blk: {</span>
<span class="line" id="L1138">                    <span class="tok-kw">if</span> (ordinal &lt;= <span class="tok-number">0</span>) {</span>
<span class="line" id="L1139">                        <span class="tok-kw">if</span> (ordinal == macho.BIND_SPECIAL_DYLIB_SELF)</span>
<span class="line" id="L1140">                            <span class="tok-kw">break</span> :blk <span class="tok-str">&quot;self import&quot;</span>;</span>
<span class="line" id="L1141">                        <span class="tok-kw">if</span> (ordinal == macho.BIND_SPECIAL_DYLIB_MAIN_EXECUTABLE)</span>
<span class="line" id="L1142">                            <span class="tok-kw">break</span> :blk <span class="tok-str">&quot;main executable&quot;</span>;</span>
<span class="line" id="L1143">                        <span class="tok-kw">if</span> (ordinal == macho.BIND_SPECIAL_DYLIB_FLAT_LOOKUP)</span>
<span class="line" id="L1144">                            <span class="tok-kw">break</span> :blk <span class="tok-str">&quot;flat lookup&quot;</span>;</span>
<span class="line" id="L1145">                        <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L1146">                    }</span>
<span class="line" id="L1147">                    <span class="tok-kw">const</span> full_path = imports[<span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-builtin">@bitCast</span>(ordinal)) - <span class="tok-number">1</span>];</span>
<span class="line" id="L1148">                    <span class="tok-kw">const</span> basename = fs.path.basename(full_path);</span>
<span class="line" id="L1149">                    assert(basename.len &gt; <span class="tok-number">0</span>);</span>
<span class="line" id="L1150">                    <span class="tok-kw">const</span> ext = mem.lastIndexOfScalar(<span class="tok-type">u8</span>, basename, <span class="tok-str">'.'</span>) <span class="tok-kw">orelse</span> basename.len;</span>
<span class="line" id="L1151">                    <span class="tok-kw">break</span> :blk basename[<span class="tok-number">0</span>..ext];</span>
<span class="line" id="L1152">                };</span>
<span class="line" id="L1153">                <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;(undefined)&quot;</span>);</span>
<span class="line" id="L1154">                <span class="tok-kw">if</span> (sym.weakRef()) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; weakref&quot;</span>);</span>
<span class="line" id="L1155">                <span class="tok-kw">if</span> (sym.ext()) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; external&quot;</span>);</span>
<span class="line" id="L1156">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {s} (from {s})\n&quot;</span>, .{</span>
<span class="line" id="L1157">                    sym_name,</span>
<span class="line" id="L1158">                    import_name,</span>
<span class="line" id="L1159">                });</span>
<span class="line" id="L1160">            }</span>
<span class="line" id="L1161">        }</span>
<span class="line" id="L1162">    }</span>
<span class="line" id="L1163"></span>
<span class="line" id="L1164">    <span class="tok-kw">fn</span> <span class="tok-fn">dumpIndirectSymtab</span>(</span>
<span class="line" id="L1165">        gpa: Allocator,</span>
<span class="line" id="L1166">        sections: []<span class="tok-kw">const</span> macho.section_64,</span>
<span class="line" id="L1167">        symtab: Symtab,</span>
<span class="line" id="L1168">        writer: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L1169">    ) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1170">        <span class="tok-kw">try</span> writer.writeAll(indirect_symtab_label ++ <span class="tok-str">&quot;\n&quot;</span>);</span>
<span class="line" id="L1171"></span>
<span class="line" id="L1172">        <span class="tok-kw">var</span> sects = std.ArrayList(macho.section_64).init(gpa);</span>
<span class="line" id="L1173">        <span class="tok-kw">defer</span> sects.deinit();</span>
<span class="line" id="L1174">        <span class="tok-kw">try</span> sects.ensureUnusedCapacity(<span class="tok-number">3</span>);</span>
<span class="line" id="L1175"></span>
<span class="line" id="L1176">        <span class="tok-kw">for</span> (sections) |sect| {</span>
<span class="line" id="L1177">            <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, sect.sectName(), <span class="tok-str">&quot;__stubs&quot;</span>)) sects.appendAssumeCapacity(sect);</span>
<span class="line" id="L1178">            <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, sect.sectName(), <span class="tok-str">&quot;__got&quot;</span>)) sects.appendAssumeCapacity(sect);</span>
<span class="line" id="L1179">            <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, sect.sectName(), <span class="tok-str">&quot;__la_symbol_ptr&quot;</span>)) sects.appendAssumeCapacity(sect);</span>
<span class="line" id="L1180">        }</span>
<span class="line" id="L1181"></span>
<span class="line" id="L1182">        <span class="tok-kw">const</span> sortFn = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1183">            <span class="tok-kw">fn</span> <span class="tok-fn">sortFn</span>(ctx: <span class="tok-type">void</span>, lhs: macho.section_64, rhs: macho.section_64) <span class="tok-type">bool</span> {</span>
<span class="line" id="L1184">                _ = ctx;</span>
<span class="line" id="L1185">                <span class="tok-kw">return</span> lhs.reserved1 &lt; rhs.reserved1;</span>
<span class="line" id="L1186">            }</span>
<span class="line" id="L1187">        }.sortFn;</span>
<span class="line" id="L1188">        mem.sort(macho.section_64, sects.items, {}, sortFn);</span>
<span class="line" id="L1189"></span>
<span class="line" id="L1190">        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1191">        <span class="tok-kw">while</span> (i &lt; sects.items.len) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L1192">            <span class="tok-kw">const</span> sect = sects.items[i];</span>
<span class="line" id="L1193">            <span class="tok-kw">const</span> start = sect.reserved1;</span>
<span class="line" id="L1194">            <span class="tok-kw">const</span> end = <span class="tok-kw">if</span> (i + <span class="tok-number">1</span> &gt;= sects.items.len) symtab.indirect_symbols.len <span class="tok-kw">else</span> sects.items[i + <span class="tok-number">1</span>].reserved1;</span>
<span class="line" id="L1195">            <span class="tok-kw">const</span> entry_size = blk: {</span>
<span class="line" id="L1196">                <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, sect.sectName(), <span class="tok-str">&quot;__stubs&quot;</span>)) <span class="tok-kw">break</span> :blk sect.reserved2;</span>
<span class="line" id="L1197">                <span class="tok-kw">break</span> :blk <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">u64</span>);</span>
<span class="line" id="L1198">            };</span>
<span class="line" id="L1199"></span>
<span class="line" id="L1200">            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{s},{s}\n&quot;</span>, .{ sect.segName(), sect.sectName() });</span>
<span class="line" id="L1201">            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;nentries {d}\n&quot;</span>, .{end - start});</span>
<span class="line" id="L1202">            <span class="tok-kw">for</span> (symtab.indirect_symbols[start..end], <span class="tok-number">0</span>..) |index, j| {</span>
<span class="line" id="L1203">                <span class="tok-kw">const</span> sym = symtab.symbols[index];</span>
<span class="line" id="L1204">                <span class="tok-kw">const</span> addr = sect.addr + entry_size * j;</span>
<span class="line" id="L1205">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;0x{x} {d} {s}\n&quot;</span>, .{ addr, index, symtab.getString(sym.n_strx) });</span>
<span class="line" id="L1206">            }</span>
<span class="line" id="L1207">        }</span>
<span class="line" id="L1208">    }</span>
<span class="line" id="L1209"></span>
<span class="line" id="L1210">    <span class="tok-kw">fn</span> <span class="tok-fn">dumpRebaseInfo</span>(</span>
<span class="line" id="L1211">        gpa: Allocator,</span>
<span class="line" id="L1212">        data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1213">        segments: []<span class="tok-kw">const</span> macho.segment_command_64,</span>
<span class="line" id="L1214">        writer: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L1215">    ) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1216">        <span class="tok-kw">var</span> rebases = std.ArrayList(<span class="tok-type">u64</span>).init(gpa);</span>
<span class="line" id="L1217">        <span class="tok-kw">defer</span> rebases.deinit();</span>
<span class="line" id="L1218">        <span class="tok-kw">try</span> parseRebaseInfo(data, segments, &amp;rebases);</span>
<span class="line" id="L1219">        mem.sort(<span class="tok-type">u64</span>, rebases.items, {}, std.sort.asc(<span class="tok-type">u64</span>));</span>
<span class="line" id="L1220">        <span class="tok-kw">for</span> (rebases.items) |addr| {</span>
<span class="line" id="L1221">            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;0x{x}\n&quot;</span>, .{addr});</span>
<span class="line" id="L1222">        }</span>
<span class="line" id="L1223">    }</span>
<span class="line" id="L1224"></span>
<span class="line" id="L1225">    <span class="tok-kw">fn</span> <span class="tok-fn">parseRebaseInfo</span>(</span>
<span class="line" id="L1226">        data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1227">        segments: []<span class="tok-kw">const</span> macho.segment_command_64,</span>
<span class="line" id="L1228">        rebases: *std.ArrayList(<span class="tok-type">u64</span>),</span>
<span class="line" id="L1229">    ) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1230">        <span class="tok-kw">var</span> stream = std.io.fixedBufferStream(data);</span>
<span class="line" id="L1231">        <span class="tok-kw">var</span> creader = std.io.countingReader(stream.reader());</span>
<span class="line" id="L1232">        <span class="tok-kw">const</span> reader = creader.reader();</span>
<span class="line" id="L1233"></span>
<span class="line" id="L1234">        <span class="tok-kw">var</span> seg_id: ?<span class="tok-type">u8</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L1235">        <span class="tok-kw">var</span> offset: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1236">        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L1237">            <span class="tok-kw">const</span> byte = reader.readByte() <span class="tok-kw">catch</span> <span class="tok-kw">break</span>;</span>
<span class="line" id="L1238">            <span class="tok-kw">const</span> opc = byte &amp; macho.REBASE_OPCODE_MASK;</span>
<span class="line" id="L1239">            <span class="tok-kw">const</span> imm = byte &amp; macho.REBASE_IMMEDIATE_MASK;</span>
<span class="line" id="L1240">            <span class="tok-kw">switch</span> (opc) {</span>
<span class="line" id="L1241">                macho.REBASE_OPCODE_DONE =&gt; <span class="tok-kw">break</span>,</span>
<span class="line" id="L1242">                macho.REBASE_OPCODE_SET_TYPE_IMM =&gt; {},</span>
<span class="line" id="L1243">                macho.REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB =&gt; {</span>
<span class="line" id="L1244">                    seg_id = imm;</span>
<span class="line" id="L1245">                    offset = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u64</span>, reader);</span>
<span class="line" id="L1246">                },</span>
<span class="line" id="L1247">                macho.REBASE_OPCODE_ADD_ADDR_IMM_SCALED =&gt; {</span>
<span class="line" id="L1248">                    offset += imm * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">u64</span>);</span>
<span class="line" id="L1249">                },</span>
<span class="line" id="L1250">                macho.REBASE_OPCODE_ADD_ADDR_ULEB =&gt; {</span>
<span class="line" id="L1251">                    <span class="tok-kw">const</span> addend = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u64</span>, reader);</span>
<span class="line" id="L1252">                    offset += addend;</span>
<span class="line" id="L1253">                },</span>
<span class="line" id="L1254">                macho.REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB =&gt; {</span>
<span class="line" id="L1255">                    <span class="tok-kw">const</span> addend = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u64</span>, reader);</span>
<span class="line" id="L1256">                    <span class="tok-kw">const</span> seg = segments[seg_id.?];</span>
<span class="line" id="L1257">                    <span class="tok-kw">const</span> addr = seg.vmaddr + offset;</span>
<span class="line" id="L1258">                    <span class="tok-kw">try</span> rebases.append(addr);</span>
<span class="line" id="L1259">                    offset += addend + <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">u64</span>);</span>
<span class="line" id="L1260">                },</span>
<span class="line" id="L1261">                macho.REBASE_OPCODE_DO_REBASE_IMM_TIMES,</span>
<span class="line" id="L1262">                macho.REBASE_OPCODE_DO_REBASE_ULEB_TIMES,</span>
<span class="line" id="L1263">                macho.REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB,</span>
<span class="line" id="L1264">                =&gt; {</span>
<span class="line" id="L1265">                    <span class="tok-kw">var</span> ntimes: <span class="tok-type">u64</span> = <span class="tok-number">1</span>;</span>
<span class="line" id="L1266">                    <span class="tok-kw">var</span> skip: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1267">                    <span class="tok-kw">switch</span> (opc) {</span>
<span class="line" id="L1268">                        macho.REBASE_OPCODE_DO_REBASE_IMM_TIMES =&gt; {</span>
<span class="line" id="L1269">                            ntimes = imm;</span>
<span class="line" id="L1270">                        },</span>
<span class="line" id="L1271">                        macho.REBASE_OPCODE_DO_REBASE_ULEB_TIMES =&gt; {</span>
<span class="line" id="L1272">                            ntimes = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u64</span>, reader);</span>
<span class="line" id="L1273">                        },</span>
<span class="line" id="L1274">                        macho.REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB =&gt; {</span>
<span class="line" id="L1275">                            ntimes = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u64</span>, reader);</span>
<span class="line" id="L1276">                            skip = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u64</span>, reader);</span>
<span class="line" id="L1277">                        },</span>
<span class="line" id="L1278">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1279">                    }</span>
<span class="line" id="L1280">                    <span class="tok-kw">const</span> seg = segments[seg_id.?];</span>
<span class="line" id="L1281">                    <span class="tok-kw">const</span> base_addr = seg.vmaddr;</span>
<span class="line" id="L1282">                    <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1283">                    <span class="tok-kw">while</span> (count &lt; ntimes) : (count += <span class="tok-number">1</span>) {</span>
<span class="line" id="L1284">                        <span class="tok-kw">const</span> addr = base_addr + offset;</span>
<span class="line" id="L1285">                        <span class="tok-kw">try</span> rebases.append(addr);</span>
<span class="line" id="L1286">                        offset += skip + <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">u64</span>);</span>
<span class="line" id="L1287">                    }</span>
<span class="line" id="L1288">                },</span>
<span class="line" id="L1289">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">break</span>,</span>
<span class="line" id="L1290">            }</span>
<span class="line" id="L1291">        }</span>
<span class="line" id="L1292">    }</span>
<span class="line" id="L1293"></span>
<span class="line" id="L1294">    <span class="tok-kw">const</span> Binding = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1295">        address: <span class="tok-type">u64</span>,</span>
<span class="line" id="L1296">        addend: <span class="tok-type">i64</span>,</span>
<span class="line" id="L1297">        ordinal: <span class="tok-type">u16</span>,</span>
<span class="line" id="L1298">        tag: Tag,</span>
<span class="line" id="L1299">        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1300"></span>
<span class="line" id="L1301">        <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(binding: *Binding, gpa: Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L1302">            gpa.free(binding.name);</span>
<span class="line" id="L1303">        }</span>
<span class="line" id="L1304"></span>
<span class="line" id="L1305">        <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(ctx: <span class="tok-type">void</span>, lhs: Binding, rhs: Binding) <span class="tok-type">bool</span> {</span>
<span class="line" id="L1306">            _ = ctx;</span>
<span class="line" id="L1307">            <span class="tok-kw">return</span> lhs.address &lt; rhs.address;</span>
<span class="line" id="L1308">        }</span>
<span class="line" id="L1309"></span>
<span class="line" id="L1310">        <span class="tok-kw">const</span> Tag = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L1311">            ord,</span>
<span class="line" id="L1312">            self,</span>
<span class="line" id="L1313">            exe,</span>
<span class="line" id="L1314">            flat,</span>
<span class="line" id="L1315">        };</span>
<span class="line" id="L1316">    };</span>
<span class="line" id="L1317"></span>
<span class="line" id="L1318">    <span class="tok-kw">fn</span> <span class="tok-fn">dumpBindInfo</span>(</span>
<span class="line" id="L1319">        gpa: Allocator,</span>
<span class="line" id="L1320">        data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1321">        segments: []<span class="tok-kw">const</span> macho.segment_command_64,</span>
<span class="line" id="L1322">        dylibs: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1323">        writer: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L1324">    ) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1325">        <span class="tok-kw">var</span> bindings = std.ArrayList(Binding).init(gpa);</span>
<span class="line" id="L1326">        <span class="tok-kw">defer</span> {</span>
<span class="line" id="L1327">            <span class="tok-kw">for</span> (bindings.items) |*b| {</span>
<span class="line" id="L1328">                b.deinit(gpa);</span>
<span class="line" id="L1329">            }</span>
<span class="line" id="L1330">            bindings.deinit();</span>
<span class="line" id="L1331">        }</span>
<span class="line" id="L1332">        <span class="tok-kw">try</span> parseBindInfo(gpa, data, segments, &amp;bindings);</span>
<span class="line" id="L1333">        mem.sort(Binding, bindings.items, {}, Binding.lessThan);</span>
<span class="line" id="L1334">        <span class="tok-kw">for</span> (bindings.items) |binding| {</span>
<span class="line" id="L1335">            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;0x{x} [addend: {d}]&quot;</span>, .{ binding.address, binding.addend });</span>
<span class="line" id="L1336">            <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; (&quot;</span>);</span>
<span class="line" id="L1337">            <span class="tok-kw">switch</span> (binding.tag) {</span>
<span class="line" id="L1338">                .self =&gt; <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;self&quot;</span>),</span>
<span class="line" id="L1339">                .exe =&gt; <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;main executable&quot;</span>),</span>
<span class="line" id="L1340">                .flat =&gt; <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;flat lookup&quot;</span>),</span>
<span class="line" id="L1341">                .ord =&gt; <span class="tok-kw">try</span> writer.writeAll(std.fs.path.basename(dylibs[binding.ordinal - <span class="tok-number">1</span>])),</span>
<span class="line" id="L1342">            }</span>
<span class="line" id="L1343">            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;) {s}\n&quot;</span>, .{binding.name});</span>
<span class="line" id="L1344">        }</span>
<span class="line" id="L1345">    }</span>
<span class="line" id="L1346"></span>
<span class="line" id="L1347">    <span class="tok-kw">fn</span> <span class="tok-fn">parseBindInfo</span>(</span>
<span class="line" id="L1348">        gpa: Allocator,</span>
<span class="line" id="L1349">        data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1350">        segments: []<span class="tok-kw">const</span> macho.segment_command_64,</span>
<span class="line" id="L1351">        bindings: *std.ArrayList(Binding),</span>
<span class="line" id="L1352">    ) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1353">        <span class="tok-kw">var</span> stream = std.io.fixedBufferStream(data);</span>
<span class="line" id="L1354">        <span class="tok-kw">var</span> creader = std.io.countingReader(stream.reader());</span>
<span class="line" id="L1355">        <span class="tok-kw">const</span> reader = creader.reader();</span>
<span class="line" id="L1356"></span>
<span class="line" id="L1357">        <span class="tok-kw">var</span> seg_id: ?<span class="tok-type">u8</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L1358">        <span class="tok-kw">var</span> tag: Binding.Tag = .self;</span>
<span class="line" id="L1359">        <span class="tok-kw">var</span> ordinal: <span class="tok-type">u16</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1360">        <span class="tok-kw">var</span> offset: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1361">        <span class="tok-kw">var</span> addend: <span class="tok-type">i64</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1362"></span>
<span class="line" id="L1363">        <span class="tok-kw">var</span> name_buf = std.ArrayList(<span class="tok-type">u8</span>).init(gpa);</span>
<span class="line" id="L1364">        <span class="tok-kw">defer</span> name_buf.deinit();</span>
<span class="line" id="L1365"></span>
<span class="line" id="L1366">        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L1367">            <span class="tok-kw">const</span> byte = reader.readByte() <span class="tok-kw">catch</span> <span class="tok-kw">break</span>;</span>
<span class="line" id="L1368">            <span class="tok-kw">const</span> opc = byte &amp; macho.BIND_OPCODE_MASK;</span>
<span class="line" id="L1369">            <span class="tok-kw">const</span> imm = byte &amp; macho.BIND_IMMEDIATE_MASK;</span>
<span class="line" id="L1370">            <span class="tok-kw">switch</span> (opc) {</span>
<span class="line" id="L1371">                macho.BIND_OPCODE_DONE,</span>
<span class="line" id="L1372">                macho.BIND_OPCODE_SET_TYPE_IMM,</span>
<span class="line" id="L1373">                =&gt; {},</span>
<span class="line" id="L1374">                macho.BIND_OPCODE_SET_DYLIB_ORDINAL_IMM =&gt; {</span>
<span class="line" id="L1375">                    tag = .ord;</span>
<span class="line" id="L1376">                    ordinal = imm;</span>
<span class="line" id="L1377">                },</span>
<span class="line" id="L1378">                macho.BIND_OPCODE_SET_DYLIB_SPECIAL_IMM =&gt; {</span>
<span class="line" id="L1379">                    <span class="tok-kw">switch</span> (imm) {</span>
<span class="line" id="L1380">                        <span class="tok-number">0</span> =&gt; tag = .self,</span>
<span class="line" id="L1381">                        <span class="tok-number">0xf</span> =&gt; tag = .exe,</span>
<span class="line" id="L1382">                        <span class="tok-number">0xe</span> =&gt; tag = .flat,</span>
<span class="line" id="L1383">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1384">                    }</span>
<span class="line" id="L1385">                },</span>
<span class="line" id="L1386">                macho.BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB =&gt; {</span>
<span class="line" id="L1387">                    seg_id = imm;</span>
<span class="line" id="L1388">                    offset = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u64</span>, reader);</span>
<span class="line" id="L1389">                },</span>
<span class="line" id="L1390">                macho.BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM =&gt; {</span>
<span class="line" id="L1391">                    name_buf.clearRetainingCapacity();</span>
<span class="line" id="L1392">                    <span class="tok-kw">try</span> reader.readUntilDelimiterArrayList(&amp;name_buf, <span class="tok-number">0</span>, std.math.maxInt(<span class="tok-type">u32</span>));</span>
<span class="line" id="L1393">                    <span class="tok-kw">try</span> name_buf.append(<span class="tok-number">0</span>);</span>
<span class="line" id="L1394">                },</span>
<span class="line" id="L1395">                macho.BIND_OPCODE_SET_ADDEND_SLEB =&gt; {</span>
<span class="line" id="L1396">                    addend = <span class="tok-kw">try</span> std.leb.readILEB128(<span class="tok-type">i64</span>, reader);</span>
<span class="line" id="L1397">                },</span>
<span class="line" id="L1398">                macho.BIND_OPCODE_ADD_ADDR_ULEB =&gt; {</span>
<span class="line" id="L1399">                    <span class="tok-kw">const</span> x = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u64</span>, reader);</span>
<span class="line" id="L1400">                    offset = <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">i64</span>, <span class="tok-builtin">@intCast</span>(offset)) + <span class="tok-builtin">@as</span>(<span class="tok-type">i64</span>, <span class="tok-builtin">@bitCast</span>(x)));</span>
<span class="line" id="L1401">                },</span>
<span class="line" id="L1402">                macho.BIND_OPCODE_DO_BIND,</span>
<span class="line" id="L1403">                macho.BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB,</span>
<span class="line" id="L1404">                macho.BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED,</span>
<span class="line" id="L1405">                macho.BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB,</span>
<span class="line" id="L1406">                =&gt; {</span>
<span class="line" id="L1407">                    <span class="tok-kw">var</span> add_addr: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1408">                    <span class="tok-kw">var</span> count: <span class="tok-type">u64</span> = <span class="tok-number">1</span>;</span>
<span class="line" id="L1409">                    <span class="tok-kw">var</span> skip: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1410"></span>
<span class="line" id="L1411">                    <span class="tok-kw">switch</span> (opc) {</span>
<span class="line" id="L1412">                        macho.BIND_OPCODE_DO_BIND =&gt; {},</span>
<span class="line" id="L1413">                        macho.BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB =&gt; {</span>
<span class="line" id="L1414">                            add_addr = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u64</span>, reader);</span>
<span class="line" id="L1415">                        },</span>
<span class="line" id="L1416">                        macho.BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED =&gt; {</span>
<span class="line" id="L1417">                            add_addr = imm * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">u64</span>);</span>
<span class="line" id="L1418">                        },</span>
<span class="line" id="L1419">                        macho.BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB =&gt; {</span>
<span class="line" id="L1420">                            count = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u64</span>, reader);</span>
<span class="line" id="L1421">                            skip = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u64</span>, reader);</span>
<span class="line" id="L1422">                        },</span>
<span class="line" id="L1423">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1424">                    }</span>
<span class="line" id="L1425"></span>
<span class="line" id="L1426">                    <span class="tok-kw">const</span> seg = segments[seg_id.?];</span>
<span class="line" id="L1427">                    <span class="tok-kw">var</span> i: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1428">                    <span class="tok-kw">while</span> (i &lt; count) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L1429">                        <span class="tok-kw">const</span> addr: <span class="tok-type">u64</span> = <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">i64</span>, <span class="tok-builtin">@intCast</span>(seg.vmaddr + offset)));</span>
<span class="line" id="L1430">                        <span class="tok-kw">try</span> bindings.append(.{</span>
<span class="line" id="L1431">                            .address = addr,</span>
<span class="line" id="L1432">                            .addend = addend,</span>
<span class="line" id="L1433">                            .tag = tag,</span>
<span class="line" id="L1434">                            .ordinal = ordinal,</span>
<span class="line" id="L1435">                            .name = <span class="tok-kw">try</span> gpa.dupe(<span class="tok-type">u8</span>, name_buf.items),</span>
<span class="line" id="L1436">                        });</span>
<span class="line" id="L1437">                        offset += skip + <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">u64</span>) + add_addr;</span>
<span class="line" id="L1438">                    }</span>
<span class="line" id="L1439">                },</span>
<span class="line" id="L1440">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">break</span>,</span>
<span class="line" id="L1441">            }</span>
<span class="line" id="L1442">        }</span>
<span class="line" id="L1443">    }</span>
<span class="line" id="L1444"></span>
<span class="line" id="L1445">    <span class="tok-kw">fn</span> <span class="tok-fn">dumpExportsTrie</span>(</span>
<span class="line" id="L1446">        gpa: Allocator,</span>
<span class="line" id="L1447">        data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1448">        seg: macho.segment_command_64,</span>
<span class="line" id="L1449">        writer: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L1450">    ) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1451">        <span class="tok-kw">var</span> arena = std.heap.ArenaAllocator.init(gpa);</span>
<span class="line" id="L1452">        <span class="tok-kw">defer</span> arena.deinit();</span>
<span class="line" id="L1453"></span>
<span class="line" id="L1454">        <span class="tok-kw">var</span> exports = std.ArrayList(Export).init(arena.allocator());</span>
<span class="line" id="L1455">        <span class="tok-kw">var</span> it = TrieIterator{ .data = data };</span>
<span class="line" id="L1456">        <span class="tok-kw">try</span> parseTrieNode(arena.allocator(), &amp;it, <span class="tok-str">&quot;&quot;</span>, &amp;exports);</span>
<span class="line" id="L1457"></span>
<span class="line" id="L1458">        mem.sort(Export, exports.items, {}, Export.lessThan);</span>
<span class="line" id="L1459"></span>
<span class="line" id="L1460">        <span class="tok-kw">for</span> (exports.items) |exp| {</span>
<span class="line" id="L1461">            <span class="tok-kw">switch</span> (exp.tag) {</span>
<span class="line" id="L1462">                .@&quot;export&quot; =&gt; {</span>
<span class="line" id="L1463">                    <span class="tok-kw">const</span> info = exp.data.@&quot;export&quot;;</span>
<span class="line" id="L1464">                    <span class="tok-kw">if</span> (info.kind != .regular <span class="tok-kw">or</span> info.weak) {</span>
<span class="line" id="L1465">                        <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'['</span>);</span>
<span class="line" id="L1466">                    }</span>
<span class="line" id="L1467">                    <span class="tok-kw">switch</span> (info.kind) {</span>
<span class="line" id="L1468">                        .regular =&gt; {},</span>
<span class="line" id="L1469">                        .absolute =&gt; <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;ABS, &quot;</span>),</span>
<span class="line" id="L1470">                        .tlv =&gt; <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;THREAD_LOCAL, &quot;</span>),</span>
<span class="line" id="L1471">                    }</span>
<span class="line" id="L1472">                    <span class="tok-kw">if</span> (info.weak) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;WEAK&quot;</span>);</span>
<span class="line" id="L1473">                    <span class="tok-kw">if</span> (info.kind != .regular <span class="tok-kw">or</span> info.weak) {</span>
<span class="line" id="L1474">                        <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;] &quot;</span>);</span>
<span class="line" id="L1475">                    }</span>
<span class="line" id="L1476">                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{x} &quot;</span>, .{seg.vmaddr + info.vmoffset});</span>
<span class="line" id="L1477">                },</span>
<span class="line" id="L1478">                <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L1479">            }</span>
<span class="line" id="L1480"></span>
<span class="line" id="L1481">            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{s}\n&quot;</span>, .{exp.name});</span>
<span class="line" id="L1482">        }</span>
<span class="line" id="L1483">    }</span>
<span class="line" id="L1484"></span>
<span class="line" id="L1485">    <span class="tok-kw">const</span> TrieIterator = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1486">        data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1487">        pos: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L1488"></span>
<span class="line" id="L1489">        <span class="tok-kw">fn</span> <span class="tok-fn">getStream</span>(it: *TrieIterator) std.io.FixedBufferStream([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) {</span>
<span class="line" id="L1490">            <span class="tok-kw">return</span> std.io.fixedBufferStream(it.data[it.pos..]);</span>
<span class="line" id="L1491">        }</span>
<span class="line" id="L1492"></span>
<span class="line" id="L1493">        <span class="tok-kw">fn</span> <span class="tok-fn">readULEB128</span>(it: *TrieIterator) !<span class="tok-type">u64</span> {</span>
<span class="line" id="L1494">            <span class="tok-kw">var</span> stream = it.getStream();</span>
<span class="line" id="L1495">            <span class="tok-kw">var</span> creader = std.io.countingReader(stream.reader());</span>
<span class="line" id="L1496">            <span class="tok-kw">const</span> reader = creader.reader();</span>
<span class="line" id="L1497">            <span class="tok-kw">const</span> value = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u64</span>, reader);</span>
<span class="line" id="L1498">            it.pos += creader.bytes_read;</span>
<span class="line" id="L1499">            <span class="tok-kw">return</span> value;</span>
<span class="line" id="L1500">        }</span>
<span class="line" id="L1501"></span>
<span class="line" id="L1502">        <span class="tok-kw">fn</span> <span class="tok-fn">readString</span>(it: *TrieIterator) ![:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1503">            <span class="tok-kw">var</span> stream = it.getStream();</span>
<span class="line" id="L1504">            <span class="tok-kw">const</span> reader = stream.reader();</span>
<span class="line" id="L1505"></span>
<span class="line" id="L1506">            <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1507">            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (count += <span class="tok-number">1</span>) {</span>
<span class="line" id="L1508">                <span class="tok-kw">const</span> byte = <span class="tok-kw">try</span> reader.readByte();</span>
<span class="line" id="L1509">                <span class="tok-kw">if</span> (byte == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;</span>
<span class="line" id="L1510">            }</span>
<span class="line" id="L1511"></span>
<span class="line" id="L1512">            <span class="tok-kw">const</span> str = <span class="tok-builtin">@as</span>([*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(it.data.ptr + it.pos))[<span class="tok-number">0</span>..count :<span class="tok-number">0</span>];</span>
<span class="line" id="L1513">            it.pos += count + <span class="tok-number">1</span>;</span>
<span class="line" id="L1514">            <span class="tok-kw">return</span> str;</span>
<span class="line" id="L1515">        }</span>
<span class="line" id="L1516"></span>
<span class="line" id="L1517">        <span class="tok-kw">fn</span> <span class="tok-fn">readByte</span>(it: *TrieIterator) !<span class="tok-type">u8</span> {</span>
<span class="line" id="L1518">            <span class="tok-kw">var</span> stream = it.getStream();</span>
<span class="line" id="L1519">            <span class="tok-kw">const</span> value = <span class="tok-kw">try</span> stream.reader().readByte();</span>
<span class="line" id="L1520">            it.pos += <span class="tok-number">1</span>;</span>
<span class="line" id="L1521">            <span class="tok-kw">return</span> value;</span>
<span class="line" id="L1522">        }</span>
<span class="line" id="L1523">    };</span>
<span class="line" id="L1524"></span>
<span class="line" id="L1525">    <span class="tok-kw">const</span> Export = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1526">        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1527">        tag: <span class="tok-kw">enum</span> { @&quot;export&quot;, reexport, stub_resolver },</span>
<span class="line" id="L1528">        data: <span class="tok-kw">union</span> {</span>
<span class="line" id="L1529">            @&quot;export&quot;: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1530">                kind: <span class="tok-kw">enum</span> { regular, absolute, tlv },</span>
<span class="line" id="L1531">                weak: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L1532">                vmoffset: <span class="tok-type">u64</span>,</span>
<span class="line" id="L1533">            },</span>
<span class="line" id="L1534">            reexport: <span class="tok-type">u64</span>,</span>
<span class="line" id="L1535">            stub_resolver: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1536">                stub_offset: <span class="tok-type">u64</span>,</span>
<span class="line" id="L1537">                resolver_offset: <span class="tok-type">u64</span>,</span>
<span class="line" id="L1538">            },</span>
<span class="line" id="L1539">        },</span>
<span class="line" id="L1540"></span>
<span class="line" id="L1541">        <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">rankByTag</span>(self: Export) <span class="tok-type">u3</span> {</span>
<span class="line" id="L1542">            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self.tag) {</span>
<span class="line" id="L1543">                .@&quot;export&quot; =&gt; <span class="tok-number">1</span>,</span>
<span class="line" id="L1544">                .reexport =&gt; <span class="tok-number">2</span>,</span>
<span class="line" id="L1545">                .stub_resolver =&gt; <span class="tok-number">3</span>,</span>
<span class="line" id="L1546">            };</span>
<span class="line" id="L1547">        }</span>
<span class="line" id="L1548"></span>
<span class="line" id="L1549">        <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(ctx: <span class="tok-type">void</span>, lhs: Export, rhs: Export) <span class="tok-type">bool</span> {</span>
<span class="line" id="L1550">            _ = ctx;</span>
<span class="line" id="L1551">            <span class="tok-kw">if</span> (lhs.rankByTag() == rhs.rankByTag()) {</span>
<span class="line" id="L1552">                <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (lhs.tag) {</span>
<span class="line" id="L1553">                    .@&quot;export&quot; =&gt; lhs.data.@&quot;export&quot;.vmoffset &lt; rhs.data.@&quot;export&quot;.vmoffset,</span>
<span class="line" id="L1554">                    .reexport =&gt; lhs.data.reexport &lt; rhs.data.reexport,</span>
<span class="line" id="L1555">                    .stub_resolver =&gt; lhs.data.stub_resolver.stub_offset &lt; rhs.data.stub_resolver.stub_offset,</span>
<span class="line" id="L1556">                };</span>
<span class="line" id="L1557">            }</span>
<span class="line" id="L1558">            <span class="tok-kw">return</span> lhs.rankByTag() &lt; rhs.rankByTag();</span>
<span class="line" id="L1559">        }</span>
<span class="line" id="L1560">    };</span>
<span class="line" id="L1561"></span>
<span class="line" id="L1562">    <span class="tok-kw">fn</span> <span class="tok-fn">parseTrieNode</span>(</span>
<span class="line" id="L1563">        arena: Allocator,</span>
<span class="line" id="L1564">        it: *TrieIterator,</span>
<span class="line" id="L1565">        prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1566">        exports: *std.ArrayList(Export),</span>
<span class="line" id="L1567">    ) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1568">        <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> it.readULEB128();</span>
<span class="line" id="L1569">        <span class="tok-kw">if</span> (size &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L1570">            <span class="tok-kw">const</span> flags = <span class="tok-kw">try</span> it.readULEB128();</span>
<span class="line" id="L1571">            <span class="tok-kw">switch</span> (flags) {</span>
<span class="line" id="L1572">                macho.EXPORT_SYMBOL_FLAGS_REEXPORT =&gt; {</span>
<span class="line" id="L1573">                    <span class="tok-kw">const</span> ord = <span class="tok-kw">try</span> it.readULEB128();</span>
<span class="line" id="L1574">                    <span class="tok-kw">const</span> name = <span class="tok-kw">try</span> arena.dupe(<span class="tok-type">u8</span>, <span class="tok-kw">try</span> it.readString());</span>
<span class="line" id="L1575">                    <span class="tok-kw">try</span> exports.append(.{</span>
<span class="line" id="L1576">                        .name = <span class="tok-kw">if</span> (name.len &gt; <span class="tok-number">0</span>) name <span class="tok-kw">else</span> prefix,</span>
<span class="line" id="L1577">                        .tag = .reexport,</span>
<span class="line" id="L1578">                        .data = .{ .reexport = ord },</span>
<span class="line" id="L1579">                    });</span>
<span class="line" id="L1580">                },</span>
<span class="line" id="L1581">                macho.EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER =&gt; {</span>
<span class="line" id="L1582">                    <span class="tok-kw">const</span> stub_offset = <span class="tok-kw">try</span> it.readULEB128();</span>
<span class="line" id="L1583">                    <span class="tok-kw">const</span> resolver_offset = <span class="tok-kw">try</span> it.readULEB128();</span>
<span class="line" id="L1584">                    <span class="tok-kw">try</span> exports.append(.{</span>
<span class="line" id="L1585">                        .name = prefix,</span>
<span class="line" id="L1586">                        .tag = .stub_resolver,</span>
<span class="line" id="L1587">                        .data = .{ .stub_resolver = .{</span>
<span class="line" id="L1588">                            .stub_offset = stub_offset,</span>
<span class="line" id="L1589">                            .resolver_offset = resolver_offset,</span>
<span class="line" id="L1590">                        } },</span>
<span class="line" id="L1591">                    });</span>
<span class="line" id="L1592">                },</span>
<span class="line" id="L1593">                <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L1594">                    <span class="tok-kw">const</span> vmoff = <span class="tok-kw">try</span> it.readULEB128();</span>
<span class="line" id="L1595">                    <span class="tok-kw">try</span> exports.append(.{</span>
<span class="line" id="L1596">                        .name = prefix,</span>
<span class="line" id="L1597">                        .tag = .@&quot;export&quot;,</span>
<span class="line" id="L1598">                        .data = .{ .@&quot;export&quot; = .{</span>
<span class="line" id="L1599">                            .kind = <span class="tok-kw">switch</span> (flags &amp; macho.EXPORT_SYMBOL_FLAGS_KIND_MASK) {</span>
<span class="line" id="L1600">                                macho.EXPORT_SYMBOL_FLAGS_KIND_REGULAR =&gt; .regular,</span>
<span class="line" id="L1601">                                macho.EXPORT_SYMBOL_FLAGS_KIND_ABSOLUTE =&gt; .absolute,</span>
<span class="line" id="L1602">                                macho.EXPORT_SYMBOL_FLAGS_KIND_THREAD_LOCAL =&gt; .tlv,</span>
<span class="line" id="L1603">                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1604">                            },</span>
<span class="line" id="L1605">                            .weak = flags &amp; macho.EXPORT_SYMBOL_FLAGS_WEAK_DEFINITION != <span class="tok-number">0</span>,</span>
<span class="line" id="L1606">                            .vmoffset = vmoff,</span>
<span class="line" id="L1607">                        } },</span>
<span class="line" id="L1608">                    });</span>
<span class="line" id="L1609">                },</span>
<span class="line" id="L1610">            }</span>
<span class="line" id="L1611">        }</span>
<span class="line" id="L1612"></span>
<span class="line" id="L1613">        <span class="tok-kw">const</span> nedges = <span class="tok-kw">try</span> it.readByte();</span>
<span class="line" id="L1614">        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..nedges) |_| {</span>
<span class="line" id="L1615">            <span class="tok-kw">const</span> label = <span class="tok-kw">try</span> it.readString();</span>
<span class="line" id="L1616">            <span class="tok-kw">const</span> off = <span class="tok-kw">try</span> it.readULEB128();</span>
<span class="line" id="L1617">            <span class="tok-kw">const</span> prefix_label = <span class="tok-kw">try</span> std.fmt.allocPrint(arena, <span class="tok-str">&quot;{s}{s}&quot;</span>, .{ prefix, label });</span>
<span class="line" id="L1618">            <span class="tok-kw">const</span> curr = it.pos;</span>
<span class="line" id="L1619">            it.pos = off;</span>
<span class="line" id="L1620">            <span class="tok-kw">try</span> parseTrieNode(arena, it, prefix_label, exports);</span>
<span class="line" id="L1621">            it.pos = curr;</span>
<span class="line" id="L1622">        }</span>
<span class="line" id="L1623">    }</span>
<span class="line" id="L1624">};</span>
<span class="line" id="L1625"></span>
<span class="line" id="L1626"><span class="tok-kw">const</span> ElfDumper = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1627">    <span class="tok-kw">const</span> symtab_label = <span class="tok-str">&quot;symbol table&quot;</span>;</span>
<span class="line" id="L1628">    <span class="tok-kw">const</span> dynamic_symtab_label = <span class="tok-str">&quot;dynamic symbol table&quot;</span>;</span>
<span class="line" id="L1629">    <span class="tok-kw">const</span> dynamic_section_label = <span class="tok-str">&quot;dynamic section&quot;</span>;</span>
<span class="line" id="L1630">    <span class="tok-kw">const</span> archive_symtab_label = <span class="tok-str">&quot;archive symbol table&quot;</span>;</span>
<span class="line" id="L1631"></span>
<span class="line" id="L1632">    <span class="tok-kw">fn</span> <span class="tok-fn">parseAndDump</span>(step: *Step, kind: Check.Kind, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1633">        <span class="tok-kw">return</span> parseAndDumpArchive(step, kind, bytes) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1634">            <span class="tok-kw">error</span>.InvalidArchiveMagicNumber =&gt; <span class="tok-kw">try</span> parseAndDumpObject(step, kind, bytes),</span>
<span class="line" id="L1635">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1636">        };</span>
<span class="line" id="L1637">    }</span>
<span class="line" id="L1638"></span>
<span class="line" id="L1639">    <span class="tok-kw">fn</span> <span class="tok-fn">parseAndDumpArchive</span>(step: *Step, kind: Check.Kind, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1640">        <span class="tok-kw">const</span> gpa = step.owner.allocator;</span>
<span class="line" id="L1641">        <span class="tok-kw">var</span> stream = std.io.fixedBufferStream(bytes);</span>
<span class="line" id="L1642">        <span class="tok-kw">const</span> reader = stream.reader();</span>
<span class="line" id="L1643"></span>
<span class="line" id="L1644">        <span class="tok-kw">const</span> magic = <span class="tok-kw">try</span> reader.readBytesNoEof(elf.ARMAG.len);</span>
<span class="line" id="L1645">        <span class="tok-kw">if</span> (!mem.eql(<span class="tok-type">u8</span>, &amp;magic, elf.ARMAG)) {</span>
<span class="line" id="L1646">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidArchiveMagicNumber;</span>
<span class="line" id="L1647">        }</span>
<span class="line" id="L1648"></span>
<span class="line" id="L1649">        <span class="tok-kw">var</span> ctx = ArchiveContext{</span>
<span class="line" id="L1650">            .gpa = gpa,</span>
<span class="line" id="L1651">            .data = bytes,</span>
<span class="line" id="L1652">            .strtab = &amp;[<span class="tok-number">0</span>]<span class="tok-type">u8</span>{},</span>
<span class="line" id="L1653">        };</span>
<span class="line" id="L1654">        <span class="tok-kw">defer</span> {</span>
<span class="line" id="L1655">            <span class="tok-kw">for</span> (ctx.objects.items) |*object| {</span>
<span class="line" id="L1656">                gpa.free(object.name);</span>
<span class="line" id="L1657">            }</span>
<span class="line" id="L1658">            ctx.objects.deinit(gpa);</span>
<span class="line" id="L1659">        }</span>
<span class="line" id="L1660"></span>
<span class="line" id="L1661">        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L1662">            <span class="tok-kw">if</span> (stream.pos &gt;= ctx.data.len) <span class="tok-kw">break</span>;</span>
<span class="line" id="L1663">            <span class="tok-kw">if</span> (!mem.isAligned(stream.pos, <span class="tok-number">2</span>)) stream.pos += <span class="tok-number">1</span>;</span>
<span class="line" id="L1664"></span>
<span class="line" id="L1665">            <span class="tok-kw">const</span> hdr = <span class="tok-kw">try</span> reader.readStruct(elf.ar_hdr);</span>
<span class="line" id="L1666"></span>
<span class="line" id="L1667">            <span class="tok-kw">if</span> (!mem.eql(<span class="tok-type">u8</span>, &amp;hdr.ar_fmag, elf.ARFMAG)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidArchiveHeaderMagicNumber;</span>
<span class="line" id="L1668"></span>
<span class="line" id="L1669">            <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> hdr.size();</span>
<span class="line" id="L1670">            <span class="tok-kw">defer</span> {</span>
<span class="line" id="L1671">                _ = stream.seekBy(size) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L1672">            }</span>
<span class="line" id="L1673"></span>
<span class="line" id="L1674">            <span class="tok-kw">if</span> (hdr.isSymtab()) {</span>
<span class="line" id="L1675">                <span class="tok-kw">try</span> ctx.parseSymtab(ctx.data[stream.pos..][<span class="tok-number">0</span>..size], .p32);</span>
<span class="line" id="L1676">                <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1677">            }</span>
<span class="line" id="L1678">            <span class="tok-kw">if</span> (hdr.isSymtab64()) {</span>
<span class="line" id="L1679">                <span class="tok-kw">try</span> ctx.parseSymtab(ctx.data[stream.pos..][<span class="tok-number">0</span>..size], .p64);</span>
<span class="line" id="L1680">                <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1681">            }</span>
<span class="line" id="L1682">            <span class="tok-kw">if</span> (hdr.isStrtab()) {</span>
<span class="line" id="L1683">                ctx.strtab = ctx.data[stream.pos..][<span class="tok-number">0</span>..size];</span>
<span class="line" id="L1684">                <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1685">            }</span>
<span class="line" id="L1686">            <span class="tok-kw">if</span> (hdr.isSymdef() <span class="tok-kw">or</span> hdr.isSymdefSorted()) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1687"></span>
<span class="line" id="L1688">            <span class="tok-kw">const</span> name = <span class="tok-kw">if</span> (hdr.name()) |name|</span>
<span class="line" id="L1689">                <span class="tok-kw">try</span> gpa.dupe(<span class="tok-type">u8</span>, name)</span>
<span class="line" id="L1690">            <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<span class="tok-kw">try</span> hdr.nameOffset()) |off|</span>
<span class="line" id="L1691">                <span class="tok-kw">try</span> gpa.dupe(<span class="tok-type">u8</span>, ctx.getString(off))</span>
<span class="line" id="L1692">            <span class="tok-kw">else</span></span>
<span class="line" id="L1693">                <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L1694"></span>
<span class="line" id="L1695">            <span class="tok-kw">try</span> ctx.objects.append(gpa, .{ .name = name, .off = stream.pos, .len = size });</span>
<span class="line" id="L1696">        }</span>
<span class="line" id="L1697"></span>
<span class="line" id="L1698">        <span class="tok-kw">var</span> output = std.ArrayList(<span class="tok-type">u8</span>).init(gpa);</span>
<span class="line" id="L1699">        <span class="tok-kw">const</span> writer = output.writer();</span>
<span class="line" id="L1700"></span>
<span class="line" id="L1701">        <span class="tok-kw">switch</span> (kind) {</span>
<span class="line" id="L1702">            .archive_symtab =&gt; <span class="tok-kw">if</span> (ctx.symtab.items.len &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L1703">                <span class="tok-kw">try</span> ctx.dumpSymtab(writer);</span>
<span class="line" id="L1704">            } <span class="tok-kw">else</span> <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;no archive symbol table found&quot;</span>, .{}),</span>
<span class="line" id="L1705"></span>
<span class="line" id="L1706">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">if</span> (ctx.objects.items.len &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L1707">                <span class="tok-kw">try</span> ctx.dumpObjects(step, kind, writer);</span>
<span class="line" id="L1708">            } <span class="tok-kw">else</span> <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;empty archive&quot;</span>, .{}),</span>
<span class="line" id="L1709">        }</span>
<span class="line" id="L1710"></span>
<span class="line" id="L1711">        <span class="tok-kw">return</span> output.toOwnedSlice();</span>
<span class="line" id="L1712">    }</span>
<span class="line" id="L1713"></span>
<span class="line" id="L1714">    <span class="tok-kw">const</span> ArchiveContext = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1715">        gpa: Allocator,</span>
<span class="line" id="L1716">        data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1717">        symtab: std.ArrayListUnmanaged(ArSymtabEntry) = .{},</span>
<span class="line" id="L1718">        strtab: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1719">        objects: std.ArrayListUnmanaged(<span class="tok-kw">struct</span> { name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, off: <span class="tok-type">usize</span>, len: <span class="tok-type">usize</span> }) = .{},</span>
<span class="line" id="L1720"></span>
<span class="line" id="L1721">        <span class="tok-kw">fn</span> <span class="tok-fn">parseSymtab</span>(ctx: *ArchiveContext, raw: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ptr_width: <span class="tok-kw">enum</span> { p32, p64 }) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1722">            <span class="tok-kw">var</span> stream = std.io.fixedBufferStream(raw);</span>
<span class="line" id="L1723">            <span class="tok-kw">const</span> reader = stream.reader();</span>
<span class="line" id="L1724">            <span class="tok-kw">const</span> num = <span class="tok-kw">switch</span> (ptr_width) {</span>
<span class="line" id="L1725">                .p32 =&gt; <span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u32</span>, .big),</span>
<span class="line" id="L1726">                .p64 =&gt; <span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u64</span>, .big),</span>
<span class="line" id="L1727">            };</span>
<span class="line" id="L1728">            <span class="tok-kw">const</span> ptr_size: <span class="tok-type">usize</span> = <span class="tok-kw">switch</span> (ptr_width) {</span>
<span class="line" id="L1729">                .p32 =&gt; <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">u32</span>),</span>
<span class="line" id="L1730">                .p64 =&gt; <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">u64</span>),</span>
<span class="line" id="L1731">            };</span>
<span class="line" id="L1732">            <span class="tok-kw">const</span> strtab_off = (num + <span class="tok-number">1</span>) * ptr_size;</span>
<span class="line" id="L1733">            <span class="tok-kw">const</span> strtab_len = raw.len - strtab_off;</span>
<span class="line" id="L1734">            <span class="tok-kw">const</span> strtab = raw[strtab_off..][<span class="tok-number">0</span>..strtab_len];</span>
<span class="line" id="L1735"></span>
<span class="line" id="L1736">            <span class="tok-kw">try</span> ctx.symtab.ensureTotalCapacityPrecise(ctx.gpa, num);</span>
<span class="line" id="L1737"></span>
<span class="line" id="L1738">            <span class="tok-kw">var</span> stroff: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1739">            <span class="tok-kw">for</span> (<span class="tok-number">0</span>..num) |_| {</span>
<span class="line" id="L1740">                <span class="tok-kw">const</span> off = <span class="tok-kw">switch</span> (ptr_width) {</span>
<span class="line" id="L1741">                    .p32 =&gt; <span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u32</span>, .big),</span>
<span class="line" id="L1742">                    .p64 =&gt; <span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u64</span>, .big),</span>
<span class="line" id="L1743">                };</span>
<span class="line" id="L1744">                <span class="tok-kw">const</span> name = mem.sliceTo(<span class="tok-builtin">@as</span>([*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(strtab.ptr + stroff)), <span class="tok-number">0</span>);</span>
<span class="line" id="L1745">                stroff += name.len + <span class="tok-number">1</span>;</span>
<span class="line" id="L1746">                ctx.symtab.appendAssumeCapacity(.{ .off = off, .name = name });</span>
<span class="line" id="L1747">            }</span>
<span class="line" id="L1748">        }</span>
<span class="line" id="L1749"></span>
<span class="line" id="L1750">        <span class="tok-kw">fn</span> <span class="tok-fn">dumpSymtab</span>(ctx: ArchiveContext, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1751">            <span class="tok-kw">var</span> files = std.AutoHashMap(<span class="tok-type">usize</span>, []<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(ctx.gpa);</span>
<span class="line" id="L1752">            <span class="tok-kw">defer</span> files.deinit();</span>
<span class="line" id="L1753">            <span class="tok-kw">try</span> files.ensureUnusedCapacity(<span class="tok-builtin">@intCast</span>(ctx.objects.items.len));</span>
<span class="line" id="L1754"></span>
<span class="line" id="L1755">            <span class="tok-kw">for</span> (ctx.objects.items) |object| {</span>
<span class="line" id="L1756">                files.putAssumeCapacityNoClobber(object.off - <span class="tok-builtin">@sizeOf</span>(elf.ar_hdr), object.name);</span>
<span class="line" id="L1757">            }</span>
<span class="line" id="L1758"></span>
<span class="line" id="L1759">            <span class="tok-kw">var</span> symbols = std.AutoArrayHashMap(<span class="tok-type">usize</span>, std.ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>)).init(ctx.gpa);</span>
<span class="line" id="L1760">            <span class="tok-kw">defer</span> {</span>
<span class="line" id="L1761">                <span class="tok-kw">for</span> (symbols.values()) |*value| {</span>
<span class="line" id="L1762">                    value.deinit();</span>
<span class="line" id="L1763">                }</span>
<span class="line" id="L1764">                symbols.deinit();</span>
<span class="line" id="L1765">            }</span>
<span class="line" id="L1766"></span>
<span class="line" id="L1767">            <span class="tok-kw">for</span> (ctx.symtab.items) |entry| {</span>
<span class="line" id="L1768">                <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> symbols.getOrPut(<span class="tok-builtin">@intCast</span>(entry.off));</span>
<span class="line" id="L1769">                <span class="tok-kw">if</span> (!gop.found_existing) {</span>
<span class="line" id="L1770">                    gop.value_ptr.* = std.ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(ctx.gpa);</span>
<span class="line" id="L1771">                }</span>
<span class="line" id="L1772">                <span class="tok-kw">try</span> gop.value_ptr.append(entry.name);</span>
<span class="line" id="L1773">            }</span>
<span class="line" id="L1774"></span>
<span class="line" id="L1775">            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{s}\n&quot;</span>, .{archive_symtab_label});</span>
<span class="line" id="L1776">            <span class="tok-kw">for</span> (symbols.keys(), symbols.values()) |off, values| {</span>
<span class="line" id="L1777">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;in object {s}\n&quot;</span>, .{files.get(off).?});</span>
<span class="line" id="L1778">                <span class="tok-kw">for</span> (values.items) |value| {</span>
<span class="line" id="L1779">                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{s}\n&quot;</span>, .{value});</span>
<span class="line" id="L1780">                }</span>
<span class="line" id="L1781">            }</span>
<span class="line" id="L1782">        }</span>
<span class="line" id="L1783"></span>
<span class="line" id="L1784">        <span class="tok-kw">fn</span> <span class="tok-fn">dumpObjects</span>(ctx: ArchiveContext, step: *Step, kind: Check.Kind, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1785">            <span class="tok-kw">for</span> (ctx.objects.items) |object| {</span>
<span class="line" id="L1786">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;object {s}\n&quot;</span>, .{object.name});</span>
<span class="line" id="L1787">                <span class="tok-kw">const</span> output = <span class="tok-kw">try</span> parseAndDumpObject(step, kind, ctx.data[object.off..][<span class="tok-number">0</span>..object.len]);</span>
<span class="line" id="L1788">                <span class="tok-kw">defer</span> ctx.gpa.free(output);</span>
<span class="line" id="L1789">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{s}\n&quot;</span>, .{output});</span>
<span class="line" id="L1790">            }</span>
<span class="line" id="L1791">        }</span>
<span class="line" id="L1792"></span>
<span class="line" id="L1793">        <span class="tok-kw">fn</span> <span class="tok-fn">getString</span>(ctx: ArchiveContext, off: <span class="tok-type">u32</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1794">            assert(off &lt; ctx.strtab.len);</span>
<span class="line" id="L1795">            <span class="tok-kw">const</span> name = mem.sliceTo(<span class="tok-builtin">@as</span>([*:<span class="tok-str">'\n'</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(ctx.strtab.ptr + off)), <span class="tok-number">0</span>);</span>
<span class="line" id="L1796">            <span class="tok-kw">return</span> name[<span class="tok-number">0</span> .. name.len - <span class="tok-number">1</span>];</span>
<span class="line" id="L1797">        }</span>
<span class="line" id="L1798"></span>
<span class="line" id="L1799">        <span class="tok-kw">const</span> ArSymtabEntry = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1800">            name: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1801">            off: <span class="tok-type">u64</span>,</span>
<span class="line" id="L1802">        };</span>
<span class="line" id="L1803">    };</span>
<span class="line" id="L1804"></span>
<span class="line" id="L1805">    <span class="tok-kw">fn</span> <span class="tok-fn">parseAndDumpObject</span>(step: *Step, kind: Check.Kind, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1806">        <span class="tok-kw">const</span> gpa = step.owner.allocator;</span>
<span class="line" id="L1807">        <span class="tok-kw">var</span> stream = std.io.fixedBufferStream(bytes);</span>
<span class="line" id="L1808">        <span class="tok-kw">const</span> reader = stream.reader();</span>
<span class="line" id="L1809"></span>
<span class="line" id="L1810">        <span class="tok-kw">const</span> hdr = <span class="tok-kw">try</span> reader.readStruct(elf.Elf64_Ehdr);</span>
<span class="line" id="L1811">        <span class="tok-kw">if</span> (!mem.eql(<span class="tok-type">u8</span>, hdr.e_ident[<span class="tok-number">0</span>..<span class="tok-number">4</span>], <span class="tok-str">&quot;\x7fELF&quot;</span>)) {</span>
<span class="line" id="L1812">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidMagicNumber;</span>
<span class="line" id="L1813">        }</span>
<span class="line" id="L1814"></span>
<span class="line" id="L1815">        <span class="tok-kw">const</span> shdrs = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> elf.Elf64_Shdr, <span class="tok-builtin">@ptrCast</span>(bytes.ptr + hdr.e_shoff))[<span class="tok-number">0</span>..hdr.e_shnum];</span>
<span class="line" id="L1816">        <span class="tok-kw">const</span> phdrs = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> elf.Elf64_Phdr, <span class="tok-builtin">@ptrCast</span>(bytes.ptr + hdr.e_phoff))[<span class="tok-number">0</span>..hdr.e_phnum];</span>
<span class="line" id="L1817"></span>
<span class="line" id="L1818">        <span class="tok-kw">var</span> ctx = ObjectContext{</span>
<span class="line" id="L1819">            .gpa = gpa,</span>
<span class="line" id="L1820">            .data = bytes,</span>
<span class="line" id="L1821">            .hdr = hdr,</span>
<span class="line" id="L1822">            .shdrs = shdrs,</span>
<span class="line" id="L1823">            .phdrs = phdrs,</span>
<span class="line" id="L1824">            .shstrtab = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L1825">        };</span>
<span class="line" id="L1826">        ctx.shstrtab = ctx.getSectionContents(ctx.hdr.e_shstrndx);</span>
<span class="line" id="L1827"></span>
<span class="line" id="L1828">        <span class="tok-kw">for</span> (ctx.shdrs, <span class="tok-number">0</span>..) |shdr, i| <span class="tok-kw">switch</span> (shdr.sh_type) {</span>
<span class="line" id="L1829">            elf.SHT_SYMTAB, elf.SHT_DYNSYM =&gt; {</span>
<span class="line" id="L1830">                <span class="tok-kw">const</span> raw = ctx.getSectionContents(i);</span>
<span class="line" id="L1831">                <span class="tok-kw">const</span> nsyms = <span class="tok-builtin">@divExact</span>(raw.len, <span class="tok-builtin">@sizeOf</span>(elf.Elf64_Sym));</span>
<span class="line" id="L1832">                <span class="tok-kw">const</span> symbols = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> elf.Elf64_Sym, <span class="tok-builtin">@ptrCast</span>(raw.ptr))[<span class="tok-number">0</span>..nsyms];</span>
<span class="line" id="L1833">                <span class="tok-kw">const</span> strings = ctx.getSectionContents(shdr.sh_link);</span>
<span class="line" id="L1834"></span>
<span class="line" id="L1835">                <span class="tok-kw">switch</span> (shdr.sh_type) {</span>
<span class="line" id="L1836">                    elf.SHT_SYMTAB =&gt; {</span>
<span class="line" id="L1837">                        ctx.symtab = .{</span>
<span class="line" id="L1838">                            .symbols = symbols,</span>
<span class="line" id="L1839">                            .strings = strings,</span>
<span class="line" id="L1840">                        };</span>
<span class="line" id="L1841">                    },</span>
<span class="line" id="L1842">                    elf.SHT_DYNSYM =&gt; {</span>
<span class="line" id="L1843">                        ctx.dysymtab = .{</span>
<span class="line" id="L1844">                            .symbols = symbols,</span>
<span class="line" id="L1845">                            .strings = strings,</span>
<span class="line" id="L1846">                        };</span>
<span class="line" id="L1847">                    },</span>
<span class="line" id="L1848">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1849">                }</span>
<span class="line" id="L1850">            },</span>
<span class="line" id="L1851"></span>
<span class="line" id="L1852">            <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L1853">        };</span>
<span class="line" id="L1854"></span>
<span class="line" id="L1855">        <span class="tok-kw">var</span> output = std.ArrayList(<span class="tok-type">u8</span>).init(gpa);</span>
<span class="line" id="L1856">        <span class="tok-kw">const</span> writer = output.writer();</span>
<span class="line" id="L1857"></span>
<span class="line" id="L1858">        <span class="tok-kw">switch</span> (kind) {</span>
<span class="line" id="L1859">            .headers =&gt; {</span>
<span class="line" id="L1860">                <span class="tok-kw">try</span> ctx.dumpHeader(writer);</span>
<span class="line" id="L1861">                <span class="tok-kw">try</span> ctx.dumpShdrs(writer);</span>
<span class="line" id="L1862">                <span class="tok-kw">try</span> ctx.dumpPhdrs(writer);</span>
<span class="line" id="L1863">            },</span>
<span class="line" id="L1864"></span>
<span class="line" id="L1865">            .symtab =&gt; <span class="tok-kw">if</span> (ctx.symtab.symbols.len &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L1866">                <span class="tok-kw">try</span> ctx.dumpSymtab(.symtab, writer);</span>
<span class="line" id="L1867">            } <span class="tok-kw">else</span> <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;no symbol table found&quot;</span>, .{}),</span>
<span class="line" id="L1868"></span>
<span class="line" id="L1869">            .dynamic_symtab =&gt; <span class="tok-kw">if</span> (ctx.dysymtab.symbols.len &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L1870">                <span class="tok-kw">try</span> ctx.dumpSymtab(.dysymtab, writer);</span>
<span class="line" id="L1871">            } <span class="tok-kw">else</span> <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;no dynamic symbol table found&quot;</span>, .{}),</span>
<span class="line" id="L1872"></span>
<span class="line" id="L1873">            .dynamic_section =&gt; <span class="tok-kw">if</span> (ctx.getSectionByName(<span class="tok-str">&quot;.dynamic&quot;</span>)) |shndx| {</span>
<span class="line" id="L1874">                <span class="tok-kw">try</span> ctx.dumpDynamicSection(shndx, writer);</span>
<span class="line" id="L1875">            } <span class="tok-kw">else</span> <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;no .dynamic section found&quot;</span>, .{}),</span>
<span class="line" id="L1876"></span>
<span class="line" id="L1877">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;invalid check kind for ELF file format: {s}&quot;</span>, .{<span class="tok-builtin">@tagName</span>(kind)}),</span>
<span class="line" id="L1878">        }</span>
<span class="line" id="L1879"></span>
<span class="line" id="L1880">        <span class="tok-kw">return</span> output.toOwnedSlice();</span>
<span class="line" id="L1881">    }</span>
<span class="line" id="L1882"></span>
<span class="line" id="L1883">    <span class="tok-kw">const</span> ObjectContext = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1884">        gpa: Allocator,</span>
<span class="line" id="L1885">        data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1886">        hdr: elf.Elf64_Ehdr,</span>
<span class="line" id="L1887">        shdrs: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> elf.Elf64_Shdr,</span>
<span class="line" id="L1888">        phdrs: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> elf.Elf64_Phdr,</span>
<span class="line" id="L1889">        shstrtab: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1890">        symtab: Symtab = .{},</span>
<span class="line" id="L1891">        dysymtab: Symtab = .{},</span>
<span class="line" id="L1892"></span>
<span class="line" id="L1893">        <span class="tok-kw">fn</span> <span class="tok-fn">dumpHeader</span>(ctx: ObjectContext, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1894">            <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;header\n&quot;</span>);</span>
<span class="line" id="L1895">            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;type {s}\n&quot;</span>, .{<span class="tok-builtin">@tagName</span>(ctx.hdr.e_type)});</span>
<span class="line" id="L1896">            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;entry {x}\n&quot;</span>, .{ctx.hdr.e_entry});</span>
<span class="line" id="L1897">        }</span>
<span class="line" id="L1898"></span>
<span class="line" id="L1899">        <span class="tok-kw">fn</span> <span class="tok-fn">dumpPhdrs</span>(ctx: ObjectContext, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1900">            <span class="tok-kw">if</span> (ctx.phdrs.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;</span>
<span class="line" id="L1901"></span>
<span class="line" id="L1902">            <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;program headers\n&quot;</span>);</span>
<span class="line" id="L1903"></span>
<span class="line" id="L1904">            <span class="tok-kw">for</span> (ctx.phdrs, <span class="tok-number">0</span>..) |phdr, phndx| {</span>
<span class="line" id="L1905">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;phdr {d}\n&quot;</span>, .{phndx});</span>
<span class="line" id="L1906">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;type {s}\n&quot;</span>, .{fmtPhType(phdr.p_type)});</span>
<span class="line" id="L1907">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;vaddr {x}\n&quot;</span>, .{phdr.p_vaddr});</span>
<span class="line" id="L1908">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;paddr {x}\n&quot;</span>, .{phdr.p_paddr});</span>
<span class="line" id="L1909">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;offset {x}\n&quot;</span>, .{phdr.p_offset});</span>
<span class="line" id="L1910">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;memsz {x}\n&quot;</span>, .{phdr.p_memsz});</span>
<span class="line" id="L1911">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;filesz {x}\n&quot;</span>, .{phdr.p_filesz});</span>
<span class="line" id="L1912">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;align {x}\n&quot;</span>, .{phdr.p_align});</span>
<span class="line" id="L1913"></span>
<span class="line" id="L1914">                {</span>
<span class="line" id="L1915">                    <span class="tok-kw">const</span> flags = phdr.p_flags;</span>
<span class="line" id="L1916">                    <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;flags&quot;</span>);</span>
<span class="line" id="L1917">                    <span class="tok-kw">if</span> (flags &gt; <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">' '</span>);</span>
<span class="line" id="L1918">                    <span class="tok-kw">if</span> (flags &amp; elf.PF_R != <span class="tok-number">0</span>) {</span>
<span class="line" id="L1919">                        <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'R'</span>);</span>
<span class="line" id="L1920">                    }</span>
<span class="line" id="L1921">                    <span class="tok-kw">if</span> (flags &amp; elf.PF_W != <span class="tok-number">0</span>) {</span>
<span class="line" id="L1922">                        <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'W'</span>);</span>
<span class="line" id="L1923">                    }</span>
<span class="line" id="L1924">                    <span class="tok-kw">if</span> (flags &amp; elf.PF_X != <span class="tok-number">0</span>) {</span>
<span class="line" id="L1925">                        <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'E'</span>);</span>
<span class="line" id="L1926">                    }</span>
<span class="line" id="L1927">                    <span class="tok-kw">if</span> (flags &amp; elf.PF_MASKOS != <span class="tok-number">0</span>) {</span>
<span class="line" id="L1928">                        <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;OS&quot;</span>);</span>
<span class="line" id="L1929">                    }</span>
<span class="line" id="L1930">                    <span class="tok-kw">if</span> (flags &amp; elf.PF_MASKPROC != <span class="tok-number">0</span>) {</span>
<span class="line" id="L1931">                        <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;PROC&quot;</span>);</span>
<span class="line" id="L1932">                    }</span>
<span class="line" id="L1933">                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);</span>
<span class="line" id="L1934">                }</span>
<span class="line" id="L1935">            }</span>
<span class="line" id="L1936">        }</span>
<span class="line" id="L1937"></span>
<span class="line" id="L1938">        <span class="tok-kw">fn</span> <span class="tok-fn">dumpShdrs</span>(ctx: ObjectContext, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1939">            <span class="tok-kw">if</span> (ctx.shdrs.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;</span>
<span class="line" id="L1940"></span>
<span class="line" id="L1941">            <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;section headers\n&quot;</span>);</span>
<span class="line" id="L1942"></span>
<span class="line" id="L1943">            <span class="tok-kw">for</span> (ctx.shdrs, <span class="tok-number">0</span>..) |shdr, shndx| {</span>
<span class="line" id="L1944">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;shdr {d}\n&quot;</span>, .{shndx});</span>
<span class="line" id="L1945">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;name {s}\n&quot;</span>, .{ctx.getSectionName(shndx)});</span>
<span class="line" id="L1946">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;type {s}\n&quot;</span>, .{fmtShType(shdr.sh_type)});</span>
<span class="line" id="L1947">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;addr {x}\n&quot;</span>, .{shdr.sh_addr});</span>
<span class="line" id="L1948">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;offset {x}\n&quot;</span>, .{shdr.sh_offset});</span>
<span class="line" id="L1949">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;size {x}\n&quot;</span>, .{shdr.sh_size});</span>
<span class="line" id="L1950">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;addralign {x}\n&quot;</span>, .{shdr.sh_addralign});</span>
<span class="line" id="L1951">                <span class="tok-comment">// TODO dump formatted sh_flags</span>
</span>
<span class="line" id="L1952">            }</span>
<span class="line" id="L1953">        }</span>
<span class="line" id="L1954"></span>
<span class="line" id="L1955">        <span class="tok-kw">fn</span> <span class="tok-fn">dumpDynamicSection</span>(ctx: ObjectContext, shndx: <span class="tok-type">usize</span>, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1956">            <span class="tok-kw">const</span> shdr = ctx.shdrs[shndx];</span>
<span class="line" id="L1957">            <span class="tok-kw">const</span> strtab = ctx.getSectionContents(shdr.sh_link);</span>
<span class="line" id="L1958">            <span class="tok-kw">const</span> data = ctx.getSectionContents(shndx);</span>
<span class="line" id="L1959">            <span class="tok-kw">const</span> nentries = <span class="tok-builtin">@divExact</span>(data.len, <span class="tok-builtin">@sizeOf</span>(elf.Elf64_Dyn));</span>
<span class="line" id="L1960">            <span class="tok-kw">const</span> entries = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> elf.Elf64_Dyn, <span class="tok-builtin">@ptrCast</span>(data.ptr))[<span class="tok-number">0</span>..nentries];</span>
<span class="line" id="L1961"></span>
<span class="line" id="L1962">            <span class="tok-kw">try</span> writer.writeAll(ElfDumper.dynamic_section_label ++ <span class="tok-str">&quot;\n&quot;</span>);</span>
<span class="line" id="L1963"></span>
<span class="line" id="L1964">            <span class="tok-kw">for</span> (entries) |entry| {</span>
<span class="line" id="L1965">                <span class="tok-kw">const</span> key = <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@bitCast</span>(entry.d_tag));</span>
<span class="line" id="L1966">                <span class="tok-kw">const</span> value = entry.d_val;</span>
<span class="line" id="L1967"></span>
<span class="line" id="L1968">                <span class="tok-kw">const</span> key_str = <span class="tok-kw">switch</span> (key) {</span>
<span class="line" id="L1969">                    elf.DT_NEEDED =&gt; <span class="tok-str">&quot;NEEDED&quot;</span>,</span>
<span class="line" id="L1970">                    elf.DT_SONAME =&gt; <span class="tok-str">&quot;SONAME&quot;</span>,</span>
<span class="line" id="L1971">                    elf.DT_INIT_ARRAY =&gt; <span class="tok-str">&quot;INIT_ARRAY&quot;</span>,</span>
<span class="line" id="L1972">                    elf.DT_INIT_ARRAYSZ =&gt; <span class="tok-str">&quot;INIT_ARRAYSZ&quot;</span>,</span>
<span class="line" id="L1973">                    elf.DT_FINI_ARRAY =&gt; <span class="tok-str">&quot;FINI_ARRAY&quot;</span>,</span>
<span class="line" id="L1974">                    elf.DT_FINI_ARRAYSZ =&gt; <span class="tok-str">&quot;FINI_ARRAYSZ&quot;</span>,</span>
<span class="line" id="L1975">                    elf.DT_HASH =&gt; <span class="tok-str">&quot;HASH&quot;</span>,</span>
<span class="line" id="L1976">                    elf.DT_GNU_HASH =&gt; <span class="tok-str">&quot;GNU_HASH&quot;</span>,</span>
<span class="line" id="L1977">                    elf.DT_STRTAB =&gt; <span class="tok-str">&quot;STRTAB&quot;</span>,</span>
<span class="line" id="L1978">                    elf.DT_SYMTAB =&gt; <span class="tok-str">&quot;SYMTAB&quot;</span>,</span>
<span class="line" id="L1979">                    elf.DT_STRSZ =&gt; <span class="tok-str">&quot;STRSZ&quot;</span>,</span>
<span class="line" id="L1980">                    elf.DT_SYMENT =&gt; <span class="tok-str">&quot;SYMENT&quot;</span>,</span>
<span class="line" id="L1981">                    elf.DT_PLTGOT =&gt; <span class="tok-str">&quot;PLTGOT&quot;</span>,</span>
<span class="line" id="L1982">                    elf.DT_PLTRELSZ =&gt; <span class="tok-str">&quot;PLTRELSZ&quot;</span>,</span>
<span class="line" id="L1983">                    elf.DT_PLTREL =&gt; <span class="tok-str">&quot;PLTREL&quot;</span>,</span>
<span class="line" id="L1984">                    elf.DT_JMPREL =&gt; <span class="tok-str">&quot;JMPREL&quot;</span>,</span>
<span class="line" id="L1985">                    elf.DT_RELA =&gt; <span class="tok-str">&quot;RELA&quot;</span>,</span>
<span class="line" id="L1986">                    elf.DT_RELASZ =&gt; <span class="tok-str">&quot;RELASZ&quot;</span>,</span>
<span class="line" id="L1987">                    elf.DT_RELAENT =&gt; <span class="tok-str">&quot;RELAENT&quot;</span>,</span>
<span class="line" id="L1988">                    elf.DT_VERDEF =&gt; <span class="tok-str">&quot;VERDEF&quot;</span>,</span>
<span class="line" id="L1989">                    elf.DT_VERDEFNUM =&gt; <span class="tok-str">&quot;VERDEFNUM&quot;</span>,</span>
<span class="line" id="L1990">                    elf.DT_FLAGS =&gt; <span class="tok-str">&quot;FLAGS&quot;</span>,</span>
<span class="line" id="L1991">                    elf.DT_FLAGS_1 =&gt; <span class="tok-str">&quot;FLAGS_1&quot;</span>,</span>
<span class="line" id="L1992">                    elf.DT_VERNEED =&gt; <span class="tok-str">&quot;VERNEED&quot;</span>,</span>
<span class="line" id="L1993">                    elf.DT_VERNEEDNUM =&gt; <span class="tok-str">&quot;VERNEEDNUM&quot;</span>,</span>
<span class="line" id="L1994">                    elf.DT_VERSYM =&gt; <span class="tok-str">&quot;VERSYM&quot;</span>,</span>
<span class="line" id="L1995">                    elf.DT_RELACOUNT =&gt; <span class="tok-str">&quot;RELACOUNT&quot;</span>,</span>
<span class="line" id="L1996">                    elf.DT_RPATH =&gt; <span class="tok-str">&quot;RPATH&quot;</span>,</span>
<span class="line" id="L1997">                    elf.DT_RUNPATH =&gt; <span class="tok-str">&quot;RUNPATH&quot;</span>,</span>
<span class="line" id="L1998">                    elf.DT_INIT =&gt; <span class="tok-str">&quot;INIT&quot;</span>,</span>
<span class="line" id="L1999">                    elf.DT_FINI =&gt; <span class="tok-str">&quot;FINI&quot;</span>,</span>
<span class="line" id="L2000">                    elf.DT_NULL =&gt; <span class="tok-str">&quot;NULL&quot;</span>,</span>
<span class="line" id="L2001">                    <span class="tok-kw">else</span> =&gt; <span class="tok-str">&quot;UNKNOWN&quot;</span>,</span>
<span class="line" id="L2002">                };</span>
<span class="line" id="L2003">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{s}&quot;</span>, .{key_str});</span>
<span class="line" id="L2004"></span>
<span class="line" id="L2005">                <span class="tok-kw">switch</span> (key) {</span>
<span class="line" id="L2006">                    elf.DT_NEEDED,</span>
<span class="line" id="L2007">                    elf.DT_SONAME,</span>
<span class="line" id="L2008">                    elf.DT_RPATH,</span>
<span class="line" id="L2009">                    elf.DT_RUNPATH,</span>
<span class="line" id="L2010">                    =&gt; {</span>
<span class="line" id="L2011">                        <span class="tok-kw">const</span> name = getString(strtab, <span class="tok-builtin">@intCast</span>(value));</span>
<span class="line" id="L2012">                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {s}&quot;</span>, .{name});</span>
<span class="line" id="L2013">                    },</span>
<span class="line" id="L2014"></span>
<span class="line" id="L2015">                    elf.DT_INIT_ARRAY,</span>
<span class="line" id="L2016">                    elf.DT_FINI_ARRAY,</span>
<span class="line" id="L2017">                    elf.DT_HASH,</span>
<span class="line" id="L2018">                    elf.DT_GNU_HASH,</span>
<span class="line" id="L2019">                    elf.DT_STRTAB,</span>
<span class="line" id="L2020">                    elf.DT_SYMTAB,</span>
<span class="line" id="L2021">                    elf.DT_PLTGOT,</span>
<span class="line" id="L2022">                    elf.DT_JMPREL,</span>
<span class="line" id="L2023">                    elf.DT_RELA,</span>
<span class="line" id="L2024">                    elf.DT_VERDEF,</span>
<span class="line" id="L2025">                    elf.DT_VERNEED,</span>
<span class="line" id="L2026">                    elf.DT_VERSYM,</span>
<span class="line" id="L2027">                    elf.DT_INIT,</span>
<span class="line" id="L2028">                    elf.DT_FINI,</span>
<span class="line" id="L2029">                    elf.DT_NULL,</span>
<span class="line" id="L2030">                    =&gt; <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {x}&quot;</span>, .{value}),</span>
<span class="line" id="L2031"></span>
<span class="line" id="L2032">                    elf.DT_INIT_ARRAYSZ,</span>
<span class="line" id="L2033">                    elf.DT_FINI_ARRAYSZ,</span>
<span class="line" id="L2034">                    elf.DT_STRSZ,</span>
<span class="line" id="L2035">                    elf.DT_SYMENT,</span>
<span class="line" id="L2036">                    elf.DT_PLTRELSZ,</span>
<span class="line" id="L2037">                    elf.DT_RELASZ,</span>
<span class="line" id="L2038">                    elf.DT_RELAENT,</span>
<span class="line" id="L2039">                    elf.DT_RELACOUNT,</span>
<span class="line" id="L2040">                    =&gt; <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {d}&quot;</span>, .{value}),</span>
<span class="line" id="L2041"></span>
<span class="line" id="L2042">                    elf.DT_PLTREL =&gt; <span class="tok-kw">try</span> writer.writeAll(<span class="tok-kw">switch</span> (value) {</span>
<span class="line" id="L2043">                        elf.DT_REL =&gt; <span class="tok-str">&quot; REL&quot;</span>,</span>
<span class="line" id="L2044">                        elf.DT_RELA =&gt; <span class="tok-str">&quot; RELA&quot;</span>,</span>
<span class="line" id="L2045">                        <span class="tok-kw">else</span> =&gt; <span class="tok-str">&quot; UNKNOWN&quot;</span>,</span>
<span class="line" id="L2046">                    }),</span>
<span class="line" id="L2047"></span>
<span class="line" id="L2048">                    elf.DT_FLAGS =&gt; <span class="tok-kw">if</span> (value &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L2049">                        <span class="tok-kw">if</span> (value &amp; elf.DF_ORIGIN != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; ORIGIN&quot;</span>);</span>
<span class="line" id="L2050">                        <span class="tok-kw">if</span> (value &amp; elf.DF_SYMBOLIC != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; SYMBOLIC&quot;</span>);</span>
<span class="line" id="L2051">                        <span class="tok-kw">if</span> (value &amp; elf.DF_TEXTREL != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; TEXTREL&quot;</span>);</span>
<span class="line" id="L2052">                        <span class="tok-kw">if</span> (value &amp; elf.DF_BIND_NOW != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; BIND_NOW&quot;</span>);</span>
<span class="line" id="L2053">                        <span class="tok-kw">if</span> (value &amp; elf.DF_STATIC_TLS != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; STATIC_TLS&quot;</span>);</span>
<span class="line" id="L2054">                    },</span>
<span class="line" id="L2055"></span>
<span class="line" id="L2056">                    elf.DT_FLAGS_1 =&gt; <span class="tok-kw">if</span> (value &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L2057">                        <span class="tok-kw">if</span> (value &amp; elf.DF_1_NOW != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; NOW&quot;</span>);</span>
<span class="line" id="L2058">                        <span class="tok-kw">if</span> (value &amp; elf.DF_1_GLOBAL != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; GLOBAL&quot;</span>);</span>
<span class="line" id="L2059">                        <span class="tok-kw">if</span> (value &amp; elf.DF_1_GROUP != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; GROUP&quot;</span>);</span>
<span class="line" id="L2060">                        <span class="tok-kw">if</span> (value &amp; elf.DF_1_NODELETE != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; NODELETE&quot;</span>);</span>
<span class="line" id="L2061">                        <span class="tok-kw">if</span> (value &amp; elf.DF_1_LOADFLTR != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; LOADFLTR&quot;</span>);</span>
<span class="line" id="L2062">                        <span class="tok-kw">if</span> (value &amp; elf.DF_1_INITFIRST != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; INITFIRST&quot;</span>);</span>
<span class="line" id="L2063">                        <span class="tok-kw">if</span> (value &amp; elf.DF_1_NOOPEN != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; NOOPEN&quot;</span>);</span>
<span class="line" id="L2064">                        <span class="tok-kw">if</span> (value &amp; elf.DF_1_ORIGIN != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; ORIGIN&quot;</span>);</span>
<span class="line" id="L2065">                        <span class="tok-kw">if</span> (value &amp; elf.DF_1_DIRECT != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; DIRECT&quot;</span>);</span>
<span class="line" id="L2066">                        <span class="tok-kw">if</span> (value &amp; elf.DF_1_TRANS != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; TRANS&quot;</span>);</span>
<span class="line" id="L2067">                        <span class="tok-kw">if</span> (value &amp; elf.DF_1_INTERPOSE != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; INTERPOSE&quot;</span>);</span>
<span class="line" id="L2068">                        <span class="tok-kw">if</span> (value &amp; elf.DF_1_NODEFLIB != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; NODEFLIB&quot;</span>);</span>
<span class="line" id="L2069">                        <span class="tok-kw">if</span> (value &amp; elf.DF_1_NODUMP != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; NODUMP&quot;</span>);</span>
<span class="line" id="L2070">                        <span class="tok-kw">if</span> (value &amp; elf.DF_1_CONFALT != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; CONFALT&quot;</span>);</span>
<span class="line" id="L2071">                        <span class="tok-kw">if</span> (value &amp; elf.DF_1_ENDFILTEE != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; ENDFILTEE&quot;</span>);</span>
<span class="line" id="L2072">                        <span class="tok-kw">if</span> (value &amp; elf.DF_1_DISPRELDNE != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; DISPRELDNE&quot;</span>);</span>
<span class="line" id="L2073">                        <span class="tok-kw">if</span> (value &amp; elf.DF_1_DISPRELPND != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; DISPRELPND&quot;</span>);</span>
<span class="line" id="L2074">                        <span class="tok-kw">if</span> (value &amp; elf.DF_1_NODIRECT != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; NODIRECT&quot;</span>);</span>
<span class="line" id="L2075">                        <span class="tok-kw">if</span> (value &amp; elf.DF_1_IGNMULDEF != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; IGNMULDEF&quot;</span>);</span>
<span class="line" id="L2076">                        <span class="tok-kw">if</span> (value &amp; elf.DF_1_NOKSYMS != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; NOKSYMS&quot;</span>);</span>
<span class="line" id="L2077">                        <span class="tok-kw">if</span> (value &amp; elf.DF_1_NOHDR != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; NOHDR&quot;</span>);</span>
<span class="line" id="L2078">                        <span class="tok-kw">if</span> (value &amp; elf.DF_1_EDITED != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; EDITED&quot;</span>);</span>
<span class="line" id="L2079">                        <span class="tok-kw">if</span> (value &amp; elf.DF_1_NORELOC != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; NORELOC&quot;</span>);</span>
<span class="line" id="L2080">                        <span class="tok-kw">if</span> (value &amp; elf.DF_1_SYMINTPOSE != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; SYMINTPOSE&quot;</span>);</span>
<span class="line" id="L2081">                        <span class="tok-kw">if</span> (value &amp; elf.DF_1_GLOBAUDIT != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; GLOBAUDIT&quot;</span>);</span>
<span class="line" id="L2082">                        <span class="tok-kw">if</span> (value &amp; elf.DF_1_SINGLETON != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; SINGLETON&quot;</span>);</span>
<span class="line" id="L2083">                        <span class="tok-kw">if</span> (value &amp; elf.DF_1_STUB != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; STUB&quot;</span>);</span>
<span class="line" id="L2084">                        <span class="tok-kw">if</span> (value &amp; elf.DF_1_PIE != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; PIE&quot;</span>);</span>
<span class="line" id="L2085">                    },</span>
<span class="line" id="L2086"></span>
<span class="line" id="L2087">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {x}&quot;</span>, .{value}),</span>
<span class="line" id="L2088">                }</span>
<span class="line" id="L2089">                <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);</span>
<span class="line" id="L2090">            }</span>
<span class="line" id="L2091">        }</span>
<span class="line" id="L2092"></span>
<span class="line" id="L2093">        <span class="tok-kw">fn</span> <span class="tok-fn">dumpSymtab</span>(ctx: ObjectContext, <span class="tok-kw">comptime</span> @&quot;type&quot;: <span class="tok-kw">enum</span> { symtab, dysymtab }, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2094">            <span class="tok-kw">const</span> symtab = <span class="tok-kw">switch</span> (@&quot;type&quot;) {</span>
<span class="line" id="L2095">                .symtab =&gt; ctx.symtab,</span>
<span class="line" id="L2096">                .dysymtab =&gt; ctx.dysymtab,</span>
<span class="line" id="L2097">            };</span>
<span class="line" id="L2098"></span>
<span class="line" id="L2099">            <span class="tok-kw">try</span> writer.writeAll(<span class="tok-kw">switch</span> (@&quot;type&quot;) {</span>
<span class="line" id="L2100">                .symtab =&gt; symtab_label,</span>
<span class="line" id="L2101">                .dysymtab =&gt; dynamic_symtab_label,</span>
<span class="line" id="L2102">            } ++ <span class="tok-str">&quot;\n&quot;</span>);</span>
<span class="line" id="L2103"></span>
<span class="line" id="L2104">            <span class="tok-kw">for</span> (symtab.symbols, <span class="tok-number">0</span>..) |sym, index| {</span>
<span class="line" id="L2105">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{x} {x}&quot;</span>, .{ sym.st_value, sym.st_size });</span>
<span class="line" id="L2106"></span>
<span class="line" id="L2107">                {</span>
<span class="line" id="L2108">                    <span class="tok-kw">if</span> (elf.SHN_LORESERVE &lt;= sym.st_shndx <span class="tok-kw">and</span> sym.st_shndx &lt; elf.SHN_HIRESERVE) {</span>
<span class="line" id="L2109">                        <span class="tok-kw">if</span> (elf.SHN_LOPROC &lt;= sym.st_shndx <span class="tok-kw">and</span> sym.st_shndx &lt; elf.SHN_HIPROC) {</span>
<span class="line" id="L2110">                            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; LO+{d}&quot;</span>, .{sym.st_shndx - elf.SHN_LOPROC});</span>
<span class="line" id="L2111">                        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2112">                            <span class="tok-kw">const</span> sym_ndx = <span class="tok-kw">switch</span> (sym.st_shndx) {</span>
<span class="line" id="L2113">                                elf.SHN_ABS =&gt; <span class="tok-str">&quot;ABS&quot;</span>,</span>
<span class="line" id="L2114">                                elf.SHN_COMMON =&gt; <span class="tok-str">&quot;COM&quot;</span>,</span>
<span class="line" id="L2115">                                elf.SHN_LIVEPATCH =&gt; <span class="tok-str">&quot;LIV&quot;</span>,</span>
<span class="line" id="L2116">                                <span class="tok-kw">else</span> =&gt; <span class="tok-str">&quot;UNK&quot;</span>,</span>
<span class="line" id="L2117">                            };</span>
<span class="line" id="L2118">                            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {s}&quot;</span>, .{sym_ndx});</span>
<span class="line" id="L2119">                        }</span>
<span class="line" id="L2120">                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (sym.st_shndx == elf.SHN_UNDEF) {</span>
<span class="line" id="L2121">                        <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; UND&quot;</span>);</span>
<span class="line" id="L2122">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2123">                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {x}&quot;</span>, .{sym.st_shndx});</span>
<span class="line" id="L2124">                    }</span>
<span class="line" id="L2125">                }</span>
<span class="line" id="L2126"></span>
<span class="line" id="L2127">                blk: {</span>
<span class="line" id="L2128">                    <span class="tok-kw">const</span> tt = sym.st_type();</span>
<span class="line" id="L2129">                    <span class="tok-kw">const</span> sym_type = <span class="tok-kw">switch</span> (tt) {</span>
<span class="line" id="L2130">                        elf.STT_NOTYPE =&gt; <span class="tok-str">&quot;NOTYPE&quot;</span>,</span>
<span class="line" id="L2131">                        elf.STT_OBJECT =&gt; <span class="tok-str">&quot;OBJECT&quot;</span>,</span>
<span class="line" id="L2132">                        elf.STT_FUNC =&gt; <span class="tok-str">&quot;FUNC&quot;</span>,</span>
<span class="line" id="L2133">                        elf.STT_SECTION =&gt; <span class="tok-str">&quot;SECTION&quot;</span>,</span>
<span class="line" id="L2134">                        elf.STT_FILE =&gt; <span class="tok-str">&quot;FILE&quot;</span>,</span>
<span class="line" id="L2135">                        elf.STT_COMMON =&gt; <span class="tok-str">&quot;COMMON&quot;</span>,</span>
<span class="line" id="L2136">                        elf.STT_TLS =&gt; <span class="tok-str">&quot;TLS&quot;</span>,</span>
<span class="line" id="L2137">                        elf.STT_NUM =&gt; <span class="tok-str">&quot;NUM&quot;</span>,</span>
<span class="line" id="L2138">                        elf.STT_GNU_IFUNC =&gt; <span class="tok-str">&quot;IFUNC&quot;</span>,</span>
<span class="line" id="L2139">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">if</span> (elf.STT_LOPROC &lt;= tt <span class="tok-kw">and</span> tt &lt; elf.STT_HIPROC) {</span>
<span class="line" id="L2140">                            <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; LOPROC+{d}&quot;</span>, .{tt - elf.STT_LOPROC});</span>
<span class="line" id="L2141">                        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (elf.STT_LOOS &lt;= tt <span class="tok-kw">and</span> tt &lt; elf.STT_HIOS) {</span>
<span class="line" id="L2142">                            <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; LOOS+{d}&quot;</span>, .{tt - elf.STT_LOOS});</span>
<span class="line" id="L2143">                        } <span class="tok-kw">else</span> <span class="tok-str">&quot;UNK&quot;</span>,</span>
<span class="line" id="L2144">                    };</span>
<span class="line" id="L2145">                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {s}&quot;</span>, .{sym_type});</span>
<span class="line" id="L2146">                }</span>
<span class="line" id="L2147"></span>
<span class="line" id="L2148">                blk: {</span>
<span class="line" id="L2149">                    <span class="tok-kw">const</span> bind = sym.st_bind();</span>
<span class="line" id="L2150">                    <span class="tok-kw">const</span> sym_bind = <span class="tok-kw">switch</span> (bind) {</span>
<span class="line" id="L2151">                        elf.STB_LOCAL =&gt; <span class="tok-str">&quot;LOCAL&quot;</span>,</span>
<span class="line" id="L2152">                        elf.STB_GLOBAL =&gt; <span class="tok-str">&quot;GLOBAL&quot;</span>,</span>
<span class="line" id="L2153">                        elf.STB_WEAK =&gt; <span class="tok-str">&quot;WEAK&quot;</span>,</span>
<span class="line" id="L2154">                        elf.STB_NUM =&gt; <span class="tok-str">&quot;NUM&quot;</span>,</span>
<span class="line" id="L2155">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">if</span> (elf.STB_LOPROC &lt;= bind <span class="tok-kw">and</span> bind &lt; elf.STB_HIPROC) {</span>
<span class="line" id="L2156">                            <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; LOPROC+{d}&quot;</span>, .{bind - elf.STB_LOPROC});</span>
<span class="line" id="L2157">                        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (elf.STB_LOOS &lt;= bind <span class="tok-kw">and</span> bind &lt; elf.STB_HIOS) {</span>
<span class="line" id="L2158">                            <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; LOOS+{d}&quot;</span>, .{bind - elf.STB_LOOS});</span>
<span class="line" id="L2159">                        } <span class="tok-kw">else</span> <span class="tok-str">&quot;UNKNOWN&quot;</span>,</span>
<span class="line" id="L2160">                    };</span>
<span class="line" id="L2161">                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {s}&quot;</span>, .{sym_bind});</span>
<span class="line" id="L2162">                }</span>
<span class="line" id="L2163"></span>
<span class="line" id="L2164">                <span class="tok-kw">const</span> sym_vis = <span class="tok-builtin">@as</span>(elf.STV, <span class="tok-builtin">@enumFromInt</span>(sym.st_other));</span>
<span class="line" id="L2165">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {s}&quot;</span>, .{<span class="tok-builtin">@tagName</span>(sym_vis)});</span>
<span class="line" id="L2166"></span>
<span class="line" id="L2167">                <span class="tok-kw">const</span> sym_name = <span class="tok-kw">switch</span> (sym.st_type()) {</span>
<span class="line" id="L2168">                    elf.STT_SECTION =&gt; ctx.getSectionName(sym.st_shndx),</span>
<span class="line" id="L2169">                    <span class="tok-kw">else</span> =&gt; symtab.getName(index).?,</span>
<span class="line" id="L2170">                };</span>
<span class="line" id="L2171">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {s}\n&quot;</span>, .{sym_name});</span>
<span class="line" id="L2172">            }</span>
<span class="line" id="L2173">        }</span>
<span class="line" id="L2174"></span>
<span class="line" id="L2175">        <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSectionName</span>(ctx: ObjectContext, shndx: <span class="tok-type">usize</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L2176">            <span class="tok-kw">const</span> shdr = ctx.shdrs[shndx];</span>
<span class="line" id="L2177">            <span class="tok-kw">return</span> getString(ctx.shstrtab, shdr.sh_name);</span>
<span class="line" id="L2178">        }</span>
<span class="line" id="L2179"></span>
<span class="line" id="L2180">        <span class="tok-kw">fn</span> <span class="tok-fn">getSectionContents</span>(ctx: ObjectContext, shndx: <span class="tok-type">usize</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L2181">            <span class="tok-kw">const</span> shdr = ctx.shdrs[shndx];</span>
<span class="line" id="L2182">            assert(shdr.sh_offset &lt; ctx.data.len);</span>
<span class="line" id="L2183">            assert(shdr.sh_offset + shdr.sh_size &lt;= ctx.data.len);</span>
<span class="line" id="L2184">            <span class="tok-kw">return</span> ctx.data[shdr.sh_offset..][<span class="tok-number">0</span>..shdr.sh_size];</span>
<span class="line" id="L2185">        }</span>
<span class="line" id="L2186"></span>
<span class="line" id="L2187">        <span class="tok-kw">fn</span> <span class="tok-fn">getSectionByName</span>(ctx: ObjectContext, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?<span class="tok-type">usize</span> {</span>
<span class="line" id="L2188">            <span class="tok-kw">for</span> (<span class="tok-number">0</span>..ctx.shdrs.len) |shndx| {</span>
<span class="line" id="L2189">                <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, ctx.getSectionName(shndx), name)) <span class="tok-kw">return</span> shndx;</span>
<span class="line" id="L2190">            } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2191">        }</span>
<span class="line" id="L2192">    };</span>
<span class="line" id="L2193"></span>
<span class="line" id="L2194">    <span class="tok-kw">const</span> Symtab = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2195">        symbols: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> elf.Elf64_Sym = &amp;[<span class="tok-number">0</span>]elf.Elf64_Sym{},</span>
<span class="line" id="L2196">        strings: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;[<span class="tok-number">0</span>]<span class="tok-type">u8</span>{},</span>
<span class="line" id="L2197"></span>
<span class="line" id="L2198">        <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(st: Symtab, index: <span class="tok-type">usize</span>) ?elf.Elf64_Sym {</span>
<span class="line" id="L2199">            <span class="tok-kw">if</span> (index &gt;= st.symbols.len) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2200">            <span class="tok-kw">return</span> st.symbols[index];</span>
<span class="line" id="L2201">        }</span>
<span class="line" id="L2202"></span>
<span class="line" id="L2203">        <span class="tok-kw">fn</span> <span class="tok-fn">getName</span>(st: Symtab, index: <span class="tok-type">usize</span>) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L2204">            <span class="tok-kw">const</span> sym = st.get(index) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2205">            <span class="tok-kw">return</span> getString(st.strings, sym.st_name);</span>
<span class="line" id="L2206">        }</span>
<span class="line" id="L2207">    };</span>
<span class="line" id="L2208"></span>
<span class="line" id="L2209">    <span class="tok-kw">fn</span> <span class="tok-fn">getString</span>(strtab: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, off: <span class="tok-type">u32</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L2210">        assert(off &lt; strtab.len);</span>
<span class="line" id="L2211">        <span class="tok-kw">return</span> mem.sliceTo(<span class="tok-builtin">@as</span>([*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(strtab.ptr + off)), <span class="tok-number">0</span>);</span>
<span class="line" id="L2212">    }</span>
<span class="line" id="L2213"></span>
<span class="line" id="L2214">    <span class="tok-kw">fn</span> <span class="tok-fn">fmtShType</span>(sh_type: <span class="tok-type">u32</span>) std.fmt.Formatter(formatShType) {</span>
<span class="line" id="L2215">        <span class="tok-kw">return</span> .{ .data = sh_type };</span>
<span class="line" id="L2216">    }</span>
<span class="line" id="L2217"></span>
<span class="line" id="L2218">    <span class="tok-kw">fn</span> <span class="tok-fn">formatShType</span>(</span>
<span class="line" id="L2219">        sh_type: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2220">        <span class="tok-kw">comptime</span> unused_fmt_string: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2221">        options: std.fmt.FormatOptions,</span>
<span class="line" id="L2222">        writer: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L2223">    ) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2224">        _ = unused_fmt_string;</span>
<span class="line" id="L2225">        _ = options;</span>
<span class="line" id="L2226">        <span class="tok-kw">const</span> name = <span class="tok-kw">switch</span> (sh_type) {</span>
<span class="line" id="L2227">            elf.SHT_NULL =&gt; <span class="tok-str">&quot;NULL&quot;</span>,</span>
<span class="line" id="L2228">            elf.SHT_PROGBITS =&gt; <span class="tok-str">&quot;PROGBITS&quot;</span>,</span>
<span class="line" id="L2229">            elf.SHT_SYMTAB =&gt; <span class="tok-str">&quot;SYMTAB&quot;</span>,</span>
<span class="line" id="L2230">            elf.SHT_STRTAB =&gt; <span class="tok-str">&quot;STRTAB&quot;</span>,</span>
<span class="line" id="L2231">            elf.SHT_RELA =&gt; <span class="tok-str">&quot;RELA&quot;</span>,</span>
<span class="line" id="L2232">            elf.SHT_HASH =&gt; <span class="tok-str">&quot;HASH&quot;</span>,</span>
<span class="line" id="L2233">            elf.SHT_DYNAMIC =&gt; <span class="tok-str">&quot;DYNAMIC&quot;</span>,</span>
<span class="line" id="L2234">            elf.SHT_NOTE =&gt; <span class="tok-str">&quot;NOTE&quot;</span>,</span>
<span class="line" id="L2235">            elf.SHT_NOBITS =&gt; <span class="tok-str">&quot;NOBITS&quot;</span>,</span>
<span class="line" id="L2236">            elf.SHT_REL =&gt; <span class="tok-str">&quot;REL&quot;</span>,</span>
<span class="line" id="L2237">            elf.SHT_SHLIB =&gt; <span class="tok-str">&quot;SHLIB&quot;</span>,</span>
<span class="line" id="L2238">            elf.SHT_DYNSYM =&gt; <span class="tok-str">&quot;DYNSYM&quot;</span>,</span>
<span class="line" id="L2239">            elf.SHT_INIT_ARRAY =&gt; <span class="tok-str">&quot;INIT_ARRAY&quot;</span>,</span>
<span class="line" id="L2240">            elf.SHT_FINI_ARRAY =&gt; <span class="tok-str">&quot;FINI_ARRAY&quot;</span>,</span>
<span class="line" id="L2241">            elf.SHT_PREINIT_ARRAY =&gt; <span class="tok-str">&quot;PREINIT_ARRAY&quot;</span>,</span>
<span class="line" id="L2242">            elf.SHT_GROUP =&gt; <span class="tok-str">&quot;GROUP&quot;</span>,</span>
<span class="line" id="L2243">            elf.SHT_SYMTAB_SHNDX =&gt; <span class="tok-str">&quot;SYMTAB_SHNDX&quot;</span>,</span>
<span class="line" id="L2244">            elf.SHT_X86_64_UNWIND =&gt; <span class="tok-str">&quot;X86_64_UNWIND&quot;</span>,</span>
<span class="line" id="L2245">            elf.SHT_LLVM_ADDRSIG =&gt; <span class="tok-str">&quot;LLVM_ADDRSIG&quot;</span>,</span>
<span class="line" id="L2246">            elf.SHT_GNU_HASH =&gt; <span class="tok-str">&quot;GNU_HASH&quot;</span>,</span>
<span class="line" id="L2247">            elf.SHT_GNU_VERDEF =&gt; <span class="tok-str">&quot;VERDEF&quot;</span>,</span>
<span class="line" id="L2248">            elf.SHT_GNU_VERNEED =&gt; <span class="tok-str">&quot;VERNEED&quot;</span>,</span>
<span class="line" id="L2249">            elf.SHT_GNU_VERSYM =&gt; <span class="tok-str">&quot;VERSYM&quot;</span>,</span>
<span class="line" id="L2250">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">if</span> (elf.SHT_LOOS &lt;= sh_type <span class="tok-kw">and</span> sh_type &lt; elf.SHT_HIOS) {</span>
<span class="line" id="L2251">                <span class="tok-kw">return</span> <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;LOOS+0x{x}&quot;</span>, .{sh_type - elf.SHT_LOOS});</span>
<span class="line" id="L2252">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (elf.SHT_LOPROC &lt;= sh_type <span class="tok-kw">and</span> sh_type &lt; elf.SHT_HIPROC) {</span>
<span class="line" id="L2253">                <span class="tok-kw">return</span> <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;LOPROC+0x{x}&quot;</span>, .{sh_type - elf.SHT_LOPROC});</span>
<span class="line" id="L2254">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (elf.SHT_LOUSER &lt;= sh_type <span class="tok-kw">and</span> sh_type &lt; elf.SHT_HIUSER) {</span>
<span class="line" id="L2255">                <span class="tok-kw">return</span> <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;LOUSER+0x{x}&quot;</span>, .{sh_type - elf.SHT_LOUSER});</span>
<span class="line" id="L2256">            } <span class="tok-kw">else</span> <span class="tok-str">&quot;UNKNOWN&quot;</span>,</span>
<span class="line" id="L2257">        };</span>
<span class="line" id="L2258">        <span class="tok-kw">try</span> writer.writeAll(name);</span>
<span class="line" id="L2259">    }</span>
<span class="line" id="L2260"></span>
<span class="line" id="L2261">    <span class="tok-kw">fn</span> <span class="tok-fn">fmtPhType</span>(ph_type: <span class="tok-type">u32</span>) std.fmt.Formatter(formatPhType) {</span>
<span class="line" id="L2262">        <span class="tok-kw">return</span> .{ .data = ph_type };</span>
<span class="line" id="L2263">    }</span>
<span class="line" id="L2264"></span>
<span class="line" id="L2265">    <span class="tok-kw">fn</span> <span class="tok-fn">formatPhType</span>(</span>
<span class="line" id="L2266">        ph_type: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2267">        <span class="tok-kw">comptime</span> unused_fmt_string: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2268">        options: std.fmt.FormatOptions,</span>
<span class="line" id="L2269">        writer: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L2270">    ) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2271">        _ = unused_fmt_string;</span>
<span class="line" id="L2272">        _ = options;</span>
<span class="line" id="L2273">        <span class="tok-kw">const</span> p_type = <span class="tok-kw">switch</span> (ph_type) {</span>
<span class="line" id="L2274">            elf.PT_NULL =&gt; <span class="tok-str">&quot;NULL&quot;</span>,</span>
<span class="line" id="L2275">            elf.PT_LOAD =&gt; <span class="tok-str">&quot;LOAD&quot;</span>,</span>
<span class="line" id="L2276">            elf.PT_DYNAMIC =&gt; <span class="tok-str">&quot;DYNAMIC&quot;</span>,</span>
<span class="line" id="L2277">            elf.PT_INTERP =&gt; <span class="tok-str">&quot;INTERP&quot;</span>,</span>
<span class="line" id="L2278">            elf.PT_NOTE =&gt; <span class="tok-str">&quot;NOTE&quot;</span>,</span>
<span class="line" id="L2279">            elf.PT_SHLIB =&gt; <span class="tok-str">&quot;SHLIB&quot;</span>,</span>
<span class="line" id="L2280">            elf.PT_PHDR =&gt; <span class="tok-str">&quot;PHDR&quot;</span>,</span>
<span class="line" id="L2281">            elf.PT_TLS =&gt; <span class="tok-str">&quot;TLS&quot;</span>,</span>
<span class="line" id="L2282">            elf.PT_NUM =&gt; <span class="tok-str">&quot;NUM&quot;</span>,</span>
<span class="line" id="L2283">            elf.PT_GNU_EH_FRAME =&gt; <span class="tok-str">&quot;GNU_EH_FRAME&quot;</span>,</span>
<span class="line" id="L2284">            elf.PT_GNU_STACK =&gt; <span class="tok-str">&quot;GNU_STACK&quot;</span>,</span>
<span class="line" id="L2285">            elf.PT_GNU_RELRO =&gt; <span class="tok-str">&quot;GNU_RELRO&quot;</span>,</span>
<span class="line" id="L2286">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">if</span> (elf.PT_LOOS &lt;= ph_type <span class="tok-kw">and</span> ph_type &lt; elf.PT_HIOS) {</span>
<span class="line" id="L2287">                <span class="tok-kw">return</span> <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;LOOS+0x{x}&quot;</span>, .{ph_type - elf.PT_LOOS});</span>
<span class="line" id="L2288">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (elf.PT_LOPROC &lt;= ph_type <span class="tok-kw">and</span> ph_type &lt; elf.PT_HIPROC) {</span>
<span class="line" id="L2289">                <span class="tok-kw">return</span> <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;LOPROC+0x{x}&quot;</span>, .{ph_type - elf.PT_LOPROC});</span>
<span class="line" id="L2290">            } <span class="tok-kw">else</span> <span class="tok-str">&quot;UNKNOWN&quot;</span>,</span>
<span class="line" id="L2291">        };</span>
<span class="line" id="L2292">        <span class="tok-kw">try</span> writer.writeAll(p_type);</span>
<span class="line" id="L2293">    }</span>
<span class="line" id="L2294">};</span>
<span class="line" id="L2295"></span>
<span class="line" id="L2296"><span class="tok-kw">const</span> WasmDumper = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2297">    <span class="tok-kw">const</span> symtab_label = <span class="tok-str">&quot;symbols&quot;</span>;</span>
<span class="line" id="L2298"></span>
<span class="line" id="L2299">    <span class="tok-kw">fn</span> <span class="tok-fn">parseAndDump</span>(step: *Step, kind: Check.Kind, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L2300">        <span class="tok-kw">const</span> gpa = step.owner.allocator;</span>
<span class="line" id="L2301">        <span class="tok-kw">var</span> fbs = std.io.fixedBufferStream(bytes);</span>
<span class="line" id="L2302">        <span class="tok-kw">const</span> reader = fbs.reader();</span>
<span class="line" id="L2303"></span>
<span class="line" id="L2304">        <span class="tok-kw">const</span> buf = <span class="tok-kw">try</span> reader.readBytesNoEof(<span class="tok-number">8</span>);</span>
<span class="line" id="L2305">        <span class="tok-kw">if</span> (!mem.eql(<span class="tok-type">u8</span>, buf[<span class="tok-number">0</span>..<span class="tok-number">4</span>], &amp;std.wasm.magic)) {</span>
<span class="line" id="L2306">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidMagicByte;</span>
<span class="line" id="L2307">        }</span>
<span class="line" id="L2308">        <span class="tok-kw">if</span> (!mem.eql(<span class="tok-type">u8</span>, buf[<span class="tok-number">4</span>..], &amp;std.wasm.version)) {</span>
<span class="line" id="L2309">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedWasmVersion;</span>
<span class="line" id="L2310">        }</span>
<span class="line" id="L2311"></span>
<span class="line" id="L2312">        <span class="tok-kw">var</span> output = std.ArrayList(<span class="tok-type">u8</span>).init(gpa);</span>
<span class="line" id="L2313">        <span class="tok-kw">errdefer</span> output.deinit();</span>
<span class="line" id="L2314">        <span class="tok-kw">const</span> writer = output.writer();</span>
<span class="line" id="L2315"></span>
<span class="line" id="L2316">        <span class="tok-kw">switch</span> (kind) {</span>
<span class="line" id="L2317">            .headers =&gt; {</span>
<span class="line" id="L2318">                <span class="tok-kw">while</span> (reader.readByte()) |current_byte| {</span>
<span class="line" id="L2319">                    <span class="tok-kw">const</span> section = std.meta.intToEnum(std.wasm.Section, current_byte) <span class="tok-kw">catch</span> {</span>
<span class="line" id="L2320">                        <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;Found invalid section id '{d}'&quot;</span>, .{current_byte});</span>
<span class="line" id="L2321">                    };</span>
<span class="line" id="L2322"></span>
<span class="line" id="L2323">                    <span class="tok-kw">const</span> section_length = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u32</span>, reader);</span>
<span class="line" id="L2324">                    <span class="tok-kw">try</span> parseAndDumpSection(step, section, bytes[fbs.pos..][<span class="tok-number">0</span>..section_length], writer);</span>
<span class="line" id="L2325">                    fbs.pos += section_length;</span>
<span class="line" id="L2326">                } <span class="tok-kw">else</span> |_| {} <span class="tok-comment">// reached end of stream</span>
</span>
<span class="line" id="L2327">            },</span>
<span class="line" id="L2328"></span>
<span class="line" id="L2329">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;invalid check kind for Wasm file format: {s}&quot;</span>, .{<span class="tok-builtin">@tagName</span>(kind)}),</span>
<span class="line" id="L2330">        }</span>
<span class="line" id="L2331"></span>
<span class="line" id="L2332">        <span class="tok-kw">return</span> output.toOwnedSlice();</span>
<span class="line" id="L2333">    }</span>
<span class="line" id="L2334"></span>
<span class="line" id="L2335">    <span class="tok-kw">fn</span> <span class="tok-fn">parseAndDumpSection</span>(</span>
<span class="line" id="L2336">        step: *Step,</span>
<span class="line" id="L2337">        section: std.wasm.Section,</span>
<span class="line" id="L2338">        data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2339">        writer: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L2340">    ) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2341">        <span class="tok-kw">var</span> fbs = std.io.fixedBufferStream(data);</span>
<span class="line" id="L2342">        <span class="tok-kw">const</span> reader = fbs.reader();</span>
<span class="line" id="L2343"></span>
<span class="line" id="L2344">        <span class="tok-kw">try</span> writer.print(</span>
<span class="line" id="L2345">            <span class="tok-str">\\Section {s}</span></span>

<span class="line" id="L2346">            <span class="tok-str">\\size {d}</span></span>

<span class="line" id="L2347">        , .{ <span class="tok-builtin">@tagName</span>(section), data.len });</span>
<span class="line" id="L2348"></span>
<span class="line" id="L2349">        <span class="tok-kw">switch</span> (section) {</span>
<span class="line" id="L2350">            .<span class="tok-type">type</span>,</span>
<span class="line" id="L2351">            .import,</span>
<span class="line" id="L2352">            .function,</span>
<span class="line" id="L2353">            .table,</span>
<span class="line" id="L2354">            .memory,</span>
<span class="line" id="L2355">            .global,</span>
<span class="line" id="L2356">            .@&quot;export&quot;,</span>
<span class="line" id="L2357">            .element,</span>
<span class="line" id="L2358">            .code,</span>
<span class="line" id="L2359">            .data,</span>
<span class="line" id="L2360">            =&gt; {</span>
<span class="line" id="L2361">                <span class="tok-kw">const</span> entries = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u32</span>, reader);</span>
<span class="line" id="L2362">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;\nentries {d}\n&quot;</span>, .{entries});</span>
<span class="line" id="L2363">                <span class="tok-kw">try</span> dumpSection(step, section, data[fbs.pos..], entries, writer);</span>
<span class="line" id="L2364">            },</span>
<span class="line" id="L2365">            .custom =&gt; {</span>
<span class="line" id="L2366">                <span class="tok-kw">const</span> name_length = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u32</span>, reader);</span>
<span class="line" id="L2367">                <span class="tok-kw">const</span> name = data[fbs.pos..][<span class="tok-number">0</span>..name_length];</span>
<span class="line" id="L2368">                fbs.pos += name_length;</span>
<span class="line" id="L2369">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;\nname {s}\n&quot;</span>, .{name});</span>
<span class="line" id="L2370"></span>
<span class="line" id="L2371">                <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;name&quot;</span>)) {</span>
<span class="line" id="L2372">                    <span class="tok-kw">try</span> parseDumpNames(step, reader, writer, data);</span>
<span class="line" id="L2373">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;producers&quot;</span>)) {</span>
<span class="line" id="L2374">                    <span class="tok-kw">try</span> parseDumpProducers(reader, writer, data);</span>
<span class="line" id="L2375">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;target_features&quot;</span>)) {</span>
<span class="line" id="L2376">                    <span class="tok-kw">try</span> parseDumpFeatures(reader, writer, data);</span>
<span class="line" id="L2377">                }</span>
<span class="line" id="L2378">                <span class="tok-comment">// TODO: Implement parsing and dumping other custom sections (such as relocations)</span>
</span>
<span class="line" id="L2379">            },</span>
<span class="line" id="L2380">            .start =&gt; {</span>
<span class="line" id="L2381">                <span class="tok-kw">const</span> start = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u32</span>, reader);</span>
<span class="line" id="L2382">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;\nstart {d}\n&quot;</span>, .{start});</span>
<span class="line" id="L2383">            },</span>
<span class="line" id="L2384">            .data_count =&gt; {</span>
<span class="line" id="L2385">                <span class="tok-kw">const</span> count = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u32</span>, reader);</span>
<span class="line" id="L2386">                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;\ncount {d}\n&quot;</span>, .{count});</span>
<span class="line" id="L2387">            },</span>
<span class="line" id="L2388">            <span class="tok-kw">else</span> =&gt; {}, <span class="tok-comment">// skip unknown sections</span>
</span>
<span class="line" id="L2389">        }</span>
<span class="line" id="L2390">    }</span>
<span class="line" id="L2391"></span>
<span class="line" id="L2392">    <span class="tok-kw">fn</span> <span class="tok-fn">dumpSection</span>(step: *Step, section: std.wasm.Section, data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, entries: <span class="tok-type">u32</span>, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2393">        <span class="tok-kw">var</span> fbs = std.io.fixedBufferStream(data);</span>
<span class="line" id="L2394">        <span class="tok-kw">const</span> reader = fbs.reader();</span>
<span class="line" id="L2395"></span>
<span class="line" id="L2396">        <span class="tok-kw">switch</span> (section) {</span>
<span class="line" id="L2397">            .<span class="tok-type">type</span> =&gt; {</span>
<span class="line" id="L2398">                <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2399">                <span class="tok-kw">while</span> (i &lt; entries) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L2400">                    <span class="tok-kw">const</span> func_type = <span class="tok-kw">try</span> reader.readByte();</span>
<span class="line" id="L2401">                    <span class="tok-kw">if</span> (func_type != std.wasm.function_type) {</span>
<span class="line" id="L2402">                        <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;expected function type, found byte '{d}'&quot;</span>, .{func_type});</span>
<span class="line" id="L2403">                    }</span>
<span class="line" id="L2404">                    <span class="tok-kw">const</span> params = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u32</span>, reader);</span>
<span class="line" id="L2405">                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;params {d}\n&quot;</span>, .{params});</span>
<span class="line" id="L2406">                    <span class="tok-kw">var</span> index: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2407">                    <span class="tok-kw">while</span> (index &lt; params) : (index += <span class="tok-number">1</span>) {</span>
<span class="line" id="L2408">                        <span class="tok-kw">try</span> parseDumpType(step, std.wasm.Valtype, reader, writer);</span>
<span class="line" id="L2409">                    } <span class="tok-kw">else</span> index = <span class="tok-number">0</span>;</span>
<span class="line" id="L2410">                    <span class="tok-kw">const</span> returns = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u32</span>, reader);</span>
<span class="line" id="L2411">                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;returns {d}\n&quot;</span>, .{returns});</span>
<span class="line" id="L2412">                    <span class="tok-kw">while</span> (index &lt; returns) : (index += <span class="tok-number">1</span>) {</span>
<span class="line" id="L2413">                        <span class="tok-kw">try</span> parseDumpType(step, std.wasm.Valtype, reader, writer);</span>
<span class="line" id="L2414">                    }</span>
<span class="line" id="L2415">                }</span>
<span class="line" id="L2416">            },</span>
<span class="line" id="L2417">            .import =&gt; {</span>
<span class="line" id="L2418">                <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2419">                <span class="tok-kw">while</span> (i &lt; entries) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L2420">                    <span class="tok-kw">const</span> module_name_len = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u32</span>, reader);</span>
<span class="line" id="L2421">                    <span class="tok-kw">const</span> module_name = data[fbs.pos..][<span class="tok-number">0</span>..module_name_len];</span>
<span class="line" id="L2422">                    fbs.pos += module_name_len;</span>
<span class="line" id="L2423">                    <span class="tok-kw">const</span> name_len = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u32</span>, reader);</span>
<span class="line" id="L2424">                    <span class="tok-kw">const</span> name = data[fbs.pos..][<span class="tok-number">0</span>..name_len];</span>
<span class="line" id="L2425">                    fbs.pos += name_len;</span>
<span class="line" id="L2426"></span>
<span class="line" id="L2427">                    <span class="tok-kw">const</span> kind = std.meta.intToEnum(std.wasm.ExternalKind, <span class="tok-kw">try</span> reader.readByte()) <span class="tok-kw">catch</span> {</span>
<span class="line" id="L2428">                        <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;invalid import kind&quot;</span>, .{});</span>
<span class="line" id="L2429">                    };</span>
<span class="line" id="L2430"></span>
<span class="line" id="L2431">                    <span class="tok-kw">try</span> writer.print(</span>
<span class="line" id="L2432">                        <span class="tok-str">\\module {s}</span></span>

<span class="line" id="L2433">                        <span class="tok-str">\\name {s}</span></span>

<span class="line" id="L2434">                        <span class="tok-str">\\kind {s}</span></span>

<span class="line" id="L2435">                    , .{ module_name, name, <span class="tok-builtin">@tagName</span>(kind) });</span>
<span class="line" id="L2436">                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);</span>
<span class="line" id="L2437">                    <span class="tok-kw">switch</span> (kind) {</span>
<span class="line" id="L2438">                        .function =&gt; {</span>
<span class="line" id="L2439">                            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;index {d}\n&quot;</span>, .{<span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u32</span>, reader)});</span>
<span class="line" id="L2440">                        },</span>
<span class="line" id="L2441">                        .memory =&gt; {</span>
<span class="line" id="L2442">                            <span class="tok-kw">try</span> parseDumpLimits(reader, writer);</span>
<span class="line" id="L2443">                        },</span>
<span class="line" id="L2444">                        .global =&gt; {</span>
<span class="line" id="L2445">                            <span class="tok-kw">try</span> parseDumpType(step, std.wasm.Valtype, reader, writer);</span>
<span class="line" id="L2446">                            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;mutable {}\n&quot;</span>, .{<span class="tok-number">0x01</span> == <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u32</span>, reader)});</span>
<span class="line" id="L2447">                        },</span>
<span class="line" id="L2448">                        .table =&gt; {</span>
<span class="line" id="L2449">                            <span class="tok-kw">try</span> parseDumpType(step, std.wasm.RefType, reader, writer);</span>
<span class="line" id="L2450">                            <span class="tok-kw">try</span> parseDumpLimits(reader, writer);</span>
<span class="line" id="L2451">                        },</span>
<span class="line" id="L2452">                    }</span>
<span class="line" id="L2453">                }</span>
<span class="line" id="L2454">            },</span>
<span class="line" id="L2455">            .function =&gt; {</span>
<span class="line" id="L2456">                <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2457">                <span class="tok-kw">while</span> (i &lt; entries) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L2458">                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;index {d}\n&quot;</span>, .{<span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u32</span>, reader)});</span>
<span class="line" id="L2459">                }</span>
<span class="line" id="L2460">            },</span>
<span class="line" id="L2461">            .table =&gt; {</span>
<span class="line" id="L2462">                <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2463">                <span class="tok-kw">while</span> (i &lt; entries) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L2464">                    <span class="tok-kw">try</span> parseDumpType(step, std.wasm.RefType, reader, writer);</span>
<span class="line" id="L2465">                    <span class="tok-kw">try</span> parseDumpLimits(reader, writer);</span>
<span class="line" id="L2466">                }</span>
<span class="line" id="L2467">            },</span>
<span class="line" id="L2468">            .memory =&gt; {</span>
<span class="line" id="L2469">                <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2470">                <span class="tok-kw">while</span> (i &lt; entries) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L2471">                    <span class="tok-kw">try</span> parseDumpLimits(reader, writer);</span>
<span class="line" id="L2472">                }</span>
<span class="line" id="L2473">            },</span>
<span class="line" id="L2474">            .global =&gt; {</span>
<span class="line" id="L2475">                <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2476">                <span class="tok-kw">while</span> (i &lt; entries) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L2477">                    <span class="tok-kw">try</span> parseDumpType(step, std.wasm.Valtype, reader, writer);</span>
<span class="line" id="L2478">                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;mutable {}\n&quot;</span>, .{<span class="tok-number">0x01</span> == <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u1</span>, reader)});</span>
<span class="line" id="L2479">                    <span class="tok-kw">try</span> parseDumpInit(step, reader, writer);</span>
<span class="line" id="L2480">                }</span>
<span class="line" id="L2481">            },</span>
<span class="line" id="L2482">            .@&quot;export&quot; =&gt; {</span>
<span class="line" id="L2483">                <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2484">                <span class="tok-kw">while</span> (i &lt; entries) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L2485">                    <span class="tok-kw">const</span> name_len = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u32</span>, reader);</span>
<span class="line" id="L2486">                    <span class="tok-kw">const</span> name = data[fbs.pos..][<span class="tok-number">0</span>..name_len];</span>
<span class="line" id="L2487">                    fbs.pos += name_len;</span>
<span class="line" id="L2488">                    <span class="tok-kw">const</span> kind_byte = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u8</span>, reader);</span>
<span class="line" id="L2489">                    <span class="tok-kw">const</span> kind = std.meta.intToEnum(std.wasm.ExternalKind, kind_byte) <span class="tok-kw">catch</span> {</span>
<span class="line" id="L2490">                        <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;invalid export kind value '{d}'&quot;</span>, .{kind_byte});</span>
<span class="line" id="L2491">                    };</span>
<span class="line" id="L2492">                    <span class="tok-kw">const</span> index = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u32</span>, reader);</span>
<span class="line" id="L2493">                    <span class="tok-kw">try</span> writer.print(</span>
<span class="line" id="L2494">                        <span class="tok-str">\\name {s}</span></span>

<span class="line" id="L2495">                        <span class="tok-str">\\kind {s}</span></span>

<span class="line" id="L2496">                        <span class="tok-str">\\index {d}</span></span>

<span class="line" id="L2497">                    , .{ name, <span class="tok-builtin">@tagName</span>(kind), index });</span>
<span class="line" id="L2498">                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);</span>
<span class="line" id="L2499">                }</span>
<span class="line" id="L2500">            },</span>
<span class="line" id="L2501">            .element =&gt; {</span>
<span class="line" id="L2502">                <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2503">                <span class="tok-kw">while</span> (i &lt; entries) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L2504">                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;table index {d}\n&quot;</span>, .{<span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u32</span>, reader)});</span>
<span class="line" id="L2505">                    <span class="tok-kw">try</span> parseDumpInit(step, reader, writer);</span>
<span class="line" id="L2506"></span>
<span class="line" id="L2507">                    <span class="tok-kw">const</span> function_indexes = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u32</span>, reader);</span>
<span class="line" id="L2508">                    <span class="tok-kw">var</span> function_index: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2509">                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;indexes {d}\n&quot;</span>, .{function_indexes});</span>
<span class="line" id="L2510">                    <span class="tok-kw">while</span> (function_index &lt; function_indexes) : (function_index += <span class="tok-number">1</span>) {</span>
<span class="line" id="L2511">                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;index {d}\n&quot;</span>, .{<span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u32</span>, reader)});</span>
<span class="line" id="L2512">                    }</span>
<span class="line" id="L2513">                }</span>
<span class="line" id="L2514">            },</span>
<span class="line" id="L2515">            .code =&gt; {}, <span class="tok-comment">// code section is considered opaque to linker</span>
</span>
<span class="line" id="L2516">            .data =&gt; {</span>
<span class="line" id="L2517">                <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2518">                <span class="tok-kw">while</span> (i &lt; entries) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L2519">                    <span class="tok-kw">const</span> flags = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u32</span>, reader);</span>
<span class="line" id="L2520">                    <span class="tok-kw">const</span> index = <span class="tok-kw">if</span> (flags &amp; <span class="tok-number">0x02</span> != <span class="tok-number">0</span>)</span>
<span class="line" id="L2521">                        <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u32</span>, reader)</span>
<span class="line" id="L2522">                    <span class="tok-kw">else</span></span>
<span class="line" id="L2523">                        <span class="tok-number">0</span>;</span>
<span class="line" id="L2524">                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;memory index 0x{x}\n&quot;</span>, .{index});</span>
<span class="line" id="L2525">                    <span class="tok-kw">if</span> (flags == <span class="tok-number">0</span>) {</span>
<span class="line" id="L2526">                        <span class="tok-kw">try</span> parseDumpInit(step, reader, writer);</span>
<span class="line" id="L2527">                    }</span>
<span class="line" id="L2528"></span>
<span class="line" id="L2529">                    <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u32</span>, reader);</span>
<span class="line" id="L2530">                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;size {d}\n&quot;</span>, .{size});</span>
<span class="line" id="L2531">                    <span class="tok-kw">try</span> reader.skipBytes(size, .{}); <span class="tok-comment">// we do not care about the content of the segments</span>
</span>
<span class="line" id="L2532">                }</span>
<span class="line" id="L2533">            },</span>
<span class="line" id="L2534">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L2535">        }</span>
<span class="line" id="L2536">    }</span>
<span class="line" id="L2537"></span>
<span class="line" id="L2538">    <span class="tok-kw">fn</span> <span class="tok-fn">parseDumpType</span>(step: *Step, <span class="tok-kw">comptime</span> WasmType: <span class="tok-type">type</span>, reader: <span class="tok-kw">anytype</span>, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2539">        <span class="tok-kw">const</span> type_byte = <span class="tok-kw">try</span> reader.readByte();</span>
<span class="line" id="L2540">        <span class="tok-kw">const</span> valtype = std.meta.intToEnum(WasmType, type_byte) <span class="tok-kw">catch</span> {</span>
<span class="line" id="L2541">            <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;Invalid wasm type value '{d}'&quot;</span>, .{type_byte});</span>
<span class="line" id="L2542">        };</span>
<span class="line" id="L2543">        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;type {s}\n&quot;</span>, .{<span class="tok-builtin">@tagName</span>(valtype)});</span>
<span class="line" id="L2544">    }</span>
<span class="line" id="L2545"></span>
<span class="line" id="L2546">    <span class="tok-kw">fn</span> <span class="tok-fn">parseDumpLimits</span>(reader: <span class="tok-kw">anytype</span>, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2547">        <span class="tok-kw">const</span> flags = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u8</span>, reader);</span>
<span class="line" id="L2548">        <span class="tok-kw">const</span> min = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u32</span>, reader);</span>
<span class="line" id="L2549"></span>
<span class="line" id="L2550">        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;min {x}\n&quot;</span>, .{min});</span>
<span class="line" id="L2551">        <span class="tok-kw">if</span> (flags != <span class="tok-number">0</span>) {</span>
<span class="line" id="L2552">            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;max {x}\n&quot;</span>, .{<span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u32</span>, reader)});</span>
<span class="line" id="L2553">        }</span>
<span class="line" id="L2554">    }</span>
<span class="line" id="L2555"></span>
<span class="line" id="L2556">    <span class="tok-kw">fn</span> <span class="tok-fn">parseDumpInit</span>(step: *Step, reader: <span class="tok-kw">anytype</span>, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2557">        <span class="tok-kw">const</span> byte = <span class="tok-kw">try</span> reader.readByte();</span>
<span class="line" id="L2558">        <span class="tok-kw">const</span> opcode = std.meta.intToEnum(std.wasm.Opcode, byte) <span class="tok-kw">catch</span> {</span>
<span class="line" id="L2559">            <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;invalid wasm opcode '{d}'&quot;</span>, .{byte});</span>
<span class="line" id="L2560">        };</span>
<span class="line" id="L2561">        <span class="tok-kw">switch</span> (opcode) {</span>
<span class="line" id="L2562">            .i32_const =&gt; <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;i32.const {x}\n&quot;</span>, .{<span class="tok-kw">try</span> std.leb.readILEB128(<span class="tok-type">i32</span>, reader)}),</span>
<span class="line" id="L2563">            .i64_const =&gt; <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;i64.const {x}\n&quot;</span>, .{<span class="tok-kw">try</span> std.leb.readILEB128(<span class="tok-type">i64</span>, reader)}),</span>
<span class="line" id="L2564">            .f32_const =&gt; <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;f32.const {x}\n&quot;</span>, .{<span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u32</span>, .little)))}),</span>
<span class="line" id="L2565">            .f64_const =&gt; <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;f64.const {x}\n&quot;</span>, .{<span class="tok-builtin">@as</span>(<span class="tok-type">f64</span>, <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u64</span>, .little)))}),</span>
<span class="line" id="L2566">            .global_get =&gt; <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;global.get {x}\n&quot;</span>, .{<span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u32</span>, reader)}),</span>
<span class="line" id="L2567">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L2568">        }</span>
<span class="line" id="L2569">        <span class="tok-kw">const</span> end_opcode = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u8</span>, reader);</span>
<span class="line" id="L2570">        <span class="tok-kw">if</span> (end_opcode != std.wasm.opcode(.end)) {</span>
<span class="line" id="L2571">            <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;expected 'end' opcode in init expression&quot;</span>, .{});</span>
<span class="line" id="L2572">        }</span>
<span class="line" id="L2573">    }</span>
<span class="line" id="L2574"></span>
<span class="line" id="L2575">    <span class="tok-kw">fn</span> <span class="tok-fn">parseDumpNames</span>(step: *Step, reader: <span class="tok-kw">anytype</span>, writer: <span class="tok-kw">anytype</span>, data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2576">        <span class="tok-kw">while</span> (reader.context.pos &lt; data.len) {</span>
<span class="line" id="L2577">            <span class="tok-kw">try</span> parseDumpType(step, std.wasm.NameSubsection, reader, writer);</span>
<span class="line" id="L2578">            <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u32</span>, reader);</span>
<span class="line" id="L2579">            <span class="tok-kw">const</span> entries = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u32</span>, reader);</span>
<span class="line" id="L2580">            <span class="tok-kw">try</span> writer.print(</span>
<span class="line" id="L2581">                <span class="tok-str">\\size {d}</span></span>

<span class="line" id="L2582">                <span class="tok-str">\\names {d}</span></span>

<span class="line" id="L2583">            , .{ size, entries });</span>
<span class="line" id="L2584">            <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);</span>
<span class="line" id="L2585">            <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2586">            <span class="tok-kw">while</span> (i &lt; entries) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L2587">                <span class="tok-kw">const</span> index = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u32</span>, reader);</span>
<span class="line" id="L2588">                <span class="tok-kw">const</span> name_len = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u32</span>, reader);</span>
<span class="line" id="L2589">                <span class="tok-kw">const</span> pos = reader.context.pos;</span>
<span class="line" id="L2590">                <span class="tok-kw">const</span> name = data[pos..][<span class="tok-number">0</span>..name_len];</span>
<span class="line" id="L2591">                reader.context.pos += name_len;</span>
<span class="line" id="L2592"></span>
<span class="line" id="L2593">                <span class="tok-kw">try</span> writer.print(</span>
<span class="line" id="L2594">                    <span class="tok-str">\\index {d}</span></span>

<span class="line" id="L2595">                    <span class="tok-str">\\name {s}</span></span>

<span class="line" id="L2596">                , .{ index, name });</span>
<span class="line" id="L2597">                <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);</span>
<span class="line" id="L2598">            }</span>
<span class="line" id="L2599">        }</span>
<span class="line" id="L2600">    }</span>
<span class="line" id="L2601"></span>
<span class="line" id="L2602">    <span class="tok-kw">fn</span> <span class="tok-fn">parseDumpProducers</span>(reader: <span class="tok-kw">anytype</span>, writer: <span class="tok-kw">anytype</span>, data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2603">        <span class="tok-kw">const</span> field_count = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u32</span>, reader);</span>
<span class="line" id="L2604">        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;fields {d}\n&quot;</span>, .{field_count});</span>
<span class="line" id="L2605">        <span class="tok-kw">var</span> current_field: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2606">        <span class="tok-kw">while</span> (current_field &lt; field_count) : (current_field += <span class="tok-number">1</span>) {</span>
<span class="line" id="L2607">            <span class="tok-kw">const</span> field_name_length = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u32</span>, reader);</span>
<span class="line" id="L2608">            <span class="tok-kw">const</span> field_name = data[reader.context.pos..][<span class="tok-number">0</span>..field_name_length];</span>
<span class="line" id="L2609">            reader.context.pos += field_name_length;</span>
<span class="line" id="L2610"></span>
<span class="line" id="L2611">            <span class="tok-kw">const</span> value_count = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u32</span>, reader);</span>
<span class="line" id="L2612">            <span class="tok-kw">try</span> writer.print(</span>
<span class="line" id="L2613">                <span class="tok-str">\\field_name {s}</span></span>

<span class="line" id="L2614">                <span class="tok-str">\\values {d}</span></span>

<span class="line" id="L2615">            , .{ field_name, value_count });</span>
<span class="line" id="L2616">            <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);</span>
<span class="line" id="L2617">            <span class="tok-kw">var</span> current_value: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2618">            <span class="tok-kw">while</span> (current_value &lt; value_count) : (current_value += <span class="tok-number">1</span>) {</span>
<span class="line" id="L2619">                <span class="tok-kw">const</span> value_length = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u32</span>, reader);</span>
<span class="line" id="L2620">                <span class="tok-kw">const</span> value = data[reader.context.pos..][<span class="tok-number">0</span>..value_length];</span>
<span class="line" id="L2621">                reader.context.pos += value_length;</span>
<span class="line" id="L2622"></span>
<span class="line" id="L2623">                <span class="tok-kw">const</span> version_length = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u32</span>, reader);</span>
<span class="line" id="L2624">                <span class="tok-kw">const</span> version = data[reader.context.pos..][<span class="tok-number">0</span>..version_length];</span>
<span class="line" id="L2625">                reader.context.pos += version_length;</span>
<span class="line" id="L2626"></span>
<span class="line" id="L2627">                <span class="tok-kw">try</span> writer.print(</span>
<span class="line" id="L2628">                    <span class="tok-str">\\value_name {s}</span></span>

<span class="line" id="L2629">                    <span class="tok-str">\\version {s}</span></span>

<span class="line" id="L2630">                , .{ value, version });</span>
<span class="line" id="L2631">                <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);</span>
<span class="line" id="L2632">            }</span>
<span class="line" id="L2633">        }</span>
<span class="line" id="L2634">    }</span>
<span class="line" id="L2635"></span>
<span class="line" id="L2636">    <span class="tok-kw">fn</span> <span class="tok-fn">parseDumpFeatures</span>(reader: <span class="tok-kw">anytype</span>, writer: <span class="tok-kw">anytype</span>, data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2637">        <span class="tok-kw">const</span> feature_count = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u32</span>, reader);</span>
<span class="line" id="L2638">        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;features {d}\n&quot;</span>, .{feature_count});</span>
<span class="line" id="L2639"></span>
<span class="line" id="L2640">        <span class="tok-kw">var</span> index: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2641">        <span class="tok-kw">while</span> (index &lt; feature_count) : (index += <span class="tok-number">1</span>) {</span>
<span class="line" id="L2642">            <span class="tok-kw">const</span> prefix_byte = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u8</span>, reader);</span>
<span class="line" id="L2643">            <span class="tok-kw">const</span> name_length = <span class="tok-kw">try</span> std.leb.readULEB128(<span class="tok-type">u32</span>, reader);</span>
<span class="line" id="L2644">            <span class="tok-kw">const</span> feature_name = data[reader.context.pos..][<span class="tok-number">0</span>..name_length];</span>
<span class="line" id="L2645">            reader.context.pos += name_length;</span>
<span class="line" id="L2646"></span>
<span class="line" id="L2647">            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{c} {s}\n&quot;</span>, .{ prefix_byte, feature_name });</span>
<span class="line" id="L2648">        }</span>
<span class="line" id="L2649">    }</span>
<span class="line" id="L2650">};</span>
<span class="line" id="L2651"></span>
</code></pre></body>
</html>