<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Thread.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg==">
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-comment">//! This struct represents a kernel thread, and acts as a namespace for concurrency</span></span>
<span class="line" id="L2"><span class="tok-comment">//! primitives that operate on kernel threads. For concurrency primitives that support</span></span>
<span class="line" id="L3"><span class="tok-comment">//! both evented I/O and async I/O, see the respective names in the top level std namespace.</span></span>
<span class="line" id="L4"></span>
<span class="line" id="L5"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std.zig&quot;</span>);</span>
<span class="line" id="L6"><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);</span>
<span class="line" id="L7"><span class="tok-kw">const</span> math = std.math;</span>
<span class="line" id="L8"><span class="tok-kw">const</span> os = std.os;</span>
<span class="line" id="L9"><span class="tok-kw">const</span> assert = std.debug.assert;</span>
<span class="line" id="L10"><span class="tok-kw">const</span> target = builtin.target;</span>
<span class="line" id="L11"></span>
<span class="line" id="L12"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Futex = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Thread/Futex.zig&quot;</span>);</span>
<span class="line" id="L13"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ResetEvent = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Thread/ResetEvent.zig&quot;</span>);</span>
<span class="line" id="L14"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Mutex = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Thread/Mutex.zig&quot;</span>);</span>
<span class="line" id="L15"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Semaphore = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Thread/Semaphore.zig&quot;</span>);</span>
<span class="line" id="L16"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Condition = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Thread/Condition.zig&quot;</span>);</span>
<span class="line" id="L17"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> RwLock = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Thread/RwLock.zig&quot;</span>);</span>
<span class="line" id="L18"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Pool = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Thread/Pool.zig&quot;</span>);</span>
<span class="line" id="L19"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> WaitGroup = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Thread/WaitGroup.zig&quot;</span>);</span>
<span class="line" id="L20"></span>
<span class="line" id="L21"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> use_pthreads = target.os.tag != .windows <span class="tok-kw">and</span> target.os.tag != .wasi <span class="tok-kw">and</span> builtin.link_libc;</span>
<span class="line" id="L22"></span>
<span class="line" id="L23"><span class="tok-kw">const</span> Thread = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L24"><span class="tok-kw">const</span> Impl = <span class="tok-kw">if</span> (target.os.tag == .windows)</span>
<span class="line" id="L25">    WindowsThreadImpl</span>
<span class="line" id="L26"><span class="tok-kw">else</span> <span class="tok-kw">if</span> (use_pthreads)</span>
<span class="line" id="L27">    PosixThreadImpl</span>
<span class="line" id="L28"><span class="tok-kw">else</span> <span class="tok-kw">if</span> (target.os.tag == .linux)</span>
<span class="line" id="L29">    LinuxThreadImpl</span>
<span class="line" id="L30"><span class="tok-kw">else</span> <span class="tok-kw">if</span> (target.os.tag == .wasi)</span>
<span class="line" id="L31">    WasiThreadImpl</span>
<span class="line" id="L32"><span class="tok-kw">else</span></span>
<span class="line" id="L33">    UnsupportedImpl;</span>
<span class="line" id="L34"></span>
<span class="line" id="L35">impl: Impl,</span>
<span class="line" id="L36"></span>
<span class="line" id="L37"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> max_name_len = <span class="tok-kw">switch</span> (target.os.tag) {</span>
<span class="line" id="L38">    .linux =&gt; <span class="tok-number">15</span>,</span>
<span class="line" id="L39">    .windows =&gt; <span class="tok-number">31</span>,</span>
<span class="line" id="L40">    .macos, .ios, .watchos, .tvos =&gt; <span class="tok-number">63</span>,</span>
<span class="line" id="L41">    .netbsd =&gt; <span class="tok-number">31</span>,</span>
<span class="line" id="L42">    .freebsd =&gt; <span class="tok-number">15</span>,</span>
<span class="line" id="L43">    .openbsd =&gt; <span class="tok-number">23</span>,</span>
<span class="line" id="L44">    .dragonfly =&gt; <span class="tok-number">1023</span>,</span>
<span class="line" id="L45">    .solaris, .illumos =&gt; <span class="tok-number">31</span>,</span>
<span class="line" id="L46">    <span class="tok-kw">else</span> =&gt; <span class="tok-number">0</span>,</span>
<span class="line" id="L47">};</span>
<span class="line" id="L48"></span>
<span class="line" id="L49"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SetNameError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L50">    NameTooLong,</span>
<span class="line" id="L51">    Unsupported,</span>
<span class="line" id="L52">    Unexpected,</span>
<span class="line" id="L53">} || os.PrctlError || os.WriteError || std.fs.File.OpenError || std.fmt.BufPrintError;</span>
<span class="line" id="L54"></span>
<span class="line" id="L55"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setName</span>(self: Thread, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) SetNameError!<span class="tok-type">void</span> {</span>
<span class="line" id="L56">    <span class="tok-kw">if</span> (name.len &gt; max_name_len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;</span>
<span class="line" id="L57"></span>
<span class="line" id="L58">    <span class="tok-kw">const</span> name_with_terminator = blk: {</span>
<span class="line" id="L59">        <span class="tok-kw">var</span> name_buf: [max_name_len:<span class="tok-number">0</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L60">        <span class="tok-builtin">@memcpy</span>(name_buf[<span class="tok-number">0</span>..name.len], name);</span>
<span class="line" id="L61">        name_buf[name.len] = <span class="tok-number">0</span>;</span>
<span class="line" id="L62">        <span class="tok-kw">break</span> :blk name_buf[<span class="tok-number">0</span>..name.len :<span class="tok-number">0</span>];</span>
<span class="line" id="L63">    };</span>
<span class="line" id="L64"></span>
<span class="line" id="L65">    <span class="tok-kw">switch</span> (target.os.tag) {</span>
<span class="line" id="L66">        .linux =&gt; <span class="tok-kw">if</span> (use_pthreads) {</span>
<span class="line" id="L67">            <span class="tok-kw">if</span> (self.getHandle() == std.c.pthread_self()) {</span>
<span class="line" id="L68">                <span class="tok-comment">// Set the name of the calling thread (no thread id required).</span>
</span>
<span class="line" id="L69">                <span class="tok-kw">const</span> err = <span class="tok-kw">try</span> os.prctl(.SET_NAME, .{<span class="tok-builtin">@intFromPtr</span>(name_with_terminator.ptr)});</span>
<span class="line" id="L70">                <span class="tok-kw">switch</span> (<span class="tok-builtin">@as</span>(os.E, <span class="tok-builtin">@enumFromInt</span>(err))) {</span>
<span class="line" id="L71">                    .SUCCESS =&gt; <span class="tok-kw">return</span>,</span>
<span class="line" id="L72">                    <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> os.unexpectedErrno(e),</span>
<span class="line" id="L73">                }</span>
<span class="line" id="L74">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L75">                <span class="tok-kw">const</span> err = std.c.pthread_setname_np(self.getHandle(), name_with_terminator.ptr);</span>
<span class="line" id="L76">                <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L77">                    .SUCCESS =&gt; <span class="tok-kw">return</span>,</span>
<span class="line" id="L78">                    .RANGE =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L79">                    <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> os.unexpectedErrno(e),</span>
<span class="line" id="L80">                }</span>
<span class="line" id="L81">            }</span>
<span class="line" id="L82">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L83">            <span class="tok-kw">var</span> buf: [<span class="tok-number">32</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L84">            <span class="tok-kw">const</span> path = <span class="tok-kw">try</span> std.fmt.bufPrint(&amp;buf, <span class="tok-str">&quot;/proc/self/task/{d}/comm&quot;</span>, .{self.getHandle()});</span>
<span class="line" id="L85"></span>
<span class="line" id="L86">            <span class="tok-kw">const</span> file = <span class="tok-kw">try</span> std.fs.cwd().openFile(path, .{ .mode = .write_only });</span>
<span class="line" id="L87">            <span class="tok-kw">defer</span> file.close();</span>
<span class="line" id="L88"></span>
<span class="line" id="L89">            <span class="tok-kw">try</span> file.writer().writeAll(name);</span>
<span class="line" id="L90">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L91">        },</span>
<span class="line" id="L92">        .windows =&gt; {</span>
<span class="line" id="L93">            <span class="tok-kw">var</span> buf: [max_name_len]<span class="tok-type">u16</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L94">            <span class="tok-kw">const</span> len = <span class="tok-kw">try</span> std.unicode.utf8ToUtf16Le(&amp;buf, name);</span>
<span class="line" id="L95">            <span class="tok-kw">const</span> byte_len = math.cast(<span class="tok-type">c_ushort</span>, len * <span class="tok-number">2</span>) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;</span>
<span class="line" id="L96"></span>
<span class="line" id="L97">            <span class="tok-comment">// Note: NT allocates its own copy, no use-after-free here.</span>
</span>
<span class="line" id="L98">            <span class="tok-kw">const</span> unicode_string = os.windows.UNICODE_STRING{</span>
<span class="line" id="L99">                .Length = byte_len,</span>
<span class="line" id="L100">                .MaximumLength = byte_len,</span>
<span class="line" id="L101">                .Buffer = &amp;buf,</span>
<span class="line" id="L102">            };</span>
<span class="line" id="L103"></span>
<span class="line" id="L104">            <span class="tok-kw">switch</span> (os.windows.ntdll.NtSetInformationThread(</span>
<span class="line" id="L105">                self.getHandle(),</span>
<span class="line" id="L106">                .ThreadNameInformation,</span>
<span class="line" id="L107">                &amp;unicode_string,</span>
<span class="line" id="L108">                <span class="tok-builtin">@sizeOf</span>(os.windows.UNICODE_STRING),</span>
<span class="line" id="L109">            )) {</span>
<span class="line" id="L110">                .SUCCESS =&gt; <span class="tok-kw">return</span>,</span>
<span class="line" id="L111">                .NOT_IMPLEMENTED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unsupported,</span>
<span class="line" id="L112">                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> os.windows.unexpectedStatus(err),</span>
<span class="line" id="L113">            }</span>
<span class="line" id="L114">        },</span>
<span class="line" id="L115">        .macos, .ios, .watchos, .tvos =&gt; <span class="tok-kw">if</span> (use_pthreads) {</span>
<span class="line" id="L116">            <span class="tok-comment">// There doesn't seem to be a way to set the name for an arbitrary thread, only the current one.</span>
</span>
<span class="line" id="L117">            <span class="tok-kw">if</span> (self.getHandle() != std.c.pthread_self()) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unsupported;</span>
<span class="line" id="L118"></span>
<span class="line" id="L119">            <span class="tok-kw">const</span> err = std.c.pthread_setname_np(name_with_terminator.ptr);</span>
<span class="line" id="L120">            <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L121">                .SUCCESS =&gt; <span class="tok-kw">return</span>,</span>
<span class="line" id="L122">                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> os.unexpectedErrno(e),</span>
<span class="line" id="L123">            }</span>
<span class="line" id="L124">        },</span>
<span class="line" id="L125">        .netbsd, .solaris, .illumos =&gt; <span class="tok-kw">if</span> (use_pthreads) {</span>
<span class="line" id="L126">            <span class="tok-kw">const</span> err = std.c.pthread_setname_np(self.getHandle(), name_with_terminator.ptr, <span class="tok-null">null</span>);</span>
<span class="line" id="L127">            <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L128">                .SUCCESS =&gt; <span class="tok-kw">return</span>,</span>
<span class="line" id="L129">                .INVAL =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L130">                .SRCH =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L131">                .NOMEM =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L132">                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> os.unexpectedErrno(e),</span>
<span class="line" id="L133">            }</span>
<span class="line" id="L134">        },</span>
<span class="line" id="L135">        .freebsd, .openbsd =&gt; <span class="tok-kw">if</span> (use_pthreads) {</span>
<span class="line" id="L136">            <span class="tok-comment">// Use pthread_set_name_np for FreeBSD because pthread_setname_np is FreeBSD 12.2+ only.</span>
</span>
<span class="line" id="L137">            <span class="tok-comment">// TODO maybe revisit this if depending on FreeBSD 12.2+ is acceptable because</span>
</span>
<span class="line" id="L138">            <span class="tok-comment">// pthread_setname_np can return an error.</span>
</span>
<span class="line" id="L139"></span>
<span class="line" id="L140">            std.c.pthread_set_name_np(self.getHandle(), name_with_terminator.ptr);</span>
<span class="line" id="L141">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L142">        },</span>
<span class="line" id="L143">        .dragonfly =&gt; <span class="tok-kw">if</span> (use_pthreads) {</span>
<span class="line" id="L144">            <span class="tok-kw">const</span> err = std.c.pthread_setname_np(self.getHandle(), name_with_terminator.ptr);</span>
<span class="line" id="L145">            <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L146">                .SUCCESS =&gt; <span class="tok-kw">return</span>,</span>
<span class="line" id="L147">                .INVAL =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L148">                .FAULT =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L149">                .NAMETOOLONG =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// already checked</span>
</span>
<span class="line" id="L150">                .SRCH =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L151">                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> os.unexpectedErrno(e),</span>
<span class="line" id="L152">            }</span>
<span class="line" id="L153">        },</span>
<span class="line" id="L154">        <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L155">    }</span>
<span class="line" id="L156">    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unsupported;</span>
<span class="line" id="L157">}</span>
<span class="line" id="L158"></span>
<span class="line" id="L159"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetNameError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L160">    <span class="tok-comment">// For Windows, the name is converted from UTF16 to UTF8</span>
</span>
<span class="line" id="L161">    CodepointTooLarge,</span>
<span class="line" id="L162">    Utf8CannotEncodeSurrogateHalf,</span>
<span class="line" id="L163">    DanglingSurrogateHalf,</span>
<span class="line" id="L164">    ExpectedSecondSurrogateHalf,</span>
<span class="line" id="L165">    UnexpectedSecondSurrogateHalf,</span>
<span class="line" id="L166"></span>
<span class="line" id="L167">    Unsupported,</span>
<span class="line" id="L168">    Unexpected,</span>
<span class="line" id="L169">} || os.PrctlError || os.ReadError || std.fs.File.OpenError || std.fmt.BufPrintError;</span>
<span class="line" id="L170"></span>
<span class="line" id="L171"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getName</span>(self: Thread, buffer_ptr: *[max_name_len:<span class="tok-number">0</span>]<span class="tok-type">u8</span>) GetNameError!?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L172">    buffer_ptr[max_name_len] = <span class="tok-number">0</span>;</span>
<span class="line" id="L173">    <span class="tok-kw">var</span> buffer: [:<span class="tok-number">0</span>]<span class="tok-type">u8</span> = buffer_ptr;</span>
<span class="line" id="L174"></span>
<span class="line" id="L175">    <span class="tok-kw">switch</span> (target.os.tag) {</span>
<span class="line" id="L176">        .linux =&gt; <span class="tok-kw">if</span> (use_pthreads) {</span>
<span class="line" id="L177">            <span class="tok-kw">if</span> (self.getHandle() == std.c.pthread_self()) {</span>
<span class="line" id="L178">                <span class="tok-comment">// Get the name of the calling thread (no thread id required).</span>
</span>
<span class="line" id="L179">                <span class="tok-kw">const</span> err = <span class="tok-kw">try</span> os.prctl(.GET_NAME, .{<span class="tok-builtin">@intFromPtr</span>(buffer.ptr)});</span>
<span class="line" id="L180">                <span class="tok-kw">switch</span> (<span class="tok-builtin">@as</span>(os.E, <span class="tok-builtin">@enumFromInt</span>(err))) {</span>
<span class="line" id="L181">                    .SUCCESS =&gt; <span class="tok-kw">return</span> std.mem.sliceTo(buffer, <span class="tok-number">0</span>),</span>
<span class="line" id="L182">                    <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> os.unexpectedErrno(e),</span>
<span class="line" id="L183">                }</span>
<span class="line" id="L184">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L185">                <span class="tok-kw">const</span> err = std.c.pthread_getname_np(self.getHandle(), buffer.ptr, max_name_len + <span class="tok-number">1</span>);</span>
<span class="line" id="L186">                <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L187">                    .SUCCESS =&gt; <span class="tok-kw">return</span> std.mem.sliceTo(buffer, <span class="tok-number">0</span>),</span>
<span class="line" id="L188">                    .RANGE =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L189">                    <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> os.unexpectedErrno(e),</span>
<span class="line" id="L190">                }</span>
<span class="line" id="L191">            }</span>
<span class="line" id="L192">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L193">            <span class="tok-kw">var</span> buf: [<span class="tok-number">32</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L194">            <span class="tok-kw">const</span> path = <span class="tok-kw">try</span> std.fmt.bufPrint(&amp;buf, <span class="tok-str">&quot;/proc/self/task/{d}/comm&quot;</span>, .{self.getHandle()});</span>
<span class="line" id="L195"></span>
<span class="line" id="L196">            <span class="tok-kw">const</span> file = <span class="tok-kw">try</span> std.fs.cwd().openFile(path, .{});</span>
<span class="line" id="L197">            <span class="tok-kw">defer</span> file.close();</span>
<span class="line" id="L198"></span>
<span class="line" id="L199">            <span class="tok-kw">const</span> data_len = <span class="tok-kw">try</span> file.reader().readAll(buffer_ptr[<span class="tok-number">0</span> .. max_name_len + <span class="tok-number">1</span>]);</span>
<span class="line" id="L200"></span>
<span class="line" id="L201">            <span class="tok-kw">return</span> <span class="tok-kw">if</span> (data_len &gt;= <span class="tok-number">1</span>) buffer[<span class="tok-number">0</span> .. data_len - <span class="tok-number">1</span>] <span class="tok-kw">else</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L202">        },</span>
<span class="line" id="L203">        .windows =&gt; {</span>
<span class="line" id="L204">            <span class="tok-kw">const</span> buf_capacity = <span class="tok-builtin">@sizeOf</span>(os.windows.UNICODE_STRING) + (<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">u16</span>) * max_name_len);</span>
<span class="line" id="L205">            <span class="tok-kw">var</span> buf: [buf_capacity]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(os.windows.UNICODE_STRING)) = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L206"></span>
<span class="line" id="L207">            <span class="tok-kw">switch</span> (os.windows.ntdll.NtQueryInformationThread(</span>
<span class="line" id="L208">                self.getHandle(),</span>
<span class="line" id="L209">                .ThreadNameInformation,</span>
<span class="line" id="L210">                &amp;buf,</span>
<span class="line" id="L211">                buf_capacity,</span>
<span class="line" id="L212">                <span class="tok-null">null</span>,</span>
<span class="line" id="L213">            )) {</span>
<span class="line" id="L214">                .SUCCESS =&gt; {</span>
<span class="line" id="L215">                    <span class="tok-kw">const</span> string = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> os.windows.UNICODE_STRING, <span class="tok-builtin">@ptrCast</span>(&amp;buf));</span>
<span class="line" id="L216">                    <span class="tok-kw">const</span> len = <span class="tok-kw">try</span> std.unicode.utf16leToUtf8(buffer, string.Buffer[<span class="tok-number">0</span> .. string.Length / <span class="tok-number">2</span>]);</span>
<span class="line" id="L217">                    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (len &gt; <span class="tok-number">0</span>) buffer[<span class="tok-number">0</span>..len] <span class="tok-kw">else</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L218">                },</span>
<span class="line" id="L219">                .NOT_IMPLEMENTED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unsupported,</span>
<span class="line" id="L220">                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> os.windows.unexpectedStatus(err),</span>
<span class="line" id="L221">            }</span>
<span class="line" id="L222">        },</span>
<span class="line" id="L223">        .macos, .ios, .watchos, .tvos =&gt; <span class="tok-kw">if</span> (use_pthreads) {</span>
<span class="line" id="L224">            <span class="tok-kw">const</span> err = std.c.pthread_getname_np(self.getHandle(), buffer.ptr, max_name_len + <span class="tok-number">1</span>);</span>
<span class="line" id="L225">            <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L226">                .SUCCESS =&gt; <span class="tok-kw">return</span> std.mem.sliceTo(buffer, <span class="tok-number">0</span>),</span>
<span class="line" id="L227">                .SRCH =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L228">                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> os.unexpectedErrno(e),</span>
<span class="line" id="L229">            }</span>
<span class="line" id="L230">        },</span>
<span class="line" id="L231">        .netbsd, .solaris, .illumos =&gt; <span class="tok-kw">if</span> (use_pthreads) {</span>
<span class="line" id="L232">            <span class="tok-kw">const</span> err = std.c.pthread_getname_np(self.getHandle(), buffer.ptr, max_name_len + <span class="tok-number">1</span>);</span>
<span class="line" id="L233">            <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L234">                .SUCCESS =&gt; <span class="tok-kw">return</span> std.mem.sliceTo(buffer, <span class="tok-number">0</span>),</span>
<span class="line" id="L235">                .INVAL =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L236">                .SRCH =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L237">                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> os.unexpectedErrno(e),</span>
<span class="line" id="L238">            }</span>
<span class="line" id="L239">        },</span>
<span class="line" id="L240">        .freebsd, .openbsd =&gt; <span class="tok-kw">if</span> (use_pthreads) {</span>
<span class="line" id="L241">            <span class="tok-comment">// Use pthread_get_name_np for FreeBSD because pthread_getname_np is FreeBSD 12.2+ only.</span>
</span>
<span class="line" id="L242">            <span class="tok-comment">// TODO maybe revisit this if depending on FreeBSD 12.2+ is acceptable because pthread_getname_np can return an error.</span>
</span>
<span class="line" id="L243"></span>
<span class="line" id="L244">            std.c.pthread_get_name_np(self.getHandle(), buffer.ptr, max_name_len + <span class="tok-number">1</span>);</span>
<span class="line" id="L245">            <span class="tok-kw">return</span> std.mem.sliceTo(buffer, <span class="tok-number">0</span>);</span>
<span class="line" id="L246">        },</span>
<span class="line" id="L247">        .dragonfly =&gt; <span class="tok-kw">if</span> (use_pthreads) {</span>
<span class="line" id="L248">            <span class="tok-kw">const</span> err = std.c.pthread_getname_np(self.getHandle(), buffer.ptr, max_name_len + <span class="tok-number">1</span>);</span>
<span class="line" id="L249">            <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L250">                .SUCCESS =&gt; <span class="tok-kw">return</span> std.mem.sliceTo(buffer, <span class="tok-number">0</span>),</span>
<span class="line" id="L251">                .INVAL =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L252">                .FAULT =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L253">                .SRCH =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L254">                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> os.unexpectedErrno(e),</span>
<span class="line" id="L255">            }</span>
<span class="line" id="L256">        },</span>
<span class="line" id="L257">        <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L258">    }</span>
<span class="line" id="L259">    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unsupported;</span>
<span class="line" id="L260">}</span>
<span class="line" id="L261"></span>
<span class="line" id="L262"><span class="tok-comment">/// Represents an ID per thread guaranteed to be unique only within a process.</span></span>
<span class="line" id="L263"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Id = <span class="tok-kw">switch</span> (target.os.tag) {</span>
<span class="line" id="L264">    .linux,</span>
<span class="line" id="L265">    .dragonfly,</span>
<span class="line" id="L266">    .netbsd,</span>
<span class="line" id="L267">    .freebsd,</span>
<span class="line" id="L268">    .openbsd,</span>
<span class="line" id="L269">    .haiku,</span>
<span class="line" id="L270">    .wasi,</span>
<span class="line" id="L271">    =&gt; <span class="tok-type">u32</span>,</span>
<span class="line" id="L272">    .macos, .ios, .watchos, .tvos =&gt; <span class="tok-type">u64</span>,</span>
<span class="line" id="L273">    .windows =&gt; os.windows.DWORD,</span>
<span class="line" id="L274">    <span class="tok-kw">else</span> =&gt; <span class="tok-type">usize</span>,</span>
<span class="line" id="L275">};</span>
<span class="line" id="L276"></span>
<span class="line" id="L277"><span class="tok-comment">/// Returns the platform ID of the callers thread.</span></span>
<span class="line" id="L278"><span class="tok-comment">/// Attempts to use thread locals and avoid syscalls when possible.</span></span>
<span class="line" id="L279"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getCurrentId</span>() Id {</span>
<span class="line" id="L280">    <span class="tok-kw">return</span> Impl.getCurrentId();</span>
<span class="line" id="L281">}</span>
<span class="line" id="L282"></span>
<span class="line" id="L283"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CpuCountError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L284">    PermissionDenied,</span>
<span class="line" id="L285">    SystemResources,</span>
<span class="line" id="L286">    Unexpected,</span>
<span class="line" id="L287">};</span>
<span class="line" id="L288"></span>
<span class="line" id="L289"><span class="tok-comment">/// Returns the platforms view on the number of logical CPU cores available.</span></span>
<span class="line" id="L290"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getCpuCount</span>() CpuCountError!<span class="tok-type">usize</span> {</span>
<span class="line" id="L291">    <span class="tok-kw">return</span> Impl.getCpuCount();</span>
<span class="line" id="L292">}</span>
<span class="line" id="L293"></span>
<span class="line" id="L294"><span class="tok-comment">/// Configuration options for hints on how to spawn threads.</span></span>
<span class="line" id="L295"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SpawnConfig = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L296">    <span class="tok-comment">// TODO compile-time call graph analysis to determine stack upper bound</span>
</span>
<span class="line" id="L297">    <span class="tok-comment">// https://github.com/ziglang/zig/issues/157</span>
</span>
<span class="line" id="L298"></span>
<span class="line" id="L299">    <span class="tok-comment">/// Size in bytes of the Thread's stack</span></span>
<span class="line" id="L300">    stack_size: <span class="tok-type">usize</span> = <span class="tok-number">16</span> * <span class="tok-number">1024</span> * <span class="tok-number">1024</span>,</span>
<span class="line" id="L301">    <span class="tok-comment">/// The allocator to be used to allocate memory for the to-be-spawned thread</span></span>
<span class="line" id="L302">    allocator: ?std.mem.Allocator = <span class="tok-null">null</span>,</span>
<span class="line" id="L303">};</span>
<span class="line" id="L304"></span>
<span class="line" id="L305"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SpawnError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L306">    <span class="tok-comment">/// A system-imposed limit on the number of threads was encountered.</span></span>
<span class="line" id="L307">    <span class="tok-comment">/// There are a number of limits that may trigger this error:</span></span>
<span class="line" id="L308">    <span class="tok-comment">/// *  the  RLIMIT_NPROC soft resource limit (set via setrlimit(2)),</span></span>
<span class="line" id="L309">    <span class="tok-comment">///    which limits the number of processes and threads for  a  real</span></span>
<span class="line" id="L310">    <span class="tok-comment">///    user ID, was reached;</span></span>
<span class="line" id="L311">    <span class="tok-comment">/// *  the kernel's system-wide limit on the number of processes and</span></span>
<span class="line" id="L312">    <span class="tok-comment">///    threads,  /proc/sys/kernel/threads-max,  was   reached   (see</span></span>
<span class="line" id="L313">    <span class="tok-comment">///    proc(5));</span></span>
<span class="line" id="L314">    <span class="tok-comment">/// *  the  maximum  number  of  PIDs, /proc/sys/kernel/pid_max, was</span></span>
<span class="line" id="L315">    <span class="tok-comment">///    reached (see proc(5)); or</span></span>
<span class="line" id="L316">    <span class="tok-comment">/// *  the PID limit (pids.max) imposed by the cgroup &quot;process  num‐</span></span>
<span class="line" id="L317">    <span class="tok-comment">///    ber&quot; (PIDs) controller was reached.</span></span>
<span class="line" id="L318">    ThreadQuotaExceeded,</span>
<span class="line" id="L319"></span>
<span class="line" id="L320">    <span class="tok-comment">/// The kernel cannot allocate sufficient memory to allocate a task structure</span></span>
<span class="line" id="L321">    <span class="tok-comment">/// for the child, or to copy those parts of the caller's context that need to</span></span>
<span class="line" id="L322">    <span class="tok-comment">/// be copied.</span></span>
<span class="line" id="L323">    SystemResources,</span>
<span class="line" id="L324"></span>
<span class="line" id="L325">    <span class="tok-comment">/// Not enough userland memory to spawn the thread.</span></span>
<span class="line" id="L326">    OutOfMemory,</span>
<span class="line" id="L327"></span>
<span class="line" id="L328">    <span class="tok-comment">/// `mlockall` is enabled, and the memory needed to spawn the thread</span></span>
<span class="line" id="L329">    <span class="tok-comment">/// would exceed the limit.</span></span>
<span class="line" id="L330">    LockedMemoryLimitExceeded,</span>
<span class="line" id="L331"></span>
<span class="line" id="L332">    Unexpected,</span>
<span class="line" id="L333">};</span>
<span class="line" id="L334"></span>
<span class="line" id="L335"><span class="tok-comment">/// Spawns a new thread which executes `function` using `args` and returns a handle to the spawned thread.</span></span>
<span class="line" id="L336"><span class="tok-comment">/// `config` can be used as hints to the platform for now to spawn and execute the `function`.</span></span>
<span class="line" id="L337"><span class="tok-comment">/// The caller must eventually either call `join()` to wait for the thread to finish and free its resources</span></span>
<span class="line" id="L338"><span class="tok-comment">/// or call `detach()` to excuse the caller from calling `join()` and have the thread clean up its resources on completion.</span></span>
<span class="line" id="L339"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">spawn</span>(config: SpawnConfig, <span class="tok-kw">comptime</span> function: <span class="tok-kw">anytype</span>, args: <span class="tok-kw">anytype</span>) SpawnError!Thread {</span>
<span class="line" id="L340">    <span class="tok-kw">if</span> (builtin.single_threaded) {</span>
<span class="line" id="L341">        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot spawn thread when building in single-threaded mode&quot;</span>);</span>
<span class="line" id="L342">    }</span>
<span class="line" id="L343"></span>
<span class="line" id="L344">    <span class="tok-kw">const</span> impl = <span class="tok-kw">try</span> Impl.spawn(config, function, args);</span>
<span class="line" id="L345">    <span class="tok-kw">return</span> Thread{ .impl = impl };</span>
<span class="line" id="L346">}</span>
<span class="line" id="L347"></span>
<span class="line" id="L348"><span class="tok-comment">/// Represents a kernel thread handle.</span></span>
<span class="line" id="L349"><span class="tok-comment">/// May be an integer or a pointer depending on the platform.</span></span>
<span class="line" id="L350"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Handle = Impl.ThreadHandle;</span>
<span class="line" id="L351"></span>
<span class="line" id="L352"><span class="tok-comment">/// Returns the handle of this thread</span></span>
<span class="line" id="L353"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getHandle</span>(self: Thread) Handle {</span>
<span class="line" id="L354">    <span class="tok-kw">return</span> self.impl.getHandle();</span>
<span class="line" id="L355">}</span>
<span class="line" id="L356"></span>
<span class="line" id="L357"><span class="tok-comment">/// Release the obligation of the caller to call `join()` and have the thread clean up its own resources on completion.</span></span>
<span class="line" id="L358"><span class="tok-comment">/// Once called, this consumes the Thread object and invoking any other functions on it is considered undefined behavior.</span></span>
<span class="line" id="L359"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">detach</span>(self: Thread) <span class="tok-type">void</span> {</span>
<span class="line" id="L360">    <span class="tok-kw">return</span> self.impl.detach();</span>
<span class="line" id="L361">}</span>
<span class="line" id="L362"></span>
<span class="line" id="L363"><span class="tok-comment">/// Waits for the thread to complete, then deallocates any resources created on `spawn()`.</span></span>
<span class="line" id="L364"><span class="tok-comment">/// Once called, this consumes the Thread object and invoking any other functions on it is considered undefined behavior.</span></span>
<span class="line" id="L365"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">join</span>(self: Thread) <span class="tok-type">void</span> {</span>
<span class="line" id="L366">    <span class="tok-kw">return</span> self.impl.join();</span>
<span class="line" id="L367">}</span>
<span class="line" id="L368"></span>
<span class="line" id="L369"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> YieldError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L370">    <span class="tok-comment">/// The system is not configured to allow yielding</span></span>
<span class="line" id="L371">    SystemCannotYield,</span>
<span class="line" id="L372">};</span>
<span class="line" id="L373"></span>
<span class="line" id="L374"><span class="tok-comment">/// Yields the current thread potentially allowing other threads to run.</span></span>
<span class="line" id="L375"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">yield</span>() YieldError!<span class="tok-type">void</span> {</span>
<span class="line" id="L376">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L377">        <span class="tok-comment">// The return value has to do with how many other threads there are; it is not</span>
</span>
<span class="line" id="L378">        <span class="tok-comment">// an error condition on Windows.</span>
</span>
<span class="line" id="L379">        _ = os.windows.kernel32.SwitchToThread();</span>
<span class="line" id="L380">        <span class="tok-kw">return</span>;</span>
<span class="line" id="L381">    }</span>
<span class="line" id="L382">    <span class="tok-kw">switch</span> (os.errno(os.system.sched_yield())) {</span>
<span class="line" id="L383">        .SUCCESS =&gt; <span class="tok-kw">return</span>,</span>
<span class="line" id="L384">        .NOSYS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemCannotYield,</span>
<span class="line" id="L385">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemCannotYield,</span>
<span class="line" id="L386">    }</span>
<span class="line" id="L387">}</span>
<span class="line" id="L388"></span>
<span class="line" id="L389"><span class="tok-comment">/// State to synchronize detachment of spawner thread to spawned thread</span></span>
<span class="line" id="L390"><span class="tok-kw">const</span> Completion = std.atomic.Value(<span class="tok-kw">enum</span>(<span class="tok-type">u8</span>) {</span>
<span class="line" id="L391">    running,</span>
<span class="line" id="L392">    detached,</span>
<span class="line" id="L393">    completed,</span>
<span class="line" id="L394">});</span>
<span class="line" id="L395"></span>
<span class="line" id="L396"><span class="tok-comment">/// Used by the Thread implementations to call the spawned function with the arguments.</span></span>
<span class="line" id="L397"><span class="tok-kw">fn</span> <span class="tok-fn">callFn</span>(<span class="tok-kw">comptime</span> f: <span class="tok-kw">anytype</span>, args: <span class="tok-kw">anytype</span>) <span class="tok-kw">switch</span> (Impl) {</span>
<span class="line" id="L398">    WindowsThreadImpl =&gt; std.os.windows.DWORD,</span>
<span class="line" id="L399">    LinuxThreadImpl =&gt; <span class="tok-type">u8</span>,</span>
<span class="line" id="L400">    PosixThreadImpl =&gt; ?*<span class="tok-type">anyopaque</span>,</span>
<span class="line" id="L401">    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L402">} {</span>
<span class="line" id="L403">    <span class="tok-kw">const</span> default_value = <span class="tok-kw">if</span> (Impl == PosixThreadImpl) <span class="tok-null">null</span> <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L404">    <span class="tok-kw">const</span> bad_fn_ret = <span class="tok-str">&quot;expected return type of startFn to be 'u8', 'noreturn', 'void', or '!void'&quot;</span>;</span>
<span class="line" id="L405"></span>
<span class="line" id="L406">    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(f)).Fn.return_type.?)) {</span>
<span class="line" id="L407">        .NoReturn =&gt; {</span>
<span class="line" id="L408">            <span class="tok-builtin">@call</span>(.auto, f, args);</span>
<span class="line" id="L409">        },</span>
<span class="line" id="L410">        .Void =&gt; {</span>
<span class="line" id="L411">            <span class="tok-builtin">@call</span>(.auto, f, args);</span>
<span class="line" id="L412">            <span class="tok-kw">return</span> default_value;</span>
<span class="line" id="L413">        },</span>
<span class="line" id="L414">        .Int =&gt; |info| {</span>
<span class="line" id="L415">            <span class="tok-kw">if</span> (info.bits != <span class="tok-number">8</span>) {</span>
<span class="line" id="L416">                <span class="tok-builtin">@compileError</span>(bad_fn_ret);</span>
<span class="line" id="L417">            }</span>
<span class="line" id="L418"></span>
<span class="line" id="L419">            <span class="tok-kw">const</span> status = <span class="tok-builtin">@call</span>(.auto, f, args);</span>
<span class="line" id="L420">            <span class="tok-kw">if</span> (Impl != PosixThreadImpl) {</span>
<span class="line" id="L421">                <span class="tok-kw">return</span> status;</span>
<span class="line" id="L422">            }</span>
<span class="line" id="L423"></span>
<span class="line" id="L424">            <span class="tok-comment">// pthreads don't support exit status, ignore value</span>
</span>
<span class="line" id="L425">            <span class="tok-kw">return</span> default_value;</span>
<span class="line" id="L426">        },</span>
<span class="line" id="L427">        .ErrorUnion =&gt; |info| {</span>
<span class="line" id="L428">            <span class="tok-kw">if</span> (info.payload != <span class="tok-type">void</span>) {</span>
<span class="line" id="L429">                <span class="tok-builtin">@compileError</span>(bad_fn_ret);</span>
<span class="line" id="L430">            }</span>
<span class="line" id="L431"></span>
<span class="line" id="L432">            <span class="tok-builtin">@call</span>(.auto, f, args) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L433">                std.debug.print(<span class="tok-str">&quot;error: {s}\n&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)});</span>
<span class="line" id="L434">                <span class="tok-kw">if</span> (<span class="tok-builtin">@errorReturnTrace</span>()) |trace| {</span>
<span class="line" id="L435">                    std.debug.dumpStackTrace(trace.*);</span>
<span class="line" id="L436">                }</span>
<span class="line" id="L437">            };</span>
<span class="line" id="L438"></span>
<span class="line" id="L439">            <span class="tok-kw">return</span> default_value;</span>
<span class="line" id="L440">        },</span>
<span class="line" id="L441">        <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L442">            <span class="tok-builtin">@compileError</span>(bad_fn_ret);</span>
<span class="line" id="L443">        },</span>
<span class="line" id="L444">    }</span>
<span class="line" id="L445">}</span>
<span class="line" id="L446"></span>
<span class="line" id="L447"><span class="tok-comment">/// We can't compile error in the `Impl` switch statement as its eagerly evaluated.</span></span>
<span class="line" id="L448"><span class="tok-comment">/// So instead, we compile-error on the methods themselves for platforms which don't support threads.</span></span>
<span class="line" id="L449"><span class="tok-kw">const</span> UnsupportedImpl = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L450">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ThreadHandle = <span class="tok-type">void</span>;</span>
<span class="line" id="L451"></span>
<span class="line" id="L452">    <span class="tok-kw">fn</span> <span class="tok-fn">getCurrentId</span>() <span class="tok-type">usize</span> {</span>
<span class="line" id="L453">        <span class="tok-kw">return</span> unsupported({});</span>
<span class="line" id="L454">    }</span>
<span class="line" id="L455"></span>
<span class="line" id="L456">    <span class="tok-kw">fn</span> <span class="tok-fn">getCpuCount</span>() !<span class="tok-type">usize</span> {</span>
<span class="line" id="L457">        <span class="tok-kw">return</span> unsupported({});</span>
<span class="line" id="L458">    }</span>
<span class="line" id="L459"></span>
<span class="line" id="L460">    <span class="tok-kw">fn</span> <span class="tok-fn">spawn</span>(config: SpawnConfig, <span class="tok-kw">comptime</span> f: <span class="tok-kw">anytype</span>, args: <span class="tok-kw">anytype</span>) !Impl {</span>
<span class="line" id="L461">        <span class="tok-kw">return</span> unsupported(.{ config, f, args });</span>
<span class="line" id="L462">    }</span>
<span class="line" id="L463"></span>
<span class="line" id="L464">    <span class="tok-kw">fn</span> <span class="tok-fn">getHandle</span>(self: Impl) ThreadHandle {</span>
<span class="line" id="L465">        <span class="tok-kw">return</span> unsupported(self);</span>
<span class="line" id="L466">    }</span>
<span class="line" id="L467"></span>
<span class="line" id="L468">    <span class="tok-kw">fn</span> <span class="tok-fn">detach</span>(self: Impl) <span class="tok-type">void</span> {</span>
<span class="line" id="L469">        <span class="tok-kw">return</span> unsupported(self);</span>
<span class="line" id="L470">    }</span>
<span class="line" id="L471"></span>
<span class="line" id="L472">    <span class="tok-kw">fn</span> <span class="tok-fn">join</span>(self: Impl) <span class="tok-type">void</span> {</span>
<span class="line" id="L473">        <span class="tok-kw">return</span> unsupported(self);</span>
<span class="line" id="L474">    }</span>
<span class="line" id="L475"></span>
<span class="line" id="L476">    <span class="tok-kw">fn</span> <span class="tok-fn">unsupported</span>(unused: <span class="tok-kw">anytype</span>) <span class="tok-type">noreturn</span> {</span>
<span class="line" id="L477">        _ = unused;</span>
<span class="line" id="L478">        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unsupported operating system &quot;</span> ++ <span class="tok-builtin">@tagName</span>(target.os.tag));</span>
<span class="line" id="L479">    }</span>
<span class="line" id="L480">};</span>
<span class="line" id="L481"></span>
<span class="line" id="L482"><span class="tok-kw">const</span> WindowsThreadImpl = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L483">    <span class="tok-kw">const</span> windows = os.windows;</span>
<span class="line" id="L484"></span>
<span class="line" id="L485">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ThreadHandle = windows.HANDLE;</span>
<span class="line" id="L486"></span>
<span class="line" id="L487">    <span class="tok-kw">fn</span> <span class="tok-fn">getCurrentId</span>() windows.DWORD {</span>
<span class="line" id="L488">        <span class="tok-kw">return</span> windows.kernel32.GetCurrentThreadId();</span>
<span class="line" id="L489">    }</span>
<span class="line" id="L490"></span>
<span class="line" id="L491">    <span class="tok-kw">fn</span> <span class="tok-fn">getCpuCount</span>() !<span class="tok-type">usize</span> {</span>
<span class="line" id="L492">        <span class="tok-comment">// Faster than calling into GetSystemInfo(), even if amortized.</span>
</span>
<span class="line" id="L493">        <span class="tok-kw">return</span> windows.peb().NumberOfProcessors;</span>
<span class="line" id="L494">    }</span>
<span class="line" id="L495"></span>
<span class="line" id="L496">    thread: *ThreadCompletion,</span>
<span class="line" id="L497"></span>
<span class="line" id="L498">    <span class="tok-kw">const</span> ThreadCompletion = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L499">        completion: Completion,</span>
<span class="line" id="L500">        heap_ptr: windows.PVOID,</span>
<span class="line" id="L501">        heap_handle: windows.HANDLE,</span>
<span class="line" id="L502">        thread_handle: windows.HANDLE = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L503"></span>
<span class="line" id="L504">        <span class="tok-kw">fn</span> <span class="tok-fn">free</span>(self: ThreadCompletion) <span class="tok-type">void</span> {</span>
<span class="line" id="L505">            <span class="tok-kw">const</span> status = windows.kernel32.HeapFree(self.heap_handle, <span class="tok-number">0</span>, self.heap_ptr);</span>
<span class="line" id="L506">            assert(status != <span class="tok-number">0</span>);</span>
<span class="line" id="L507">        }</span>
<span class="line" id="L508">    };</span>
<span class="line" id="L509"></span>
<span class="line" id="L510">    <span class="tok-kw">fn</span> <span class="tok-fn">spawn</span>(config: SpawnConfig, <span class="tok-kw">comptime</span> f: <span class="tok-kw">anytype</span>, args: <span class="tok-kw">anytype</span>) !Impl {</span>
<span class="line" id="L511">        <span class="tok-kw">const</span> Args = <span class="tok-builtin">@TypeOf</span>(args);</span>
<span class="line" id="L512">        <span class="tok-kw">const</span> Instance = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L513">            fn_args: Args,</span>
<span class="line" id="L514">            thread: ThreadCompletion,</span>
<span class="line" id="L515"></span>
<span class="line" id="L516">            <span class="tok-kw">fn</span> <span class="tok-fn">entryFn</span>(raw_ptr: windows.PVOID) <span class="tok-kw">callconv</span>(.C) windows.DWORD {</span>
<span class="line" id="L517">                <span class="tok-kw">const</span> self: *<span class="tok-builtin">@This</span>() = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(raw_ptr));</span>
<span class="line" id="L518">                <span class="tok-kw">defer</span> <span class="tok-kw">switch</span> (self.thread.completion.swap(.completed, .SeqCst)) {</span>
<span class="line" id="L519">                    .running =&gt; {},</span>
<span class="line" id="L520">                    .completed =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L521">                    .detached =&gt; self.thread.free(),</span>
<span class="line" id="L522">                };</span>
<span class="line" id="L523">                <span class="tok-kw">return</span> callFn(f, self.fn_args);</span>
<span class="line" id="L524">            }</span>
<span class="line" id="L525">        };</span>
<span class="line" id="L526"></span>
<span class="line" id="L527">        <span class="tok-kw">const</span> heap_handle = windows.kernel32.GetProcessHeap() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory;</span>
<span class="line" id="L528">        <span class="tok-kw">const</span> alloc_bytes = <span class="tok-builtin">@alignOf</span>(Instance) + <span class="tok-builtin">@sizeOf</span>(Instance);</span>
<span class="line" id="L529">        <span class="tok-kw">const</span> alloc_ptr = windows.kernel32.HeapAlloc(heap_handle, <span class="tok-number">0</span>, alloc_bytes) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory;</span>
<span class="line" id="L530">        <span class="tok-kw">errdefer</span> assert(windows.kernel32.HeapFree(heap_handle, <span class="tok-number">0</span>, alloc_ptr) != <span class="tok-number">0</span>);</span>
<span class="line" id="L531"></span>
<span class="line" id="L532">        <span class="tok-kw">const</span> instance_bytes = <span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(alloc_ptr))[<span class="tok-number">0</span>..alloc_bytes];</span>
<span class="line" id="L533">        <span class="tok-kw">var</span> fba = std.heap.FixedBufferAllocator.init(instance_bytes);</span>
<span class="line" id="L534">        <span class="tok-kw">const</span> instance = fba.allocator().create(Instance) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L535">        instance.* = .{</span>
<span class="line" id="L536">            .fn_args = args,</span>
<span class="line" id="L537">            .thread = .{</span>
<span class="line" id="L538">                .completion = Completion.init(.running),</span>
<span class="line" id="L539">                .heap_ptr = alloc_ptr,</span>
<span class="line" id="L540">                .heap_handle = heap_handle,</span>
<span class="line" id="L541">            },</span>
<span class="line" id="L542">        };</span>
<span class="line" id="L543"></span>
<span class="line" id="L544">        <span class="tok-comment">// Windows appears to only support SYSTEM_INFO.dwAllocationGranularity minimum stack size.</span>
</span>
<span class="line" id="L545">        <span class="tok-comment">// Going lower makes it default to that specified in the executable (~1mb).</span>
</span>
<span class="line" id="L546">        <span class="tok-comment">// Its also fine if the limit here is incorrect as stack size is only a hint.</span>
</span>
<span class="line" id="L547">        <span class="tok-kw">var</span> stack_size = std.math.cast(<span class="tok-type">u32</span>, config.stack_size) <span class="tok-kw">orelse</span> std.math.maxInt(<span class="tok-type">u32</span>);</span>
<span class="line" id="L548">        stack_size = <span class="tok-builtin">@max</span>(<span class="tok-number">64</span> * <span class="tok-number">1024</span>, stack_size);</span>
<span class="line" id="L549"></span>
<span class="line" id="L550">        instance.thread.thread_handle = windows.kernel32.CreateThread(</span>
<span class="line" id="L551">            <span class="tok-null">null</span>,</span>
<span class="line" id="L552">            stack_size,</span>
<span class="line" id="L553">            Instance.entryFn,</span>
<span class="line" id="L554">            instance,</span>
<span class="line" id="L555">            <span class="tok-number">0</span>,</span>
<span class="line" id="L556">            <span class="tok-null">null</span>,</span>
<span class="line" id="L557">        ) <span class="tok-kw">orelse</span> {</span>
<span class="line" id="L558">            <span class="tok-kw">const</span> errno = windows.kernel32.GetLastError();</span>
<span class="line" id="L559">            <span class="tok-kw">return</span> windows.unexpectedError(errno);</span>
<span class="line" id="L560">        };</span>
<span class="line" id="L561"></span>
<span class="line" id="L562">        <span class="tok-kw">return</span> Impl{ .thread = &amp;instance.thread };</span>
<span class="line" id="L563">    }</span>
<span class="line" id="L564"></span>
<span class="line" id="L565">    <span class="tok-kw">fn</span> <span class="tok-fn">getHandle</span>(self: Impl) ThreadHandle {</span>
<span class="line" id="L566">        <span class="tok-kw">return</span> self.thread.thread_handle;</span>
<span class="line" id="L567">    }</span>
<span class="line" id="L568"></span>
<span class="line" id="L569">    <span class="tok-kw">fn</span> <span class="tok-fn">detach</span>(self: Impl) <span class="tok-type">void</span> {</span>
<span class="line" id="L570">        windows.CloseHandle(self.thread.thread_handle);</span>
<span class="line" id="L571">        <span class="tok-kw">switch</span> (self.thread.completion.swap(.detached, .SeqCst)) {</span>
<span class="line" id="L572">            .running =&gt; {},</span>
<span class="line" id="L573">            .completed =&gt; self.thread.free(),</span>
<span class="line" id="L574">            .detached =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L575">        }</span>
<span class="line" id="L576">    }</span>
<span class="line" id="L577"></span>
<span class="line" id="L578">    <span class="tok-kw">fn</span> <span class="tok-fn">join</span>(self: Impl) <span class="tok-type">void</span> {</span>
<span class="line" id="L579">        windows.WaitForSingleObjectEx(self.thread.thread_handle, windows.INFINITE, <span class="tok-null">false</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L580">        windows.CloseHandle(self.thread.thread_handle);</span>
<span class="line" id="L581">        assert(self.thread.completion.load(.SeqCst) == .completed);</span>
<span class="line" id="L582">        self.thread.free();</span>
<span class="line" id="L583">    }</span>
<span class="line" id="L584">};</span>
<span class="line" id="L585"></span>
<span class="line" id="L586"><span class="tok-kw">const</span> PosixThreadImpl = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L587">    <span class="tok-kw">const</span> c = std.c;</span>
<span class="line" id="L588"></span>
<span class="line" id="L589">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ThreadHandle = c.pthread_t;</span>
<span class="line" id="L590"></span>
<span class="line" id="L591">    <span class="tok-kw">fn</span> <span class="tok-fn">getCurrentId</span>() Id {</span>
<span class="line" id="L592">        <span class="tok-kw">switch</span> (target.os.tag) {</span>
<span class="line" id="L593">            .linux =&gt; {</span>
<span class="line" id="L594">                <span class="tok-kw">return</span> LinuxThreadImpl.getCurrentId();</span>
<span class="line" id="L595">            },</span>
<span class="line" id="L596">            .macos, .ios, .watchos, .tvos =&gt; {</span>
<span class="line" id="L597">                <span class="tok-kw">var</span> thread_id: <span class="tok-type">u64</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L598">                <span class="tok-comment">// Pass thread=null to get the current thread ID.</span>
</span>
<span class="line" id="L599">                assert(c.pthread_threadid_np(<span class="tok-null">null</span>, &amp;thread_id) == <span class="tok-number">0</span>);</span>
<span class="line" id="L600">                <span class="tok-kw">return</span> thread_id;</span>
<span class="line" id="L601">            },</span>
<span class="line" id="L602">            .dragonfly =&gt; {</span>
<span class="line" id="L603">                <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@bitCast</span>(c.lwp_gettid()));</span>
<span class="line" id="L604">            },</span>
<span class="line" id="L605">            .netbsd =&gt; {</span>
<span class="line" id="L606">                <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@bitCast</span>(c._lwp_self()));</span>
<span class="line" id="L607">            },</span>
<span class="line" id="L608">            .freebsd =&gt; {</span>
<span class="line" id="L609">                <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@bitCast</span>(c.pthread_getthreadid_np()));</span>
<span class="line" id="L610">            },</span>
<span class="line" id="L611">            .openbsd =&gt; {</span>
<span class="line" id="L612">                <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@bitCast</span>(c.getthrid()));</span>
<span class="line" id="L613">            },</span>
<span class="line" id="L614">            .haiku =&gt; {</span>
<span class="line" id="L615">                <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@bitCast</span>(c.find_thread(<span class="tok-null">null</span>)));</span>
<span class="line" id="L616">            },</span>
<span class="line" id="L617">            <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L618">                <span class="tok-kw">return</span> <span class="tok-builtin">@intFromPtr</span>(c.pthread_self());</span>
<span class="line" id="L619">            },</span>
<span class="line" id="L620">        }</span>
<span class="line" id="L621">    }</span>
<span class="line" id="L622"></span>
<span class="line" id="L623">    <span class="tok-kw">fn</span> <span class="tok-fn">getCpuCount</span>() !<span class="tok-type">usize</span> {</span>
<span class="line" id="L624">        <span class="tok-kw">switch</span> (target.os.tag) {</span>
<span class="line" id="L625">            .linux =&gt; {</span>
<span class="line" id="L626">                <span class="tok-kw">return</span> LinuxThreadImpl.getCpuCount();</span>
<span class="line" id="L627">            },</span>
<span class="line" id="L628">            .openbsd =&gt; {</span>
<span class="line" id="L629">                <span class="tok-kw">var</span> count: <span class="tok-type">c_int</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L630">                <span class="tok-kw">var</span> count_size: <span class="tok-type">usize</span> = <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">c_int</span>);</span>
<span class="line" id="L631">                <span class="tok-kw">const</span> mib = [_]<span class="tok-type">c_int</span>{ os.CTL.HW, os.system.HW.NCPUONLINE };</span>
<span class="line" id="L632">                os.sysctl(&amp;mib, &amp;count, &amp;count_size, <span class="tok-null">null</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L633">                    <span class="tok-kw">error</span>.NameTooLong, <span class="tok-kw">error</span>.UnknownName =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L634">                    <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L635">                };</span>
<span class="line" id="L636">                <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(count));</span>
<span class="line" id="L637">            },</span>
<span class="line" id="L638">            .solaris, .illumos =&gt; {</span>
<span class="line" id="L639">                <span class="tok-comment">// The &quot;proper&quot; way to get the cpu count would be to query</span>
</span>
<span class="line" id="L640">                <span class="tok-comment">// /dev/kstat via ioctls, and traverse a linked list for each</span>
</span>
<span class="line" id="L641">                <span class="tok-comment">// cpu.</span>
</span>
<span class="line" id="L642">                <span class="tok-kw">const</span> rc = c.sysconf(os._SC.NPROCESSORS_ONLN);</span>
<span class="line" id="L643">                <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (os.errno(rc)) {</span>
<span class="line" id="L644">                    .SUCCESS =&gt; <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(rc)),</span>
<span class="line" id="L645">                    <span class="tok-kw">else</span> =&gt; |err| os.unexpectedErrno(err),</span>
<span class="line" id="L646">                };</span>
<span class="line" id="L647">            },</span>
<span class="line" id="L648">            .haiku =&gt; {</span>
<span class="line" id="L649">                <span class="tok-kw">var</span> system_info: os.system.system_info = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L650">                <span class="tok-kw">const</span> rc = os.system.get_system_info(&amp;system_info); <span class="tok-comment">// always returns B_OK</span>
</span>
<span class="line" id="L651">                <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (os.errno(rc)) {</span>
<span class="line" id="L652">                    .SUCCESS =&gt; <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(system_info.cpu_count)),</span>
<span class="line" id="L653">                    <span class="tok-kw">else</span> =&gt; |err| os.unexpectedErrno(err),</span>
<span class="line" id="L654">                };</span>
<span class="line" id="L655">            },</span>
<span class="line" id="L656">            <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L657">                <span class="tok-kw">var</span> count: <span class="tok-type">c_int</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L658">                <span class="tok-kw">var</span> count_len: <span class="tok-type">usize</span> = <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">c_int</span>);</span>
<span class="line" id="L659">                <span class="tok-kw">const</span> name = <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> target.isDarwin()) <span class="tok-str">&quot;hw.logicalcpu&quot;</span> <span class="tok-kw">else</span> <span class="tok-str">&quot;hw.ncpu&quot;</span>;</span>
<span class="line" id="L660">                os.sysctlbynameZ(name, &amp;count, &amp;count_len, <span class="tok-null">null</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L661">                    <span class="tok-kw">error</span>.NameTooLong, <span class="tok-kw">error</span>.UnknownName =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L662">                    <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L663">                };</span>
<span class="line" id="L664">                <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(count));</span>
<span class="line" id="L665">            },</span>
<span class="line" id="L666">        }</span>
<span class="line" id="L667">    }</span>
<span class="line" id="L668"></span>
<span class="line" id="L669">    handle: ThreadHandle,</span>
<span class="line" id="L670"></span>
<span class="line" id="L671">    <span class="tok-kw">fn</span> <span class="tok-fn">spawn</span>(config: SpawnConfig, <span class="tok-kw">comptime</span> f: <span class="tok-kw">anytype</span>, args: <span class="tok-kw">anytype</span>) !Impl {</span>
<span class="line" id="L672">        <span class="tok-kw">const</span> Args = <span class="tok-builtin">@TypeOf</span>(args);</span>
<span class="line" id="L673">        <span class="tok-kw">const</span> allocator = std.heap.c_allocator;</span>
<span class="line" id="L674"></span>
<span class="line" id="L675">        <span class="tok-kw">const</span> Instance = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L676">            <span class="tok-kw">fn</span> <span class="tok-fn">entryFn</span>(raw_arg: ?*<span class="tok-type">anyopaque</span>) <span class="tok-kw">callconv</span>(.C) ?*<span class="tok-type">anyopaque</span> {</span>
<span class="line" id="L677">                <span class="tok-comment">// @alignCast() below doesn't support zero-sized-types (ZST)</span>
</span>
<span class="line" id="L678">                <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Args) &lt; <span class="tok-number">1</span>) {</span>
<span class="line" id="L679">                    <span class="tok-kw">return</span> callFn(f, <span class="tok-builtin">@as</span>(Args, <span class="tok-null">undefined</span>));</span>
<span class="line" id="L680">                }</span>
<span class="line" id="L681"></span>
<span class="line" id="L682">                <span class="tok-kw">const</span> args_ptr: *Args = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(raw_arg));</span>
<span class="line" id="L683">                <span class="tok-kw">defer</span> allocator.destroy(args_ptr);</span>
<span class="line" id="L684">                <span class="tok-kw">return</span> callFn(f, args_ptr.*);</span>
<span class="line" id="L685">            }</span>
<span class="line" id="L686">        };</span>
<span class="line" id="L687"></span>
<span class="line" id="L688">        <span class="tok-kw">const</span> args_ptr = <span class="tok-kw">try</span> allocator.create(Args);</span>
<span class="line" id="L689">        args_ptr.* = args;</span>
<span class="line" id="L690">        <span class="tok-kw">errdefer</span> allocator.destroy(args_ptr);</span>
<span class="line" id="L691"></span>
<span class="line" id="L692">        <span class="tok-kw">var</span> attr: c.pthread_attr_t = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L693">        <span class="tok-kw">if</span> (c.pthread_attr_init(&amp;attr) != .SUCCESS) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources;</span>
<span class="line" id="L694">        <span class="tok-kw">defer</span> assert(c.pthread_attr_destroy(&amp;attr) == .SUCCESS);</span>
<span class="line" id="L695"></span>
<span class="line" id="L696">        <span class="tok-comment">// Use the same set of parameters used by the libc-less impl.</span>
</span>
<span class="line" id="L697">        <span class="tok-kw">const</span> stack_size = <span class="tok-builtin">@max</span>(config.stack_size, <span class="tok-number">16</span> * <span class="tok-number">1024</span>);</span>
<span class="line" id="L698">        assert(c.pthread_attr_setstacksize(&amp;attr, stack_size) == .SUCCESS);</span>
<span class="line" id="L699">        assert(c.pthread_attr_setguardsize(&amp;attr, std.mem.page_size) == .SUCCESS);</span>
<span class="line" id="L700"></span>
<span class="line" id="L701">        <span class="tok-kw">var</span> handle: c.pthread_t = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L702">        <span class="tok-kw">switch</span> (c.pthread_create(</span>
<span class="line" id="L703">            &amp;handle,</span>
<span class="line" id="L704">            &amp;attr,</span>
<span class="line" id="L705">            Instance.entryFn,</span>
<span class="line" id="L706">            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Args) &gt; <span class="tok-number">1</span>) <span class="tok-builtin">@as</span>(*<span class="tok-type">anyopaque</span>, <span class="tok-builtin">@ptrCast</span>(args_ptr)) <span class="tok-kw">else</span> <span class="tok-null">undefined</span>,</span>
<span class="line" id="L707">        )) {</span>
<span class="line" id="L708">            .SUCCESS =&gt; <span class="tok-kw">return</span> Impl{ .handle = handle },</span>
<span class="line" id="L709">            .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L710">            .PERM =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L711">            .INVAL =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L712">            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> os.unexpectedErrno(err),</span>
<span class="line" id="L713">        }</span>
<span class="line" id="L714">    }</span>
<span class="line" id="L715"></span>
<span class="line" id="L716">    <span class="tok-kw">fn</span> <span class="tok-fn">getHandle</span>(self: Impl) ThreadHandle {</span>
<span class="line" id="L717">        <span class="tok-kw">return</span> self.handle;</span>
<span class="line" id="L718">    }</span>
<span class="line" id="L719"></span>
<span class="line" id="L720">    <span class="tok-kw">fn</span> <span class="tok-fn">detach</span>(self: Impl) <span class="tok-type">void</span> {</span>
<span class="line" id="L721">        <span class="tok-kw">switch</span> (c.pthread_detach(self.handle)) {</span>
<span class="line" id="L722">            .SUCCESS =&gt; {},</span>
<span class="line" id="L723">            .INVAL =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// thread handle is not joinable</span>
</span>
<span class="line" id="L724">            .SRCH =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// thread handle is invalid</span>
</span>
<span class="line" id="L725">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L726">        }</span>
<span class="line" id="L727">    }</span>
<span class="line" id="L728"></span>
<span class="line" id="L729">    <span class="tok-kw">fn</span> <span class="tok-fn">join</span>(self: Impl) <span class="tok-type">void</span> {</span>
<span class="line" id="L730">        <span class="tok-kw">switch</span> (c.pthread_join(self.handle, <span class="tok-null">null</span>)) {</span>
<span class="line" id="L731">            .SUCCESS =&gt; {},</span>
<span class="line" id="L732">            .INVAL =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// thread handle is not joinable (or another thread is already joining in)</span>
</span>
<span class="line" id="L733">            .SRCH =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// thread handle is invalid</span>
</span>
<span class="line" id="L734">            .DEADLK =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// two threads tried to join each other</span>
</span>
<span class="line" id="L735">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L736">        }</span>
<span class="line" id="L737">    }</span>
<span class="line" id="L738">};</span>
<span class="line" id="L739"></span>
<span class="line" id="L740"><span class="tok-kw">const</span> WasiThreadImpl = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L741">    thread: *WasiThread,</span>
<span class="line" id="L742"></span>
<span class="line" id="L743">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ThreadHandle = <span class="tok-type">i32</span>;</span>
<span class="line" id="L744">    <span class="tok-kw">threadlocal</span> <span class="tok-kw">var</span> tls_thread_id: Id = <span class="tok-number">0</span>;</span>
<span class="line" id="L745"></span>
<span class="line" id="L746">    <span class="tok-kw">const</span> WasiThread = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L747">        <span class="tok-comment">/// Thread ID</span></span>
<span class="line" id="L748">        tid: std.atomic.Value(<span class="tok-type">i32</span>) = std.atomic.Value(<span class="tok-type">i32</span>).init(<span class="tok-number">0</span>),</span>
<span class="line" id="L749">        <span class="tok-comment">/// Contains all memory which was allocated to bootstrap this thread, including:</span></span>
<span class="line" id="L750">        <span class="tok-comment">/// - Guard page</span></span>
<span class="line" id="L751">        <span class="tok-comment">/// - Stack</span></span>
<span class="line" id="L752">        <span class="tok-comment">/// - TLS segment</span></span>
<span class="line" id="L753">        <span class="tok-comment">/// - `Instance`</span></span>
<span class="line" id="L754">        <span class="tok-comment">/// All memory is freed upon call to `join`</span></span>
<span class="line" id="L755">        memory: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L756">        <span class="tok-comment">/// The allocator used to allocate the thread's memory,</span></span>
<span class="line" id="L757">        <span class="tok-comment">/// which is also used during `join` to ensure clean-up.</span></span>
<span class="line" id="L758">        allocator: std.mem.Allocator,</span>
<span class="line" id="L759">        <span class="tok-comment">/// The current state of the thread.</span></span>
<span class="line" id="L760">        state: State = State.init(.running),</span>
<span class="line" id="L761">    };</span>
<span class="line" id="L762"></span>
<span class="line" id="L763">    <span class="tok-comment">/// A meta-data structure used to bootstrap a thread</span></span>
<span class="line" id="L764">    <span class="tok-kw">const</span> Instance = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L765">        thread: WasiThread,</span>
<span class="line" id="L766">        <span class="tok-comment">/// Contains the offset to the new __tls_base.</span></span>
<span class="line" id="L767">        <span class="tok-comment">/// The offset starting from the memory's base.</span></span>
<span class="line" id="L768">        tls_offset: <span class="tok-type">usize</span>,</span>
<span class="line" id="L769">        <span class="tok-comment">/// Contains the offset to the stack for the newly spawned thread.</span></span>
<span class="line" id="L770">        <span class="tok-comment">/// The offset is calculated starting from the memory's base.</span></span>
<span class="line" id="L771">        stack_offset: <span class="tok-type">usize</span>,</span>
<span class="line" id="L772">        <span class="tok-comment">/// Contains the raw pointer value to the wrapper which holds all arguments</span></span>
<span class="line" id="L773">        <span class="tok-comment">/// for the callback.</span></span>
<span class="line" id="L774">        raw_ptr: <span class="tok-type">usize</span>,</span>
<span class="line" id="L775">        <span class="tok-comment">/// Function pointer to a wrapping function which will call the user's</span></span>
<span class="line" id="L776">        <span class="tok-comment">/// function upon thread spawn. The above mentioned pointer will be passed</span></span>
<span class="line" id="L777">        <span class="tok-comment">/// to this function pointer as its argument.</span></span>
<span class="line" id="L778">        call_back: *<span class="tok-kw">const</span> <span class="tok-kw">fn</span> (<span class="tok-type">usize</span>) <span class="tok-type">void</span>,</span>
<span class="line" id="L779">        <span class="tok-comment">/// When a thread is in `detached` state, we must free all of its memory</span></span>
<span class="line" id="L780">        <span class="tok-comment">/// upon thread completion. However, as this is done while still within</span></span>
<span class="line" id="L781">        <span class="tok-comment">/// the thread, we must first jump back to the main thread's stack or else</span></span>
<span class="line" id="L782">        <span class="tok-comment">/// we end up freeing the stack that we're currently using.</span></span>
<span class="line" id="L783">        original_stack_pointer: [*]<span class="tok-type">u8</span>,</span>
<span class="line" id="L784">    };</span>
<span class="line" id="L785"></span>
<span class="line" id="L786">    <span class="tok-kw">const</span> State = std.atomic.Value(<span class="tok-kw">enum</span>(<span class="tok-type">u8</span>) { running, completed, detached });</span>
<span class="line" id="L787"></span>
<span class="line" id="L788">    <span class="tok-kw">fn</span> <span class="tok-fn">getCurrentId</span>() Id {</span>
<span class="line" id="L789">        <span class="tok-kw">return</span> tls_thread_id;</span>
<span class="line" id="L790">    }</span>
<span class="line" id="L791"></span>
<span class="line" id="L792">    <span class="tok-kw">fn</span> <span class="tok-fn">getHandle</span>(self: Impl) ThreadHandle {</span>
<span class="line" id="L793">        <span class="tok-kw">return</span> self.thread.tid.load(.SeqCst);</span>
<span class="line" id="L794">    }</span>
<span class="line" id="L795"></span>
<span class="line" id="L796">    <span class="tok-kw">fn</span> <span class="tok-fn">detach</span>(self: Impl) <span class="tok-type">void</span> {</span>
<span class="line" id="L797">        <span class="tok-kw">switch</span> (self.thread.state.swap(.detached, .SeqCst)) {</span>
<span class="line" id="L798">            .running =&gt; {},</span>
<span class="line" id="L799">            .completed =&gt; self.join(),</span>
<span class="line" id="L800">            .detached =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L801">        }</span>
<span class="line" id="L802">    }</span>
<span class="line" id="L803"></span>
<span class="line" id="L804">    <span class="tok-kw">fn</span> <span class="tok-fn">join</span>(self: Impl) <span class="tok-type">void</span> {</span>
<span class="line" id="L805">        <span class="tok-kw">defer</span> {</span>
<span class="line" id="L806">            <span class="tok-comment">// Create a copy of the allocator so we do not free the reference to the</span>
</span>
<span class="line" id="L807">            <span class="tok-comment">// original allocator while freeing the memory.</span>
</span>
<span class="line" id="L808">            <span class="tok-kw">var</span> allocator = self.thread.allocator;</span>
<span class="line" id="L809">            allocator.free(self.thread.memory);</span>
<span class="line" id="L810">        }</span>
<span class="line" id="L811"></span>
<span class="line" id="L812">        <span class="tok-kw">var</span> spin: <span class="tok-type">u8</span> = <span class="tok-number">10</span>;</span>
<span class="line" id="L813">        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L814">            <span class="tok-kw">const</span> tid = self.thread.tid.load(.SeqCst);</span>
<span class="line" id="L815">            <span class="tok-kw">if</span> (tid == <span class="tok-number">0</span>) {</span>
<span class="line" id="L816">                <span class="tok-kw">break</span>;</span>
<span class="line" id="L817">            }</span>
<span class="line" id="L818"></span>
<span class="line" id="L819">            <span class="tok-kw">if</span> (spin &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L820">                spin -= <span class="tok-number">1</span>;</span>
<span class="line" id="L821">                std.atomic.spinLoopHint();</span>
<span class="line" id="L822">                <span class="tok-kw">continue</span>;</span>
<span class="line" id="L823">            }</span>
<span class="line" id="L824"></span>
<span class="line" id="L825">            <span class="tok-kw">const</span> result = <span class="tok-kw">asm</span> (</span>
<span class="line" id="L826">                <span class="tok-str">\\ local.get %[ptr]</span></span>

<span class="line" id="L827">                <span class="tok-str">\\ local.get %[expected]</span></span>

<span class="line" id="L828">                <span class="tok-str">\\ i64.const -1 # infinite</span></span>

<span class="line" id="L829">                <span class="tok-str">\\ memory.atomic.wait32 0</span></span>

<span class="line" id="L830">                <span class="tok-str">\\ local.set %[ret]</span></span>

<span class="line" id="L831">                : [ret] <span class="tok-str">&quot;=r&quot;</span> (-&gt; <span class="tok-type">u32</span>),</span>
<span class="line" id="L832">                : [ptr] <span class="tok-str">&quot;r&quot;</span> (&amp;self.thread.tid.value),</span>
<span class="line" id="L833">                  [expected] <span class="tok-str">&quot;r&quot;</span> (tid),</span>
<span class="line" id="L834">            );</span>
<span class="line" id="L835">            <span class="tok-kw">switch</span> (result) {</span>
<span class="line" id="L836">                <span class="tok-number">0</span> =&gt; <span class="tok-kw">continue</span>, <span class="tok-comment">// ok</span>
</span>
<span class="line" id="L837">                <span class="tok-number">1</span> =&gt; <span class="tok-kw">continue</span>, <span class="tok-comment">// expected =! loaded</span>
</span>
<span class="line" id="L838">                <span class="tok-number">2</span> =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// timeout (infinite)</span>
</span>
<span class="line" id="L839">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L840">            }</span>
<span class="line" id="L841">        }</span>
<span class="line" id="L842">    }</span>
<span class="line" id="L843"></span>
<span class="line" id="L844">    <span class="tok-kw">fn</span> <span class="tok-fn">spawn</span>(config: std.Thread.SpawnConfig, <span class="tok-kw">comptime</span> f: <span class="tok-kw">anytype</span>, args: <span class="tok-kw">anytype</span>) !WasiThreadImpl {</span>
<span class="line" id="L845">        <span class="tok-kw">if</span> (config.allocator == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory; <span class="tok-comment">// an allocator is required to spawn a WASI-thread</span>
</span>
<span class="line" id="L846"></span>
<span class="line" id="L847">        <span class="tok-comment">// Wrapping struct required to hold the user-provided function arguments.</span>
</span>
<span class="line" id="L848">        <span class="tok-kw">const</span> Wrapper = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L849">            args: <span class="tok-builtin">@TypeOf</span>(args),</span>
<span class="line" id="L850">            <span class="tok-kw">fn</span> <span class="tok-fn">entry</span>(ptr: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L851">                <span class="tok-kw">const</span> w: *<span class="tok-builtin">@This</span>() = <span class="tok-builtin">@ptrFromInt</span>(ptr);</span>
<span class="line" id="L852">                <span class="tok-builtin">@call</span>(.auto, f, w.args);</span>
<span class="line" id="L853">            }</span>
<span class="line" id="L854">        };</span>
<span class="line" id="L855"></span>
<span class="line" id="L856">        <span class="tok-kw">var</span> stack_offset: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L857">        <span class="tok-kw">var</span> tls_offset: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L858">        <span class="tok-kw">var</span> wrapper_offset: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L859">        <span class="tok-kw">var</span> instance_offset: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L860"></span>
<span class="line" id="L861">        <span class="tok-comment">// Calculate the bytes we have to allocate to store all thread information, including:</span>
</span>
<span class="line" id="L862">        <span class="tok-comment">// - The actual stack for the thread</span>
</span>
<span class="line" id="L863">        <span class="tok-comment">// - The TLS segment</span>
</span>
<span class="line" id="L864">        <span class="tok-comment">// - `Instance` - containing information about how to call the user's function.</span>
</span>
<span class="line" id="L865">        <span class="tok-kw">const</span> map_bytes = blk: {</span>
<span class="line" id="L866">            <span class="tok-comment">// start with atleast a single page, which is used as a guard to prevent</span>
</span>
<span class="line" id="L867">            <span class="tok-comment">// other threads clobbering our new thread.</span>
</span>
<span class="line" id="L868">            <span class="tok-comment">// Unfortunately, WebAssembly has no notion of read-only segments, so this</span>
</span>
<span class="line" id="L869">            <span class="tok-comment">// is only a best effort.</span>
</span>
<span class="line" id="L870">            <span class="tok-kw">var</span> bytes: <span class="tok-type">usize</span> = std.wasm.page_size;</span>
<span class="line" id="L871"></span>
<span class="line" id="L872">            bytes = std.mem.alignForward(<span class="tok-type">usize</span>, bytes, <span class="tok-number">16</span>); <span class="tok-comment">// align stack to 16 bytes</span>
</span>
<span class="line" id="L873">            stack_offset = bytes;</span>
<span class="line" id="L874">            bytes += <span class="tok-builtin">@max</span>(std.wasm.page_size, config.stack_size);</span>
<span class="line" id="L875"></span>
<span class="line" id="L876">            bytes = std.mem.alignForward(<span class="tok-type">usize</span>, bytes, __tls_align());</span>
<span class="line" id="L877">            tls_offset = bytes;</span>
<span class="line" id="L878">            bytes += __tls_size();</span>
<span class="line" id="L879"></span>
<span class="line" id="L880">            bytes = std.mem.alignForward(<span class="tok-type">usize</span>, bytes, <span class="tok-builtin">@alignOf</span>(Wrapper));</span>
<span class="line" id="L881">            wrapper_offset = bytes;</span>
<span class="line" id="L882">            bytes += <span class="tok-builtin">@sizeOf</span>(Wrapper);</span>
<span class="line" id="L883"></span>
<span class="line" id="L884">            bytes = std.mem.alignForward(<span class="tok-type">usize</span>, bytes, <span class="tok-builtin">@alignOf</span>(Instance));</span>
<span class="line" id="L885">            instance_offset = bytes;</span>
<span class="line" id="L886">            bytes += <span class="tok-builtin">@sizeOf</span>(Instance);</span>
<span class="line" id="L887"></span>
<span class="line" id="L888">            bytes = std.mem.alignForward(<span class="tok-type">usize</span>, bytes, std.wasm.page_size);</span>
<span class="line" id="L889">            <span class="tok-kw">break</span> :blk bytes;</span>
<span class="line" id="L890">        };</span>
<span class="line" id="L891"></span>
<span class="line" id="L892">        <span class="tok-comment">// Allocate the amount of memory required for all meta data.</span>
</span>
<span class="line" id="L893">        <span class="tok-kw">const</span> allocated_memory = <span class="tok-kw">try</span> config.allocator.?.alloc(<span class="tok-type">u8</span>, map_bytes);</span>
<span class="line" id="L894"></span>
<span class="line" id="L895">        <span class="tok-kw">const</span> wrapper: *Wrapper = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;allocated_memory[wrapper_offset]));</span>
<span class="line" id="L896">        wrapper.* = .{ .args = args };</span>
<span class="line" id="L897"></span>
<span class="line" id="L898">        <span class="tok-kw">const</span> instance: *Instance = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;allocated_memory[instance_offset]));</span>
<span class="line" id="L899">        instance.* = .{</span>
<span class="line" id="L900">            .thread = .{ .memory = allocated_memory, .allocator = config.allocator.? },</span>
<span class="line" id="L901">            .tls_offset = tls_offset,</span>
<span class="line" id="L902">            .stack_offset = stack_offset,</span>
<span class="line" id="L903">            .raw_ptr = <span class="tok-builtin">@intFromPtr</span>(wrapper),</span>
<span class="line" id="L904">            .call_back = &amp;Wrapper.entry,</span>
<span class="line" id="L905">            .original_stack_pointer = __get_stack_pointer(),</span>
<span class="line" id="L906">        };</span>
<span class="line" id="L907"></span>
<span class="line" id="L908">        <span class="tok-kw">const</span> tid = spawnWasiThread(instance);</span>
<span class="line" id="L909">        <span class="tok-comment">// The specification says any value lower than 0 indicates an error.</span>
</span>
<span class="line" id="L910">        <span class="tok-comment">// The values of such error are unspecified. WASI-Libc treats it as EAGAIN.</span>
</span>
<span class="line" id="L911">        <span class="tok-kw">if</span> (tid &lt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L912">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources;</span>
<span class="line" id="L913">        }</span>
<span class="line" id="L914">        instance.thread.tid.store(tid, .SeqCst);</span>
<span class="line" id="L915"></span>
<span class="line" id="L916">        <span class="tok-kw">return</span> .{ .thread = &amp;instance.thread };</span>
<span class="line" id="L917">    }</span>
<span class="line" id="L918"></span>
<span class="line" id="L919">    <span class="tok-comment">/// Bootstrap procedure, called by the host environment after thread creation.</span></span>
<span class="line" id="L920">    <span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">wasi_thread_start</span>(tid: <span class="tok-type">i32</span>, arg: *Instance) <span class="tok-type">void</span> {</span>
<span class="line" id="L921">        <span class="tok-kw">if</span> (builtin.single_threaded) {</span>
<span class="line" id="L922">            <span class="tok-comment">// ensure function is not analyzed in single-threaded mode</span>
</span>
<span class="line" id="L923">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L924">        }</span>
<span class="line" id="L925">        __set_stack_pointer(arg.thread.memory.ptr + arg.stack_offset);</span>
<span class="line" id="L926">        __wasm_init_tls(arg.thread.memory.ptr + arg.tls_offset);</span>
<span class="line" id="L927">        <span class="tok-builtin">@atomicStore</span>(<span class="tok-type">u32</span>, &amp;WasiThreadImpl.tls_thread_id, <span class="tok-builtin">@intCast</span>(tid), .SeqCst);</span>
<span class="line" id="L928"></span>
<span class="line" id="L929">        <span class="tok-comment">// Finished bootstrapping, call user's procedure.</span>
</span>
<span class="line" id="L930">        arg.call_back(arg.raw_ptr);</span>
<span class="line" id="L931"></span>
<span class="line" id="L932">        <span class="tok-kw">switch</span> (arg.thread.state.swap(.completed, .SeqCst)) {</span>
<span class="line" id="L933">            .running =&gt; {</span>
<span class="line" id="L934">                <span class="tok-comment">// reset the Thread ID</span>
</span>
<span class="line" id="L935">                <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (</span>
<span class="line" id="L936">                    <span class="tok-str">\\ local.get %[ptr]</span></span>

<span class="line" id="L937">                    <span class="tok-str">\\ i32.const 0</span></span>

<span class="line" id="L938">                    <span class="tok-str">\\ i32.atomic.store 0</span></span>

<span class="line" id="L939">                    :</span>
<span class="line" id="L940">                    : [ptr] <span class="tok-str">&quot;r&quot;</span> (&amp;arg.thread.tid.value),</span>
<span class="line" id="L941">                );</span>
<span class="line" id="L942"></span>
<span class="line" id="L943">                <span class="tok-comment">// Wake the main thread listening to this thread</span>
</span>
<span class="line" id="L944">                <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (</span>
<span class="line" id="L945">                    <span class="tok-str">\\ local.get %[ptr]</span></span>

<span class="line" id="L946">                    <span class="tok-str">\\ i32.const 1 # waiters</span></span>

<span class="line" id="L947">                    <span class="tok-str">\\ memory.atomic.notify 0</span></span>

<span class="line" id="L948">                    <span class="tok-str">\\ drop # no need to know the waiters</span></span>

<span class="line" id="L949">                    :</span>
<span class="line" id="L950">                    : [ptr] <span class="tok-str">&quot;r&quot;</span> (&amp;arg.thread.tid.value),</span>
<span class="line" id="L951">                );</span>
<span class="line" id="L952">            },</span>
<span class="line" id="L953">            .completed =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L954">            .detached =&gt; {</span>
<span class="line" id="L955">                <span class="tok-comment">// restore the original stack pointer so we can free the memory</span>
</span>
<span class="line" id="L956">                <span class="tok-comment">// without having to worry about freeing the stack</span>
</span>
<span class="line" id="L957">                __set_stack_pointer(arg.original_stack_pointer);</span>
<span class="line" id="L958">                <span class="tok-comment">// Ensure a copy so we don't free the allocator reference itself</span>
</span>
<span class="line" id="L959">                <span class="tok-kw">var</span> allocator = arg.thread.allocator;</span>
<span class="line" id="L960">                allocator.free(arg.thread.memory);</span>
<span class="line" id="L961">            },</span>
<span class="line" id="L962">        }</span>
<span class="line" id="L963">    }</span>
<span class="line" id="L964"></span>
<span class="line" id="L965">    <span class="tok-comment">/// Asks the host to create a new thread for us.</span></span>
<span class="line" id="L966">    <span class="tok-comment">/// Newly created thread will call `wasi_tread_start` with the thread ID as well</span></span>
<span class="line" id="L967">    <span class="tok-comment">/// as the input `arg` that was provided to `spawnWasiThread`</span></span>
<span class="line" id="L968">    <span class="tok-kw">const</span> spawnWasiThread = @&quot;thread-spawn&quot;;</span>
<span class="line" id="L969">    <span class="tok-kw">extern</span> <span class="tok-str">&quot;wasi&quot;</span> <span class="tok-kw">fn</span> <span class="tok-fn">@&quot;thread-spawn&quot;</span>(arg: *Instance) <span class="tok-type">i32</span>;</span>
<span class="line" id="L970"></span>
<span class="line" id="L971">    <span class="tok-comment">/// Initializes the TLS data segment starting at `memory`.</span></span>
<span class="line" id="L972">    <span class="tok-comment">/// This is a synthetic function, generated by the linker.</span></span>
<span class="line" id="L973">    <span class="tok-kw">extern</span> <span class="tok-kw">fn</span> <span class="tok-fn">__wasm_init_tls</span>(memory: [*]<span class="tok-type">u8</span>) <span class="tok-type">void</span>;</span>
<span class="line" id="L974"></span>
<span class="line" id="L975">    <span class="tok-comment">/// Returns a pointer to the base of the TLS data segment for the current thread</span></span>
<span class="line" id="L976">    <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">__tls_base</span>() [*]<span class="tok-type">u8</span> {</span>
<span class="line" id="L977">        <span class="tok-kw">return</span> <span class="tok-kw">asm</span> (</span>
<span class="line" id="L978">            <span class="tok-str">\\ .globaltype __tls_base, i32</span></span>

<span class="line" id="L979">            <span class="tok-str">\\ global.get __tls_base</span></span>

<span class="line" id="L980">            <span class="tok-str">\\ local.set %[ret]</span></span>

<span class="line" id="L981">            : [ret] <span class="tok-str">&quot;=r&quot;</span> (-&gt; [*]<span class="tok-type">u8</span>),</span>
<span class="line" id="L982">        );</span>
<span class="line" id="L983">    }</span>
<span class="line" id="L984"></span>
<span class="line" id="L985">    <span class="tok-comment">/// Returns the size of the TLS segment</span></span>
<span class="line" id="L986">    <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">__tls_size</span>() <span class="tok-type">u32</span> {</span>
<span class="line" id="L987">        <span class="tok-kw">return</span> <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (</span>
<span class="line" id="L988">            <span class="tok-str">\\ .globaltype __tls_size, i32, immutable</span></span>

<span class="line" id="L989">            <span class="tok-str">\\ global.get __tls_size</span></span>

<span class="line" id="L990">            <span class="tok-str">\\ local.set %[ret]</span></span>

<span class="line" id="L991">            : [ret] <span class="tok-str">&quot;=r&quot;</span> (-&gt; <span class="tok-type">u32</span>),</span>
<span class="line" id="L992">        );</span>
<span class="line" id="L993">    }</span>
<span class="line" id="L994"></span>
<span class="line" id="L995">    <span class="tok-comment">/// Returns the alignment of the TLS segment</span></span>
<span class="line" id="L996">    <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">__tls_align</span>() <span class="tok-type">u32</span> {</span>
<span class="line" id="L997">        <span class="tok-kw">return</span> <span class="tok-kw">asm</span> (</span>
<span class="line" id="L998">            <span class="tok-str">\\ .globaltype __tls_align, i32, immutable</span></span>

<span class="line" id="L999">            <span class="tok-str">\\ global.get __tls_align</span></span>

<span class="line" id="L1000">            <span class="tok-str">\\ local.set %[ret]</span></span>

<span class="line" id="L1001">            : [ret] <span class="tok-str">&quot;=r&quot;</span> (-&gt; <span class="tok-type">u32</span>),</span>
<span class="line" id="L1002">        );</span>
<span class="line" id="L1003">    }</span>
<span class="line" id="L1004"></span>
<span class="line" id="L1005">    <span class="tok-comment">/// Allows for setting the stack pointer in the WebAssembly module.</span></span>
<span class="line" id="L1006">    <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">__set_stack_pointer</span>(addr: [*]<span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L1007">        <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (</span>
<span class="line" id="L1008">            <span class="tok-str">\\ local.get %[ptr]</span></span>

<span class="line" id="L1009">            <span class="tok-str">\\ global.set __stack_pointer</span></span>

<span class="line" id="L1010">            :</span>
<span class="line" id="L1011">            : [ptr] <span class="tok-str">&quot;r&quot;</span> (addr),</span>
<span class="line" id="L1012">        );</span>
<span class="line" id="L1013">    }</span>
<span class="line" id="L1014"></span>
<span class="line" id="L1015">    <span class="tok-comment">/// Returns the current value of the stack pointer</span></span>
<span class="line" id="L1016">    <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">__get_stack_pointer</span>() [*]<span class="tok-type">u8</span> {</span>
<span class="line" id="L1017">        <span class="tok-kw">return</span> <span class="tok-kw">asm</span> (</span>
<span class="line" id="L1018">            <span class="tok-str">\\ global.get __stack_pointer</span></span>

<span class="line" id="L1019">            <span class="tok-str">\\ local.set %[stack_ptr]</span></span>

<span class="line" id="L1020">            : [stack_ptr] <span class="tok-str">&quot;=r&quot;</span> (-&gt; [*]<span class="tok-type">u8</span>),</span>
<span class="line" id="L1021">        );</span>
<span class="line" id="L1022">    }</span>
<span class="line" id="L1023">};</span>
<span class="line" id="L1024"></span>
<span class="line" id="L1025"><span class="tok-kw">const</span> LinuxThreadImpl = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1026">    <span class="tok-kw">const</span> linux = os.linux;</span>
<span class="line" id="L1027"></span>
<span class="line" id="L1028">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ThreadHandle = <span class="tok-type">i32</span>;</span>
<span class="line" id="L1029"></span>
<span class="line" id="L1030">    <span class="tok-kw">threadlocal</span> <span class="tok-kw">var</span> tls_thread_id: ?Id = <span class="tok-null">null</span>;</span>
<span class="line" id="L1031"></span>
<span class="line" id="L1032">    <span class="tok-kw">fn</span> <span class="tok-fn">getCurrentId</span>() Id {</span>
<span class="line" id="L1033">        <span class="tok-kw">return</span> tls_thread_id <span class="tok-kw">orelse</span> {</span>
<span class="line" id="L1034">            <span class="tok-kw">const</span> tid = <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@bitCast</span>(linux.gettid()));</span>
<span class="line" id="L1035">            tls_thread_id = tid;</span>
<span class="line" id="L1036">            <span class="tok-kw">return</span> tid;</span>
<span class="line" id="L1037">        };</span>
<span class="line" id="L1038">    }</span>
<span class="line" id="L1039"></span>
<span class="line" id="L1040">    <span class="tok-kw">fn</span> <span class="tok-fn">getCpuCount</span>() !<span class="tok-type">usize</span> {</span>
<span class="line" id="L1041">        <span class="tok-kw">const</span> cpu_set = <span class="tok-kw">try</span> os.sched_getaffinity(<span class="tok-number">0</span>);</span>
<span class="line" id="L1042">        <span class="tok-comment">// TODO: should not need this usize cast</span>
</span>
<span class="line" id="L1043">        <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, os.CPU_COUNT(cpu_set));</span>
<span class="line" id="L1044">    }</span>
<span class="line" id="L1045"></span>
<span class="line" id="L1046">    thread: *ThreadCompletion,</span>
<span class="line" id="L1047"></span>
<span class="line" id="L1048">    <span class="tok-kw">const</span> ThreadCompletion = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1049">        completion: Completion = Completion.init(.running),</span>
<span class="line" id="L1050">        child_tid: std.atomic.Value(<span class="tok-type">i32</span>) = std.atomic.Value(<span class="tok-type">i32</span>).init(<span class="tok-number">1</span>),</span>
<span class="line" id="L1051">        parent_tid: <span class="tok-type">i32</span> = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L1052">        mapped: []<span class="tok-kw">align</span>(std.mem.page_size) <span class="tok-type">u8</span>,</span>
<span class="line" id="L1053"></span>
<span class="line" id="L1054">        <span class="tok-comment">/// Calls `munmap(mapped.ptr, mapped.len)` then `exit(1)` without touching the stack (which lives in `mapped.ptr`).</span></span>
<span class="line" id="L1055">        <span class="tok-comment">/// Ported over from musl libc's pthread detached implementation:</span></span>
<span class="line" id="L1056">        <span class="tok-comment">/// https://github.com/ifduyue/musl/search?q=__unmapself</span></span>
<span class="line" id="L1057">        <span class="tok-kw">fn</span> <span class="tok-fn">freeAndExit</span>(self: *ThreadCompletion) <span class="tok-type">noreturn</span> {</span>
<span class="line" id="L1058">            <span class="tok-kw">switch</span> (target.cpu.arch) {</span>
<span class="line" id="L1059">                .x86 =&gt; <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (</span>
<span class="line" id="L1060">                    <span class="tok-str">\\  movl $91, %%eax</span></span>

<span class="line" id="L1061">                    <span class="tok-str">\\  movl %[ptr], %%ebx</span></span>

<span class="line" id="L1062">                    <span class="tok-str">\\  movl %[len], %%ecx</span></span>

<span class="line" id="L1063">                    <span class="tok-str">\\  int $128</span></span>

<span class="line" id="L1064">                    <span class="tok-str">\\  movl $1, %%eax</span></span>

<span class="line" id="L1065">                    <span class="tok-str">\\  movl $0, %%ebx</span></span>

<span class="line" id="L1066">                    <span class="tok-str">\\  int $128</span></span>

<span class="line" id="L1067">                    :</span>
<span class="line" id="L1068">                    : [ptr] <span class="tok-str">&quot;r&quot;</span> (<span class="tok-builtin">@intFromPtr</span>(self.mapped.ptr)),</span>
<span class="line" id="L1069">                      [len] <span class="tok-str">&quot;r&quot;</span> (self.mapped.len),</span>
<span class="line" id="L1070">                    : <span class="tok-str">&quot;memory&quot;</span></span>
<span class="line" id="L1071">                ),</span>
<span class="line" id="L1072">                .x86_64 =&gt; <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (</span>
<span class="line" id="L1073">                    <span class="tok-str">\\  movq $11, %%rax</span></span>

<span class="line" id="L1074">                    <span class="tok-str">\\  syscall</span></span>

<span class="line" id="L1075">                    <span class="tok-str">\\  movq $60, %%rax</span></span>

<span class="line" id="L1076">                    <span class="tok-str">\\  movq $1, %%rdi</span></span>

<span class="line" id="L1077">                    <span class="tok-str">\\  syscall</span></span>

<span class="line" id="L1078">                    :</span>
<span class="line" id="L1079">                    : [ptr] <span class="tok-str">&quot;{rdi}&quot;</span> (<span class="tok-builtin">@intFromPtr</span>(self.mapped.ptr)),</span>
<span class="line" id="L1080">                      [len] <span class="tok-str">&quot;{rsi}&quot;</span> (self.mapped.len),</span>
<span class="line" id="L1081">                ),</span>
<span class="line" id="L1082">                .arm, .armeb, .thumb, .thumbeb =&gt; <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (</span>
<span class="line" id="L1083">                    <span class="tok-str">\\  mov r7, #91</span></span>

<span class="line" id="L1084">                    <span class="tok-str">\\  mov r0, %[ptr]</span></span>

<span class="line" id="L1085">                    <span class="tok-str">\\  mov r1, %[len]</span></span>

<span class="line" id="L1086">                    <span class="tok-str">\\  svc 0</span></span>

<span class="line" id="L1087">                    <span class="tok-str">\\  mov r7, #1</span></span>

<span class="line" id="L1088">                    <span class="tok-str">\\  mov r0, #0</span></span>

<span class="line" id="L1089">                    <span class="tok-str">\\  svc 0</span></span>

<span class="line" id="L1090">                    :</span>
<span class="line" id="L1091">                    : [ptr] <span class="tok-str">&quot;r&quot;</span> (<span class="tok-builtin">@intFromPtr</span>(self.mapped.ptr)),</span>
<span class="line" id="L1092">                      [len] <span class="tok-str">&quot;r&quot;</span> (self.mapped.len),</span>
<span class="line" id="L1093">                    : <span class="tok-str">&quot;memory&quot;</span></span>
<span class="line" id="L1094">                ),</span>
<span class="line" id="L1095">                .aarch64, .aarch64_be, .aarch64_32 =&gt; <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (</span>
<span class="line" id="L1096">                    <span class="tok-str">\\  mov x8, #215</span></span>

<span class="line" id="L1097">                    <span class="tok-str">\\  mov x0, %[ptr]</span></span>

<span class="line" id="L1098">                    <span class="tok-str">\\  mov x1, %[len]</span></span>

<span class="line" id="L1099">                    <span class="tok-str">\\  svc 0</span></span>

<span class="line" id="L1100">                    <span class="tok-str">\\  mov x8, #93</span></span>

<span class="line" id="L1101">                    <span class="tok-str">\\  mov x0, #0</span></span>

<span class="line" id="L1102">                    <span class="tok-str">\\  svc 0</span></span>

<span class="line" id="L1103">                    :</span>
<span class="line" id="L1104">                    : [ptr] <span class="tok-str">&quot;r&quot;</span> (<span class="tok-builtin">@intFromPtr</span>(self.mapped.ptr)),</span>
<span class="line" id="L1105">                      [len] <span class="tok-str">&quot;r&quot;</span> (self.mapped.len),</span>
<span class="line" id="L1106">                    : <span class="tok-str">&quot;memory&quot;</span></span>
<span class="line" id="L1107">                ),</span>
<span class="line" id="L1108">                .mips, .mipsel =&gt; <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (</span>
<span class="line" id="L1109">                    <span class="tok-str">\\  move $sp, $25</span></span>

<span class="line" id="L1110">                    <span class="tok-str">\\  li $2, 4091</span></span>

<span class="line" id="L1111">                    <span class="tok-str">\\  move $4, %[ptr]</span></span>

<span class="line" id="L1112">                    <span class="tok-str">\\  move $5, %[len]</span></span>

<span class="line" id="L1113">                    <span class="tok-str">\\  syscall</span></span>

<span class="line" id="L1114">                    <span class="tok-str">\\  li $2, 4001</span></span>

<span class="line" id="L1115">                    <span class="tok-str">\\  li $4, 0</span></span>

<span class="line" id="L1116">                    <span class="tok-str">\\  syscall</span></span>

<span class="line" id="L1117">                    :</span>
<span class="line" id="L1118">                    : [ptr] <span class="tok-str">&quot;r&quot;</span> (<span class="tok-builtin">@intFromPtr</span>(self.mapped.ptr)),</span>
<span class="line" id="L1119">                      [len] <span class="tok-str">&quot;r&quot;</span> (self.mapped.len),</span>
<span class="line" id="L1120">                    : <span class="tok-str">&quot;memory&quot;</span></span>
<span class="line" id="L1121">                ),</span>
<span class="line" id="L1122">                .mips64, .mips64el =&gt; <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (</span>
<span class="line" id="L1123">                    <span class="tok-str">\\  li $2, 4091</span></span>

<span class="line" id="L1124">                    <span class="tok-str">\\  move $4, %[ptr]</span></span>

<span class="line" id="L1125">                    <span class="tok-str">\\  move $5, %[len]</span></span>

<span class="line" id="L1126">                    <span class="tok-str">\\  syscall</span></span>

<span class="line" id="L1127">                    <span class="tok-str">\\  li $2, 4001</span></span>

<span class="line" id="L1128">                    <span class="tok-str">\\  li $4, 0</span></span>

<span class="line" id="L1129">                    <span class="tok-str">\\  syscall</span></span>

<span class="line" id="L1130">                    :</span>
<span class="line" id="L1131">                    : [ptr] <span class="tok-str">&quot;r&quot;</span> (<span class="tok-builtin">@intFromPtr</span>(self.mapped.ptr)),</span>
<span class="line" id="L1132">                      [len] <span class="tok-str">&quot;r&quot;</span> (self.mapped.len),</span>
<span class="line" id="L1133">                    : <span class="tok-str">&quot;memory&quot;</span></span>
<span class="line" id="L1134">                ),</span>
<span class="line" id="L1135">                .powerpc, .powerpcle, .powerpc64, .powerpc64le =&gt; <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (</span>
<span class="line" id="L1136">                    <span class="tok-str">\\  li 0, 91</span></span>

<span class="line" id="L1137">                    <span class="tok-str">\\  mr %[ptr], 3</span></span>

<span class="line" id="L1138">                    <span class="tok-str">\\  mr %[len], 4</span></span>

<span class="line" id="L1139">                    <span class="tok-str">\\  sc</span></span>

<span class="line" id="L1140">                    <span class="tok-str">\\  li 0, 1</span></span>

<span class="line" id="L1141">                    <span class="tok-str">\\  li 3, 0</span></span>

<span class="line" id="L1142">                    <span class="tok-str">\\  sc</span></span>

<span class="line" id="L1143">                    <span class="tok-str">\\  blr</span></span>

<span class="line" id="L1144">                    :</span>
<span class="line" id="L1145">                    : [ptr] <span class="tok-str">&quot;r&quot;</span> (<span class="tok-builtin">@intFromPtr</span>(self.mapped.ptr)),</span>
<span class="line" id="L1146">                      [len] <span class="tok-str">&quot;r&quot;</span> (self.mapped.len),</span>
<span class="line" id="L1147">                    : <span class="tok-str">&quot;memory&quot;</span></span>
<span class="line" id="L1148">                ),</span>
<span class="line" id="L1149">                .riscv64 =&gt; <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (</span>
<span class="line" id="L1150">                    <span class="tok-str">\\  li a7, 215</span></span>

<span class="line" id="L1151">                    <span class="tok-str">\\  mv a0, %[ptr]</span></span>

<span class="line" id="L1152">                    <span class="tok-str">\\  mv a1, %[len]</span></span>

<span class="line" id="L1153">                    <span class="tok-str">\\  ecall</span></span>

<span class="line" id="L1154">                    <span class="tok-str">\\  li a7, 93</span></span>

<span class="line" id="L1155">                    <span class="tok-str">\\  mv a0, zero</span></span>

<span class="line" id="L1156">                    <span class="tok-str">\\  ecall</span></span>

<span class="line" id="L1157">                    :</span>
<span class="line" id="L1158">                    : [ptr] <span class="tok-str">&quot;r&quot;</span> (<span class="tok-builtin">@intFromPtr</span>(self.mapped.ptr)),</span>
<span class="line" id="L1159">                      [len] <span class="tok-str">&quot;r&quot;</span> (self.mapped.len),</span>
<span class="line" id="L1160">                    : <span class="tok-str">&quot;memory&quot;</span></span>
<span class="line" id="L1161">                ),</span>
<span class="line" id="L1162">                .sparc64 =&gt; <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (</span>
<span class="line" id="L1163">                    <span class="tok-str">\\ # SPARCs really don't like it when active stack frames</span></span>

<span class="line" id="L1164">                    <span class="tok-str">\\ # is unmapped (it will result in a segfault), so we</span></span>

<span class="line" id="L1165">                    <span class="tok-str">\\ # force-deactivate it by running `restore` until</span></span>

<span class="line" id="L1166">                    <span class="tok-str">\\ # all frames are cleared.</span></span>

<span class="line" id="L1167">                    <span class="tok-str">\\  1:</span></span>

<span class="line" id="L1168">                    <span class="tok-str">\\  cmp %%fp, 0</span></span>

<span class="line" id="L1169">                    <span class="tok-str">\\  beq 2f</span></span>

<span class="line" id="L1170">                    <span class="tok-str">\\  nop</span></span>

<span class="line" id="L1171">                    <span class="tok-str">\\  ba 1b</span></span>

<span class="line" id="L1172">                    <span class="tok-str">\\  restore</span></span>

<span class="line" id="L1173">                    <span class="tok-str">\\  2:</span></span>

<span class="line" id="L1174">                    <span class="tok-str">\\  mov 73, %%g1</span></span>

<span class="line" id="L1175">                    <span class="tok-str">\\  mov %[ptr], %%o0</span></span>

<span class="line" id="L1176">                    <span class="tok-str">\\  mov %[len], %%o1</span></span>

<span class="line" id="L1177">                    <span class="tok-str">\\  # Flush register window contents to prevent background</span></span>

<span class="line" id="L1178">                    <span class="tok-str">\\  # memory access before unmapping the stack.</span></span>

<span class="line" id="L1179">                    <span class="tok-str">\\  flushw</span></span>

<span class="line" id="L1180">                    <span class="tok-str">\\  t 0x6d</span></span>

<span class="line" id="L1181">                    <span class="tok-str">\\  mov 1, %%g1</span></span>

<span class="line" id="L1182">                    <span class="tok-str">\\  mov 1, %%o0</span></span>

<span class="line" id="L1183">                    <span class="tok-str">\\  t 0x6d</span></span>

<span class="line" id="L1184">                    :</span>
<span class="line" id="L1185">                    : [ptr] <span class="tok-str">&quot;r&quot;</span> (<span class="tok-builtin">@intFromPtr</span>(self.mapped.ptr)),</span>
<span class="line" id="L1186">                      [len] <span class="tok-str">&quot;r&quot;</span> (self.mapped.len),</span>
<span class="line" id="L1187">                    : <span class="tok-str">&quot;memory&quot;</span></span>
<span class="line" id="L1188">                ),</span>
<span class="line" id="L1189">                <span class="tok-kw">else</span> =&gt; |cpu_arch| <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unsupported linux arch: &quot;</span> ++ <span class="tok-builtin">@tagName</span>(cpu_arch)),</span>
<span class="line" id="L1190">            }</span>
<span class="line" id="L1191">            <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L1192">        }</span>
<span class="line" id="L1193">    };</span>
<span class="line" id="L1194"></span>
<span class="line" id="L1195">    <span class="tok-kw">fn</span> <span class="tok-fn">spawn</span>(config: SpawnConfig, <span class="tok-kw">comptime</span> f: <span class="tok-kw">anytype</span>, args: <span class="tok-kw">anytype</span>) !Impl {</span>
<span class="line" id="L1196">        <span class="tok-kw">const</span> page_size = std.mem.page_size;</span>
<span class="line" id="L1197">        <span class="tok-kw">const</span> Args = <span class="tok-builtin">@TypeOf</span>(args);</span>
<span class="line" id="L1198">        <span class="tok-kw">const</span> Instance = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1199">            fn_args: Args,</span>
<span class="line" id="L1200">            thread: ThreadCompletion,</span>
<span class="line" id="L1201"></span>
<span class="line" id="L1202">            <span class="tok-kw">fn</span> <span class="tok-fn">entryFn</span>(raw_arg: <span class="tok-type">usize</span>) <span class="tok-kw">callconv</span>(.C) <span class="tok-type">u8</span> {</span>
<span class="line" id="L1203">                <span class="tok-kw">const</span> self = <span class="tok-builtin">@as</span>(*<span class="tok-builtin">@This</span>(), <span class="tok-builtin">@ptrFromInt</span>(raw_arg));</span>
<span class="line" id="L1204">                <span class="tok-kw">defer</span> <span class="tok-kw">switch</span> (self.thread.completion.swap(.completed, .SeqCst)) {</span>
<span class="line" id="L1205">                    .running =&gt; {},</span>
<span class="line" id="L1206">                    .completed =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1207">                    .detached =&gt; self.thread.freeAndExit(),</span>
<span class="line" id="L1208">                };</span>
<span class="line" id="L1209">                <span class="tok-kw">return</span> callFn(f, self.fn_args);</span>
<span class="line" id="L1210">            }</span>
<span class="line" id="L1211">        };</span>
<span class="line" id="L1212"></span>
<span class="line" id="L1213">        <span class="tok-kw">var</span> guard_offset: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1214">        <span class="tok-kw">var</span> stack_offset: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1215">        <span class="tok-kw">var</span> tls_offset: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1216">        <span class="tok-kw">var</span> instance_offset: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1217"></span>
<span class="line" id="L1218">        <span class="tok-kw">const</span> map_bytes = blk: {</span>
<span class="line" id="L1219">            <span class="tok-kw">var</span> bytes: <span class="tok-type">usize</span> = page_size;</span>
<span class="line" id="L1220">            guard_offset = bytes;</span>
<span class="line" id="L1221"></span>
<span class="line" id="L1222">            bytes += <span class="tok-builtin">@max</span>(page_size, config.stack_size);</span>
<span class="line" id="L1223">            bytes = std.mem.alignForward(<span class="tok-type">usize</span>, bytes, page_size);</span>
<span class="line" id="L1224">            stack_offset = bytes;</span>
<span class="line" id="L1225"></span>
<span class="line" id="L1226">            bytes = std.mem.alignForward(<span class="tok-type">usize</span>, bytes, linux.tls.tls_image.alloc_align);</span>
<span class="line" id="L1227">            tls_offset = bytes;</span>
<span class="line" id="L1228">            bytes += linux.tls.tls_image.alloc_size;</span>
<span class="line" id="L1229"></span>
<span class="line" id="L1230">            bytes = std.mem.alignForward(<span class="tok-type">usize</span>, bytes, <span class="tok-builtin">@alignOf</span>(Instance));</span>
<span class="line" id="L1231">            instance_offset = bytes;</span>
<span class="line" id="L1232">            bytes += <span class="tok-builtin">@sizeOf</span>(Instance);</span>
<span class="line" id="L1233"></span>
<span class="line" id="L1234">            bytes = std.mem.alignForward(<span class="tok-type">usize</span>, bytes, page_size);</span>
<span class="line" id="L1235">            <span class="tok-kw">break</span> :blk bytes;</span>
<span class="line" id="L1236">        };</span>
<span class="line" id="L1237"></span>
<span class="line" id="L1238">        <span class="tok-comment">// map all memory needed without read/write permissions</span>
</span>
<span class="line" id="L1239">        <span class="tok-comment">// to avoid committing the whole region right away</span>
</span>
<span class="line" id="L1240">        <span class="tok-comment">// anonymous mapping ensures file descriptor limits are not exceeded</span>
</span>
<span class="line" id="L1241">        <span class="tok-kw">const</span> mapped = os.mmap(</span>
<span class="line" id="L1242">            <span class="tok-null">null</span>,</span>
<span class="line" id="L1243">            map_bytes,</span>
<span class="line" id="L1244">            os.PROT.NONE,</span>
<span class="line" id="L1245">            os.MAP.PRIVATE | os.MAP.ANONYMOUS,</span>
<span class="line" id="L1246">            -<span class="tok-number">1</span>,</span>
<span class="line" id="L1247">            <span class="tok-number">0</span>,</span>
<span class="line" id="L1248">        ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1249">            <span class="tok-kw">error</span>.MemoryMappingNotSupported =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1250">            <span class="tok-kw">error</span>.AccessDenied =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1251">            <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1252">            <span class="tok-kw">error</span>.ProcessFdQuotaExceeded =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1253">            <span class="tok-kw">error</span>.SystemFdQuotaExceeded =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1254">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1255">        };</span>
<span class="line" id="L1256">        assert(mapped.len &gt;= map_bytes);</span>
<span class="line" id="L1257">        <span class="tok-kw">errdefer</span> os.munmap(mapped);</span>
<span class="line" id="L1258"></span>
<span class="line" id="L1259">        <span class="tok-comment">// map everything but the guard page as read/write</span>
</span>
<span class="line" id="L1260">        os.mprotect(</span>
<span class="line" id="L1261">            <span class="tok-builtin">@alignCast</span>(mapped[guard_offset..]),</span>
<span class="line" id="L1262">            os.PROT.READ | os.PROT.WRITE,</span>
<span class="line" id="L1263">        ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1264">            <span class="tok-kw">error</span>.AccessDenied =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1265">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1266">        };</span>
<span class="line" id="L1267"></span>
<span class="line" id="L1268">        <span class="tok-comment">// Prepare the TLS segment and prepare a user_desc struct when needed on x86</span>
</span>
<span class="line" id="L1269">        <span class="tok-kw">var</span> tls_ptr = os.linux.tls.prepareTLS(mapped[tls_offset..]);</span>
<span class="line" id="L1270">        <span class="tok-kw">var</span> user_desc: <span class="tok-kw">if</span> (target.cpu.arch == .x86) os.linux.user_desc <span class="tok-kw">else</span> <span class="tok-type">void</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1271">        <span class="tok-kw">if</span> (target.cpu.arch == .x86) {</span>
<span class="line" id="L1272">            <span class="tok-kw">defer</span> tls_ptr = <span class="tok-builtin">@intFromPtr</span>(&amp;user_desc);</span>
<span class="line" id="L1273">            user_desc = .{</span>
<span class="line" id="L1274">                .entry_number = os.linux.tls.tls_image.gdt_entry_number,</span>
<span class="line" id="L1275">                .base_addr = tls_ptr,</span>
<span class="line" id="L1276">                .limit = <span class="tok-number">0xfffff</span>,</span>
<span class="line" id="L1277">                .flags = .{</span>
<span class="line" id="L1278">                    .seg_32bit = <span class="tok-number">1</span>,</span>
<span class="line" id="L1279">                    .contents = <span class="tok-number">0</span>, <span class="tok-comment">// Data</span>
</span>
<span class="line" id="L1280">                    .read_exec_only = <span class="tok-number">0</span>,</span>
<span class="line" id="L1281">                    .limit_in_pages = <span class="tok-number">1</span>,</span>
<span class="line" id="L1282">                    .seg_not_present = <span class="tok-number">0</span>,</span>
<span class="line" id="L1283">                    .useable = <span class="tok-number">1</span>,</span>
<span class="line" id="L1284">                },</span>
<span class="line" id="L1285">            };</span>
<span class="line" id="L1286">        }</span>
<span class="line" id="L1287"></span>
<span class="line" id="L1288">        <span class="tok-kw">const</span> instance: *Instance = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;mapped[instance_offset]));</span>
<span class="line" id="L1289">        instance.* = .{</span>
<span class="line" id="L1290">            .fn_args = args,</span>
<span class="line" id="L1291">            .thread = .{ .mapped = mapped },</span>
<span class="line" id="L1292">        };</span>
<span class="line" id="L1293"></span>
<span class="line" id="L1294">        <span class="tok-kw">const</span> flags: <span class="tok-type">u32</span> = linux.CLONE.THREAD | linux.CLONE.DETACHED |</span>
<span class="line" id="L1295">            linux.CLONE.VM | linux.CLONE.FS | linux.CLONE.FILES |</span>
<span class="line" id="L1296">            linux.CLONE.PARENT_SETTID | linux.CLONE.CHILD_CLEARTID |</span>
<span class="line" id="L1297">            linux.CLONE.SIGHAND | linux.CLONE.SYSVSEM | linux.CLONE.SETTLS;</span>
<span class="line" id="L1298"></span>
<span class="line" id="L1299">        <span class="tok-kw">switch</span> (linux.getErrno(linux.clone(</span>
<span class="line" id="L1300">            Instance.entryFn,</span>
<span class="line" id="L1301">            <span class="tok-builtin">@intFromPtr</span>(&amp;mapped[stack_offset]),</span>
<span class="line" id="L1302">            flags,</span>
<span class="line" id="L1303">            <span class="tok-builtin">@intFromPtr</span>(instance),</span>
<span class="line" id="L1304">            &amp;instance.thread.parent_tid,</span>
<span class="line" id="L1305">            tls_ptr,</span>
<span class="line" id="L1306">            &amp;instance.thread.child_tid.raw,</span>
<span class="line" id="L1307">        ))) {</span>
<span class="line" id="L1308">            .SUCCESS =&gt; <span class="tok-kw">return</span> Impl{ .thread = &amp;instance.thread },</span>
<span class="line" id="L1309">            .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ThreadQuotaExceeded,</span>
<span class="line" id="L1310">            .INVAL =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1311">            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L1312">            .NOSPC =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1313">            .PERM =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1314">            .USERS =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1315">            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> os.unexpectedErrno(err),</span>
<span class="line" id="L1316">        }</span>
<span class="line" id="L1317">    }</span>
<span class="line" id="L1318"></span>
<span class="line" id="L1319">    <span class="tok-kw">fn</span> <span class="tok-fn">getHandle</span>(self: Impl) ThreadHandle {</span>
<span class="line" id="L1320">        <span class="tok-kw">return</span> self.thread.parent_tid;</span>
<span class="line" id="L1321">    }</span>
<span class="line" id="L1322"></span>
<span class="line" id="L1323">    <span class="tok-kw">fn</span> <span class="tok-fn">detach</span>(self: Impl) <span class="tok-type">void</span> {</span>
<span class="line" id="L1324">        <span class="tok-kw">switch</span> (self.thread.completion.swap(.detached, .SeqCst)) {</span>
<span class="line" id="L1325">            .running =&gt; {},</span>
<span class="line" id="L1326">            .completed =&gt; self.join(),</span>
<span class="line" id="L1327">            .detached =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1328">        }</span>
<span class="line" id="L1329">    }</span>
<span class="line" id="L1330"></span>
<span class="line" id="L1331">    <span class="tok-kw">fn</span> <span class="tok-fn">join</span>(self: Impl) <span class="tok-type">void</span> {</span>
<span class="line" id="L1332">        <span class="tok-kw">defer</span> os.munmap(self.thread.mapped);</span>
<span class="line" id="L1333"></span>
<span class="line" id="L1334">        <span class="tok-kw">var</span> spin: <span class="tok-type">u8</span> = <span class="tok-number">10</span>;</span>
<span class="line" id="L1335">        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L1336">            <span class="tok-kw">const</span> tid = self.thread.child_tid.load(.SeqCst);</span>
<span class="line" id="L1337">            <span class="tok-kw">if</span> (tid == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1338">                <span class="tok-kw">break</span>;</span>
<span class="line" id="L1339">            }</span>
<span class="line" id="L1340"></span>
<span class="line" id="L1341">            <span class="tok-kw">if</span> (spin &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L1342">                spin -= <span class="tok-number">1</span>;</span>
<span class="line" id="L1343">                std.atomic.spinLoopHint();</span>
<span class="line" id="L1344">                <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1345">            }</span>
<span class="line" id="L1346"></span>
<span class="line" id="L1347">            <span class="tok-kw">switch</span> (linux.getErrno(linux.futex_wait(</span>
<span class="line" id="L1348">                &amp;self.thread.child_tid.raw,</span>
<span class="line" id="L1349">                linux.FUTEX.WAIT,</span>
<span class="line" id="L1350">                tid,</span>
<span class="line" id="L1351">                <span class="tok-null">null</span>,</span>
<span class="line" id="L1352">            ))) {</span>
<span class="line" id="L1353">                .SUCCESS =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L1354">                .INTR =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L1355">                .AGAIN =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L1356">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1357">            }</span>
<span class="line" id="L1358">        }</span>
<span class="line" id="L1359">    }</span>
<span class="line" id="L1360">};</span>
<span class="line" id="L1361"></span>
<span class="line" id="L1362"><span class="tok-kw">fn</span> <span class="tok-fn">testThreadName</span>(thread: *Thread) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1363">    <span class="tok-kw">const</span> testCases = &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{</span>
<span class="line" id="L1364">        <span class="tok-str">&quot;mythread&quot;</span>,</span>
<span class="line" id="L1365">        <span class="tok-str">&quot;b&quot;</span> ** max_name_len,</span>
<span class="line" id="L1366">    };</span>
<span class="line" id="L1367"></span>
<span class="line" id="L1368">    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (testCases) |tc| {</span>
<span class="line" id="L1369">        <span class="tok-kw">try</span> thread.setName(tc);</span>
<span class="line" id="L1370"></span>
<span class="line" id="L1371">        <span class="tok-kw">var</span> name_buffer: [max_name_len:<span class="tok-number">0</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1372"></span>
<span class="line" id="L1373">        <span class="tok-kw">const</span> name = <span class="tok-kw">try</span> thread.getName(&amp;name_buffer);</span>
<span class="line" id="L1374">        <span class="tok-kw">if</span> (name) |value| {</span>
<span class="line" id="L1375">            <span class="tok-kw">try</span> std.testing.expectEqual(tc.len, value.len);</span>
<span class="line" id="L1376">            <span class="tok-kw">try</span> std.testing.expectEqualStrings(tc, value);</span>
<span class="line" id="L1377">        }</span>
<span class="line" id="L1378">    }</span>
<span class="line" id="L1379">}</span>
<span class="line" id="L1380"></span>
<span class="line" id="L1381"><span class="tok-kw">test</span> <span class="tok-str">&quot;setName, getName&quot;</span> {</span>
<span class="line" id="L1382">    <span class="tok-kw">if</span> (builtin.single_threaded) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;</span>
<span class="line" id="L1383"></span>
<span class="line" id="L1384">    <span class="tok-kw">const</span> Context = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1385">        start_wait_event: ResetEvent = .{},</span>
<span class="line" id="L1386">        test_done_event: ResetEvent = .{},</span>
<span class="line" id="L1387">        thread_done_event: ResetEvent = .{},</span>
<span class="line" id="L1388"></span>
<span class="line" id="L1389">        done: std.atomic.Value(<span class="tok-type">bool</span>) = std.atomic.Value(<span class="tok-type">bool</span>).init(<span class="tok-null">false</span>),</span>
<span class="line" id="L1390">        thread: Thread = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L1391"></span>
<span class="line" id="L1392">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">run</span>(ctx: *<span class="tok-builtin">@This</span>()) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1393">            <span class="tok-comment">// Wait for the main thread to have set the thread field in the context.</span>
</span>
<span class="line" id="L1394">            ctx.start_wait_event.wait();</span>
<span class="line" id="L1395"></span>
<span class="line" id="L1396">            <span class="tok-kw">switch</span> (target.os.tag) {</span>
<span class="line" id="L1397">                .windows =&gt; testThreadName(&amp;ctx.thread) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1398">                    <span class="tok-kw">error</span>.Unsupported =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,</span>
<span class="line" id="L1399">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L1400">                },</span>
<span class="line" id="L1401">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">try</span> testThreadName(&amp;ctx.thread),</span>
<span class="line" id="L1402">            }</span>
<span class="line" id="L1403"></span>
<span class="line" id="L1404">            <span class="tok-comment">// Signal our test is done</span>
</span>
<span class="line" id="L1405">            ctx.test_done_event.set();</span>
<span class="line" id="L1406"></span>
<span class="line" id="L1407">            <span class="tok-comment">// wait for the thread to property exit</span>
</span>
<span class="line" id="L1408">            ctx.thread_done_event.wait();</span>
<span class="line" id="L1409">        }</span>
<span class="line" id="L1410">    };</span>
<span class="line" id="L1411"></span>
<span class="line" id="L1412">    <span class="tok-kw">var</span> context = Context{};</span>
<span class="line" id="L1413">    <span class="tok-kw">var</span> thread = <span class="tok-kw">try</span> spawn(.{}, Context.run, .{&amp;context});</span>
<span class="line" id="L1414"></span>
<span class="line" id="L1415">    context.thread = thread;</span>
<span class="line" id="L1416">    context.start_wait_event.set();</span>
<span class="line" id="L1417">    context.test_done_event.wait();</span>
<span class="line" id="L1418"></span>
<span class="line" id="L1419">    <span class="tok-kw">switch</span> (target.os.tag) {</span>
<span class="line" id="L1420">        .macos, .ios, .watchos, .tvos =&gt; {</span>
<span class="line" id="L1421">            <span class="tok-kw">const</span> res = thread.setName(<span class="tok-str">&quot;foobar&quot;</span>);</span>
<span class="line" id="L1422">            <span class="tok-kw">try</span> std.testing.expectError(<span class="tok-kw">error</span>.Unsupported, res);</span>
<span class="line" id="L1423">        },</span>
<span class="line" id="L1424">        .windows =&gt; testThreadName(&amp;thread) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1425">            <span class="tok-kw">error</span>.Unsupported =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,</span>
<span class="line" id="L1426">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L1427">        },</span>
<span class="line" id="L1428">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">try</span> testThreadName(&amp;thread),</span>
<span class="line" id="L1429">    }</span>
<span class="line" id="L1430"></span>
<span class="line" id="L1431">    context.thread_done_event.set();</span>
<span class="line" id="L1432">    thread.join();</span>
<span class="line" id="L1433">}</span>
<span class="line" id="L1434"></span>
<span class="line" id="L1435"><span class="tok-kw">test</span> {</span>
<span class="line" id="L1436">    <span class="tok-comment">// Doesn't use testing.refAllDecls() since that would pull in the compileError spinLoopHint.</span>
</span>
<span class="line" id="L1437">    _ = Futex;</span>
<span class="line" id="L1438">    _ = ResetEvent;</span>
<span class="line" id="L1439">    _ = Mutex;</span>
<span class="line" id="L1440">    _ = Semaphore;</span>
<span class="line" id="L1441">    _ = Condition;</span>
<span class="line" id="L1442">    _ = RwLock;</span>
<span class="line" id="L1443">}</span>
<span class="line" id="L1444"></span>
<span class="line" id="L1445"><span class="tok-kw">fn</span> <span class="tok-fn">testIncrementNotify</span>(value: *<span class="tok-type">usize</span>, event: *ResetEvent) <span class="tok-type">void</span> {</span>
<span class="line" id="L1446">    value.* += <span class="tok-number">1</span>;</span>
<span class="line" id="L1447">    event.set();</span>
<span class="line" id="L1448">}</span>
<span class="line" id="L1449"></span>
<span class="line" id="L1450"><span class="tok-kw">test</span> <span class="tok-str">&quot;Thread.join&quot;</span> {</span>
<span class="line" id="L1451">    <span class="tok-kw">if</span> (builtin.single_threaded) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;</span>
<span class="line" id="L1452"></span>
<span class="line" id="L1453">    <span class="tok-kw">var</span> value: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1454">    <span class="tok-kw">var</span> event = ResetEvent{};</span>
<span class="line" id="L1455"></span>
<span class="line" id="L1456">    <span class="tok-kw">const</span> thread = <span class="tok-kw">try</span> Thread.spawn(.{}, testIncrementNotify, .{ &amp;value, &amp;event });</span>
<span class="line" id="L1457">    thread.join();</span>
<span class="line" id="L1458"></span>
<span class="line" id="L1459">    <span class="tok-kw">try</span> std.testing.expectEqual(value, <span class="tok-number">1</span>);</span>
<span class="line" id="L1460">}</span>
<span class="line" id="L1461"></span>
<span class="line" id="L1462"><span class="tok-kw">test</span> <span class="tok-str">&quot;Thread.detach&quot;</span> {</span>
<span class="line" id="L1463">    <span class="tok-kw">if</span> (builtin.single_threaded) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;</span>
<span class="line" id="L1464"></span>
<span class="line" id="L1465">    <span class="tok-kw">var</span> value: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1466">    <span class="tok-kw">var</span> event = ResetEvent{};</span>
<span class="line" id="L1467"></span>
<span class="line" id="L1468">    <span class="tok-kw">const</span> thread = <span class="tok-kw">try</span> Thread.spawn(.{}, testIncrementNotify, .{ &amp;value, &amp;event });</span>
<span class="line" id="L1469">    thread.detach();</span>
<span class="line" id="L1470"></span>
<span class="line" id="L1471">    event.wait();</span>
<span class="line" id="L1472">    <span class="tok-kw">try</span> std.testing.expectEqual(value, <span class="tok-number">1</span>);</span>
<span class="line" id="L1473">}</span>
<span class="line" id="L1474"></span>
</code></pre></body>
</html>