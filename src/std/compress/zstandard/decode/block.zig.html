<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>compress/zstandard/decode/block.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg==">
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);</span>
<span class="line" id="L2"><span class="tok-kw">const</span> assert = std.debug.assert;</span>
<span class="line" id="L3"><span class="tok-kw">const</span> RingBuffer = std.RingBuffer;</span>
<span class="line" id="L4"></span>
<span class="line" id="L5"><span class="tok-kw">const</span> types = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;../types.zig&quot;</span>);</span>
<span class="line" id="L6"><span class="tok-kw">const</span> frame = types.frame;</span>
<span class="line" id="L7"><span class="tok-kw">const</span> Table = types.compressed_block.Table;</span>
<span class="line" id="L8"><span class="tok-kw">const</span> LiteralsSection = types.compressed_block.LiteralsSection;</span>
<span class="line" id="L9"><span class="tok-kw">const</span> SequencesSection = types.compressed_block.SequencesSection;</span>
<span class="line" id="L10"></span>
<span class="line" id="L11"><span class="tok-kw">const</span> huffman = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;huffman.zig&quot;</span>);</span>
<span class="line" id="L12"><span class="tok-kw">const</span> readers = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;../readers.zig&quot;</span>);</span>
<span class="line" id="L13"></span>
<span class="line" id="L14"><span class="tok-kw">const</span> decodeFseTable = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fse.zig&quot;</span>).decodeFseTable;</span>
<span class="line" id="L15"></span>
<span class="line" id="L16"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <span class="tok-kw">error</span>{</span>
<span class="line" id="L17">    BlockSizeOverMaximum,</span>
<span class="line" id="L18">    MalformedBlockSize,</span>
<span class="line" id="L19">    ReservedBlock,</span>
<span class="line" id="L20">    MalformedRleBlock,</span>
<span class="line" id="L21">    MalformedCompressedBlock,</span>
<span class="line" id="L22">};</span>
<span class="line" id="L23"></span>
<span class="line" id="L24"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DecodeState = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L25">    repeat_offsets: [<span class="tok-number">3</span>]<span class="tok-type">u32</span>,</span>
<span class="line" id="L26"></span>
<span class="line" id="L27">    offset: StateData(<span class="tok-number">8</span>),</span>
<span class="line" id="L28">    match: StateData(<span class="tok-number">9</span>),</span>
<span class="line" id="L29">    literal: StateData(<span class="tok-number">9</span>),</span>
<span class="line" id="L30"></span>
<span class="line" id="L31">    offset_fse_buffer: []Table.Fse,</span>
<span class="line" id="L32">    match_fse_buffer: []Table.Fse,</span>
<span class="line" id="L33">    literal_fse_buffer: []Table.Fse,</span>
<span class="line" id="L34"></span>
<span class="line" id="L35">    fse_tables_undefined: <span class="tok-type">bool</span>,</span>
<span class="line" id="L36"></span>
<span class="line" id="L37">    literal_stream_reader: readers.ReverseBitReader,</span>
<span class="line" id="L38">    literal_stream_index: <span class="tok-type">usize</span>,</span>
<span class="line" id="L39">    literal_streams: LiteralsSection.Streams,</span>
<span class="line" id="L40">    literal_header: LiteralsSection.Header,</span>
<span class="line" id="L41">    huffman_tree: ?LiteralsSection.HuffmanTree,</span>
<span class="line" id="L42"></span>
<span class="line" id="L43">    literal_written_count: <span class="tok-type">usize</span>,</span>
<span class="line" id="L44">    written_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L45"></span>
<span class="line" id="L46">    <span class="tok-kw">fn</span> <span class="tok-fn">StateData</span>(<span class="tok-kw">comptime</span> max_accuracy_log: <span class="tok-type">comptime_int</span>) <span class="tok-type">type</span> {</span>
<span class="line" id="L47">        <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L48">            state: State,</span>
<span class="line" id="L49">            table: Table,</span>
<span class="line" id="L50">            accuracy_log: <span class="tok-type">u8</span>,</span>
<span class="line" id="L51"></span>
<span class="line" id="L52">            <span class="tok-kw">const</span> State = std.meta.Int(.unsigned, max_accuracy_log);</span>
<span class="line" id="L53">        };</span>
<span class="line" id="L54">    }</span>
<span class="line" id="L55"></span>
<span class="line" id="L56">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(</span>
<span class="line" id="L57">        literal_fse_buffer: []Table.Fse,</span>
<span class="line" id="L58">        match_fse_buffer: []Table.Fse,</span>
<span class="line" id="L59">        offset_fse_buffer: []Table.Fse,</span>
<span class="line" id="L60">    ) DecodeState {</span>
<span class="line" id="L61">        <span class="tok-kw">return</span> DecodeState{</span>
<span class="line" id="L62">            .repeat_offsets = .{</span>
<span class="line" id="L63">                types.compressed_block.start_repeated_offset_1,</span>
<span class="line" id="L64">                types.compressed_block.start_repeated_offset_2,</span>
<span class="line" id="L65">                types.compressed_block.start_repeated_offset_3,</span>
<span class="line" id="L66">            },</span>
<span class="line" id="L67"></span>
<span class="line" id="L68">            .offset = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L69">            .match = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L70">            .literal = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L71"></span>
<span class="line" id="L72">            .literal_fse_buffer = literal_fse_buffer,</span>
<span class="line" id="L73">            .match_fse_buffer = match_fse_buffer,</span>
<span class="line" id="L74">            .offset_fse_buffer = offset_fse_buffer,</span>
<span class="line" id="L75"></span>
<span class="line" id="L76">            .fse_tables_undefined = <span class="tok-null">true</span>,</span>
<span class="line" id="L77"></span>
<span class="line" id="L78">            .literal_written_count = <span class="tok-number">0</span>,</span>
<span class="line" id="L79">            .literal_header = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L80">            .literal_streams = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L81">            .literal_stream_reader = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L82">            .literal_stream_index = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L83">            .huffman_tree = <span class="tok-null">null</span>,</span>
<span class="line" id="L84"></span>
<span class="line" id="L85">            .written_count = <span class="tok-number">0</span>,</span>
<span class="line" id="L86">        };</span>
<span class="line" id="L87">    }</span>
<span class="line" id="L88"></span>
<span class="line" id="L89">    <span class="tok-comment">/// Prepare the decoder to decode a compressed block. Loads the literals</span></span>
<span class="line" id="L90">    <span class="tok-comment">/// stream and Huffman tree from `literals` and reads the FSE tables from</span></span>
<span class="line" id="L91">    <span class="tok-comment">/// `source`.</span></span>
<span class="line" id="L92">    <span class="tok-comment">///</span></span>
<span class="line" id="L93">    <span class="tok-comment">/// Errors returned:</span></span>
<span class="line" id="L94">    <span class="tok-comment">///   - `error.BitStreamHasNoStartBit` if the (reversed) literal bitstream's</span></span>
<span class="line" id="L95">    <span class="tok-comment">///     first byte does not have any bits set</span></span>
<span class="line" id="L96">    <span class="tok-comment">///   - `error.TreelessLiteralsFirst` `literals` is a treeless literals</span></span>
<span class="line" id="L97">    <span class="tok-comment">///     section and the decode state does not have a Huffman tree from a</span></span>
<span class="line" id="L98">    <span class="tok-comment">///     previous block</span></span>
<span class="line" id="L99">    <span class="tok-comment">///   - `error.RepeatModeFirst` on the first call if one of the sequence FSE</span></span>
<span class="line" id="L100">    <span class="tok-comment">///     tables is set to repeat mode</span></span>
<span class="line" id="L101">    <span class="tok-comment">///   - `error.MalformedAccuracyLog` if an FSE table has an invalid accuracy</span></span>
<span class="line" id="L102">    <span class="tok-comment">///   - `error.MalformedFseTable` if there are errors decoding an FSE table</span></span>
<span class="line" id="L103">    <span class="tok-comment">///   - `error.EndOfStream` if `source` ends before all FSE tables are read</span></span>
<span class="line" id="L104">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">prepare</span>(</span>
<span class="line" id="L105">        self: *DecodeState,</span>
<span class="line" id="L106">        source: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L107">        literals: LiteralsSection,</span>
<span class="line" id="L108">        sequences_header: SequencesSection.Header,</span>
<span class="line" id="L109">    ) !<span class="tok-type">void</span> {</span>
<span class="line" id="L110">        self.literal_written_count = <span class="tok-number">0</span>;</span>
<span class="line" id="L111">        self.literal_header = literals.header;</span>
<span class="line" id="L112">        self.literal_streams = literals.streams;</span>
<span class="line" id="L113"></span>
<span class="line" id="L114">        <span class="tok-kw">if</span> (literals.huffman_tree) |tree| {</span>
<span class="line" id="L115">            self.huffman_tree = tree;</span>
<span class="line" id="L116">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (literals.header.block_type == .treeless <span class="tok-kw">and</span> self.huffman_tree == <span class="tok-null">null</span>) {</span>
<span class="line" id="L117">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TreelessLiteralsFirst;</span>
<span class="line" id="L118">        }</span>
<span class="line" id="L119"></span>
<span class="line" id="L120">        <span class="tok-kw">switch</span> (literals.header.block_type) {</span>
<span class="line" id="L121">            .raw, .rle =&gt; {},</span>
<span class="line" id="L122">            .compressed, .treeless =&gt; {</span>
<span class="line" id="L123">                self.literal_stream_index = <span class="tok-number">0</span>;</span>
<span class="line" id="L124">                <span class="tok-kw">switch</span> (literals.streams) {</span>
<span class="line" id="L125">                    .one =&gt; |slice| <span class="tok-kw">try</span> self.initLiteralStream(slice),</span>
<span class="line" id="L126">                    .four =&gt; |streams| <span class="tok-kw">try</span> self.initLiteralStream(streams[<span class="tok-number">0</span>]),</span>
<span class="line" id="L127">                }</span>
<span class="line" id="L128">            },</span>
<span class="line" id="L129">        }</span>
<span class="line" id="L130"></span>
<span class="line" id="L131">        <span class="tok-kw">if</span> (sequences_header.sequence_count &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L132">            <span class="tok-kw">try</span> self.updateFseTable(source, .literal, sequences_header.literal_lengths);</span>
<span class="line" id="L133">            <span class="tok-kw">try</span> self.updateFseTable(source, .offset, sequences_header.offsets);</span>
<span class="line" id="L134">            <span class="tok-kw">try</span> self.updateFseTable(source, .match, sequences_header.match_lengths);</span>
<span class="line" id="L135">            self.fse_tables_undefined = <span class="tok-null">false</span>;</span>
<span class="line" id="L136">        }</span>
<span class="line" id="L137">    }</span>
<span class="line" id="L138"></span>
<span class="line" id="L139">    <span class="tok-comment">/// Read initial FSE states for sequence decoding.</span></span>
<span class="line" id="L140">    <span class="tok-comment">///</span></span>
<span class="line" id="L141">    <span class="tok-comment">/// Errors returned:</span></span>
<span class="line" id="L142">    <span class="tok-comment">///   - `error.EndOfStream` if `bit_reader` does not contain enough bits.</span></span>
<span class="line" id="L143">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readInitialFseState</span>(self: *DecodeState, bit_reader: *readers.ReverseBitReader) <span class="tok-kw">error</span>{EndOfStream}!<span class="tok-type">void</span> {</span>
<span class="line" id="L144">        self.literal.state = <span class="tok-kw">try</span> bit_reader.readBitsNoEof(<span class="tok-type">u9</span>, self.literal.accuracy_log);</span>
<span class="line" id="L145">        self.offset.state = <span class="tok-kw">try</span> bit_reader.readBitsNoEof(<span class="tok-type">u8</span>, self.offset.accuracy_log);</span>
<span class="line" id="L146">        self.match.state = <span class="tok-kw">try</span> bit_reader.readBitsNoEof(<span class="tok-type">u9</span>, self.match.accuracy_log);</span>
<span class="line" id="L147">    }</span>
<span class="line" id="L148"></span>
<span class="line" id="L149">    <span class="tok-kw">fn</span> <span class="tok-fn">updateRepeatOffset</span>(self: *DecodeState, offset: <span class="tok-type">u32</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L150">        self.repeat_offsets[<span class="tok-number">2</span>] = self.repeat_offsets[<span class="tok-number">1</span>];</span>
<span class="line" id="L151">        self.repeat_offsets[<span class="tok-number">1</span>] = self.repeat_offsets[<span class="tok-number">0</span>];</span>
<span class="line" id="L152">        self.repeat_offsets[<span class="tok-number">0</span>] = offset;</span>
<span class="line" id="L153">    }</span>
<span class="line" id="L154"></span>
<span class="line" id="L155">    <span class="tok-kw">fn</span> <span class="tok-fn">useRepeatOffset</span>(self: *DecodeState, index: <span class="tok-type">usize</span>) <span class="tok-type">u32</span> {</span>
<span class="line" id="L156">        <span class="tok-kw">if</span> (index == <span class="tok-number">1</span>)</span>
<span class="line" id="L157">            std.mem.swap(<span class="tok-type">u32</span>, &amp;self.repeat_offsets[<span class="tok-number">0</span>], &amp;self.repeat_offsets[<span class="tok-number">1</span>])</span>
<span class="line" id="L158">        <span class="tok-kw">else</span> <span class="tok-kw">if</span> (index == <span class="tok-number">2</span>) {</span>
<span class="line" id="L159">            std.mem.swap(<span class="tok-type">u32</span>, &amp;self.repeat_offsets[<span class="tok-number">0</span>], &amp;self.repeat_offsets[<span class="tok-number">2</span>]);</span>
<span class="line" id="L160">            std.mem.swap(<span class="tok-type">u32</span>, &amp;self.repeat_offsets[<span class="tok-number">1</span>], &amp;self.repeat_offsets[<span class="tok-number">2</span>]);</span>
<span class="line" id="L161">        }</span>
<span class="line" id="L162">        <span class="tok-kw">return</span> self.repeat_offsets[<span class="tok-number">0</span>];</span>
<span class="line" id="L163">    }</span>
<span class="line" id="L164"></span>
<span class="line" id="L165">    <span class="tok-kw">const</span> DataType = <span class="tok-kw">enum</span> { offset, match, literal };</span>
<span class="line" id="L166"></span>
<span class="line" id="L167">    <span class="tok-kw">fn</span> <span class="tok-fn">updateState</span>(</span>
<span class="line" id="L168">        self: *DecodeState,</span>
<span class="line" id="L169">        <span class="tok-kw">comptime</span> choice: DataType,</span>
<span class="line" id="L170">        bit_reader: *readers.ReverseBitReader,</span>
<span class="line" id="L171">    ) <span class="tok-kw">error</span>{ MalformedFseBits, EndOfStream }!<span class="tok-type">void</span> {</span>
<span class="line" id="L172">        <span class="tok-kw">switch</span> (<span class="tok-builtin">@field</span>(self, <span class="tok-builtin">@tagName</span>(choice)).table) {</span>
<span class="line" id="L173">            .rle =&gt; {},</span>
<span class="line" id="L174">            .fse =&gt; |table| {</span>
<span class="line" id="L175">                <span class="tok-kw">const</span> data = table[<span class="tok-builtin">@field</span>(self, <span class="tok-builtin">@tagName</span>(choice)).state];</span>
<span class="line" id="L176">                <span class="tok-kw">const</span> T = <span class="tok-builtin">@TypeOf</span>(<span class="tok-builtin">@field</span>(self, <span class="tok-builtin">@tagName</span>(choice))).State;</span>
<span class="line" id="L177">                <span class="tok-kw">const</span> bits_summand = <span class="tok-kw">try</span> bit_reader.readBitsNoEof(T, data.bits);</span>
<span class="line" id="L178">                <span class="tok-kw">const</span> next_state = std.math.cast(</span>
<span class="line" id="L179">                    <span class="tok-builtin">@TypeOf</span>(<span class="tok-builtin">@field</span>(self, <span class="tok-builtin">@tagName</span>(choice))).State,</span>
<span class="line" id="L180">                    data.baseline + bits_summand,</span>
<span class="line" id="L181">                ) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedFseBits;</span>
<span class="line" id="L182">                <span class="tok-builtin">@field</span>(self, <span class="tok-builtin">@tagName</span>(choice)).state = next_state;</span>
<span class="line" id="L183">            },</span>
<span class="line" id="L184">        }</span>
<span class="line" id="L185">    }</span>
<span class="line" id="L186"></span>
<span class="line" id="L187">    <span class="tok-kw">const</span> FseTableError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L188">        MalformedFseTable,</span>
<span class="line" id="L189">        MalformedAccuracyLog,</span>
<span class="line" id="L190">        RepeatModeFirst,</span>
<span class="line" id="L191">        EndOfStream,</span>
<span class="line" id="L192">    };</span>
<span class="line" id="L193"></span>
<span class="line" id="L194">    <span class="tok-kw">fn</span> <span class="tok-fn">updateFseTable</span>(</span>
<span class="line" id="L195">        self: *DecodeState,</span>
<span class="line" id="L196">        source: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L197">        <span class="tok-kw">comptime</span> choice: DataType,</span>
<span class="line" id="L198">        mode: SequencesSection.Header.Mode,</span>
<span class="line" id="L199">    ) !<span class="tok-type">void</span> {</span>
<span class="line" id="L200">        <span class="tok-kw">const</span> field_name = <span class="tok-builtin">@tagName</span>(choice);</span>
<span class="line" id="L201">        <span class="tok-kw">switch</span> (mode) {</span>
<span class="line" id="L202">            .predefined =&gt; {</span>
<span class="line" id="L203">                <span class="tok-builtin">@field</span>(self, field_name).accuracy_log =</span>
<span class="line" id="L204">                    <span class="tok-builtin">@field</span>(types.compressed_block.default_accuracy_log, field_name);</span>
<span class="line" id="L205"></span>
<span class="line" id="L206">                <span class="tok-builtin">@field</span>(self, field_name).table =</span>
<span class="line" id="L207">                    <span class="tok-builtin">@field</span>(types.compressed_block, <span class="tok-str">&quot;predefined_&quot;</span> ++ field_name ++ <span class="tok-str">&quot;_fse_table&quot;</span>);</span>
<span class="line" id="L208">            },</span>
<span class="line" id="L209">            .rle =&gt; {</span>
<span class="line" id="L210">                <span class="tok-builtin">@field</span>(self, field_name).accuracy_log = <span class="tok-number">0</span>;</span>
<span class="line" id="L211">                <span class="tok-builtin">@field</span>(self, field_name).table = .{ .rle = <span class="tok-kw">try</span> source.readByte() };</span>
<span class="line" id="L212">            },</span>
<span class="line" id="L213">            .fse =&gt; {</span>
<span class="line" id="L214">                <span class="tok-kw">var</span> bit_reader = readers.bitReader(source);</span>
<span class="line" id="L215"></span>
<span class="line" id="L216">                <span class="tok-kw">const</span> table_size = <span class="tok-kw">try</span> decodeFseTable(</span>
<span class="line" id="L217">                    &amp;bit_reader,</span>
<span class="line" id="L218">                    <span class="tok-builtin">@field</span>(types.compressed_block.table_symbol_count_max, field_name),</span>
<span class="line" id="L219">                    <span class="tok-builtin">@field</span>(types.compressed_block.table_accuracy_log_max, field_name),</span>
<span class="line" id="L220">                    <span class="tok-builtin">@field</span>(self, field_name ++ <span class="tok-str">&quot;_fse_buffer&quot;</span>),</span>
<span class="line" id="L221">                );</span>
<span class="line" id="L222">                <span class="tok-builtin">@field</span>(self, field_name).table = .{</span>
<span class="line" id="L223">                    .fse = <span class="tok-builtin">@field</span>(self, field_name ++ <span class="tok-str">&quot;_fse_buffer&quot;</span>)[<span class="tok-number">0</span>..table_size],</span>
<span class="line" id="L224">                };</span>
<span class="line" id="L225">                <span class="tok-builtin">@field</span>(self, field_name).accuracy_log = std.math.log2_int_ceil(<span class="tok-type">usize</span>, table_size);</span>
<span class="line" id="L226">            },</span>
<span class="line" id="L227">            .repeat =&gt; <span class="tok-kw">if</span> (self.fse_tables_undefined) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.RepeatModeFirst,</span>
<span class="line" id="L228">        }</span>
<span class="line" id="L229">    }</span>
<span class="line" id="L230"></span>
<span class="line" id="L231">    <span class="tok-kw">const</span> Sequence = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L232">        literal_length: <span class="tok-type">u32</span>,</span>
<span class="line" id="L233">        match_length: <span class="tok-type">u32</span>,</span>
<span class="line" id="L234">        offset: <span class="tok-type">u32</span>,</span>
<span class="line" id="L235">    };</span>
<span class="line" id="L236"></span>
<span class="line" id="L237">    <span class="tok-kw">fn</span> <span class="tok-fn">nextSequence</span>(</span>
<span class="line" id="L238">        self: *DecodeState,</span>
<span class="line" id="L239">        bit_reader: *readers.ReverseBitReader,</span>
<span class="line" id="L240">    ) <span class="tok-kw">error</span>{ InvalidBitStream, EndOfStream }!Sequence {</span>
<span class="line" id="L241">        <span class="tok-kw">const</span> raw_code = self.getCode(.offset);</span>
<span class="line" id="L242">        <span class="tok-kw">const</span> offset_code = std.math.cast(<span class="tok-type">u5</span>, raw_code) <span class="tok-kw">orelse</span> {</span>
<span class="line" id="L243">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidBitStream;</span>
<span class="line" id="L244">        };</span>
<span class="line" id="L245">        <span class="tok-kw">const</span> offset_value = (<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>) &lt;&lt; offset_code) + <span class="tok-kw">try</span> bit_reader.readBitsNoEof(<span class="tok-type">u32</span>, offset_code);</span>
<span class="line" id="L246"></span>
<span class="line" id="L247">        <span class="tok-kw">const</span> match_code = self.getCode(.match);</span>
<span class="line" id="L248">        <span class="tok-kw">if</span> (match_code &gt;= types.compressed_block.match_length_code_table.len)</span>
<span class="line" id="L249">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidBitStream;</span>
<span class="line" id="L250">        <span class="tok-kw">const</span> match = types.compressed_block.match_length_code_table[match_code];</span>
<span class="line" id="L251">        <span class="tok-kw">const</span> match_length = match[<span class="tok-number">0</span>] + <span class="tok-kw">try</span> bit_reader.readBitsNoEof(<span class="tok-type">u32</span>, match[<span class="tok-number">1</span>]);</span>
<span class="line" id="L252"></span>
<span class="line" id="L253">        <span class="tok-kw">const</span> literal_code = self.getCode(.literal);</span>
<span class="line" id="L254">        <span class="tok-kw">if</span> (literal_code &gt;= types.compressed_block.literals_length_code_table.len)</span>
<span class="line" id="L255">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidBitStream;</span>
<span class="line" id="L256">        <span class="tok-kw">const</span> literal = types.compressed_block.literals_length_code_table[literal_code];</span>
<span class="line" id="L257">        <span class="tok-kw">const</span> literal_length = literal[<span class="tok-number">0</span>] + <span class="tok-kw">try</span> bit_reader.readBitsNoEof(<span class="tok-type">u32</span>, literal[<span class="tok-number">1</span>]);</span>
<span class="line" id="L258"></span>
<span class="line" id="L259">        <span class="tok-kw">const</span> offset = <span class="tok-kw">if</span> (offset_value &gt; <span class="tok-number">3</span>) offset: {</span>
<span class="line" id="L260">            <span class="tok-kw">const</span> offset = offset_value - <span class="tok-number">3</span>;</span>
<span class="line" id="L261">            self.updateRepeatOffset(offset);</span>
<span class="line" id="L262">            <span class="tok-kw">break</span> :offset offset;</span>
<span class="line" id="L263">        } <span class="tok-kw">else</span> offset: {</span>
<span class="line" id="L264">            <span class="tok-kw">if</span> (literal_length == <span class="tok-number">0</span>) {</span>
<span class="line" id="L265">                <span class="tok-kw">if</span> (offset_value == <span class="tok-number">3</span>) {</span>
<span class="line" id="L266">                    <span class="tok-kw">const</span> offset = self.repeat_offsets[<span class="tok-number">0</span>] - <span class="tok-number">1</span>;</span>
<span class="line" id="L267">                    self.updateRepeatOffset(offset);</span>
<span class="line" id="L268">                    <span class="tok-kw">break</span> :offset offset;</span>
<span class="line" id="L269">                }</span>
<span class="line" id="L270">                <span class="tok-kw">break</span> :offset self.useRepeatOffset(offset_value);</span>
<span class="line" id="L271">            }</span>
<span class="line" id="L272">            <span class="tok-kw">break</span> :offset self.useRepeatOffset(offset_value - <span class="tok-number">1</span>);</span>
<span class="line" id="L273">        };</span>
<span class="line" id="L274"></span>
<span class="line" id="L275">        <span class="tok-kw">if</span> (offset == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidBitStream;</span>
<span class="line" id="L276"></span>
<span class="line" id="L277">        <span class="tok-kw">return</span> .{</span>
<span class="line" id="L278">            .literal_length = literal_length,</span>
<span class="line" id="L279">            .match_length = match_length,</span>
<span class="line" id="L280">            .offset = offset,</span>
<span class="line" id="L281">        };</span>
<span class="line" id="L282">    }</span>
<span class="line" id="L283"></span>
<span class="line" id="L284">    <span class="tok-kw">fn</span> <span class="tok-fn">executeSequenceSlice</span>(</span>
<span class="line" id="L285">        self: *DecodeState,</span>
<span class="line" id="L286">        dest: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L287">        write_pos: <span class="tok-type">usize</span>,</span>
<span class="line" id="L288">        sequence: Sequence,</span>
<span class="line" id="L289">    ) (<span class="tok-kw">error</span>{MalformedSequence} || DecodeLiteralsError)!<span class="tok-type">void</span> {</span>
<span class="line" id="L290">        <span class="tok-kw">if</span> (sequence.offset &gt; write_pos + sequence.literal_length) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedSequence;</span>
<span class="line" id="L291"></span>
<span class="line" id="L292">        <span class="tok-kw">try</span> self.decodeLiteralsSlice(dest[write_pos..], sequence.literal_length);</span>
<span class="line" id="L293">        <span class="tok-kw">const</span> copy_start = write_pos + sequence.literal_length - sequence.offset;</span>
<span class="line" id="L294">        <span class="tok-kw">for</span> (</span>
<span class="line" id="L295">            dest[write_pos + sequence.literal_length ..][<span class="tok-number">0</span>..sequence.match_length],</span>
<span class="line" id="L296">            dest[copy_start..][<span class="tok-number">0</span>..sequence.match_length],</span>
<span class="line" id="L297">        ) |*d, s| d.* = s;</span>
<span class="line" id="L298">        self.written_count += sequence.match_length;</span>
<span class="line" id="L299">    }</span>
<span class="line" id="L300"></span>
<span class="line" id="L301">    <span class="tok-kw">fn</span> <span class="tok-fn">executeSequenceRingBuffer</span>(</span>
<span class="line" id="L302">        self: *DecodeState,</span>
<span class="line" id="L303">        dest: *RingBuffer,</span>
<span class="line" id="L304">        sequence: Sequence,</span>
<span class="line" id="L305">    ) (<span class="tok-kw">error</span>{MalformedSequence} || DecodeLiteralsError)!<span class="tok-type">void</span> {</span>
<span class="line" id="L306">        <span class="tok-kw">if</span> (sequence.offset &gt; <span class="tok-builtin">@min</span>(dest.data.len, self.written_count + sequence.literal_length))</span>
<span class="line" id="L307">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedSequence;</span>
<span class="line" id="L308"></span>
<span class="line" id="L309">        <span class="tok-kw">try</span> self.decodeLiteralsRingBuffer(dest, sequence.literal_length);</span>
<span class="line" id="L310">        <span class="tok-kw">const</span> copy_start = dest.write_index + dest.data.len - sequence.offset;</span>
<span class="line" id="L311">        <span class="tok-kw">const</span> copy_slice = dest.sliceAt(copy_start, sequence.match_length);</span>
<span class="line" id="L312">        dest.writeSliceForwardsAssumeCapacity(copy_slice.first);</span>
<span class="line" id="L313">        dest.writeSliceForwardsAssumeCapacity(copy_slice.second);</span>
<span class="line" id="L314">        self.written_count += sequence.match_length;</span>
<span class="line" id="L315">    }</span>
<span class="line" id="L316"></span>
<span class="line" id="L317">    <span class="tok-kw">const</span> DecodeSequenceError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L318">        InvalidBitStream,</span>
<span class="line" id="L319">        EndOfStream,</span>
<span class="line" id="L320">        MalformedSequence,</span>
<span class="line" id="L321">        MalformedFseBits,</span>
<span class="line" id="L322">    } || DecodeLiteralsError;</span>
<span class="line" id="L323"></span>
<span class="line" id="L324">    <span class="tok-comment">/// Decode one sequence from `bit_reader` into `dest`, written starting at</span></span>
<span class="line" id="L325">    <span class="tok-comment">/// `write_pos` and update FSE states if `last_sequence` is `false`.</span></span>
<span class="line" id="L326">    <span class="tok-comment">/// `prepare()` must be called for the block before attempting to decode</span></span>
<span class="line" id="L327">    <span class="tok-comment">/// sequences.</span></span>
<span class="line" id="L328">    <span class="tok-comment">///</span></span>
<span class="line" id="L329">    <span class="tok-comment">/// Errors returned:</span></span>
<span class="line" id="L330">    <span class="tok-comment">///   - `error.MalformedSequence` if the decompressed sequence would be</span></span>
<span class="line" id="L331">    <span class="tok-comment">///     longer than `sequence_size_limit` or the sequence's offset is too</span></span>
<span class="line" id="L332">    <span class="tok-comment">///     large</span></span>
<span class="line" id="L333">    <span class="tok-comment">///   - `error.UnexpectedEndOfLiteralStream` if the decoder state's literal</span></span>
<span class="line" id="L334">    <span class="tok-comment">///     streams do not contain enough literals for the sequence (this may</span></span>
<span class="line" id="L335">    <span class="tok-comment">///     mean the literal stream or the sequence is malformed).</span></span>
<span class="line" id="L336">    <span class="tok-comment">///   - `error.InvalidBitStream` if the FSE sequence bitstream is malformed</span></span>
<span class="line" id="L337">    <span class="tok-comment">///   - `error.EndOfStream` if `bit_reader` does not contain enough bits</span></span>
<span class="line" id="L338">    <span class="tok-comment">///   - `error.DestTooSmall` if `dest` is not large enough to holde the</span></span>
<span class="line" id="L339">    <span class="tok-comment">///     decompressed sequence</span></span>
<span class="line" id="L340">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeSequenceSlice</span>(</span>
<span class="line" id="L341">        self: *DecodeState,</span>
<span class="line" id="L342">        dest: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L343">        write_pos: <span class="tok-type">usize</span>,</span>
<span class="line" id="L344">        bit_reader: *readers.ReverseBitReader,</span>
<span class="line" id="L345">        sequence_size_limit: <span class="tok-type">usize</span>,</span>
<span class="line" id="L346">        last_sequence: <span class="tok-type">bool</span>,</span>
<span class="line" id="L347">    ) (<span class="tok-kw">error</span>{DestTooSmall} || DecodeSequenceError)!<span class="tok-type">usize</span> {</span>
<span class="line" id="L348">        <span class="tok-kw">const</span> sequence = <span class="tok-kw">try</span> self.nextSequence(bit_reader);</span>
<span class="line" id="L349">        <span class="tok-kw">const</span> sequence_length = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, sequence.literal_length) + sequence.match_length;</span>
<span class="line" id="L350">        <span class="tok-kw">if</span> (sequence_length &gt; sequence_size_limit) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedSequence;</span>
<span class="line" id="L351">        <span class="tok-kw">if</span> (sequence_length &gt; dest[write_pos..].len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DestTooSmall;</span>
<span class="line" id="L352"></span>
<span class="line" id="L353">        <span class="tok-kw">try</span> self.executeSequenceSlice(dest, write_pos, sequence);</span>
<span class="line" id="L354">        <span class="tok-kw">if</span> (!last_sequence) {</span>
<span class="line" id="L355">            <span class="tok-kw">try</span> self.updateState(.literal, bit_reader);</span>
<span class="line" id="L356">            <span class="tok-kw">try</span> self.updateState(.match, bit_reader);</span>
<span class="line" id="L357">            <span class="tok-kw">try</span> self.updateState(.offset, bit_reader);</span>
<span class="line" id="L358">        }</span>
<span class="line" id="L359">        <span class="tok-kw">return</span> sequence_length;</span>
<span class="line" id="L360">    }</span>
<span class="line" id="L361"></span>
<span class="line" id="L362">    <span class="tok-comment">/// Decode one sequence from `bit_reader` into `dest`; see</span></span>
<span class="line" id="L363">    <span class="tok-comment">/// `decodeSequenceSlice`.</span></span>
<span class="line" id="L364">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeSequenceRingBuffer</span>(</span>
<span class="line" id="L365">        self: *DecodeState,</span>
<span class="line" id="L366">        dest: *RingBuffer,</span>
<span class="line" id="L367">        bit_reader: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L368">        sequence_size_limit: <span class="tok-type">usize</span>,</span>
<span class="line" id="L369">        last_sequence: <span class="tok-type">bool</span>,</span>
<span class="line" id="L370">    ) DecodeSequenceError!<span class="tok-type">usize</span> {</span>
<span class="line" id="L371">        <span class="tok-kw">const</span> sequence = <span class="tok-kw">try</span> self.nextSequence(bit_reader);</span>
<span class="line" id="L372">        <span class="tok-kw">const</span> sequence_length = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, sequence.literal_length) + sequence.match_length;</span>
<span class="line" id="L373">        <span class="tok-kw">if</span> (sequence_length &gt; sequence_size_limit) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedSequence;</span>
<span class="line" id="L374"></span>
<span class="line" id="L375">        <span class="tok-kw">try</span> self.executeSequenceRingBuffer(dest, sequence);</span>
<span class="line" id="L376">        <span class="tok-kw">if</span> (!last_sequence) {</span>
<span class="line" id="L377">            <span class="tok-kw">try</span> self.updateState(.literal, bit_reader);</span>
<span class="line" id="L378">            <span class="tok-kw">try</span> self.updateState(.match, bit_reader);</span>
<span class="line" id="L379">            <span class="tok-kw">try</span> self.updateState(.offset, bit_reader);</span>
<span class="line" id="L380">        }</span>
<span class="line" id="L381">        <span class="tok-kw">return</span> sequence_length;</span>
<span class="line" id="L382">    }</span>
<span class="line" id="L383"></span>
<span class="line" id="L384">    <span class="tok-kw">fn</span> <span class="tok-fn">nextLiteralMultiStream</span>(</span>
<span class="line" id="L385">        self: *DecodeState,</span>
<span class="line" id="L386">    ) <span class="tok-kw">error</span>{BitStreamHasNoStartBit}!<span class="tok-type">void</span> {</span>
<span class="line" id="L387">        self.literal_stream_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L388">        <span class="tok-kw">try</span> self.initLiteralStream(self.literal_streams.four[self.literal_stream_index]);</span>
<span class="line" id="L389">    }</span>
<span class="line" id="L390"></span>
<span class="line" id="L391">    <span class="tok-kw">fn</span> <span class="tok-fn">initLiteralStream</span>(self: *DecodeState, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-kw">error</span>{BitStreamHasNoStartBit}!<span class="tok-type">void</span> {</span>
<span class="line" id="L392">        <span class="tok-kw">try</span> self.literal_stream_reader.init(bytes);</span>
<span class="line" id="L393">    }</span>
<span class="line" id="L394"></span>
<span class="line" id="L395">    <span class="tok-kw">fn</span> <span class="tok-fn">isLiteralStreamEmpty</span>(self: *DecodeState) <span class="tok-type">bool</span> {</span>
<span class="line" id="L396">        <span class="tok-kw">switch</span> (self.literal_streams) {</span>
<span class="line" id="L397">            .one =&gt; <span class="tok-kw">return</span> self.literal_stream_reader.isEmpty(),</span>
<span class="line" id="L398">            .four =&gt; <span class="tok-kw">return</span> self.literal_stream_index == <span class="tok-number">3</span> <span class="tok-kw">and</span> self.literal_stream_reader.isEmpty(),</span>
<span class="line" id="L399">        }</span>
<span class="line" id="L400">    }</span>
<span class="line" id="L401"></span>
<span class="line" id="L402">    <span class="tok-kw">const</span> LiteralBitsError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L403">        BitStreamHasNoStartBit,</span>
<span class="line" id="L404">        UnexpectedEndOfLiteralStream,</span>
<span class="line" id="L405">    };</span>
<span class="line" id="L406">    <span class="tok-kw">fn</span> <span class="tok-fn">readLiteralsBits</span>(</span>
<span class="line" id="L407">        self: *DecodeState,</span>
<span class="line" id="L408">        bit_count_to_read: <span class="tok-type">usize</span>,</span>
<span class="line" id="L409">    ) LiteralBitsError!<span class="tok-type">u16</span> {</span>
<span class="line" id="L410">        <span class="tok-kw">return</span> self.literal_stream_reader.readBitsNoEof(<span class="tok-type">u16</span>, bit_count_to_read) <span class="tok-kw">catch</span> bits: {</span>
<span class="line" id="L411">            <span class="tok-kw">if</span> (self.literal_streams == .four <span class="tok-kw">and</span> self.literal_stream_index &lt; <span class="tok-number">3</span>) {</span>
<span class="line" id="L412">                <span class="tok-kw">try</span> self.nextLiteralMultiStream();</span>
<span class="line" id="L413">                <span class="tok-kw">break</span> :bits self.literal_stream_reader.readBitsNoEof(<span class="tok-type">u16</span>, bit_count_to_read) <span class="tok-kw">catch</span></span>
<span class="line" id="L414">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedEndOfLiteralStream;</span>
<span class="line" id="L415">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L416">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedEndOfLiteralStream;</span>
<span class="line" id="L417">            }</span>
<span class="line" id="L418">        };</span>
<span class="line" id="L419">    }</span>
<span class="line" id="L420"></span>
<span class="line" id="L421">    <span class="tok-kw">const</span> DecodeLiteralsError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L422">        MalformedLiteralsLength,</span>
<span class="line" id="L423">        NotFound,</span>
<span class="line" id="L424">    } || LiteralBitsError;</span>
<span class="line" id="L425"></span>
<span class="line" id="L426">    <span class="tok-comment">/// Decode `len` bytes of literals into `dest`.</span></span>
<span class="line" id="L427">    <span class="tok-comment">///</span></span>
<span class="line" id="L428">    <span class="tok-comment">/// Errors returned:</span></span>
<span class="line" id="L429">    <span class="tok-comment">///   - `error.MalformedLiteralsLength` if the number of literal bytes</span></span>
<span class="line" id="L430">    <span class="tok-comment">///     decoded by `self` plus `len` is greater than the regenerated size of</span></span>
<span class="line" id="L431">    <span class="tok-comment">///     `literals`</span></span>
<span class="line" id="L432">    <span class="tok-comment">///   - `error.UnexpectedEndOfLiteralStream` and `error.NotFound` if there</span></span>
<span class="line" id="L433">    <span class="tok-comment">///     are problems decoding Huffman compressed literals</span></span>
<span class="line" id="L434">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeLiteralsSlice</span>(</span>
<span class="line" id="L435">        self: *DecodeState,</span>
<span class="line" id="L436">        dest: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L437">        len: <span class="tok-type">usize</span>,</span>
<span class="line" id="L438">    ) DecodeLiteralsError!<span class="tok-type">void</span> {</span>
<span class="line" id="L439">        <span class="tok-kw">if</span> (self.literal_written_count + len &gt; self.literal_header.regenerated_size)</span>
<span class="line" id="L440">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedLiteralsLength;</span>
<span class="line" id="L441"></span>
<span class="line" id="L442">        <span class="tok-kw">switch</span> (self.literal_header.block_type) {</span>
<span class="line" id="L443">            .raw =&gt; {</span>
<span class="line" id="L444">                <span class="tok-kw">const</span> literal_data = self.literal_streams.one[self.literal_written_count..][<span class="tok-number">0</span>..len];</span>
<span class="line" id="L445">                <span class="tok-builtin">@memcpy</span>(dest[<span class="tok-number">0</span>..len], literal_data);</span>
<span class="line" id="L446">                self.literal_written_count += len;</span>
<span class="line" id="L447">                self.written_count += len;</span>
<span class="line" id="L448">            },</span>
<span class="line" id="L449">            .rle =&gt; {</span>
<span class="line" id="L450">                <span class="tok-kw">for</span> (<span class="tok-number">0</span>..len) |i| {</span>
<span class="line" id="L451">                    dest[i] = self.literal_streams.one[<span class="tok-number">0</span>];</span>
<span class="line" id="L452">                }</span>
<span class="line" id="L453">                self.literal_written_count += len;</span>
<span class="line" id="L454">                self.written_count += len;</span>
<span class="line" id="L455">            },</span>
<span class="line" id="L456">            .compressed, .treeless =&gt; {</span>
<span class="line" id="L457">                <span class="tok-comment">// const written_bytes_per_stream = (literals.header.regenerated_size + 3) / 4;</span>
</span>
<span class="line" id="L458">                <span class="tok-kw">const</span> huffman_tree = self.huffman_tree <span class="tok-kw">orelse</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L459">                <span class="tok-kw">const</span> max_bit_count = huffman_tree.max_bit_count;</span>
<span class="line" id="L460">                <span class="tok-kw">const</span> starting_bit_count = LiteralsSection.HuffmanTree.weightToBitCount(</span>
<span class="line" id="L461">                    huffman_tree.nodes[huffman_tree.symbol_count_minus_one].weight,</span>
<span class="line" id="L462">                    max_bit_count,</span>
<span class="line" id="L463">                );</span>
<span class="line" id="L464">                <span class="tok-kw">var</span> bits_read: <span class="tok-type">u4</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L465">                <span class="tok-kw">var</span> huffman_tree_index: <span class="tok-type">usize</span> = huffman_tree.symbol_count_minus_one;</span>
<span class="line" id="L466">                <span class="tok-kw">var</span> bit_count_to_read: <span class="tok-type">u4</span> = starting_bit_count;</span>
<span class="line" id="L467">                <span class="tok-kw">for</span> (<span class="tok-number">0</span>..len) |i| {</span>
<span class="line" id="L468">                    <span class="tok-kw">var</span> prefix: <span class="tok-type">u16</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L469">                    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L470">                        <span class="tok-kw">const</span> new_bits = self.readLiteralsBits(bit_count_to_read) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L471">                            <span class="tok-kw">return</span> err;</span>
<span class="line" id="L472">                        };</span>
<span class="line" id="L473">                        prefix &lt;&lt;= bit_count_to_read;</span>
<span class="line" id="L474">                        prefix |= new_bits;</span>
<span class="line" id="L475">                        bits_read += bit_count_to_read;</span>
<span class="line" id="L476">                        <span class="tok-kw">const</span> result = huffman_tree.query(huffman_tree_index, prefix) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L477">                            <span class="tok-kw">return</span> err;</span>
<span class="line" id="L478">                        };</span>
<span class="line" id="L479"></span>
<span class="line" id="L480">                        <span class="tok-kw">switch</span> (result) {</span>
<span class="line" id="L481">                            .symbol =&gt; |sym| {</span>
<span class="line" id="L482">                                dest[i] = sym;</span>
<span class="line" id="L483">                                bit_count_to_read = starting_bit_count;</span>
<span class="line" id="L484">                                bits_read = <span class="tok-number">0</span>;</span>
<span class="line" id="L485">                                huffman_tree_index = huffman_tree.symbol_count_minus_one;</span>
<span class="line" id="L486">                                <span class="tok-kw">break</span>;</span>
<span class="line" id="L487">                            },</span>
<span class="line" id="L488">                            .index =&gt; |index| {</span>
<span class="line" id="L489">                                huffman_tree_index = index;</span>
<span class="line" id="L490">                                <span class="tok-kw">const</span> bit_count = LiteralsSection.HuffmanTree.weightToBitCount(</span>
<span class="line" id="L491">                                    huffman_tree.nodes[index].weight,</span>
<span class="line" id="L492">                                    max_bit_count,</span>
<span class="line" id="L493">                                );</span>
<span class="line" id="L494">                                bit_count_to_read = bit_count - bits_read;</span>
<span class="line" id="L495">                            },</span>
<span class="line" id="L496">                        }</span>
<span class="line" id="L497">                    }</span>
<span class="line" id="L498">                }</span>
<span class="line" id="L499">                self.literal_written_count += len;</span>
<span class="line" id="L500">                self.written_count += len;</span>
<span class="line" id="L501">            },</span>
<span class="line" id="L502">        }</span>
<span class="line" id="L503">    }</span>
<span class="line" id="L504"></span>
<span class="line" id="L505">    <span class="tok-comment">/// Decode literals into `dest`; see `decodeLiteralsSlice()`.</span></span>
<span class="line" id="L506">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeLiteralsRingBuffer</span>(</span>
<span class="line" id="L507">        self: *DecodeState,</span>
<span class="line" id="L508">        dest: *RingBuffer,</span>
<span class="line" id="L509">        len: <span class="tok-type">usize</span>,</span>
<span class="line" id="L510">    ) DecodeLiteralsError!<span class="tok-type">void</span> {</span>
<span class="line" id="L511">        <span class="tok-kw">if</span> (self.literal_written_count + len &gt; self.literal_header.regenerated_size)</span>
<span class="line" id="L512">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedLiteralsLength;</span>
<span class="line" id="L513"></span>
<span class="line" id="L514">        <span class="tok-kw">switch</span> (self.literal_header.block_type) {</span>
<span class="line" id="L515">            .raw =&gt; {</span>
<span class="line" id="L516">                <span class="tok-kw">const</span> literals_end = self.literal_written_count + len;</span>
<span class="line" id="L517">                <span class="tok-kw">const</span> literal_data = self.literal_streams.one[self.literal_written_count..literals_end];</span>
<span class="line" id="L518">                dest.writeSliceAssumeCapacity(literal_data);</span>
<span class="line" id="L519">                self.literal_written_count += len;</span>
<span class="line" id="L520">                self.written_count += len;</span>
<span class="line" id="L521">            },</span>
<span class="line" id="L522">            .rle =&gt; {</span>
<span class="line" id="L523">                <span class="tok-kw">for</span> (<span class="tok-number">0</span>..len) |_| {</span>
<span class="line" id="L524">                    dest.writeAssumeCapacity(self.literal_streams.one[<span class="tok-number">0</span>]);</span>
<span class="line" id="L525">                }</span>
<span class="line" id="L526">                self.literal_written_count += len;</span>
<span class="line" id="L527">                self.written_count += len;</span>
<span class="line" id="L528">            },</span>
<span class="line" id="L529">            .compressed, .treeless =&gt; {</span>
<span class="line" id="L530">                <span class="tok-comment">// const written_bytes_per_stream = (literals.header.regenerated_size + 3) / 4;</span>
</span>
<span class="line" id="L531">                <span class="tok-kw">const</span> huffman_tree = self.huffman_tree <span class="tok-kw">orelse</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L532">                <span class="tok-kw">const</span> max_bit_count = huffman_tree.max_bit_count;</span>
<span class="line" id="L533">                <span class="tok-kw">const</span> starting_bit_count = LiteralsSection.HuffmanTree.weightToBitCount(</span>
<span class="line" id="L534">                    huffman_tree.nodes[huffman_tree.symbol_count_minus_one].weight,</span>
<span class="line" id="L535">                    max_bit_count,</span>
<span class="line" id="L536">                );</span>
<span class="line" id="L537">                <span class="tok-kw">var</span> bits_read: <span class="tok-type">u4</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L538">                <span class="tok-kw">var</span> huffman_tree_index: <span class="tok-type">usize</span> = huffman_tree.symbol_count_minus_one;</span>
<span class="line" id="L539">                <span class="tok-kw">var</span> bit_count_to_read: <span class="tok-type">u4</span> = starting_bit_count;</span>
<span class="line" id="L540">                <span class="tok-kw">for</span> (<span class="tok-number">0</span>..len) |_| {</span>
<span class="line" id="L541">                    <span class="tok-kw">var</span> prefix: <span class="tok-type">u16</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L542">                    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L543">                        <span class="tok-kw">const</span> new_bits = <span class="tok-kw">try</span> self.readLiteralsBits(bit_count_to_read);</span>
<span class="line" id="L544">                        prefix &lt;&lt;= bit_count_to_read;</span>
<span class="line" id="L545">                        prefix |= new_bits;</span>
<span class="line" id="L546">                        bits_read += bit_count_to_read;</span>
<span class="line" id="L547">                        <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> huffman_tree.query(huffman_tree_index, prefix);</span>
<span class="line" id="L548"></span>
<span class="line" id="L549">                        <span class="tok-kw">switch</span> (result) {</span>
<span class="line" id="L550">                            .symbol =&gt; |sym| {</span>
<span class="line" id="L551">                                dest.writeAssumeCapacity(sym);</span>
<span class="line" id="L552">                                bit_count_to_read = starting_bit_count;</span>
<span class="line" id="L553">                                bits_read = <span class="tok-number">0</span>;</span>
<span class="line" id="L554">                                huffman_tree_index = huffman_tree.symbol_count_minus_one;</span>
<span class="line" id="L555">                                <span class="tok-kw">break</span>;</span>
<span class="line" id="L556">                            },</span>
<span class="line" id="L557">                            .index =&gt; |index| {</span>
<span class="line" id="L558">                                huffman_tree_index = index;</span>
<span class="line" id="L559">                                <span class="tok-kw">const</span> bit_count = LiteralsSection.HuffmanTree.weightToBitCount(</span>
<span class="line" id="L560">                                    huffman_tree.nodes[index].weight,</span>
<span class="line" id="L561">                                    max_bit_count,</span>
<span class="line" id="L562">                                );</span>
<span class="line" id="L563">                                bit_count_to_read = bit_count - bits_read;</span>
<span class="line" id="L564">                            },</span>
<span class="line" id="L565">                        }</span>
<span class="line" id="L566">                    }</span>
<span class="line" id="L567">                }</span>
<span class="line" id="L568">                self.literal_written_count += len;</span>
<span class="line" id="L569">                self.written_count += len;</span>
<span class="line" id="L570">            },</span>
<span class="line" id="L571">        }</span>
<span class="line" id="L572">    }</span>
<span class="line" id="L573"></span>
<span class="line" id="L574">    <span class="tok-kw">fn</span> <span class="tok-fn">getCode</span>(self: *DecodeState, <span class="tok-kw">comptime</span> choice: DataType) <span class="tok-type">u32</span> {</span>
<span class="line" id="L575">        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@field</span>(self, <span class="tok-builtin">@tagName</span>(choice)).table) {</span>
<span class="line" id="L576">            .rle =&gt; |value| value,</span>
<span class="line" id="L577">            .fse =&gt; |table| table[<span class="tok-builtin">@field</span>(self, <span class="tok-builtin">@tagName</span>(choice)).state].symbol,</span>
<span class="line" id="L578">        };</span>
<span class="line" id="L579">    }</span>
<span class="line" id="L580">};</span>
<span class="line" id="L581"></span>
<span class="line" id="L582"><span class="tok-comment">/// Decode a single block from `src` into `dest`. The beginning of `src` must be</span></span>
<span class="line" id="L583"><span class="tok-comment">/// the start of the block content (i.e. directly after the block header).</span></span>
<span class="line" id="L584"><span class="tok-comment">/// Increments `consumed_count` by the number of bytes read from `src` to decode</span></span>
<span class="line" id="L585"><span class="tok-comment">/// the block and returns the decompressed size of the block.</span></span>
<span class="line" id="L586"><span class="tok-comment">///</span></span>
<span class="line" id="L587"><span class="tok-comment">/// Errors returned:</span></span>
<span class="line" id="L588"><span class="tok-comment">///</span></span>
<span class="line" id="L589"><span class="tok-comment">///   - `error.BlockSizeOverMaximum` if block's size is larger than 1 &lt;&lt; 17 or</span></span>
<span class="line" id="L590"><span class="tok-comment">///     `dest[written_count..].len`</span></span>
<span class="line" id="L591"><span class="tok-comment">///   - `error.MalformedBlockSize` if `src.len` is smaller than the block size</span></span>
<span class="line" id="L592"><span class="tok-comment">///     and the block is a raw or compressed block</span></span>
<span class="line" id="L593"><span class="tok-comment">///   - `error.ReservedBlock` if the block is a reserved block</span></span>
<span class="line" id="L594"><span class="tok-comment">///   - `error.MalformedRleBlock` if the block is an RLE block and `src.len &lt; 1`</span></span>
<span class="line" id="L595"><span class="tok-comment">///   - `error.MalformedCompressedBlock` if there are errors decoding a</span></span>
<span class="line" id="L596"><span class="tok-comment">///     compressed block</span></span>
<span class="line" id="L597"><span class="tok-comment">///   - `error.DestTooSmall` is `dest` is not large enough to hold the</span></span>
<span class="line" id="L598"><span class="tok-comment">///     decompressed block</span></span>
<span class="line" id="L599"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeBlock</span>(</span>
<span class="line" id="L600">    dest: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L601">    src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L602">    block_header: frame.Zstandard.Block.Header,</span>
<span class="line" id="L603">    decode_state: *DecodeState,</span>
<span class="line" id="L604">    consumed_count: *<span class="tok-type">usize</span>,</span>
<span class="line" id="L605">    block_size_max: <span class="tok-type">usize</span>,</span>
<span class="line" id="L606">    written_count: <span class="tok-type">usize</span>,</span>
<span class="line" id="L607">) (<span class="tok-kw">error</span>{DestTooSmall} || Error)!<span class="tok-type">usize</span> {</span>
<span class="line" id="L608">    <span class="tok-kw">const</span> block_size = block_header.block_size;</span>
<span class="line" id="L609">    <span class="tok-kw">if</span> (block_size_max &lt; block_size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BlockSizeOverMaximum;</span>
<span class="line" id="L610">    <span class="tok-kw">switch</span> (block_header.block_type) {</span>
<span class="line" id="L611">        .raw =&gt; {</span>
<span class="line" id="L612">            <span class="tok-kw">if</span> (src.len &lt; block_size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedBlockSize;</span>
<span class="line" id="L613">            <span class="tok-kw">if</span> (dest[written_count..].len &lt; block_size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DestTooSmall;</span>
<span class="line" id="L614">            <span class="tok-builtin">@memcpy</span>(dest[written_count..][<span class="tok-number">0</span>..block_size], src[<span class="tok-number">0</span>..block_size]);</span>
<span class="line" id="L615">            consumed_count.* += block_size;</span>
<span class="line" id="L616">            decode_state.written_count += block_size;</span>
<span class="line" id="L617">            <span class="tok-kw">return</span> block_size;</span>
<span class="line" id="L618">        },</span>
<span class="line" id="L619">        .rle =&gt; {</span>
<span class="line" id="L620">            <span class="tok-kw">if</span> (src.len &lt; <span class="tok-number">1</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedRleBlock;</span>
<span class="line" id="L621">            <span class="tok-kw">if</span> (dest[written_count..].len &lt; block_size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DestTooSmall;</span>
<span class="line" id="L622">            <span class="tok-kw">for</span> (written_count..block_size + written_count) |write_pos| {</span>
<span class="line" id="L623">                dest[write_pos] = src[<span class="tok-number">0</span>];</span>
<span class="line" id="L624">            }</span>
<span class="line" id="L625">            consumed_count.* += <span class="tok-number">1</span>;</span>
<span class="line" id="L626">            decode_state.written_count += block_size;</span>
<span class="line" id="L627">            <span class="tok-kw">return</span> block_size;</span>
<span class="line" id="L628">        },</span>
<span class="line" id="L629">        .compressed =&gt; {</span>
<span class="line" id="L630">            <span class="tok-kw">if</span> (src.len &lt; block_size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedBlockSize;</span>
<span class="line" id="L631">            <span class="tok-kw">var</span> bytes_read: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L632">            <span class="tok-kw">const</span> literals = decodeLiteralsSectionSlice(src[<span class="tok-number">0</span>..block_size], &amp;bytes_read) <span class="tok-kw">catch</span></span>
<span class="line" id="L633">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L634">            <span class="tok-kw">var</span> fbs = std.io.fixedBufferStream(src[bytes_read..block_size]);</span>
<span class="line" id="L635">            <span class="tok-kw">const</span> fbs_reader = fbs.reader();</span>
<span class="line" id="L636">            <span class="tok-kw">const</span> sequences_header = decodeSequencesHeader(fbs_reader) <span class="tok-kw">catch</span></span>
<span class="line" id="L637">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L638"></span>
<span class="line" id="L639">            decode_state.prepare(fbs_reader, literals, sequences_header) <span class="tok-kw">catch</span></span>
<span class="line" id="L640">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L641"></span>
<span class="line" id="L642">            bytes_read += fbs.pos;</span>
<span class="line" id="L643"></span>
<span class="line" id="L644">            <span class="tok-kw">var</span> bytes_written: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L645">            {</span>
<span class="line" id="L646">                <span class="tok-kw">const</span> bit_stream_bytes = src[bytes_read..block_size];</span>
<span class="line" id="L647">                <span class="tok-kw">var</span> bit_stream: readers.ReverseBitReader = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L648">                bit_stream.init(bit_stream_bytes) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L649"></span>
<span class="line" id="L650">                <span class="tok-kw">if</span> (sequences_header.sequence_count &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L651">                    decode_state.readInitialFseState(&amp;bit_stream) <span class="tok-kw">catch</span></span>
<span class="line" id="L652">                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L653"></span>
<span class="line" id="L654">                    <span class="tok-kw">var</span> sequence_size_limit = block_size_max;</span>
<span class="line" id="L655">                    <span class="tok-kw">for</span> (<span class="tok-number">0</span>..sequences_header.sequence_count) |i| {</span>
<span class="line" id="L656">                        <span class="tok-kw">const</span> write_pos = written_count + bytes_written;</span>
<span class="line" id="L657">                        <span class="tok-kw">const</span> decompressed_size = decode_state.decodeSequenceSlice(</span>
<span class="line" id="L658">                            dest,</span>
<span class="line" id="L659">                            write_pos,</span>
<span class="line" id="L660">                            &amp;bit_stream,</span>
<span class="line" id="L661">                            sequence_size_limit,</span>
<span class="line" id="L662">                            i == sequences_header.sequence_count - <span class="tok-number">1</span>,</span>
<span class="line" id="L663">                        ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L664">                            <span class="tok-kw">error</span>.DestTooSmall =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DestTooSmall,</span>
<span class="line" id="L665">                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock,</span>
<span class="line" id="L666">                        };</span>
<span class="line" id="L667">                        bytes_written += decompressed_size;</span>
<span class="line" id="L668">                        sequence_size_limit -= decompressed_size;</span>
<span class="line" id="L669">                    }</span>
<span class="line" id="L670">                }</span>
<span class="line" id="L671"></span>
<span class="line" id="L672">                <span class="tok-kw">if</span> (!bit_stream.isEmpty()) {</span>
<span class="line" id="L673">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L674">                }</span>
<span class="line" id="L675">            }</span>
<span class="line" id="L676"></span>
<span class="line" id="L677">            <span class="tok-kw">if</span> (decode_state.literal_written_count &lt; literals.header.regenerated_size) {</span>
<span class="line" id="L678">                <span class="tok-kw">const</span> len = literals.header.regenerated_size - decode_state.literal_written_count;</span>
<span class="line" id="L679">                <span class="tok-kw">if</span> (len &gt; dest[written_count + bytes_written ..].len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DestTooSmall;</span>
<span class="line" id="L680">                decode_state.decodeLiteralsSlice(dest[written_count + bytes_written ..], len) <span class="tok-kw">catch</span></span>
<span class="line" id="L681">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L682">                bytes_written += len;</span>
<span class="line" id="L683">            }</span>
<span class="line" id="L684"></span>
<span class="line" id="L685">            <span class="tok-kw">switch</span> (decode_state.literal_header.block_type) {</span>
<span class="line" id="L686">                .treeless, .compressed =&gt; {</span>
<span class="line" id="L687">                    <span class="tok-kw">if</span> (!decode_state.isLiteralStreamEmpty()) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L688">                },</span>
<span class="line" id="L689">                .raw, .rle =&gt; {},</span>
<span class="line" id="L690">            }</span>
<span class="line" id="L691"></span>
<span class="line" id="L692">            consumed_count.* += block_size;</span>
<span class="line" id="L693">            <span class="tok-kw">return</span> bytes_written;</span>
<span class="line" id="L694">        },</span>
<span class="line" id="L695">        .reserved =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReservedBlock,</span>
<span class="line" id="L696">    }</span>
<span class="line" id="L697">}</span>
<span class="line" id="L698"></span>
<span class="line" id="L699"><span class="tok-comment">/// Decode a single block from `src` into `dest`; see `decodeBlock()`. Returns</span></span>
<span class="line" id="L700"><span class="tok-comment">/// the size of the decompressed block, which can be used with `dest.sliceLast()`</span></span>
<span class="line" id="L701"><span class="tok-comment">/// to get the decompressed bytes. `error.BlockSizeOverMaximum` is returned if</span></span>
<span class="line" id="L702"><span class="tok-comment">/// the block's compressed or decompressed size is larger than `block_size_max`.</span></span>
<span class="line" id="L703"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeBlockRingBuffer</span>(</span>
<span class="line" id="L704">    dest: *RingBuffer,</span>
<span class="line" id="L705">    src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L706">    block_header: frame.Zstandard.Block.Header,</span>
<span class="line" id="L707">    decode_state: *DecodeState,</span>
<span class="line" id="L708">    consumed_count: *<span class="tok-type">usize</span>,</span>
<span class="line" id="L709">    block_size_max: <span class="tok-type">usize</span>,</span>
<span class="line" id="L710">) Error!<span class="tok-type">usize</span> {</span>
<span class="line" id="L711">    <span class="tok-kw">const</span> block_size = block_header.block_size;</span>
<span class="line" id="L712">    <span class="tok-kw">if</span> (block_size_max &lt; block_size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BlockSizeOverMaximum;</span>
<span class="line" id="L713">    <span class="tok-kw">switch</span> (block_header.block_type) {</span>
<span class="line" id="L714">        .raw =&gt; {</span>
<span class="line" id="L715">            <span class="tok-kw">if</span> (src.len &lt; block_size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedBlockSize;</span>
<span class="line" id="L716">            <span class="tok-kw">const</span> data = src[<span class="tok-number">0</span>..block_size];</span>
<span class="line" id="L717">            dest.writeSliceAssumeCapacity(data);</span>
<span class="line" id="L718">            consumed_count.* += block_size;</span>
<span class="line" id="L719">            decode_state.written_count += block_size;</span>
<span class="line" id="L720">            <span class="tok-kw">return</span> block_size;</span>
<span class="line" id="L721">        },</span>
<span class="line" id="L722">        .rle =&gt; {</span>
<span class="line" id="L723">            <span class="tok-kw">if</span> (src.len &lt; <span class="tok-number">1</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedRleBlock;</span>
<span class="line" id="L724">            <span class="tok-kw">for</span> (<span class="tok-number">0</span>..block_size) |_| {</span>
<span class="line" id="L725">                dest.writeAssumeCapacity(src[<span class="tok-number">0</span>]);</span>
<span class="line" id="L726">            }</span>
<span class="line" id="L727">            consumed_count.* += <span class="tok-number">1</span>;</span>
<span class="line" id="L728">            decode_state.written_count += block_size;</span>
<span class="line" id="L729">            <span class="tok-kw">return</span> block_size;</span>
<span class="line" id="L730">        },</span>
<span class="line" id="L731">        .compressed =&gt; {</span>
<span class="line" id="L732">            <span class="tok-kw">if</span> (src.len &lt; block_size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedBlockSize;</span>
<span class="line" id="L733">            <span class="tok-kw">var</span> bytes_read: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L734">            <span class="tok-kw">const</span> literals = decodeLiteralsSectionSlice(src[<span class="tok-number">0</span>..block_size], &amp;bytes_read) <span class="tok-kw">catch</span></span>
<span class="line" id="L735">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L736">            <span class="tok-kw">var</span> fbs = std.io.fixedBufferStream(src[bytes_read..block_size]);</span>
<span class="line" id="L737">            <span class="tok-kw">const</span> fbs_reader = fbs.reader();</span>
<span class="line" id="L738">            <span class="tok-kw">const</span> sequences_header = decodeSequencesHeader(fbs_reader) <span class="tok-kw">catch</span></span>
<span class="line" id="L739">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L740"></span>
<span class="line" id="L741">            decode_state.prepare(fbs_reader, literals, sequences_header) <span class="tok-kw">catch</span></span>
<span class="line" id="L742">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L743"></span>
<span class="line" id="L744">            bytes_read += fbs.pos;</span>
<span class="line" id="L745"></span>
<span class="line" id="L746">            <span class="tok-kw">var</span> bytes_written: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L747">            {</span>
<span class="line" id="L748">                <span class="tok-kw">const</span> bit_stream_bytes = src[bytes_read..block_size];</span>
<span class="line" id="L749">                <span class="tok-kw">var</span> bit_stream: readers.ReverseBitReader = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L750">                bit_stream.init(bit_stream_bytes) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L751"></span>
<span class="line" id="L752">                <span class="tok-kw">if</span> (sequences_header.sequence_count &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L753">                    decode_state.readInitialFseState(&amp;bit_stream) <span class="tok-kw">catch</span></span>
<span class="line" id="L754">                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L755"></span>
<span class="line" id="L756">                    <span class="tok-kw">var</span> sequence_size_limit = block_size_max;</span>
<span class="line" id="L757">                    <span class="tok-kw">for</span> (<span class="tok-number">0</span>..sequences_header.sequence_count) |i| {</span>
<span class="line" id="L758">                        <span class="tok-kw">const</span> decompressed_size = decode_state.decodeSequenceRingBuffer(</span>
<span class="line" id="L759">                            dest,</span>
<span class="line" id="L760">                            &amp;bit_stream,</span>
<span class="line" id="L761">                            sequence_size_limit,</span>
<span class="line" id="L762">                            i == sequences_header.sequence_count - <span class="tok-number">1</span>,</span>
<span class="line" id="L763">                        ) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L764">                        bytes_written += decompressed_size;</span>
<span class="line" id="L765">                        sequence_size_limit -= decompressed_size;</span>
<span class="line" id="L766">                    }</span>
<span class="line" id="L767">                }</span>
<span class="line" id="L768"></span>
<span class="line" id="L769">                <span class="tok-kw">if</span> (!bit_stream.isEmpty()) {</span>
<span class="line" id="L770">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L771">                }</span>
<span class="line" id="L772">            }</span>
<span class="line" id="L773"></span>
<span class="line" id="L774">            <span class="tok-kw">if</span> (decode_state.literal_written_count &lt; literals.header.regenerated_size) {</span>
<span class="line" id="L775">                <span class="tok-kw">const</span> len = literals.header.regenerated_size - decode_state.literal_written_count;</span>
<span class="line" id="L776">                decode_state.decodeLiteralsRingBuffer(dest, len) <span class="tok-kw">catch</span></span>
<span class="line" id="L777">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L778">                bytes_written += len;</span>
<span class="line" id="L779">            }</span>
<span class="line" id="L780"></span>
<span class="line" id="L781">            <span class="tok-kw">switch</span> (decode_state.literal_header.block_type) {</span>
<span class="line" id="L782">                .treeless, .compressed =&gt; {</span>
<span class="line" id="L783">                    <span class="tok-kw">if</span> (!decode_state.isLiteralStreamEmpty()) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L784">                },</span>
<span class="line" id="L785">                .raw, .rle =&gt; {},</span>
<span class="line" id="L786">            }</span>
<span class="line" id="L787"></span>
<span class="line" id="L788">            consumed_count.* += block_size;</span>
<span class="line" id="L789">            <span class="tok-kw">if</span> (bytes_written &gt; block_size_max) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BlockSizeOverMaximum;</span>
<span class="line" id="L790">            <span class="tok-kw">return</span> bytes_written;</span>
<span class="line" id="L791">        },</span>
<span class="line" id="L792">        .reserved =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReservedBlock,</span>
<span class="line" id="L793">    }</span>
<span class="line" id="L794">}</span>
<span class="line" id="L795"></span>
<span class="line" id="L796"><span class="tok-comment">/// Decode a single block from `source` into `dest`. Literal and sequence data</span></span>
<span class="line" id="L797"><span class="tok-comment">/// from the block is copied into `literals_buffer` and `sequence_buffer`, which</span></span>
<span class="line" id="L798"><span class="tok-comment">/// must be large enough or `error.LiteralsBufferTooSmall` and</span></span>
<span class="line" id="L799"><span class="tok-comment">/// `error.SequenceBufferTooSmall` are returned (the maximum block size is an</span></span>
<span class="line" id="L800"><span class="tok-comment">/// upper bound for the size of both buffers). See `decodeBlock`</span></span>
<span class="line" id="L801"><span class="tok-comment">/// and `decodeBlockRingBuffer` for function that can decode a block without</span></span>
<span class="line" id="L802"><span class="tok-comment">/// these extra copies. `error.EndOfStream` is returned if `source` does not</span></span>
<span class="line" id="L803"><span class="tok-comment">/// contain enough bytes.</span></span>
<span class="line" id="L804"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeBlockReader</span>(</span>
<span class="line" id="L805">    dest: *RingBuffer,</span>
<span class="line" id="L806">    source: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L807">    block_header: frame.Zstandard.Block.Header,</span>
<span class="line" id="L808">    decode_state: *DecodeState,</span>
<span class="line" id="L809">    block_size_max: <span class="tok-type">usize</span>,</span>
<span class="line" id="L810">    literals_buffer: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L811">    sequence_buffer: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L812">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L813">    <span class="tok-kw">const</span> block_size = block_header.block_size;</span>
<span class="line" id="L814">    <span class="tok-kw">var</span> block_reader_limited = std.io.limitedReader(source, block_size);</span>
<span class="line" id="L815">    <span class="tok-kw">const</span> block_reader = block_reader_limited.reader();</span>
<span class="line" id="L816">    <span class="tok-kw">if</span> (block_size_max &lt; block_size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BlockSizeOverMaximum;</span>
<span class="line" id="L817">    <span class="tok-kw">switch</span> (block_header.block_type) {</span>
<span class="line" id="L818">        .raw =&gt; {</span>
<span class="line" id="L819">            <span class="tok-kw">if</span> (block_size == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;</span>
<span class="line" id="L820">            <span class="tok-kw">const</span> slice = dest.sliceAt(dest.write_index, block_size);</span>
<span class="line" id="L821">            <span class="tok-kw">try</span> source.readNoEof(slice.first);</span>
<span class="line" id="L822">            <span class="tok-kw">try</span> source.readNoEof(slice.second);</span>
<span class="line" id="L823">            dest.write_index = dest.mask2(dest.write_index + block_size);</span>
<span class="line" id="L824">            decode_state.written_count += block_size;</span>
<span class="line" id="L825">        },</span>
<span class="line" id="L826">        .rle =&gt; {</span>
<span class="line" id="L827">            <span class="tok-kw">const</span> byte = <span class="tok-kw">try</span> source.readByte();</span>
<span class="line" id="L828">            <span class="tok-kw">for</span> (<span class="tok-number">0</span>..block_size) |_| {</span>
<span class="line" id="L829">                dest.writeAssumeCapacity(byte);</span>
<span class="line" id="L830">            }</span>
<span class="line" id="L831">            decode_state.written_count += block_size;</span>
<span class="line" id="L832">        },</span>
<span class="line" id="L833">        .compressed =&gt; {</span>
<span class="line" id="L834">            <span class="tok-kw">const</span> literals = <span class="tok-kw">try</span> decodeLiteralsSection(block_reader, literals_buffer);</span>
<span class="line" id="L835">            <span class="tok-kw">const</span> sequences_header = <span class="tok-kw">try</span> decodeSequencesHeader(block_reader);</span>
<span class="line" id="L836"></span>
<span class="line" id="L837">            <span class="tok-kw">try</span> decode_state.prepare(block_reader, literals, sequences_header);</span>
<span class="line" id="L838"></span>
<span class="line" id="L839">            <span class="tok-kw">var</span> bytes_written: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L840">            {</span>
<span class="line" id="L841">                <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> block_reader.readAll(sequence_buffer);</span>
<span class="line" id="L842">                <span class="tok-kw">var</span> bit_stream: readers.ReverseBitReader = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L843">                <span class="tok-kw">try</span> bit_stream.init(sequence_buffer[<span class="tok-number">0</span>..size]);</span>
<span class="line" id="L844"></span>
<span class="line" id="L845">                <span class="tok-kw">if</span> (sequences_header.sequence_count &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L846">                    <span class="tok-kw">if</span> (sequence_buffer.len &lt; block_reader_limited.bytes_left)</span>
<span class="line" id="L847">                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SequenceBufferTooSmall;</span>
<span class="line" id="L848"></span>
<span class="line" id="L849">                    decode_state.readInitialFseState(&amp;bit_stream) <span class="tok-kw">catch</span></span>
<span class="line" id="L850">                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L851"></span>
<span class="line" id="L852">                    <span class="tok-kw">var</span> sequence_size_limit = block_size_max;</span>
<span class="line" id="L853">                    <span class="tok-kw">for</span> (<span class="tok-number">0</span>..sequences_header.sequence_count) |i| {</span>
<span class="line" id="L854">                        <span class="tok-kw">const</span> decompressed_size = decode_state.decodeSequenceRingBuffer(</span>
<span class="line" id="L855">                            dest,</span>
<span class="line" id="L856">                            &amp;bit_stream,</span>
<span class="line" id="L857">                            sequence_size_limit,</span>
<span class="line" id="L858">                            i == sequences_header.sequence_count - <span class="tok-number">1</span>,</span>
<span class="line" id="L859">                        ) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L860">                        sequence_size_limit -= decompressed_size;</span>
<span class="line" id="L861">                        bytes_written += decompressed_size;</span>
<span class="line" id="L862">                    }</span>
<span class="line" id="L863">                }</span>
<span class="line" id="L864"></span>
<span class="line" id="L865">                <span class="tok-kw">if</span> (!bit_stream.isEmpty()) {</span>
<span class="line" id="L866">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L867">                }</span>
<span class="line" id="L868">            }</span>
<span class="line" id="L869"></span>
<span class="line" id="L870">            <span class="tok-kw">if</span> (decode_state.literal_written_count &lt; literals.header.regenerated_size) {</span>
<span class="line" id="L871">                <span class="tok-kw">const</span> len = literals.header.regenerated_size - decode_state.literal_written_count;</span>
<span class="line" id="L872">                decode_state.decodeLiteralsRingBuffer(dest, len) <span class="tok-kw">catch</span></span>
<span class="line" id="L873">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L874">                bytes_written += len;</span>
<span class="line" id="L875">            }</span>
<span class="line" id="L876"></span>
<span class="line" id="L877">            <span class="tok-kw">switch</span> (decode_state.literal_header.block_type) {</span>
<span class="line" id="L878">                .treeless, .compressed =&gt; {</span>
<span class="line" id="L879">                    <span class="tok-kw">if</span> (!decode_state.isLiteralStreamEmpty()) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L880">                },</span>
<span class="line" id="L881">                .raw, .rle =&gt; {},</span>
<span class="line" id="L882">            }</span>
<span class="line" id="L883"></span>
<span class="line" id="L884">            <span class="tok-kw">if</span> (bytes_written &gt; block_size_max) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BlockSizeOverMaximum;</span>
<span class="line" id="L885">            <span class="tok-kw">if</span> (block_reader_limited.bytes_left != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedCompressedBlock;</span>
<span class="line" id="L886">            decode_state.literal_written_count = <span class="tok-number">0</span>;</span>
<span class="line" id="L887">        },</span>
<span class="line" id="L888">        .reserved =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReservedBlock,</span>
<span class="line" id="L889">    }</span>
<span class="line" id="L890">}</span>
<span class="line" id="L891"></span>
<span class="line" id="L892"><span class="tok-comment">/// Decode the header of a block.</span></span>
<span class="line" id="L893"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeBlockHeader</span>(src: *<span class="tok-kw">const</span> [<span class="tok-number">3</span>]<span class="tok-type">u8</span>) frame.Zstandard.Block.Header {</span>
<span class="line" id="L894">    <span class="tok-kw">const</span> last_block = src[<span class="tok-number">0</span>] &amp; <span class="tok-number">1</span> == <span class="tok-number">1</span>;</span>
<span class="line" id="L895">    <span class="tok-kw">const</span> block_type = <span class="tok-builtin">@as</span>(frame.Zstandard.Block.Type, <span class="tok-builtin">@enumFromInt</span>((src[<span class="tok-number">0</span>] &amp; <span class="tok-number">0b110</span>) &gt;&gt; <span class="tok-number">1</span>));</span>
<span class="line" id="L896">    <span class="tok-kw">const</span> block_size = ((src[<span class="tok-number">0</span>] &amp; <span class="tok-number">0b11111000</span>) &gt;&gt; <span class="tok-number">3</span>) + (<span class="tok-builtin">@as</span>(<span class="tok-type">u21</span>, src[<span class="tok-number">1</span>]) &lt;&lt; <span class="tok-number">5</span>) + (<span class="tok-builtin">@as</span>(<span class="tok-type">u21</span>, src[<span class="tok-number">2</span>]) &lt;&lt; <span class="tok-number">13</span>);</span>
<span class="line" id="L897">    <span class="tok-kw">return</span> .{</span>
<span class="line" id="L898">        .last_block = last_block,</span>
<span class="line" id="L899">        .block_type = block_type,</span>
<span class="line" id="L900">        .block_size = block_size,</span>
<span class="line" id="L901">    };</span>
<span class="line" id="L902">}</span>
<span class="line" id="L903"></span>
<span class="line" id="L904"><span class="tok-comment">/// Decode the header of a block.</span></span>
<span class="line" id="L905"><span class="tok-comment">///</span></span>
<span class="line" id="L906"><span class="tok-comment">/// Errors returned:</span></span>
<span class="line" id="L907"><span class="tok-comment">///   - `error.EndOfStream` if `src.len &lt; 3`</span></span>
<span class="line" id="L908"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeBlockHeaderSlice</span>(src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-kw">error</span>{EndOfStream}!frame.Zstandard.Block.Header {</span>
<span class="line" id="L909">    <span class="tok-kw">if</span> (src.len &lt; <span class="tok-number">3</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EndOfStream;</span>
<span class="line" id="L910">    <span class="tok-kw">return</span> decodeBlockHeader(src[<span class="tok-number">0</span>..<span class="tok-number">3</span>]);</span>
<span class="line" id="L911">}</span>
<span class="line" id="L912"></span>
<span class="line" id="L913"><span class="tok-comment">/// Decode a `LiteralsSection` from `src`, incrementing `consumed_count` by the</span></span>
<span class="line" id="L914"><span class="tok-comment">/// number of bytes the section uses.</span></span>
<span class="line" id="L915"><span class="tok-comment">///</span></span>
<span class="line" id="L916"><span class="tok-comment">/// Errors returned:</span></span>
<span class="line" id="L917"><span class="tok-comment">///   - `error.MalformedLiteralsHeader` if the header is invalid</span></span>
<span class="line" id="L918"><span class="tok-comment">///   - `error.MalformedLiteralsSection` if there are decoding errors</span></span>
<span class="line" id="L919"><span class="tok-comment">///   - `error.MalformedAccuracyLog` if compressed literals have invalid</span></span>
<span class="line" id="L920"><span class="tok-comment">///     accuracy</span></span>
<span class="line" id="L921"><span class="tok-comment">///   - `error.MalformedFseTable` if compressed literals have invalid FSE table</span></span>
<span class="line" id="L922"><span class="tok-comment">///   - `error.MalformedHuffmanTree` if there are errors decoding a Huffamn tree</span></span>
<span class="line" id="L923"><span class="tok-comment">///   - `error.EndOfStream` if there are not enough bytes in `src`</span></span>
<span class="line" id="L924"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeLiteralsSectionSlice</span>(</span>
<span class="line" id="L925">    src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L926">    consumed_count: *<span class="tok-type">usize</span>,</span>
<span class="line" id="L927">) (<span class="tok-kw">error</span>{ MalformedLiteralsHeader, MalformedLiteralsSection, EndOfStream } || huffman.Error)!LiteralsSection {</span>
<span class="line" id="L928">    <span class="tok-kw">var</span> bytes_read: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L929">    <span class="tok-kw">const</span> header = header: {</span>
<span class="line" id="L930">        <span class="tok-kw">var</span> fbs = std.io.fixedBufferStream(src);</span>
<span class="line" id="L931">        <span class="tok-kw">defer</span> bytes_read = fbs.pos;</span>
<span class="line" id="L932">        <span class="tok-kw">break</span> :header decodeLiteralsHeader(fbs.reader()) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedLiteralsHeader;</span>
<span class="line" id="L933">    };</span>
<span class="line" id="L934">    <span class="tok-kw">switch</span> (header.block_type) {</span>
<span class="line" id="L935">        .raw =&gt; {</span>
<span class="line" id="L936">            <span class="tok-kw">if</span> (src.len &lt; bytes_read + header.regenerated_size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedLiteralsSection;</span>
<span class="line" id="L937">            <span class="tok-kw">const</span> stream = src[bytes_read .. bytes_read + header.regenerated_size];</span>
<span class="line" id="L938">            consumed_count.* += header.regenerated_size + bytes_read;</span>
<span class="line" id="L939">            <span class="tok-kw">return</span> LiteralsSection{</span>
<span class="line" id="L940">                .header = header,</span>
<span class="line" id="L941">                .huffman_tree = <span class="tok-null">null</span>,</span>
<span class="line" id="L942">                .streams = .{ .one = stream },</span>
<span class="line" id="L943">            };</span>
<span class="line" id="L944">        },</span>
<span class="line" id="L945">        .rle =&gt; {</span>
<span class="line" id="L946">            <span class="tok-kw">if</span> (src.len &lt; bytes_read + <span class="tok-number">1</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedLiteralsSection;</span>
<span class="line" id="L947">            <span class="tok-kw">const</span> stream = src[bytes_read .. bytes_read + <span class="tok-number">1</span>];</span>
<span class="line" id="L948">            consumed_count.* += <span class="tok-number">1</span> + bytes_read;</span>
<span class="line" id="L949">            <span class="tok-kw">return</span> LiteralsSection{</span>
<span class="line" id="L950">                .header = header,</span>
<span class="line" id="L951">                .huffman_tree = <span class="tok-null">null</span>,</span>
<span class="line" id="L952">                .streams = .{ .one = stream },</span>
<span class="line" id="L953">            };</span>
<span class="line" id="L954">        },</span>
<span class="line" id="L955">        .compressed, .treeless =&gt; {</span>
<span class="line" id="L956">            <span class="tok-kw">const</span> huffman_tree_start = bytes_read;</span>
<span class="line" id="L957">            <span class="tok-kw">const</span> huffman_tree = <span class="tok-kw">if</span> (header.block_type == .compressed)</span>
<span class="line" id="L958">                <span class="tok-kw">try</span> huffman.decodeHuffmanTreeSlice(src[bytes_read..], &amp;bytes_read)</span>
<span class="line" id="L959">            <span class="tok-kw">else</span></span>
<span class="line" id="L960">                <span class="tok-null">null</span>;</span>
<span class="line" id="L961">            <span class="tok-kw">const</span> huffman_tree_size = bytes_read - huffman_tree_start;</span>
<span class="line" id="L962">            <span class="tok-kw">const</span> total_streams_size = std.math.sub(<span class="tok-type">usize</span>, header.compressed_size.?, huffman_tree_size) <span class="tok-kw">catch</span></span>
<span class="line" id="L963">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedLiteralsSection;</span>
<span class="line" id="L964"></span>
<span class="line" id="L965">            <span class="tok-kw">if</span> (src.len &lt; bytes_read + total_streams_size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedLiteralsSection;</span>
<span class="line" id="L966">            <span class="tok-kw">const</span> stream_data = src[bytes_read .. bytes_read + total_streams_size];</span>
<span class="line" id="L967"></span>
<span class="line" id="L968">            <span class="tok-kw">const</span> streams = <span class="tok-kw">try</span> decodeStreams(header.size_format, stream_data);</span>
<span class="line" id="L969">            consumed_count.* += bytes_read + total_streams_size;</span>
<span class="line" id="L970">            <span class="tok-kw">return</span> LiteralsSection{</span>
<span class="line" id="L971">                .header = header,</span>
<span class="line" id="L972">                .huffman_tree = huffman_tree,</span>
<span class="line" id="L973">                .streams = streams,</span>
<span class="line" id="L974">            };</span>
<span class="line" id="L975">        },</span>
<span class="line" id="L976">    }</span>
<span class="line" id="L977">}</span>
<span class="line" id="L978"></span>
<span class="line" id="L979"><span class="tok-comment">/// Decode a `LiteralsSection` from `src`, incrementing `consumed_count` by the</span></span>
<span class="line" id="L980"><span class="tok-comment">/// number of bytes the section uses. See `decodeLiterasSectionSlice()`.</span></span>
<span class="line" id="L981"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeLiteralsSection</span>(</span>
<span class="line" id="L982">    source: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L983">    buffer: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L984">) !LiteralsSection {</span>
<span class="line" id="L985">    <span class="tok-kw">const</span> header = <span class="tok-kw">try</span> decodeLiteralsHeader(source);</span>
<span class="line" id="L986">    <span class="tok-kw">switch</span> (header.block_type) {</span>
<span class="line" id="L987">        .raw =&gt; {</span>
<span class="line" id="L988">            <span class="tok-kw">try</span> source.readNoEof(buffer[<span class="tok-number">0</span>..header.regenerated_size]);</span>
<span class="line" id="L989">            <span class="tok-kw">return</span> LiteralsSection{</span>
<span class="line" id="L990">                .header = header,</span>
<span class="line" id="L991">                .huffman_tree = <span class="tok-null">null</span>,</span>
<span class="line" id="L992">                .streams = .{ .one = buffer },</span>
<span class="line" id="L993">            };</span>
<span class="line" id="L994">        },</span>
<span class="line" id="L995">        .rle =&gt; {</span>
<span class="line" id="L996">            buffer[<span class="tok-number">0</span>] = <span class="tok-kw">try</span> source.readByte();</span>
<span class="line" id="L997">            <span class="tok-kw">return</span> LiteralsSection{</span>
<span class="line" id="L998">                .header = header,</span>
<span class="line" id="L999">                .huffman_tree = <span class="tok-null">null</span>,</span>
<span class="line" id="L1000">                .streams = .{ .one = buffer[<span class="tok-number">0</span>..<span class="tok-number">1</span>] },</span>
<span class="line" id="L1001">            };</span>
<span class="line" id="L1002">        },</span>
<span class="line" id="L1003">        .compressed, .treeless =&gt; {</span>
<span class="line" id="L1004">            <span class="tok-kw">var</span> counting_reader = std.io.countingReader(source);</span>
<span class="line" id="L1005">            <span class="tok-kw">const</span> huffman_tree = <span class="tok-kw">if</span> (header.block_type == .compressed)</span>
<span class="line" id="L1006">                <span class="tok-kw">try</span> huffman.decodeHuffmanTree(counting_reader.reader(), buffer)</span>
<span class="line" id="L1007">            <span class="tok-kw">else</span></span>
<span class="line" id="L1008">                <span class="tok-null">null</span>;</span>
<span class="line" id="L1009">            <span class="tok-kw">const</span> huffman_tree_size = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(counting_reader.bytes_read));</span>
<span class="line" id="L1010">            <span class="tok-kw">const</span> total_streams_size = std.math.sub(<span class="tok-type">usize</span>, header.compressed_size.?, huffman_tree_size) <span class="tok-kw">catch</span></span>
<span class="line" id="L1011">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedLiteralsSection;</span>
<span class="line" id="L1012"></span>
<span class="line" id="L1013">            <span class="tok-kw">if</span> (total_streams_size &gt; buffer.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LiteralsBufferTooSmall;</span>
<span class="line" id="L1014">            <span class="tok-kw">try</span> source.readNoEof(buffer[<span class="tok-number">0</span>..total_streams_size]);</span>
<span class="line" id="L1015">            <span class="tok-kw">const</span> stream_data = buffer[<span class="tok-number">0</span>..total_streams_size];</span>
<span class="line" id="L1016"></span>
<span class="line" id="L1017">            <span class="tok-kw">const</span> streams = <span class="tok-kw">try</span> decodeStreams(header.size_format, stream_data);</span>
<span class="line" id="L1018">            <span class="tok-kw">return</span> LiteralsSection{</span>
<span class="line" id="L1019">                .header = header,</span>
<span class="line" id="L1020">                .huffman_tree = huffman_tree,</span>
<span class="line" id="L1021">                .streams = streams,</span>
<span class="line" id="L1022">            };</span>
<span class="line" id="L1023">        },</span>
<span class="line" id="L1024">    }</span>
<span class="line" id="L1025">}</span>
<span class="line" id="L1026"></span>
<span class="line" id="L1027"><span class="tok-kw">fn</span> <span class="tok-fn">decodeStreams</span>(size_format: <span class="tok-type">u2</span>, stream_data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !LiteralsSection.Streams {</span>
<span class="line" id="L1028">    <span class="tok-kw">if</span> (size_format == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1029">        <span class="tok-kw">return</span> .{ .one = stream_data };</span>
<span class="line" id="L1030">    }</span>
<span class="line" id="L1031"></span>
<span class="line" id="L1032">    <span class="tok-kw">if</span> (stream_data.len &lt; <span class="tok-number">6</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedLiteralsSection;</span>
<span class="line" id="L1033"></span>
<span class="line" id="L1034">    <span class="tok-kw">const</span> stream_1_length: <span class="tok-type">usize</span> = std.mem.readInt(<span class="tok-type">u16</span>, stream_data[<span class="tok-number">0</span>..<span class="tok-number">2</span>], .little);</span>
<span class="line" id="L1035">    <span class="tok-kw">const</span> stream_2_length: <span class="tok-type">usize</span> = std.mem.readInt(<span class="tok-type">u16</span>, stream_data[<span class="tok-number">2</span>..<span class="tok-number">4</span>], .little);</span>
<span class="line" id="L1036">    <span class="tok-kw">const</span> stream_3_length: <span class="tok-type">usize</span> = std.mem.readInt(<span class="tok-type">u16</span>, stream_data[<span class="tok-number">4</span>..<span class="tok-number">6</span>], .little);</span>
<span class="line" id="L1037"></span>
<span class="line" id="L1038">    <span class="tok-kw">const</span> stream_1_start = <span class="tok-number">6</span>;</span>
<span class="line" id="L1039">    <span class="tok-kw">const</span> stream_2_start = stream_1_start + stream_1_length;</span>
<span class="line" id="L1040">    <span class="tok-kw">const</span> stream_3_start = stream_2_start + stream_2_length;</span>
<span class="line" id="L1041">    <span class="tok-kw">const</span> stream_4_start = stream_3_start + stream_3_length;</span>
<span class="line" id="L1042"></span>
<span class="line" id="L1043">    <span class="tok-kw">if</span> (stream_data.len &lt; stream_4_start) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedLiteralsSection;</span>
<span class="line" id="L1044"></span>
<span class="line" id="L1045">    <span class="tok-kw">return</span> .{ .four = .{</span>
<span class="line" id="L1046">        stream_data[stream_1_start .. stream_1_start + stream_1_length],</span>
<span class="line" id="L1047">        stream_data[stream_2_start .. stream_2_start + stream_2_length],</span>
<span class="line" id="L1048">        stream_data[stream_3_start .. stream_3_start + stream_3_length],</span>
<span class="line" id="L1049">        stream_data[stream_4_start..],</span>
<span class="line" id="L1050">    } };</span>
<span class="line" id="L1051">}</span>
<span class="line" id="L1052"></span>
<span class="line" id="L1053"><span class="tok-comment">/// Decode a literals section header.</span></span>
<span class="line" id="L1054"><span class="tok-comment">///</span></span>
<span class="line" id="L1055"><span class="tok-comment">/// Errors returned:</span></span>
<span class="line" id="L1056"><span class="tok-comment">///   - `error.EndOfStream` if there are not enough bytes in `source`</span></span>
<span class="line" id="L1057"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeLiteralsHeader</span>(source: <span class="tok-kw">anytype</span>) !LiteralsSection.Header {</span>
<span class="line" id="L1058">    <span class="tok-kw">const</span> byte0 = <span class="tok-kw">try</span> source.readByte();</span>
<span class="line" id="L1059">    <span class="tok-kw">const</span> block_type = <span class="tok-builtin">@as</span>(LiteralsSection.BlockType, <span class="tok-builtin">@enumFromInt</span>(byte0 &amp; <span class="tok-number">0b11</span>));</span>
<span class="line" id="L1060">    <span class="tok-kw">const</span> size_format = <span class="tok-builtin">@as</span>(<span class="tok-type">u2</span>, <span class="tok-builtin">@intCast</span>((byte0 &amp; <span class="tok-number">0b1100</span>) &gt;&gt; <span class="tok-number">2</span>));</span>
<span class="line" id="L1061">    <span class="tok-kw">var</span> regenerated_size: <span class="tok-type">u20</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1062">    <span class="tok-kw">var</span> compressed_size: ?<span class="tok-type">u18</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L1063">    <span class="tok-kw">switch</span> (block_type) {</span>
<span class="line" id="L1064">        .raw, .rle =&gt; {</span>
<span class="line" id="L1065">            <span class="tok-kw">switch</span> (size_format) {</span>
<span class="line" id="L1066">                <span class="tok-number">0</span>, <span class="tok-number">2</span> =&gt; {</span>
<span class="line" id="L1067">                    regenerated_size = byte0 &gt;&gt; <span class="tok-number">3</span>;</span>
<span class="line" id="L1068">                },</span>
<span class="line" id="L1069">                <span class="tok-number">1</span> =&gt; regenerated_size = (byte0 &gt;&gt; <span class="tok-number">4</span>) + (<span class="tok-builtin">@as</span>(<span class="tok-type">u20</span>, <span class="tok-kw">try</span> source.readByte()) &lt;&lt; <span class="tok-number">4</span>),</span>
<span class="line" id="L1070">                <span class="tok-number">3</span> =&gt; regenerated_size = (byte0 &gt;&gt; <span class="tok-number">4</span>) +</span>
<span class="line" id="L1071">                    (<span class="tok-builtin">@as</span>(<span class="tok-type">u20</span>, <span class="tok-kw">try</span> source.readByte()) &lt;&lt; <span class="tok-number">4</span>) +</span>
<span class="line" id="L1072">                    (<span class="tok-builtin">@as</span>(<span class="tok-type">u20</span>, <span class="tok-kw">try</span> source.readByte()) &lt;&lt; <span class="tok-number">12</span>),</span>
<span class="line" id="L1073">            }</span>
<span class="line" id="L1074">        },</span>
<span class="line" id="L1075">        .compressed, .treeless =&gt; {</span>
<span class="line" id="L1076">            <span class="tok-kw">const</span> byte1 = <span class="tok-kw">try</span> source.readByte();</span>
<span class="line" id="L1077">            <span class="tok-kw">const</span> byte2 = <span class="tok-kw">try</span> source.readByte();</span>
<span class="line" id="L1078">            <span class="tok-kw">switch</span> (size_format) {</span>
<span class="line" id="L1079">                <span class="tok-number">0</span>, <span class="tok-number">1</span> =&gt; {</span>
<span class="line" id="L1080">                    regenerated_size = (byte0 &gt;&gt; <span class="tok-number">4</span>) + ((<span class="tok-builtin">@as</span>(<span class="tok-type">u20</span>, byte1) &amp; <span class="tok-number">0b00111111</span>) &lt;&lt; <span class="tok-number">4</span>);</span>
<span class="line" id="L1081">                    compressed_size = ((byte1 &amp; <span class="tok-number">0b11000000</span>) &gt;&gt; <span class="tok-number">6</span>) + (<span class="tok-builtin">@as</span>(<span class="tok-type">u18</span>, byte2) &lt;&lt; <span class="tok-number">2</span>);</span>
<span class="line" id="L1082">                },</span>
<span class="line" id="L1083">                <span class="tok-number">2</span> =&gt; {</span>
<span class="line" id="L1084">                    <span class="tok-kw">const</span> byte3 = <span class="tok-kw">try</span> source.readByte();</span>
<span class="line" id="L1085">                    regenerated_size = (byte0 &gt;&gt; <span class="tok-number">4</span>) + (<span class="tok-builtin">@as</span>(<span class="tok-type">u20</span>, byte1) &lt;&lt; <span class="tok-number">4</span>) + ((<span class="tok-builtin">@as</span>(<span class="tok-type">u20</span>, byte2) &amp; <span class="tok-number">0b00000011</span>) &lt;&lt; <span class="tok-number">12</span>);</span>
<span class="line" id="L1086">                    compressed_size = ((byte2 &amp; <span class="tok-number">0b11111100</span>) &gt;&gt; <span class="tok-number">2</span>) + (<span class="tok-builtin">@as</span>(<span class="tok-type">u18</span>, byte3) &lt;&lt; <span class="tok-number">6</span>);</span>
<span class="line" id="L1087">                },</span>
<span class="line" id="L1088">                <span class="tok-number">3</span> =&gt; {</span>
<span class="line" id="L1089">                    <span class="tok-kw">const</span> byte3 = <span class="tok-kw">try</span> source.readByte();</span>
<span class="line" id="L1090">                    <span class="tok-kw">const</span> byte4 = <span class="tok-kw">try</span> source.readByte();</span>
<span class="line" id="L1091">                    regenerated_size = (byte0 &gt;&gt; <span class="tok-number">4</span>) + (<span class="tok-builtin">@as</span>(<span class="tok-type">u20</span>, byte1) &lt;&lt; <span class="tok-number">4</span>) + ((<span class="tok-builtin">@as</span>(<span class="tok-type">u20</span>, byte2) &amp; <span class="tok-number">0b00111111</span>) &lt;&lt; <span class="tok-number">12</span>);</span>
<span class="line" id="L1092">                    compressed_size = ((byte2 &amp; <span class="tok-number">0b11000000</span>) &gt;&gt; <span class="tok-number">6</span>) + (<span class="tok-builtin">@as</span>(<span class="tok-type">u18</span>, byte3) &lt;&lt; <span class="tok-number">2</span>) + (<span class="tok-builtin">@as</span>(<span class="tok-type">u18</span>, byte4) &lt;&lt; <span class="tok-number">10</span>);</span>
<span class="line" id="L1093">                },</span>
<span class="line" id="L1094">            }</span>
<span class="line" id="L1095">        },</span>
<span class="line" id="L1096">    }</span>
<span class="line" id="L1097">    <span class="tok-kw">return</span> LiteralsSection.Header{</span>
<span class="line" id="L1098">        .block_type = block_type,</span>
<span class="line" id="L1099">        .size_format = size_format,</span>
<span class="line" id="L1100">        .regenerated_size = regenerated_size,</span>
<span class="line" id="L1101">        .compressed_size = compressed_size,</span>
<span class="line" id="L1102">    };</span>
<span class="line" id="L1103">}</span>
<span class="line" id="L1104"></span>
<span class="line" id="L1105"><span class="tok-comment">/// Decode a sequences section header.</span></span>
<span class="line" id="L1106"><span class="tok-comment">///</span></span>
<span class="line" id="L1107"><span class="tok-comment">/// Errors returned:</span></span>
<span class="line" id="L1108"><span class="tok-comment">///   - `error.ReservedBitSet` if the reserved bit is set</span></span>
<span class="line" id="L1109"><span class="tok-comment">///   - `error.EndOfStream` if there are not enough bytes in `source`</span></span>
<span class="line" id="L1110"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeSequencesHeader</span>(</span>
<span class="line" id="L1111">    source: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L1112">) !SequencesSection.Header {</span>
<span class="line" id="L1113">    <span class="tok-kw">var</span> sequence_count: <span class="tok-type">u24</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1114"></span>
<span class="line" id="L1115">    <span class="tok-kw">const</span> byte0 = <span class="tok-kw">try</span> source.readByte();</span>
<span class="line" id="L1116">    <span class="tok-kw">if</span> (byte0 == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1117">        <span class="tok-kw">return</span> SequencesSection.Header{</span>
<span class="line" id="L1118">            .sequence_count = <span class="tok-number">0</span>,</span>
<span class="line" id="L1119">            .offsets = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L1120">            .match_lengths = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L1121">            .literal_lengths = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L1122">        };</span>
<span class="line" id="L1123">    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (byte0 &lt; <span class="tok-number">128</span>) {</span>
<span class="line" id="L1124">        sequence_count = byte0;</span>
<span class="line" id="L1125">    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (byte0 &lt; <span class="tok-number">255</span>) {</span>
<span class="line" id="L1126">        sequence_count = (<span class="tok-builtin">@as</span>(<span class="tok-type">u24</span>, (byte0 - <span class="tok-number">128</span>)) &lt;&lt; <span class="tok-number">8</span>) + <span class="tok-kw">try</span> source.readByte();</span>
<span class="line" id="L1127">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1128">        sequence_count = (<span class="tok-kw">try</span> source.readByte()) + (<span class="tok-builtin">@as</span>(<span class="tok-type">u24</span>, <span class="tok-kw">try</span> source.readByte()) &lt;&lt; <span class="tok-number">8</span>) + <span class="tok-number">0x7F00</span>;</span>
<span class="line" id="L1129">    }</span>
<span class="line" id="L1130"></span>
<span class="line" id="L1131">    <span class="tok-kw">const</span> compression_modes = <span class="tok-kw">try</span> source.readByte();</span>
<span class="line" id="L1132"></span>
<span class="line" id="L1133">    <span class="tok-kw">const</span> matches_mode = <span class="tok-builtin">@as</span>(SequencesSection.Header.Mode, <span class="tok-builtin">@enumFromInt</span>((compression_modes &amp; <span class="tok-number">0b00001100</span>) &gt;&gt; <span class="tok-number">2</span>));</span>
<span class="line" id="L1134">    <span class="tok-kw">const</span> offsets_mode = <span class="tok-builtin">@as</span>(SequencesSection.Header.Mode, <span class="tok-builtin">@enumFromInt</span>((compression_modes &amp; <span class="tok-number">0b00110000</span>) &gt;&gt; <span class="tok-number">4</span>));</span>
<span class="line" id="L1135">    <span class="tok-kw">const</span> literal_mode = <span class="tok-builtin">@as</span>(SequencesSection.Header.Mode, <span class="tok-builtin">@enumFromInt</span>((compression_modes &amp; <span class="tok-number">0b11000000</span>) &gt;&gt; <span class="tok-number">6</span>));</span>
<span class="line" id="L1136">    <span class="tok-kw">if</span> (compression_modes &amp; <span class="tok-number">0b11</span> != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReservedBitSet;</span>
<span class="line" id="L1137"></span>
<span class="line" id="L1138">    <span class="tok-kw">return</span> SequencesSection.Header{</span>
<span class="line" id="L1139">        .sequence_count = sequence_count,</span>
<span class="line" id="L1140">        .offsets = offsets_mode,</span>
<span class="line" id="L1141">        .match_lengths = matches_mode,</span>
<span class="line" id="L1142">        .literal_lengths = literal_mode,</span>
<span class="line" id="L1143">    };</span>
<span class="line" id="L1144">}</span>
<span class="line" id="L1145"></span>
</code></pre></body>
</html>