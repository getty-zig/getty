<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>compress/zstandard/decompress.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg==">
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);</span>
<span class="line" id="L2"><span class="tok-kw">const</span> assert = std.debug.assert;</span>
<span class="line" id="L3"><span class="tok-kw">const</span> Allocator = std.mem.Allocator;</span>
<span class="line" id="L4"><span class="tok-kw">const</span> RingBuffer = std.RingBuffer;</span>
<span class="line" id="L5"></span>
<span class="line" id="L6"><span class="tok-kw">const</span> types = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;types.zig&quot;</span>);</span>
<span class="line" id="L7"><span class="tok-kw">const</span> frame = types.frame;</span>
<span class="line" id="L8"><span class="tok-kw">const</span> LiteralsSection = types.compressed_block.LiteralsSection;</span>
<span class="line" id="L9"><span class="tok-kw">const</span> SequencesSection = types.compressed_block.SequencesSection;</span>
<span class="line" id="L10"><span class="tok-kw">const</span> SkippableHeader = types.frame.Skippable.Header;</span>
<span class="line" id="L11"><span class="tok-kw">const</span> ZstandardHeader = types.frame.Zstandard.Header;</span>
<span class="line" id="L12"><span class="tok-kw">const</span> Table = types.compressed_block.Table;</span>
<span class="line" id="L13"></span>
<span class="line" id="L14"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> block = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;decode/block.zig&quot;</span>);</span>
<span class="line" id="L15"></span>
<span class="line" id="L16"><span class="tok-kw">const</span> readers = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;readers.zig&quot;</span>);</span>
<span class="line" id="L17"></span>
<span class="line" id="L18"><span class="tok-comment">/// Returns `true` is `magic` is a valid magic number for a skippable frame</span></span>
<span class="line" id="L19"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isSkippableMagic</span>(magic: <span class="tok-type">u32</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L20">    <span class="tok-kw">return</span> frame.Skippable.magic_number_min &lt;= magic <span class="tok-kw">and</span> magic &lt;= frame.Skippable.magic_number_max;</span>
<span class="line" id="L21">}</span>
<span class="line" id="L22"></span>
<span class="line" id="L23"><span class="tok-comment">/// Returns the kind of frame at the beginning of `source`.</span></span>
<span class="line" id="L24"><span class="tok-comment">///</span></span>
<span class="line" id="L25"><span class="tok-comment">/// Errors returned:</span></span>
<span class="line" id="L26"><span class="tok-comment">///   - `error.BadMagic` if `source` begins with bytes not equal to the</span></span>
<span class="line" id="L27"><span class="tok-comment">///     Zstandard frame magic number, or outside the range of magic numbers for</span></span>
<span class="line" id="L28"><span class="tok-comment">///     skippable frames.</span></span>
<span class="line" id="L29"><span class="tok-comment">///   - `error.EndOfStream` if `source` contains fewer than 4 bytes</span></span>
<span class="line" id="L30"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeFrameType</span>(source: <span class="tok-kw">anytype</span>) <span class="tok-kw">error</span>{ BadMagic, EndOfStream }!frame.Kind {</span>
<span class="line" id="L31">    <span class="tok-kw">const</span> magic = <span class="tok-kw">try</span> source.readInt(<span class="tok-type">u32</span>, .little);</span>
<span class="line" id="L32">    <span class="tok-kw">return</span> frameType(magic);</span>
<span class="line" id="L33">}</span>
<span class="line" id="L34"></span>
<span class="line" id="L35"><span class="tok-comment">/// Returns the kind of frame associated to `magic`.</span></span>
<span class="line" id="L36"><span class="tok-comment">///</span></span>
<span class="line" id="L37"><span class="tok-comment">/// Errors returned:</span></span>
<span class="line" id="L38"><span class="tok-comment">///   - `error.BadMagic` if `magic` is not a valid magic number.</span></span>
<span class="line" id="L39"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">frameType</span>(magic: <span class="tok-type">u32</span>) <span class="tok-kw">error</span>{BadMagic}!frame.Kind {</span>
<span class="line" id="L40">    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (magic == frame.Zstandard.magic_number)</span>
<span class="line" id="L41">        .zstandard</span>
<span class="line" id="L42">    <span class="tok-kw">else</span> <span class="tok-kw">if</span> (isSkippableMagic(magic))</span>
<span class="line" id="L43">        .skippable</span>
<span class="line" id="L44">    <span class="tok-kw">else</span></span>
<span class="line" id="L45">        <span class="tok-kw">error</span>.BadMagic;</span>
<span class="line" id="L46">}</span>
<span class="line" id="L47"></span>
<span class="line" id="L48"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FrameHeader = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L49">    zstandard: ZstandardHeader,</span>
<span class="line" id="L50">    skippable: SkippableHeader,</span>
<span class="line" id="L51">};</span>
<span class="line" id="L52"></span>
<span class="line" id="L53"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> HeaderError = <span class="tok-kw">error</span>{ BadMagic, EndOfStream, ReservedBitSet };</span>
<span class="line" id="L54"></span>
<span class="line" id="L55"><span class="tok-comment">/// Returns the header of the frame at the beginning of `source`.</span></span>
<span class="line" id="L56"><span class="tok-comment">///</span></span>
<span class="line" id="L57"><span class="tok-comment">/// Errors returned:</span></span>
<span class="line" id="L58"><span class="tok-comment">///   - `error.BadMagic` if `source` begins with bytes not equal to the</span></span>
<span class="line" id="L59"><span class="tok-comment">///     Zstandard frame magic number, or outside the range of magic numbers for</span></span>
<span class="line" id="L60"><span class="tok-comment">///     skippable frames.</span></span>
<span class="line" id="L61"><span class="tok-comment">///   - `error.EndOfStream` if `source` contains fewer than 4 bytes</span></span>
<span class="line" id="L62"><span class="tok-comment">///   - `error.ReservedBitSet` if the frame is a Zstandard frame and any of the</span></span>
<span class="line" id="L63"><span class="tok-comment">///     reserved bits are set</span></span>
<span class="line" id="L64"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeFrameHeader</span>(source: <span class="tok-kw">anytype</span>) (<span class="tok-builtin">@TypeOf</span>(source).Error || HeaderError)!FrameHeader {</span>
<span class="line" id="L65">    <span class="tok-kw">const</span> magic = <span class="tok-kw">try</span> source.readInt(<span class="tok-type">u32</span>, .little);</span>
<span class="line" id="L66">    <span class="tok-kw">const</span> frame_type = <span class="tok-kw">try</span> frameType(magic);</span>
<span class="line" id="L67">    <span class="tok-kw">switch</span> (frame_type) {</span>
<span class="line" id="L68">        .zstandard =&gt; <span class="tok-kw">return</span> FrameHeader{ .zstandard = <span class="tok-kw">try</span> decodeZstandardHeader(source) },</span>
<span class="line" id="L69">        .skippable =&gt; <span class="tok-kw">return</span> FrameHeader{</span>
<span class="line" id="L70">            .skippable = .{</span>
<span class="line" id="L71">                .magic_number = magic,</span>
<span class="line" id="L72">                .frame_size = <span class="tok-kw">try</span> source.readInt(<span class="tok-type">u32</span>, .little),</span>
<span class="line" id="L73">            },</span>
<span class="line" id="L74">        },</span>
<span class="line" id="L75">    }</span>
<span class="line" id="L76">}</span>
<span class="line" id="L77"></span>
<span class="line" id="L78"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ReadWriteCount = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L79">    read_count: <span class="tok-type">usize</span>,</span>
<span class="line" id="L80">    write_count: <span class="tok-type">usize</span>,</span>
<span class="line" id="L81">};</span>
<span class="line" id="L82"></span>
<span class="line" id="L83"><span class="tok-comment">/// Decodes frames from `src` into `dest`; returns the length of the result.</span></span>
<span class="line" id="L84"><span class="tok-comment">/// The stream should not have extra trailing bytes - either all bytes in `src`</span></span>
<span class="line" id="L85"><span class="tok-comment">/// will be decoded, or an error will be returned. An error will be returned if</span></span>
<span class="line" id="L86"><span class="tok-comment">/// a Zstandard frame in `src` does not declare its content size.</span></span>
<span class="line" id="L87"><span class="tok-comment">///</span></span>
<span class="line" id="L88"><span class="tok-comment">/// Errors returned:</span></span>
<span class="line" id="L89"><span class="tok-comment">///   - `error.DictionaryIdFlagUnsupported` if a `src` contains a frame that</span></span>
<span class="line" id="L90"><span class="tok-comment">///     uses a dictionary</span></span>
<span class="line" id="L91"><span class="tok-comment">///   - `error.MalformedFrame` if a frame in `src` is invalid</span></span>
<span class="line" id="L92"><span class="tok-comment">///   - `error.UnknownContentSizeUnsupported` if a frame in `src` does not</span></span>
<span class="line" id="L93"><span class="tok-comment">///     declare its content size</span></span>
<span class="line" id="L94"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decode</span>(dest: []<span class="tok-type">u8</span>, src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, verify_checksum: <span class="tok-type">bool</span>) <span class="tok-kw">error</span>{</span>
<span class="line" id="L95">    MalformedFrame,</span>
<span class="line" id="L96">    UnknownContentSizeUnsupported,</span>
<span class="line" id="L97">    DictionaryIdFlagUnsupported,</span>
<span class="line" id="L98">}!<span class="tok-type">usize</span> {</span>
<span class="line" id="L99">    <span class="tok-kw">var</span> write_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L100">    <span class="tok-kw">var</span> read_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L101">    <span class="tok-kw">while</span> (read_count &lt; src.len) {</span>
<span class="line" id="L102">        <span class="tok-kw">const</span> counts = decodeFrame(dest, src[read_count..], verify_checksum) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L103">            <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L104">                <span class="tok-kw">error</span>.UnknownContentSizeUnsupported =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownContentSizeUnsupported,</span>
<span class="line" id="L105">                <span class="tok-kw">error</span>.DictionaryIdFlagUnsupported =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DictionaryIdFlagUnsupported,</span>
<span class="line" id="L106">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedFrame,</span>
<span class="line" id="L107">            }</span>
<span class="line" id="L108">        };</span>
<span class="line" id="L109">        read_count += counts.read_count;</span>
<span class="line" id="L110">        write_count += counts.write_count;</span>
<span class="line" id="L111">    }</span>
<span class="line" id="L112">    <span class="tok-kw">return</span> write_count;</span>
<span class="line" id="L113">}</span>
<span class="line" id="L114"></span>
<span class="line" id="L115"><span class="tok-comment">/// Decodes a stream of frames from `src`; returns the decoded bytes. The stream</span></span>
<span class="line" id="L116"><span class="tok-comment">/// should not have extra trailing bytes - either all bytes in `src` will be</span></span>
<span class="line" id="L117"><span class="tok-comment">/// decoded, or an error will be returned.</span></span>
<span class="line" id="L118"><span class="tok-comment">///</span></span>
<span class="line" id="L119"><span class="tok-comment">/// Errors returned:</span></span>
<span class="line" id="L120"><span class="tok-comment">///   - `error.DictionaryIdFlagUnsupported` if a `src` contains a frame that</span></span>
<span class="line" id="L121"><span class="tok-comment">///     uses a dictionary</span></span>
<span class="line" id="L122"><span class="tok-comment">///   - `error.MalformedFrame` if a frame in `src` is invalid</span></span>
<span class="line" id="L123"><span class="tok-comment">///   - `error.OutOfMemory` if `allocator` cannot allocate enough memory</span></span>
<span class="line" id="L124"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeAlloc</span>(</span>
<span class="line" id="L125">    allocator: Allocator,</span>
<span class="line" id="L126">    src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L127">    verify_checksum: <span class="tok-type">bool</span>,</span>
<span class="line" id="L128">    window_size_max: <span class="tok-type">usize</span>,</span>
<span class="line" id="L129">) <span class="tok-kw">error</span>{ DictionaryIdFlagUnsupported, MalformedFrame, OutOfMemory }![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L130">    <span class="tok-kw">var</span> result = std.ArrayList(<span class="tok-type">u8</span>).init(allocator);</span>
<span class="line" id="L131">    <span class="tok-kw">errdefer</span> result.deinit();</span>
<span class="line" id="L132"></span>
<span class="line" id="L133">    <span class="tok-kw">var</span> read_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L134">    <span class="tok-kw">while</span> (read_count &lt; src.len) {</span>
<span class="line" id="L135">        read_count += decodeFrameArrayList(</span>
<span class="line" id="L136">            allocator,</span>
<span class="line" id="L137">            &amp;result,</span>
<span class="line" id="L138">            src[read_count..],</span>
<span class="line" id="L139">            verify_checksum,</span>
<span class="line" id="L140">            window_size_max,</span>
<span class="line" id="L141">        ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L142">            <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,</span>
<span class="line" id="L143">            <span class="tok-kw">error</span>.DictionaryIdFlagUnsupported =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DictionaryIdFlagUnsupported,</span>
<span class="line" id="L144">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MalformedFrame,</span>
<span class="line" id="L145">        };</span>
<span class="line" id="L146">    }</span>
<span class="line" id="L147">    <span class="tok-kw">return</span> result.toOwnedSlice();</span>
<span class="line" id="L148">}</span>
<span class="line" id="L149"></span>
<span class="line" id="L150"><span class="tok-comment">/// Decodes the frame at the start of `src` into `dest`. Returns the number of</span></span>
<span class="line" id="L151"><span class="tok-comment">/// bytes read from `src` and written to `dest`. This function can only decode</span></span>
<span class="line" id="L152"><span class="tok-comment">/// frames that declare the decompressed content size.</span></span>
<span class="line" id="L153"><span class="tok-comment">///</span></span>
<span class="line" id="L154"><span class="tok-comment">/// Errors returned:</span></span>
<span class="line" id="L155"><span class="tok-comment">///   - `error.BadMagic` if the first 4 bytes of `src` is not a valid magic</span></span>
<span class="line" id="L156"><span class="tok-comment">///     number for a Zstandard or skippable frame</span></span>
<span class="line" id="L157"><span class="tok-comment">///   - `error.UnknownContentSizeUnsupported` if the frame does not declare the</span></span>
<span class="line" id="L158"><span class="tok-comment">///     uncompressed content size</span></span>
<span class="line" id="L159"><span class="tok-comment">///   - `error.WindowSizeUnknown` if the frame does not have a valid window size</span></span>
<span class="line" id="L160"><span class="tok-comment">///   - `error.ContentTooLarge` if `dest` is smaller than the uncompressed data</span></span>
<span class="line" id="L161"><span class="tok-comment">///     size declared by the frame header</span></span>
<span class="line" id="L162"><span class="tok-comment">///   - `error.ContentSizeTooLarge` if the frame header indicates a content size</span></span>
<span class="line" id="L163"><span class="tok-comment">///     that is larger than `std.math.maxInt(usize)`</span></span>
<span class="line" id="L164"><span class="tok-comment">///   - `error.DictionaryIdFlagUnsupported` if the frame uses a dictionary</span></span>
<span class="line" id="L165"><span class="tok-comment">///   - `error.ChecksumFailure` if `verify_checksum` is true and the frame</span></span>
<span class="line" id="L166"><span class="tok-comment">///     contains a checksum that does not match the checksum of the decompressed</span></span>
<span class="line" id="L167"><span class="tok-comment">///     data</span></span>
<span class="line" id="L168"><span class="tok-comment">///   - `error.ReservedBitSet` if any of the reserved bits of the frame header</span></span>
<span class="line" id="L169"><span class="tok-comment">///     are set</span></span>
<span class="line" id="L170"><span class="tok-comment">///   - `error.EndOfStream` if `src` does not contain a complete frame</span></span>
<span class="line" id="L171"><span class="tok-comment">///   - `error.BadContentSize` if the content size declared by the frame does</span></span>
<span class="line" id="L172"><span class="tok-comment">///     not equal the actual size of decompressed data</span></span>
<span class="line" id="L173"><span class="tok-comment">///   - an error in `block.Error` if there are errors decoding a block</span></span>
<span class="line" id="L174"><span class="tok-comment">///   - `error.SkippableSizeTooLarge` if the frame is skippable and reports a</span></span>
<span class="line" id="L175"><span class="tok-comment">///     size greater than `src.len`</span></span>
<span class="line" id="L176"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeFrame</span>(</span>
<span class="line" id="L177">    dest: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L178">    src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L179">    verify_checksum: <span class="tok-type">bool</span>,</span>
<span class="line" id="L180">) (<span class="tok-kw">error</span>{</span>
<span class="line" id="L181">    BadMagic,</span>
<span class="line" id="L182">    UnknownContentSizeUnsupported,</span>
<span class="line" id="L183">    ContentTooLarge,</span>
<span class="line" id="L184">    ContentSizeTooLarge,</span>
<span class="line" id="L185">    WindowSizeUnknown,</span>
<span class="line" id="L186">    DictionaryIdFlagUnsupported,</span>
<span class="line" id="L187">    SkippableSizeTooLarge,</span>
<span class="line" id="L188">} || FrameError)!ReadWriteCount {</span>
<span class="line" id="L189">    <span class="tok-kw">var</span> fbs = std.io.fixedBufferStream(src);</span>
<span class="line" id="L190">    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> decodeFrameType(fbs.reader())) {</span>
<span class="line" id="L191">        .zstandard =&gt; <span class="tok-kw">return</span> decodeZstandardFrame(dest, src, verify_checksum),</span>
<span class="line" id="L192">        .skippable =&gt; {</span>
<span class="line" id="L193">            <span class="tok-kw">const</span> content_size = <span class="tok-kw">try</span> fbs.reader().readInt(<span class="tok-type">u32</span>, .little);</span>
<span class="line" id="L194">            <span class="tok-kw">if</span> (content_size &gt; std.math.maxInt(<span class="tok-type">usize</span>) - <span class="tok-number">8</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkippableSizeTooLarge;</span>
<span class="line" id="L195">            <span class="tok-kw">const</span> read_count = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, content_size) + <span class="tok-number">8</span>;</span>
<span class="line" id="L196">            <span class="tok-kw">if</span> (read_count &gt; src.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkippableSizeTooLarge;</span>
<span class="line" id="L197">            <span class="tok-kw">return</span> ReadWriteCount{</span>
<span class="line" id="L198">                .read_count = read_count,</span>
<span class="line" id="L199">                .write_count = <span class="tok-number">0</span>,</span>
<span class="line" id="L200">            };</span>
<span class="line" id="L201">        },</span>
<span class="line" id="L202">    }</span>
<span class="line" id="L203">}</span>
<span class="line" id="L204"></span>
<span class="line" id="L205"><span class="tok-comment">/// Decodes the frame at the start of `src` into `dest`. Returns the number of</span></span>
<span class="line" id="L206"><span class="tok-comment">/// bytes read from `src`.</span></span>
<span class="line" id="L207"><span class="tok-comment">///</span></span>
<span class="line" id="L208"><span class="tok-comment">/// Errors returned:</span></span>
<span class="line" id="L209"><span class="tok-comment">///   - `error.BadMagic` if the first 4 bytes of `src` is not a valid magic</span></span>
<span class="line" id="L210"><span class="tok-comment">///     number for a Zstandard or skippable frame</span></span>
<span class="line" id="L211"><span class="tok-comment">///   - `error.WindowSizeUnknown` if the frame does not have a valid window size</span></span>
<span class="line" id="L212"><span class="tok-comment">///   - `error.WindowTooLarge` if the window size is larger than</span></span>
<span class="line" id="L213"><span class="tok-comment">///     `window_size_max`</span></span>
<span class="line" id="L214"><span class="tok-comment">///   - `error.ContentSizeTooLarge` if the frame header indicates a content size</span></span>
<span class="line" id="L215"><span class="tok-comment">///     that is larger than `std.math.maxInt(usize)`</span></span>
<span class="line" id="L216"><span class="tok-comment">///   - `error.DictionaryIdFlagUnsupported` if the frame uses a dictionary</span></span>
<span class="line" id="L217"><span class="tok-comment">///   - `error.ChecksumFailure` if `verify_checksum` is true and the frame</span></span>
<span class="line" id="L218"><span class="tok-comment">///     contains a checksum that does not match the checksum of the decompressed</span></span>
<span class="line" id="L219"><span class="tok-comment">///     data</span></span>
<span class="line" id="L220"><span class="tok-comment">///   - `error.ReservedBitSet` if any of the reserved bits of the frame header</span></span>
<span class="line" id="L221"><span class="tok-comment">///     are set</span></span>
<span class="line" id="L222"><span class="tok-comment">///   - `error.EndOfStream` if `src` does not contain a complete frame</span></span>
<span class="line" id="L223"><span class="tok-comment">///   - `error.BadContentSize` if the content size declared by the frame does</span></span>
<span class="line" id="L224"><span class="tok-comment">///     not equal the actual size of decompressed data</span></span>
<span class="line" id="L225"><span class="tok-comment">///   - `error.OutOfMemory` if `allocator` cannot allocate enough memory</span></span>
<span class="line" id="L226"><span class="tok-comment">///   - an error in `block.Error` if there are errors decoding a block</span></span>
<span class="line" id="L227"><span class="tok-comment">///   - `error.SkippableSizeTooLarge` if the frame is skippable and reports a</span></span>
<span class="line" id="L228"><span class="tok-comment">///     size greater than `src.len`</span></span>
<span class="line" id="L229"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeFrameArrayList</span>(</span>
<span class="line" id="L230">    allocator: Allocator,</span>
<span class="line" id="L231">    dest: *std.ArrayList(<span class="tok-type">u8</span>),</span>
<span class="line" id="L232">    src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L233">    verify_checksum: <span class="tok-type">bool</span>,</span>
<span class="line" id="L234">    window_size_max: <span class="tok-type">usize</span>,</span>
<span class="line" id="L235">) (<span class="tok-kw">error</span>{ BadMagic, OutOfMemory, SkippableSizeTooLarge } || FrameContext.Error || FrameError)!<span class="tok-type">usize</span> {</span>
<span class="line" id="L236">    <span class="tok-kw">var</span> fbs = std.io.fixedBufferStream(src);</span>
<span class="line" id="L237">    <span class="tok-kw">const</span> reader = fbs.reader();</span>
<span class="line" id="L238">    <span class="tok-kw">const</span> magic = <span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u32</span>, .little);</span>
<span class="line" id="L239">    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> frameType(magic)) {</span>
<span class="line" id="L240">        .zstandard =&gt; <span class="tok-kw">return</span> decodeZstandardFrameArrayList(</span>
<span class="line" id="L241">            allocator,</span>
<span class="line" id="L242">            dest,</span>
<span class="line" id="L243">            src,</span>
<span class="line" id="L244">            verify_checksum,</span>
<span class="line" id="L245">            window_size_max,</span>
<span class="line" id="L246">        ),</span>
<span class="line" id="L247">        .skippable =&gt; {</span>
<span class="line" id="L248">            <span class="tok-kw">const</span> content_size = <span class="tok-kw">try</span> fbs.reader().readInt(<span class="tok-type">u32</span>, .little);</span>
<span class="line" id="L249">            <span class="tok-kw">if</span> (content_size &gt; std.math.maxInt(<span class="tok-type">usize</span>) - <span class="tok-number">8</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkippableSizeTooLarge;</span>
<span class="line" id="L250">            <span class="tok-kw">const</span> read_count = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, content_size) + <span class="tok-number">8</span>;</span>
<span class="line" id="L251">            <span class="tok-kw">if</span> (read_count &gt; src.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkippableSizeTooLarge;</span>
<span class="line" id="L252">            <span class="tok-kw">return</span> read_count;</span>
<span class="line" id="L253">        },</span>
<span class="line" id="L254">    }</span>
<span class="line" id="L255">}</span>
<span class="line" id="L256"></span>
<span class="line" id="L257"><span class="tok-comment">/// Returns the frame checksum corresponding to the data fed into `hasher`</span></span>
<span class="line" id="L258"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">computeChecksum</span>(hasher: *std.hash.XxHash64) <span class="tok-type">u32</span> {</span>
<span class="line" id="L259">    <span class="tok-kw">const</span> hash = hasher.final();</span>
<span class="line" id="L260">    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(hash &amp; <span class="tok-number">0xFFFFFFFF</span>));</span>
<span class="line" id="L261">}</span>
<span class="line" id="L262"></span>
<span class="line" id="L263"><span class="tok-kw">const</span> FrameError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L264">    ChecksumFailure,</span>
<span class="line" id="L265">    BadContentSize,</span>
<span class="line" id="L266">    EndOfStream,</span>
<span class="line" id="L267">    ReservedBitSet,</span>
<span class="line" id="L268">} || block.Error;</span>
<span class="line" id="L269"></span>
<span class="line" id="L270"><span class="tok-comment">/// Decode a Zstandard frame from `src` into `dest`, returning the number of</span></span>
<span class="line" id="L271"><span class="tok-comment">/// bytes read from `src` and written to `dest`. The first four bytes of `src`</span></span>
<span class="line" id="L272"><span class="tok-comment">/// must be the magic number for a Zstandard frame.</span></span>
<span class="line" id="L273"><span class="tok-comment">///</span></span>
<span class="line" id="L274"><span class="tok-comment">/// Error returned:</span></span>
<span class="line" id="L275"><span class="tok-comment">///   - `error.UnknownContentSizeUnsupported` if the frame does not declare the</span></span>
<span class="line" id="L276"><span class="tok-comment">///     uncompressed content size</span></span>
<span class="line" id="L277"><span class="tok-comment">///   - `error.ContentTooLarge` if `dest` is smaller than the uncompressed data</span></span>
<span class="line" id="L278"><span class="tok-comment">///     size declared by the frame header</span></span>
<span class="line" id="L279"><span class="tok-comment">///   - `error.WindowSizeUnknown` if the frame does not have a valid window size</span></span>
<span class="line" id="L280"><span class="tok-comment">///   - `error.DictionaryIdFlagUnsupported` if the frame uses a dictionary</span></span>
<span class="line" id="L281"><span class="tok-comment">///   - `error.ContentSizeTooLarge` if the frame header indicates a content size</span></span>
<span class="line" id="L282"><span class="tok-comment">///     that is larger than `std.math.maxInt(usize)`</span></span>
<span class="line" id="L283"><span class="tok-comment">///   - `error.ChecksumFailure` if `verify_checksum` is true and the frame</span></span>
<span class="line" id="L284"><span class="tok-comment">///     contains a checksum that does not match the checksum of the decompressed</span></span>
<span class="line" id="L285"><span class="tok-comment">///     data</span></span>
<span class="line" id="L286"><span class="tok-comment">///   - `error.ReservedBitSet` if the reserved bit of the frame header is set</span></span>
<span class="line" id="L287"><span class="tok-comment">///   - `error.EndOfStream` if `src` does not contain a complete frame</span></span>
<span class="line" id="L288"><span class="tok-comment">///   - an error in `block.Error` if there are errors decoding a block</span></span>
<span class="line" id="L289"><span class="tok-comment">///   - `error.BadContentSize` if the content size declared by the frame does</span></span>
<span class="line" id="L290"><span class="tok-comment">///     not equal the actual size of decompressed data</span></span>
<span class="line" id="L291"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeZstandardFrame</span>(</span>
<span class="line" id="L292">    dest: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L293">    src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L294">    verify_checksum: <span class="tok-type">bool</span>,</span>
<span class="line" id="L295">) (<span class="tok-kw">error</span>{</span>
<span class="line" id="L296">    UnknownContentSizeUnsupported,</span>
<span class="line" id="L297">    ContentTooLarge,</span>
<span class="line" id="L298">    ContentSizeTooLarge,</span>
<span class="line" id="L299">    WindowSizeUnknown,</span>
<span class="line" id="L300">    DictionaryIdFlagUnsupported,</span>
<span class="line" id="L301">} || FrameError)!ReadWriteCount {</span>
<span class="line" id="L302">    assert(std.mem.readInt(<span class="tok-type">u32</span>, src[<span class="tok-number">0</span>..<span class="tok-number">4</span>], .little) == frame.Zstandard.magic_number);</span>
<span class="line" id="L303">    <span class="tok-kw">var</span> consumed_count: <span class="tok-type">usize</span> = <span class="tok-number">4</span>;</span>
<span class="line" id="L304"></span>
<span class="line" id="L305">    <span class="tok-kw">var</span> frame_context = context: {</span>
<span class="line" id="L306">        <span class="tok-kw">var</span> fbs = std.io.fixedBufferStream(src[consumed_count..]);</span>
<span class="line" id="L307">        <span class="tok-kw">var</span> source = fbs.reader();</span>
<span class="line" id="L308">        <span class="tok-kw">const</span> frame_header = <span class="tok-kw">try</span> decodeZstandardHeader(source);</span>
<span class="line" id="L309">        consumed_count += fbs.pos;</span>
<span class="line" id="L310">        <span class="tok-kw">break</span> :context FrameContext.init(</span>
<span class="line" id="L311">            frame_header,</span>
<span class="line" id="L312">            std.math.maxInt(<span class="tok-type">usize</span>),</span>
<span class="line" id="L313">            verify_checksum,</span>
<span class="line" id="L314">        ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L315">            <span class="tok-kw">error</span>.WindowTooLarge =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L316">            <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L317">        };</span>
<span class="line" id="L318">    };</span>
<span class="line" id="L319">    <span class="tok-kw">const</span> counts = <span class="tok-kw">try</span> decodeZStandardFrameBlocks(</span>
<span class="line" id="L320">        dest,</span>
<span class="line" id="L321">        src[consumed_count..],</span>
<span class="line" id="L322">        &amp;frame_context,</span>
<span class="line" id="L323">    );</span>
<span class="line" id="L324">    <span class="tok-kw">return</span> ReadWriteCount{</span>
<span class="line" id="L325">        .read_count = counts.read_count + consumed_count,</span>
<span class="line" id="L326">        .write_count = counts.write_count,</span>
<span class="line" id="L327">    };</span>
<span class="line" id="L328">}</span>
<span class="line" id="L329"></span>
<span class="line" id="L330"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeZStandardFrameBlocks</span>(</span>
<span class="line" id="L331">    dest: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L332">    src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L333">    frame_context: *FrameContext,</span>
<span class="line" id="L334">) (<span class="tok-kw">error</span>{ ContentTooLarge, UnknownContentSizeUnsupported } || FrameError)!ReadWriteCount {</span>
<span class="line" id="L335">    <span class="tok-kw">const</span> content_size = frame_context.content_size <span class="tok-kw">orelse</span></span>
<span class="line" id="L336">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownContentSizeUnsupported;</span>
<span class="line" id="L337">    <span class="tok-kw">if</span> (dest.len &lt; content_size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ContentTooLarge;</span>
<span class="line" id="L338"></span>
<span class="line" id="L339">    <span class="tok-kw">var</span> consumed_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L340">    <span class="tok-kw">const</span> written_count = decodeFrameBlocksInner(</span>
<span class="line" id="L341">        dest[<span class="tok-number">0</span>..content_size],</span>
<span class="line" id="L342">        src[consumed_count..],</span>
<span class="line" id="L343">        &amp;consumed_count,</span>
<span class="line" id="L344">        <span class="tok-kw">if</span> (frame_context.hasher_opt) |*hasher| hasher <span class="tok-kw">else</span> <span class="tok-null">null</span>,</span>
<span class="line" id="L345">        frame_context.block_size_max,</span>
<span class="line" id="L346">    ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L347">        <span class="tok-kw">error</span>.DestTooSmall =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BadContentSize,</span>
<span class="line" id="L348">        <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L349">    };</span>
<span class="line" id="L350"></span>
<span class="line" id="L351">    <span class="tok-kw">if</span> (written_count != content_size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BadContentSize;</span>
<span class="line" id="L352">    <span class="tok-kw">if</span> (frame_context.has_checksum) {</span>
<span class="line" id="L353">        <span class="tok-kw">if</span> (src.len &lt; consumed_count + <span class="tok-number">4</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EndOfStream;</span>
<span class="line" id="L354">        <span class="tok-kw">const</span> checksum = std.mem.readInt(<span class="tok-type">u32</span>, src[consumed_count..][<span class="tok-number">0</span>..<span class="tok-number">4</span>], .little);</span>
<span class="line" id="L355">        consumed_count += <span class="tok-number">4</span>;</span>
<span class="line" id="L356">        <span class="tok-kw">if</span> (frame_context.hasher_opt) |*hasher| {</span>
<span class="line" id="L357">            <span class="tok-kw">if</span> (checksum != computeChecksum(hasher)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ChecksumFailure;</span>
<span class="line" id="L358">        }</span>
<span class="line" id="L359">    }</span>
<span class="line" id="L360">    <span class="tok-kw">return</span> ReadWriteCount{ .read_count = consumed_count, .write_count = written_count };</span>
<span class="line" id="L361">}</span>
<span class="line" id="L362"></span>
<span class="line" id="L363"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FrameContext = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L364">    hasher_opt: ?std.hash.XxHash64,</span>
<span class="line" id="L365">    window_size: <span class="tok-type">usize</span>,</span>
<span class="line" id="L366">    has_checksum: <span class="tok-type">bool</span>,</span>
<span class="line" id="L367">    block_size_max: <span class="tok-type">usize</span>,</span>
<span class="line" id="L368">    content_size: ?<span class="tok-type">usize</span>,</span>
<span class="line" id="L369"></span>
<span class="line" id="L370">    <span class="tok-kw">const</span> Error = <span class="tok-kw">error</span>{</span>
<span class="line" id="L371">        DictionaryIdFlagUnsupported,</span>
<span class="line" id="L372">        WindowSizeUnknown,</span>
<span class="line" id="L373">        WindowTooLarge,</span>
<span class="line" id="L374">        ContentSizeTooLarge,</span>
<span class="line" id="L375">    };</span>
<span class="line" id="L376">    <span class="tok-comment">/// Validates `frame_header` and returns the associated `FrameContext`.</span></span>
<span class="line" id="L377">    <span class="tok-comment">///</span></span>
<span class="line" id="L378">    <span class="tok-comment">/// Errors returned:</span></span>
<span class="line" id="L379">    <span class="tok-comment">///   - `error.DictionaryIdFlagUnsupported` if the frame uses a dictionary</span></span>
<span class="line" id="L380">    <span class="tok-comment">///   - `error.WindowSizeUnknown` if the frame does not have a valid window</span></span>
<span class="line" id="L381">    <span class="tok-comment">///     size</span></span>
<span class="line" id="L382">    <span class="tok-comment">///   - `error.WindowTooLarge` if the window size is larger than</span></span>
<span class="line" id="L383">    <span class="tok-comment">///     `window_size_max`</span></span>
<span class="line" id="L384">    <span class="tok-comment">///   - `error.ContentSizeTooLarge` if the frame header indicates a content</span></span>
<span class="line" id="L385">    <span class="tok-comment">///     size larger than `std.math.maxInt(usize)`</span></span>
<span class="line" id="L386">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(</span>
<span class="line" id="L387">        frame_header: ZstandardHeader,</span>
<span class="line" id="L388">        window_size_max: <span class="tok-type">usize</span>,</span>
<span class="line" id="L389">        verify_checksum: <span class="tok-type">bool</span>,</span>
<span class="line" id="L390">    ) Error!FrameContext {</span>
<span class="line" id="L391">        <span class="tok-kw">if</span> (frame_header.descriptor.dictionary_id_flag != <span class="tok-number">0</span>)</span>
<span class="line" id="L392">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DictionaryIdFlagUnsupported;</span>
<span class="line" id="L393"></span>
<span class="line" id="L394">        <span class="tok-kw">const</span> window_size_raw = frameWindowSize(frame_header) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WindowSizeUnknown;</span>
<span class="line" id="L395">        <span class="tok-kw">const</span> window_size = <span class="tok-kw">if</span> (window_size_raw &gt; window_size_max)</span>
<span class="line" id="L396">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.WindowTooLarge</span>
<span class="line" id="L397">        <span class="tok-kw">else</span></span>
<span class="line" id="L398">            <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(window_size_raw));</span>
<span class="line" id="L399"></span>
<span class="line" id="L400">        <span class="tok-kw">const</span> should_compute_checksum =</span>
<span class="line" id="L401">            frame_header.descriptor.content_checksum_flag <span class="tok-kw">and</span> verify_checksum;</span>
<span class="line" id="L402"></span>
<span class="line" id="L403">        <span class="tok-kw">const</span> content_size = <span class="tok-kw">if</span> (frame_header.content_size) |size|</span>
<span class="line" id="L404">            std.math.cast(<span class="tok-type">usize</span>, size) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ContentSizeTooLarge</span>
<span class="line" id="L405">        <span class="tok-kw">else</span></span>
<span class="line" id="L406">            <span class="tok-null">null</span>;</span>
<span class="line" id="L407"></span>
<span class="line" id="L408">        <span class="tok-kw">return</span> .{</span>
<span class="line" id="L409">            .hasher_opt = <span class="tok-kw">if</span> (should_compute_checksum) std.hash.XxHash64.init(<span class="tok-number">0</span>) <span class="tok-kw">else</span> <span class="tok-null">null</span>,</span>
<span class="line" id="L410">            .window_size = window_size,</span>
<span class="line" id="L411">            .has_checksum = frame_header.descriptor.content_checksum_flag,</span>
<span class="line" id="L412">            .block_size_max = <span class="tok-builtin">@min</span>(<span class="tok-number">1</span> &lt;&lt; <span class="tok-number">17</span>, window_size),</span>
<span class="line" id="L413">            .content_size = content_size,</span>
<span class="line" id="L414">        };</span>
<span class="line" id="L415">    }</span>
<span class="line" id="L416">};</span>
<span class="line" id="L417"></span>
<span class="line" id="L418"><span class="tok-comment">/// Decode a Zstandard from from `src` and return number of bytes read; see</span></span>
<span class="line" id="L419"><span class="tok-comment">/// `decodeZstandardFrame()`. The first four bytes of `src` must be the magic</span></span>
<span class="line" id="L420"><span class="tok-comment">/// number for a Zstandard frame.</span></span>
<span class="line" id="L421"><span class="tok-comment">///</span></span>
<span class="line" id="L422"><span class="tok-comment">/// Errors returned:</span></span>
<span class="line" id="L423"><span class="tok-comment">///   - `error.WindowSizeUnknown` if the frame does not have a valid window size</span></span>
<span class="line" id="L424"><span class="tok-comment">///   - `error.WindowTooLarge` if the window size is larger than</span></span>
<span class="line" id="L425"><span class="tok-comment">///     `window_size_max`</span></span>
<span class="line" id="L426"><span class="tok-comment">///   - `error.DictionaryIdFlagUnsupported` if the frame uses a dictionary</span></span>
<span class="line" id="L427"><span class="tok-comment">///   - `error.ContentSizeTooLarge` if the frame header indicates a content size</span></span>
<span class="line" id="L428"><span class="tok-comment">///     that is larger than `std.math.maxInt(usize)`</span></span>
<span class="line" id="L429"><span class="tok-comment">///   - `error.ChecksumFailure` if `verify_checksum` is true and the frame</span></span>
<span class="line" id="L430"><span class="tok-comment">///     contains a checksum that does not match the checksum of the decompressed</span></span>
<span class="line" id="L431"><span class="tok-comment">///     data</span></span>
<span class="line" id="L432"><span class="tok-comment">///   - `error.ReservedBitSet` if the reserved bit of the frame header is set</span></span>
<span class="line" id="L433"><span class="tok-comment">///   - `error.EndOfStream` if `src` does not contain a complete frame</span></span>
<span class="line" id="L434"><span class="tok-comment">///   - `error.OutOfMemory` if `allocator` cannot allocate enough memory</span></span>
<span class="line" id="L435"><span class="tok-comment">///   - an error in `block.Error` if there are errors decoding a block</span></span>
<span class="line" id="L436"><span class="tok-comment">///   - `error.BadContentSize` if the content size declared by the frame does</span></span>
<span class="line" id="L437"><span class="tok-comment">///     not equal the size of decompressed data</span></span>
<span class="line" id="L438"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeZstandardFrameArrayList</span>(</span>
<span class="line" id="L439">    allocator: Allocator,</span>
<span class="line" id="L440">    dest: *std.ArrayList(<span class="tok-type">u8</span>),</span>
<span class="line" id="L441">    src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L442">    verify_checksum: <span class="tok-type">bool</span>,</span>
<span class="line" id="L443">    window_size_max: <span class="tok-type">usize</span>,</span>
<span class="line" id="L444">) (<span class="tok-kw">error</span>{OutOfMemory} || FrameContext.Error || FrameError)!<span class="tok-type">usize</span> {</span>
<span class="line" id="L445">    assert(std.mem.readInt(<span class="tok-type">u32</span>, src[<span class="tok-number">0</span>..<span class="tok-number">4</span>], .little) == frame.Zstandard.magic_number);</span>
<span class="line" id="L446">    <span class="tok-kw">var</span> consumed_count: <span class="tok-type">usize</span> = <span class="tok-number">4</span>;</span>
<span class="line" id="L447"></span>
<span class="line" id="L448">    <span class="tok-kw">var</span> frame_context = context: {</span>
<span class="line" id="L449">        <span class="tok-kw">var</span> fbs = std.io.fixedBufferStream(src[consumed_count..]);</span>
<span class="line" id="L450">        <span class="tok-kw">var</span> source = fbs.reader();</span>
<span class="line" id="L451">        <span class="tok-kw">const</span> frame_header = <span class="tok-kw">try</span> decodeZstandardHeader(source);</span>
<span class="line" id="L452">        consumed_count += fbs.pos;</span>
<span class="line" id="L453">        <span class="tok-kw">break</span> :context <span class="tok-kw">try</span> FrameContext.init(frame_header, window_size_max, verify_checksum);</span>
<span class="line" id="L454">    };</span>
<span class="line" id="L455"></span>
<span class="line" id="L456">    consumed_count += <span class="tok-kw">try</span> decodeZstandardFrameBlocksArrayList(</span>
<span class="line" id="L457">        allocator,</span>
<span class="line" id="L458">        dest,</span>
<span class="line" id="L459">        src[consumed_count..],</span>
<span class="line" id="L460">        &amp;frame_context,</span>
<span class="line" id="L461">    );</span>
<span class="line" id="L462">    <span class="tok-kw">return</span> consumed_count;</span>
<span class="line" id="L463">}</span>
<span class="line" id="L464"></span>
<span class="line" id="L465"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeZstandardFrameBlocksArrayList</span>(</span>
<span class="line" id="L466">    allocator: Allocator,</span>
<span class="line" id="L467">    dest: *std.ArrayList(<span class="tok-type">u8</span>),</span>
<span class="line" id="L468">    src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L469">    frame_context: *FrameContext,</span>
<span class="line" id="L470">) (<span class="tok-kw">error</span>{OutOfMemory} || FrameError)!<span class="tok-type">usize</span> {</span>
<span class="line" id="L471">    <span class="tok-kw">const</span> initial_len = dest.items.len;</span>
<span class="line" id="L472"></span>
<span class="line" id="L473">    <span class="tok-kw">var</span> ring_buffer = <span class="tok-kw">try</span> RingBuffer.init(allocator, frame_context.window_size);</span>
<span class="line" id="L474">    <span class="tok-kw">defer</span> ring_buffer.deinit(allocator);</span>
<span class="line" id="L475"></span>
<span class="line" id="L476">    <span class="tok-comment">// These tables take 7680 bytes</span>
</span>
<span class="line" id="L477">    <span class="tok-kw">var</span> literal_fse_data: [types.compressed_block.table_size_max.literal]Table.Fse = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L478">    <span class="tok-kw">var</span> match_fse_data: [types.compressed_block.table_size_max.match]Table.Fse = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L479">    <span class="tok-kw">var</span> offset_fse_data: [types.compressed_block.table_size_max.offset]Table.Fse = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L480"></span>
<span class="line" id="L481">    <span class="tok-kw">var</span> block_header = <span class="tok-kw">try</span> block.decodeBlockHeaderSlice(src);</span>
<span class="line" id="L482">    <span class="tok-kw">var</span> consumed_count: <span class="tok-type">usize</span> = <span class="tok-number">3</span>;</span>
<span class="line" id="L483">    <span class="tok-kw">var</span> decode_state = block.DecodeState.init(&amp;literal_fse_data, &amp;match_fse_data, &amp;offset_fse_data);</span>
<span class="line" id="L484">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : ({</span>
<span class="line" id="L485">        block_header = <span class="tok-kw">try</span> block.decodeBlockHeaderSlice(src[consumed_count..]);</span>
<span class="line" id="L486">        consumed_count += <span class="tok-number">3</span>;</span>
<span class="line" id="L487">    }) {</span>
<span class="line" id="L488">        <span class="tok-kw">const</span> written_size = <span class="tok-kw">try</span> block.decodeBlockRingBuffer(</span>
<span class="line" id="L489">            &amp;ring_buffer,</span>
<span class="line" id="L490">            src[consumed_count..],</span>
<span class="line" id="L491">            block_header,</span>
<span class="line" id="L492">            &amp;decode_state,</span>
<span class="line" id="L493">            &amp;consumed_count,</span>
<span class="line" id="L494">            frame_context.block_size_max,</span>
<span class="line" id="L495">        );</span>
<span class="line" id="L496">        <span class="tok-kw">if</span> (frame_context.content_size) |size| {</span>
<span class="line" id="L497">            <span class="tok-kw">if</span> (dest.items.len - initial_len &gt; size) {</span>
<span class="line" id="L498">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BadContentSize;</span>
<span class="line" id="L499">            }</span>
<span class="line" id="L500">        }</span>
<span class="line" id="L501">        <span class="tok-kw">if</span> (written_size &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L502">            <span class="tok-kw">const</span> written_slice = ring_buffer.sliceLast(written_size);</span>
<span class="line" id="L503">            <span class="tok-kw">try</span> dest.appendSlice(written_slice.first);</span>
<span class="line" id="L504">            <span class="tok-kw">try</span> dest.appendSlice(written_slice.second);</span>
<span class="line" id="L505">            <span class="tok-kw">if</span> (frame_context.hasher_opt) |*hasher| {</span>
<span class="line" id="L506">                hasher.update(written_slice.first);</span>
<span class="line" id="L507">                hasher.update(written_slice.second);</span>
<span class="line" id="L508">            }</span>
<span class="line" id="L509">        }</span>
<span class="line" id="L510">        <span class="tok-kw">if</span> (block_header.last_block) <span class="tok-kw">break</span>;</span>
<span class="line" id="L511">    }</span>
<span class="line" id="L512">    <span class="tok-kw">if</span> (frame_context.content_size) |size| {</span>
<span class="line" id="L513">        <span class="tok-kw">if</span> (dest.items.len - initial_len != size) {</span>
<span class="line" id="L514">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BadContentSize;</span>
<span class="line" id="L515">        }</span>
<span class="line" id="L516">    }</span>
<span class="line" id="L517"></span>
<span class="line" id="L518">    <span class="tok-kw">if</span> (frame_context.has_checksum) {</span>
<span class="line" id="L519">        <span class="tok-kw">if</span> (src.len &lt; consumed_count + <span class="tok-number">4</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EndOfStream;</span>
<span class="line" id="L520">        <span class="tok-kw">const</span> checksum = std.mem.readInt(<span class="tok-type">u32</span>, src[consumed_count..][<span class="tok-number">0</span>..<span class="tok-number">4</span>], .little);</span>
<span class="line" id="L521">        consumed_count += <span class="tok-number">4</span>;</span>
<span class="line" id="L522">        <span class="tok-kw">if</span> (frame_context.hasher_opt) |*hasher| {</span>
<span class="line" id="L523">            <span class="tok-kw">if</span> (checksum != computeChecksum(hasher)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ChecksumFailure;</span>
<span class="line" id="L524">        }</span>
<span class="line" id="L525">    }</span>
<span class="line" id="L526">    <span class="tok-kw">return</span> consumed_count;</span>
<span class="line" id="L527">}</span>
<span class="line" id="L528"></span>
<span class="line" id="L529"><span class="tok-kw">fn</span> <span class="tok-fn">decodeFrameBlocksInner</span>(</span>
<span class="line" id="L530">    dest: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L531">    src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L532">    consumed_count: *<span class="tok-type">usize</span>,</span>
<span class="line" id="L533">    hash: ?*std.hash.XxHash64,</span>
<span class="line" id="L534">    block_size_max: <span class="tok-type">usize</span>,</span>
<span class="line" id="L535">) (<span class="tok-kw">error</span>{ EndOfStream, DestTooSmall } || block.Error)!<span class="tok-type">usize</span> {</span>
<span class="line" id="L536">    <span class="tok-comment">// These tables take 7680 bytes</span>
</span>
<span class="line" id="L537">    <span class="tok-kw">var</span> literal_fse_data: [types.compressed_block.table_size_max.literal]Table.Fse = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L538">    <span class="tok-kw">var</span> match_fse_data: [types.compressed_block.table_size_max.match]Table.Fse = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L539">    <span class="tok-kw">var</span> offset_fse_data: [types.compressed_block.table_size_max.offset]Table.Fse = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L540"></span>
<span class="line" id="L541">    <span class="tok-kw">var</span> block_header = <span class="tok-kw">try</span> block.decodeBlockHeaderSlice(src);</span>
<span class="line" id="L542">    <span class="tok-kw">var</span> bytes_read: <span class="tok-type">usize</span> = <span class="tok-number">3</span>;</span>
<span class="line" id="L543">    <span class="tok-kw">defer</span> consumed_count.* += bytes_read;</span>
<span class="line" id="L544">    <span class="tok-kw">var</span> decode_state = block.DecodeState.init(&amp;literal_fse_data, &amp;match_fse_data, &amp;offset_fse_data);</span>
<span class="line" id="L545">    <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L546">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : ({</span>
<span class="line" id="L547">        block_header = <span class="tok-kw">try</span> block.decodeBlockHeaderSlice(src[bytes_read..]);</span>
<span class="line" id="L548">        bytes_read += <span class="tok-number">3</span>;</span>
<span class="line" id="L549">    }) {</span>
<span class="line" id="L550">        <span class="tok-kw">const</span> written_size = <span class="tok-kw">try</span> block.decodeBlock(</span>
<span class="line" id="L551">            dest,</span>
<span class="line" id="L552">            src[bytes_read..],</span>
<span class="line" id="L553">            block_header,</span>
<span class="line" id="L554">            &amp;decode_state,</span>
<span class="line" id="L555">            &amp;bytes_read,</span>
<span class="line" id="L556">            block_size_max,</span>
<span class="line" id="L557">            count,</span>
<span class="line" id="L558">        );</span>
<span class="line" id="L559">        <span class="tok-kw">if</span> (hash) |hash_state| hash_state.update(dest[count .. count + written_size]);</span>
<span class="line" id="L560">        count += written_size;</span>
<span class="line" id="L561">        <span class="tok-kw">if</span> (block_header.last_block) <span class="tok-kw">break</span>;</span>
<span class="line" id="L562">    }</span>
<span class="line" id="L563">    <span class="tok-kw">return</span> count;</span>
<span class="line" id="L564">}</span>
<span class="line" id="L565"></span>
<span class="line" id="L566"><span class="tok-comment">/// Decode the header of a skippable frame. The first four bytes of `src` must</span></span>
<span class="line" id="L567"><span class="tok-comment">/// be a valid magic number for a skippable frame.</span></span>
<span class="line" id="L568"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeSkippableHeader</span>(src: *<span class="tok-kw">const</span> [<span class="tok-number">8</span>]<span class="tok-type">u8</span>) SkippableHeader {</span>
<span class="line" id="L569">    <span class="tok-kw">const</span> magic = std.mem.readInt(<span class="tok-type">u32</span>, src[<span class="tok-number">0</span>..<span class="tok-number">4</span>], .little);</span>
<span class="line" id="L570">    assert(isSkippableMagic(magic));</span>
<span class="line" id="L571">    <span class="tok-kw">const</span> frame_size = std.mem.readInt(<span class="tok-type">u32</span>, src[<span class="tok-number">4</span>..<span class="tok-number">8</span>], .little);</span>
<span class="line" id="L572">    <span class="tok-kw">return</span> .{</span>
<span class="line" id="L573">        .magic_number = magic,</span>
<span class="line" id="L574">        .frame_size = frame_size,</span>
<span class="line" id="L575">    };</span>
<span class="line" id="L576">}</span>
<span class="line" id="L577"></span>
<span class="line" id="L578"><span class="tok-comment">/// Returns the window size required to decompress a frame, or `null` if it</span></span>
<span class="line" id="L579"><span class="tok-comment">/// cannot be determined (which indicates a malformed frame header).</span></span>
<span class="line" id="L580"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">frameWindowSize</span>(header: ZstandardHeader) ?<span class="tok-type">u64</span> {</span>
<span class="line" id="L581">    <span class="tok-kw">if</span> (header.window_descriptor) |descriptor| {</span>
<span class="line" id="L582">        <span class="tok-kw">const</span> exponent = (descriptor &amp; <span class="tok-number">0b11111000</span>) &gt;&gt; <span class="tok-number">3</span>;</span>
<span class="line" id="L583">        <span class="tok-kw">const</span> mantissa = descriptor &amp; <span class="tok-number">0b00000111</span>;</span>
<span class="line" id="L584">        <span class="tok-kw">const</span> window_log = <span class="tok-number">10</span> + exponent;</span>
<span class="line" id="L585">        <span class="tok-kw">const</span> window_base = <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">1</span>) &lt;&lt; <span class="tok-builtin">@as</span>(<span class="tok-type">u6</span>, <span class="tok-builtin">@intCast</span>(window_log));</span>
<span class="line" id="L586">        <span class="tok-kw">const</span> window_add = (window_base / <span class="tok-number">8</span>) * mantissa;</span>
<span class="line" id="L587">        <span class="tok-kw">return</span> window_base + window_add;</span>
<span class="line" id="L588">    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> header.content_size;</span>
<span class="line" id="L589">}</span>
<span class="line" id="L590"></span>
<span class="line" id="L591"><span class="tok-comment">/// Decode the header of a Zstandard frame.</span></span>
<span class="line" id="L592"><span class="tok-comment">///</span></span>
<span class="line" id="L593"><span class="tok-comment">/// Errors returned:</span></span>
<span class="line" id="L594"><span class="tok-comment">///   - `error.ReservedBitSet` if any of the reserved bits of the header are set</span></span>
<span class="line" id="L595"><span class="tok-comment">///   - `error.EndOfStream` if `source` does not contain a complete header</span></span>
<span class="line" id="L596"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">decodeZstandardHeader</span>(</span>
<span class="line" id="L597">    source: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L598">) (<span class="tok-builtin">@TypeOf</span>(source).Error || <span class="tok-kw">error</span>{ EndOfStream, ReservedBitSet })!ZstandardHeader {</span>
<span class="line" id="L599">    <span class="tok-kw">const</span> descriptor = <span class="tok-builtin">@as</span>(ZstandardHeader.Descriptor, <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> source.readByte()));</span>
<span class="line" id="L600"></span>
<span class="line" id="L601">    <span class="tok-kw">if</span> (descriptor.reserved) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReservedBitSet;</span>
<span class="line" id="L602"></span>
<span class="line" id="L603">    <span class="tok-kw">var</span> window_descriptor: ?<span class="tok-type">u8</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L604">    <span class="tok-kw">if</span> (!descriptor.single_segment_flag) {</span>
<span class="line" id="L605">        window_descriptor = <span class="tok-kw">try</span> source.readByte();</span>
<span class="line" id="L606">    }</span>
<span class="line" id="L607"></span>
<span class="line" id="L608">    <span class="tok-kw">var</span> dictionary_id: ?<span class="tok-type">u32</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L609">    <span class="tok-kw">if</span> (descriptor.dictionary_id_flag &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L610">        <span class="tok-comment">// if flag is 3 then field_size = 4, else field_size = flag</span>
</span>
<span class="line" id="L611">        <span class="tok-kw">const</span> field_size = (<span class="tok-builtin">@as</span>(<span class="tok-type">u4</span>, <span class="tok-number">1</span>) &lt;&lt; descriptor.dictionary_id_flag) &gt;&gt; <span class="tok-number">1</span>;</span>
<span class="line" id="L612">        dictionary_id = <span class="tok-kw">try</span> source.readVarInt(<span class="tok-type">u32</span>, .little, field_size);</span>
<span class="line" id="L613">    }</span>
<span class="line" id="L614"></span>
<span class="line" id="L615">    <span class="tok-kw">var</span> content_size: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L616">    <span class="tok-kw">if</span> (descriptor.single_segment_flag <span class="tok-kw">or</span> descriptor.content_size_flag &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L617">        <span class="tok-kw">const</span> field_size = <span class="tok-builtin">@as</span>(<span class="tok-type">u4</span>, <span class="tok-number">1</span>) &lt;&lt; descriptor.content_size_flag;</span>
<span class="line" id="L618">        content_size = <span class="tok-kw">try</span> source.readVarInt(<span class="tok-type">u64</span>, .little, field_size);</span>
<span class="line" id="L619">        <span class="tok-kw">if</span> (field_size == <span class="tok-number">2</span>) content_size.? += <span class="tok-number">256</span>;</span>
<span class="line" id="L620">    }</span>
<span class="line" id="L621"></span>
<span class="line" id="L622">    <span class="tok-kw">const</span> header = ZstandardHeader{</span>
<span class="line" id="L623">        .descriptor = descriptor,</span>
<span class="line" id="L624">        .window_descriptor = window_descriptor,</span>
<span class="line" id="L625">        .dictionary_id = dictionary_id,</span>
<span class="line" id="L626">        .content_size = content_size,</span>
<span class="line" id="L627">    };</span>
<span class="line" id="L628">    <span class="tok-kw">return</span> header;</span>
<span class="line" id="L629">}</span>
<span class="line" id="L630"></span>
<span class="line" id="L631"><span class="tok-kw">test</span> {</span>
<span class="line" id="L632">    std.testing.refAllDecls(<span class="tok-builtin">@This</span>());</span>
<span class="line" id="L633">}</span>
<span class="line" id="L634"></span>
</code></pre></body>
</html>