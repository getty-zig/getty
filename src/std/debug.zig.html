<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>debug.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAPNJREFUeNpi/P//PwMlgOXHUjly9E0G4hwgZmQiQZMqEK8H4v9QzUEgQSaoADK+zhH9iAGL+C0gDoAaNg9mGLoLfgA1awK9hS9gzgJxA9RQBmQDrgMxJzRMGKE4HYj/Ial5A8QmQLwCJoBsgBYW2+TR1ChDaWt4LOBxKsi/VUh8XiD+gq4IVyzwQAMJBoKwacZlAB8Qf0bi96IZhtOAe1D6LpqaEiz6rmEzQAeIzwGxCJpieFqApo/vQKyJboAaEBsAsSEupwI1MwKjGBTVHOhegMX5UajYRqiBjMgYmj400cVh0XgTiKdC0zhJgJHS7AwQYABm9EAdCKrEfAAAAABJRU5ErkJggg=="/>
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std.zig&quot;</span>);</span>
<span class="line" id="L2"><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);</span>
<span class="line" id="L3"><span class="tok-kw">const</span> math = std.math;</span>
<span class="line" id="L4"><span class="tok-kw">const</span> mem = std.mem;</span>
<span class="line" id="L5"><span class="tok-kw">const</span> io = std.io;</span>
<span class="line" id="L6"><span class="tok-kw">const</span> os = std.os;</span>
<span class="line" id="L7"><span class="tok-kw">const</span> fs = std.fs;</span>
<span class="line" id="L8"><span class="tok-kw">const</span> testing = std.testing;</span>
<span class="line" id="L9"><span class="tok-kw">const</span> elf = std.elf;</span>
<span class="line" id="L10"><span class="tok-kw">const</span> DW = std.dwarf;</span>
<span class="line" id="L11"><span class="tok-kw">const</span> macho = std.macho;</span>
<span class="line" id="L12"><span class="tok-kw">const</span> coff = std.coff;</span>
<span class="line" id="L13"><span class="tok-kw">const</span> pdb = std.pdb;</span>
<span class="line" id="L14"><span class="tok-kw">const</span> ArrayList = std.ArrayList;</span>
<span class="line" id="L15"><span class="tok-kw">const</span> root = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;root&quot;</span>);</span>
<span class="line" id="L16"><span class="tok-kw">const</span> maxInt = std.math.maxInt;</span>
<span class="line" id="L17"><span class="tok-kw">const</span> File = std.fs.File;</span>
<span class="line" id="L18"><span class="tok-kw">const</span> windows = std.os.windows;</span>
<span class="line" id="L19"><span class="tok-kw">const</span> native_arch = builtin.cpu.arch;</span>
<span class="line" id="L20"><span class="tok-kw">const</span> native_os = builtin.os.tag;</span>
<span class="line" id="L21"><span class="tok-kw">const</span> native_endian = native_arch.endian();</span>
<span class="line" id="L22"></span>
<span class="line" id="L23"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> runtime_safety = <span class="tok-kw">switch</span> (builtin.mode) {</span>
<span class="line" id="L24">    .Debug, .ReleaseSafe =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L25">    .ReleaseFast, .ReleaseSmall =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L26">};</span>
<span class="line" id="L27"></span>
<span class="line" id="L28"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> sys_can_stack_trace = <span class="tok-kw">switch</span> (builtin.cpu.arch) {</span>
<span class="line" id="L29">    <span class="tok-comment">// Observed to go into an infinite loop.</span>
</span>
<span class="line" id="L30">    <span class="tok-comment">// TODO: Make this work.</span>
</span>
<span class="line" id="L31">    .mips,</span>
<span class="line" id="L32">    .mipsel,</span>
<span class="line" id="L33">    =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L34"></span>
<span class="line" id="L35">    <span class="tok-comment">// `@returnAddress()` in LLVM 10 gives</span>
</span>
<span class="line" id="L36">    <span class="tok-comment">// &quot;Non-Emscripten WebAssembly hasn't implemented __builtin_return_address&quot;.</span>
</span>
<span class="line" id="L37">    .wasm32,</span>
<span class="line" id="L38">    .wasm64,</span>
<span class="line" id="L39">    =&gt; builtin.os.tag == .emscripten,</span>
<span class="line" id="L40"></span>
<span class="line" id="L41">    <span class="tok-comment">// `@returnAddress()` is unsupported in LLVM 13.</span>
</span>
<span class="line" id="L42">    .bpfel,</span>
<span class="line" id="L43">    .bpfeb,</span>
<span class="line" id="L44">    =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L45"></span>
<span class="line" id="L46">    <span class="tok-kw">else</span> =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L47">};</span>
<span class="line" id="L48"></span>
<span class="line" id="L49"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> LineInfo = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L50">    line: <span class="tok-type">u64</span>,</span>
<span class="line" id="L51">    column: <span class="tok-type">u64</span>,</span>
<span class="line" id="L52">    file_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L53"></span>
<span class="line" id="L54">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: LineInfo, allocator: mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L55">        allocator.free(self.file_name);</span>
<span class="line" id="L56">    }</span>
<span class="line" id="L57">};</span>
<span class="line" id="L58"></span>
<span class="line" id="L59"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SymbolInfo = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L60">    symbol_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;???&quot;</span>,</span>
<span class="line" id="L61">    compile_unit_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;???&quot;</span>,</span>
<span class="line" id="L62">    line_info: ?LineInfo = <span class="tok-null">null</span>,</span>
<span class="line" id="L63"></span>
<span class="line" id="L64">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: SymbolInfo, allocator: mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L65">        <span class="tok-kw">if</span> (self.line_info) |li| {</span>
<span class="line" id="L66">            li.deinit(allocator);</span>
<span class="line" id="L67">        }</span>
<span class="line" id="L68">    }</span>
<span class="line" id="L69">};</span>
<span class="line" id="L70"><span class="tok-kw">const</span> PdbOrDwarf = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L71">    pdb: pdb.Pdb,</span>
<span class="line" id="L72">    dwarf: DW.DwarfInfo,</span>
<span class="line" id="L73"></span>
<span class="line" id="L74">    <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *PdbOrDwarf, allocator: mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L75">        <span class="tok-kw">switch</span> (self.*) {</span>
<span class="line" id="L76">            .pdb =&gt; |*inner| inner.deinit(),</span>
<span class="line" id="L77">            .dwarf =&gt; |*inner| inner.deinit(allocator),</span>
<span class="line" id="L78">        }</span>
<span class="line" id="L79">    }</span>
<span class="line" id="L80">};</span>
<span class="line" id="L81"></span>
<span class="line" id="L82"><span class="tok-kw">var</span> stderr_mutex = std.Thread.Mutex{};</span>
<span class="line" id="L83"></span>
<span class="line" id="L84"><span class="tok-comment">/// Print to stderr, unbuffered, and silently returning on failure. Intended</span></span>
<span class="line" id="L85"><span class="tok-comment">/// for use in &quot;printf debugging.&quot; Use `std.log` functions for proper logging.</span></span>
<span class="line" id="L86"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">print</span>(<span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L87">    stderr_mutex.lock();</span>
<span class="line" id="L88">    <span class="tok-kw">defer</span> stderr_mutex.unlock();</span>
<span class="line" id="L89">    <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L90">    <span class="tok-kw">nosuspend</span> stderr.print(fmt, args) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L91">}</span>
<span class="line" id="L92"></span>
<span class="line" id="L93"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getStderrMutex</span>() *std.Thread.Mutex {</span>
<span class="line" id="L94">    <span class="tok-kw">return</span> &amp;stderr_mutex;</span>
<span class="line" id="L95">}</span>
<span class="line" id="L96"></span>
<span class="line" id="L97"><span class="tok-comment">/// TODO multithreaded awareness</span></span>
<span class="line" id="L98"><span class="tok-kw">var</span> self_debug_info: ?DebugInfo = <span class="tok-null">null</span>;</span>
<span class="line" id="L99"></span>
<span class="line" id="L100"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSelfDebugInfo</span>() !*DebugInfo {</span>
<span class="line" id="L101">    <span class="tok-kw">if</span> (self_debug_info) |*info| {</span>
<span class="line" id="L102">        <span class="tok-kw">return</span> info;</span>
<span class="line" id="L103">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L104">        self_debug_info = <span class="tok-kw">try</span> openSelfDebugInfo(getDebugInfoAllocator());</span>
<span class="line" id="L105">        <span class="tok-kw">return</span> &amp;self_debug_info.?;</span>
<span class="line" id="L106">    }</span>
<span class="line" id="L107">}</span>
<span class="line" id="L108"></span>
<span class="line" id="L109"><span class="tok-comment">/// Tries to print the current stack trace to stderr, unbuffered, and ignores any error returned.</span></span>
<span class="line" id="L110"><span class="tok-comment">/// TODO multithreaded awareness</span></span>
<span class="line" id="L111"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpCurrentStackTrace</span>(start_addr: ?<span class="tok-type">usize</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L112">    <span class="tok-kw">nosuspend</span> {</span>
<span class="line" id="L113">        <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> builtin.target.isWasm()) {</span>
<span class="line" id="L114">            <span class="tok-kw">if</span> (native_os == .wasi) {</span>
<span class="line" id="L115">                <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L116">                stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: not implemented for Wasm\n&quot;</span>, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L117">            }</span>
<span class="line" id="L118">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L119">        }</span>
<span class="line" id="L120">        <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L121">        <span class="tok-kw">if</span> (builtin.strip_debug_info) {</span>
<span class="line" id="L122">            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: debug info stripped\n&quot;</span>, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L123">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L124">        }</span>
<span class="line" id="L125">        <span class="tok-kw">const</span> debug_info = getSelfDebugInfo() <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L126">            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: Unable to open debug info: {s}\n&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L127">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L128">        };</span>
<span class="line" id="L129">        writeCurrentStackTrace(stderr, debug_info, io.tty.detectConfig(io.getStdErr()), start_addr) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L130">            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: {s}\n&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L131">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L132">        };</span>
<span class="line" id="L133">    }</span>
<span class="line" id="L134">}</span>
<span class="line" id="L135"></span>
<span class="line" id="L136"><span class="tok-comment">/// Tries to print the stack trace starting from the supplied base pointer to stderr,</span></span>
<span class="line" id="L137"><span class="tok-comment">/// unbuffered, and ignores any error returned.</span></span>
<span class="line" id="L138"><span class="tok-comment">/// TODO multithreaded awareness</span></span>
<span class="line" id="L139"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpStackTraceFromBase</span>(bp: <span class="tok-type">usize</span>, ip: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L140">    <span class="tok-kw">nosuspend</span> {</span>
<span class="line" id="L141">        <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> builtin.target.isWasm()) {</span>
<span class="line" id="L142">            <span class="tok-kw">if</span> (native_os == .wasi) {</span>
<span class="line" id="L143">                <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L144">                stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: not implemented for Wasm\n&quot;</span>, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L145">            }</span>
<span class="line" id="L146">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L147">        }</span>
<span class="line" id="L148">        <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L149">        <span class="tok-kw">if</span> (builtin.strip_debug_info) {</span>
<span class="line" id="L150">            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: debug info stripped\n&quot;</span>, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L151">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L152">        }</span>
<span class="line" id="L153">        <span class="tok-kw">const</span> debug_info = getSelfDebugInfo() <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L154">            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: Unable to open debug info: {s}\n&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L155">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L156">        };</span>
<span class="line" id="L157">        <span class="tok-kw">const</span> tty_config = io.tty.detectConfig(io.getStdErr());</span>
<span class="line" id="L158">        <span class="tok-kw">if</span> (native_os == .windows) {</span>
<span class="line" id="L159">            writeCurrentStackTraceWindows(stderr, debug_info, tty_config, ip) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L160">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L161">        }</span>
<span class="line" id="L162"></span>
<span class="line" id="L163">        printSourceAtAddress(debug_info, stderr, ip, tty_config) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L164">        <span class="tok-kw">var</span> it = StackIterator.init(<span class="tok-null">null</span>, bp);</span>
<span class="line" id="L165">        <span class="tok-kw">while</span> (it.next()) |return_address| {</span>
<span class="line" id="L166">            <span class="tok-comment">// On arm64 macOS, the address of the last frame is 0x0 rather than 0x1 as on x86_64 macOS,</span>
</span>
<span class="line" id="L167">            <span class="tok-comment">// therefore, we do a check for `return_address == 0` before subtracting 1 from it to avoid</span>
</span>
<span class="line" id="L168">            <span class="tok-comment">// an overflow. We do not need to signal `StackIterator` as it will correctly detect this</span>
</span>
<span class="line" id="L169">            <span class="tok-comment">// condition on the subsequent iteration and return `null` thus terminating the loop.</span>
</span>
<span class="line" id="L170">            <span class="tok-comment">// same behaviour for x86-windows-msvc</span>
</span>
<span class="line" id="L171">            <span class="tok-kw">const</span> address = <span class="tok-kw">if</span> (return_address == <span class="tok-number">0</span>) return_address <span class="tok-kw">else</span> return_address - <span class="tok-number">1</span>;</span>
<span class="line" id="L172">            printSourceAtAddress(debug_info, stderr, address, tty_config) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L173">        }</span>
<span class="line" id="L174">    }</span>
<span class="line" id="L175">}</span>
<span class="line" id="L176"></span>
<span class="line" id="L177"><span class="tok-comment">/// Returns a slice with the same pointer as addresses, with a potentially smaller len.</span></span>
<span class="line" id="L178"><span class="tok-comment">/// On Windows, when first_address is not null, we ask for at least 32 stack frames,</span></span>
<span class="line" id="L179"><span class="tok-comment">/// and then try to find the first address. If addresses.len is more than 32, we</span></span>
<span class="line" id="L180"><span class="tok-comment">/// capture that many stack frames exactly, and then look for the first address,</span></span>
<span class="line" id="L181"><span class="tok-comment">/// chopping off the irrelevant frames and shifting so that the returned addresses pointer</span></span>
<span class="line" id="L182"><span class="tok-comment">/// equals the passed in addresses pointer.</span></span>
<span class="line" id="L183"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">captureStackTrace</span>(first_address: ?<span class="tok-type">usize</span>, stack_trace: *std.builtin.StackTrace) <span class="tok-type">void</span> {</span>
<span class="line" id="L184">    <span class="tok-kw">if</span> (native_os == .windows) {</span>
<span class="line" id="L185">        <span class="tok-kw">const</span> addrs = stack_trace.instruction_addresses;</span>
<span class="line" id="L186">        <span class="tok-kw">const</span> first_addr = first_address <span class="tok-kw">orelse</span> {</span>
<span class="line" id="L187">            stack_trace.index = walkStackWindows(addrs[<span class="tok-number">0</span>..]);</span>
<span class="line" id="L188">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L189">        };</span>
<span class="line" id="L190">        <span class="tok-kw">var</span> addr_buf_stack: [<span class="tok-number">32</span>]<span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L191">        <span class="tok-kw">const</span> addr_buf = <span class="tok-kw">if</span> (addr_buf_stack.len &gt; addrs.len) addr_buf_stack[<span class="tok-number">0</span>..] <span class="tok-kw">else</span> addrs;</span>
<span class="line" id="L192">        <span class="tok-kw">const</span> n = walkStackWindows(addr_buf[<span class="tok-number">0</span>..]);</span>
<span class="line" id="L193">        <span class="tok-kw">const</span> first_index = <span class="tok-kw">for</span> (addr_buf[<span class="tok-number">0</span>..n], <span class="tok-number">0</span>..) |addr, i| {</span>
<span class="line" id="L194">            <span class="tok-kw">if</span> (addr == first_addr) {</span>
<span class="line" id="L195">                <span class="tok-kw">break</span> i;</span>
<span class="line" id="L196">            }</span>
<span class="line" id="L197">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L198">            stack_trace.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L199">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L200">        };</span>
<span class="line" id="L201">        <span class="tok-kw">const</span> end_index = <span class="tok-builtin">@min</span>(first_index + addrs.len, n);</span>
<span class="line" id="L202">        <span class="tok-kw">const</span> slice = addr_buf[first_index..end_index];</span>
<span class="line" id="L203">        <span class="tok-comment">// We use a for loop here because slice and addrs may alias.</span>
</span>
<span class="line" id="L204">        <span class="tok-kw">for</span> (slice, <span class="tok-number">0</span>..) |addr, i| {</span>
<span class="line" id="L205">            addrs[i] = addr;</span>
<span class="line" id="L206">        }</span>
<span class="line" id="L207">        stack_trace.index = slice.len;</span>
<span class="line" id="L208">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L209">        <span class="tok-kw">var</span> it = StackIterator.init(first_address, <span class="tok-null">null</span>);</span>
<span class="line" id="L210">        <span class="tok-kw">for</span> (stack_trace.instruction_addresses, <span class="tok-number">0</span>..) |*addr, i| {</span>
<span class="line" id="L211">            addr.* = it.next() <span class="tok-kw">orelse</span> {</span>
<span class="line" id="L212">                stack_trace.index = i;</span>
<span class="line" id="L213">                <span class="tok-kw">return</span>;</span>
<span class="line" id="L214">            };</span>
<span class="line" id="L215">        }</span>
<span class="line" id="L216">        stack_trace.index = stack_trace.instruction_addresses.len;</span>
<span class="line" id="L217">    }</span>
<span class="line" id="L218">}</span>
<span class="line" id="L219"></span>
<span class="line" id="L220"><span class="tok-comment">/// Tries to print a stack trace to stderr, unbuffered, and ignores any error returned.</span></span>
<span class="line" id="L221"><span class="tok-comment">/// TODO multithreaded awareness</span></span>
<span class="line" id="L222"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpStackTrace</span>(stack_trace: std.builtin.StackTrace) <span class="tok-type">void</span> {</span>
<span class="line" id="L223">    <span class="tok-kw">nosuspend</span> {</span>
<span class="line" id="L224">        <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> builtin.target.isWasm()) {</span>
<span class="line" id="L225">            <span class="tok-kw">if</span> (native_os == .wasi) {</span>
<span class="line" id="L226">                <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L227">                stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: not implemented for Wasm\n&quot;</span>, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L228">            }</span>
<span class="line" id="L229">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L230">        }</span>
<span class="line" id="L231">        <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L232">        <span class="tok-kw">if</span> (builtin.strip_debug_info) {</span>
<span class="line" id="L233">            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: debug info stripped\n&quot;</span>, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L234">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L235">        }</span>
<span class="line" id="L236">        <span class="tok-kw">const</span> debug_info = getSelfDebugInfo() <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L237">            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: Unable to open debug info: {s}\n&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L238">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L239">        };</span>
<span class="line" id="L240">        writeStackTrace(stack_trace, stderr, getDebugInfoAllocator(), debug_info, io.tty.detectConfig(io.getStdErr())) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L241">            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: {s}\n&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L242">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L243">        };</span>
<span class="line" id="L244">    }</span>
<span class="line" id="L245">}</span>
<span class="line" id="L246"></span>
<span class="line" id="L247"><span class="tok-comment">/// This function invokes undefined behavior when `ok` is `false`.</span></span>
<span class="line" id="L248"><span class="tok-comment">/// In Debug and ReleaseSafe modes, calls to this function are always</span></span>
<span class="line" id="L249"><span class="tok-comment">/// generated, and the `unreachable` statement triggers a panic.</span></span>
<span class="line" id="L250"><span class="tok-comment">/// In ReleaseFast and ReleaseSmall modes, calls to this function are</span></span>
<span class="line" id="L251"><span class="tok-comment">/// optimized away, and in fact the optimizer is able to use the assertion</span></span>
<span class="line" id="L252"><span class="tok-comment">/// in its heuristics.</span></span>
<span class="line" id="L253"><span class="tok-comment">/// Inside a test block, it is best to use the `std.testing` module rather</span></span>
<span class="line" id="L254"><span class="tok-comment">/// than this function, because this function may not detect a test failure</span></span>
<span class="line" id="L255"><span class="tok-comment">/// in ReleaseFast and ReleaseSmall mode. Outside of a test block, this assert</span></span>
<span class="line" id="L256"><span class="tok-comment">/// function is the correct function to use.</span></span>
<span class="line" id="L257"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">assert</span>(ok: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L258">    <span class="tok-kw">if</span> (!ok) <span class="tok-kw">unreachable</span>; <span class="tok-comment">// assertion failure</span>
</span>
<span class="line" id="L259">}</span>
<span class="line" id="L260"></span>
<span class="line" id="L261"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">panic</span>(<span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) <span class="tok-type">noreturn</span> {</span>
<span class="line" id="L262">    <span class="tok-builtin">@setCold</span>(<span class="tok-null">true</span>);</span>
<span class="line" id="L263"></span>
<span class="line" id="L264">    panicExtra(<span class="tok-null">null</span>, <span class="tok-null">null</span>, format, args);</span>
<span class="line" id="L265">}</span>
<span class="line" id="L266"></span>
<span class="line" id="L267"><span class="tok-comment">/// `panicExtra` is useful when you want to print out an `@errorReturnTrace`</span></span>
<span class="line" id="L268"><span class="tok-comment">/// and also print out some values.</span></span>
<span class="line" id="L269"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">panicExtra</span>(</span>
<span class="line" id="L270">    trace: ?*std.builtin.StackTrace,</span>
<span class="line" id="L271">    ret_addr: ?<span class="tok-type">usize</span>,</span>
<span class="line" id="L272">    <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L273">    args: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L274">) <span class="tok-type">noreturn</span> {</span>
<span class="line" id="L275">    <span class="tok-builtin">@setCold</span>(<span class="tok-null">true</span>);</span>
<span class="line" id="L276"></span>
<span class="line" id="L277">    <span class="tok-kw">const</span> size = <span class="tok-number">0x1000</span>;</span>
<span class="line" id="L278">    <span class="tok-kw">const</span> trunc_msg = <span class="tok-str">&quot;(msg truncated)&quot;</span>;</span>
<span class="line" id="L279">    <span class="tok-kw">var</span> buf: [size + trunc_msg.len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L280">    <span class="tok-comment">// a minor annoyance with this is that it will result in the NoSpaceLeft</span>
</span>
<span class="line" id="L281">    <span class="tok-comment">// error being part of the @panic stack trace (but that error should</span>
</span>
<span class="line" id="L282">    <span class="tok-comment">// only happen rarely)</span>
</span>
<span class="line" id="L283">    <span class="tok-kw">const</span> msg = std.fmt.bufPrint(buf[<span class="tok-number">0</span>..size], format, args) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L284">        <span class="tok-kw">error</span>.NoSpaceLeft =&gt; blk: {</span>
<span class="line" id="L285">            <span class="tok-builtin">@memcpy</span>(buf[size..], trunc_msg);</span>
<span class="line" id="L286">            <span class="tok-kw">break</span> :blk &amp;buf;</span>
<span class="line" id="L287">        },</span>
<span class="line" id="L288">    };</span>
<span class="line" id="L289">    std.builtin.panic(msg, trace, ret_addr);</span>
<span class="line" id="L290">}</span>
<span class="line" id="L291"></span>
<span class="line" id="L292"><span class="tok-comment">/// Non-zero whenever the program triggered a panic.</span></span>
<span class="line" id="L293"><span class="tok-comment">/// The counter is incremented/decremented atomically.</span></span>
<span class="line" id="L294"><span class="tok-kw">var</span> panicking = std.atomic.Atomic(<span class="tok-type">u8</span>).init(<span class="tok-number">0</span>);</span>
<span class="line" id="L295"></span>
<span class="line" id="L296"><span class="tok-comment">// Locked to avoid interleaving panic messages from multiple threads.</span>
</span>
<span class="line" id="L297"><span class="tok-kw">var</span> panic_mutex = std.Thread.Mutex{};</span>
<span class="line" id="L298"></span>
<span class="line" id="L299"><span class="tok-comment">/// Counts how many times the panic handler is invoked by this thread.</span></span>
<span class="line" id="L300"><span class="tok-comment">/// This is used to catch and handle panics triggered by the panic handler.</span></span>
<span class="line" id="L301"><span class="tok-kw">threadlocal</span> <span class="tok-kw">var</span> panic_stage: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L302"></span>
<span class="line" id="L303"><span class="tok-comment">// `panicImpl` could be useful in implementing a custom panic handler which</span>
</span>
<span class="line" id="L304"><span class="tok-comment">// calls the default handler (on supported platforms)</span>
</span>
<span class="line" id="L305"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">panicImpl</span>(trace: ?*<span class="tok-kw">const</span> std.builtin.StackTrace, first_trace_addr: ?<span class="tok-type">usize</span>, msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">noreturn</span> {</span>
<span class="line" id="L306">    <span class="tok-builtin">@setCold</span>(<span class="tok-null">true</span>);</span>
<span class="line" id="L307"></span>
<span class="line" id="L308">    <span class="tok-kw">if</span> (enable_segfault_handler) {</span>
<span class="line" id="L309">        <span class="tok-comment">// If a segfault happens while panicking, we want it to actually segfault, not trigger</span>
</span>
<span class="line" id="L310">        <span class="tok-comment">// the handler.</span>
</span>
<span class="line" id="L311">        resetSegfaultHandler();</span>
<span class="line" id="L312">    }</span>
<span class="line" id="L313"></span>
<span class="line" id="L314">    <span class="tok-comment">// Note there is similar logic in handleSegfaultPosix and handleSegfaultWindowsExtra.</span>
</span>
<span class="line" id="L315">    <span class="tok-kw">nosuspend</span> <span class="tok-kw">switch</span> (panic_stage) {</span>
<span class="line" id="L316">        <span class="tok-number">0</span> =&gt; {</span>
<span class="line" id="L317">            panic_stage = <span class="tok-number">1</span>;</span>
<span class="line" id="L318"></span>
<span class="line" id="L319">            _ = panicking.fetchAdd(<span class="tok-number">1</span>, .SeqCst);</span>
<span class="line" id="L320"></span>
<span class="line" id="L321">            <span class="tok-comment">// Make sure to release the mutex when done</span>
</span>
<span class="line" id="L322">            {</span>
<span class="line" id="L323">                panic_mutex.lock();</span>
<span class="line" id="L324">                <span class="tok-kw">defer</span> panic_mutex.unlock();</span>
<span class="line" id="L325"></span>
<span class="line" id="L326">                <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L327">                <span class="tok-kw">if</span> (builtin.single_threaded) {</span>
<span class="line" id="L328">                    stderr.print(<span class="tok-str">&quot;panic: &quot;</span>, .{}) <span class="tok-kw">catch</span> os.abort();</span>
<span class="line" id="L329">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L330">                    <span class="tok-kw">const</span> current_thread_id = std.Thread.getCurrentId();</span>
<span class="line" id="L331">                    stderr.print(<span class="tok-str">&quot;thread {} panic: &quot;</span>, .{current_thread_id}) <span class="tok-kw">catch</span> os.abort();</span>
<span class="line" id="L332">                }</span>
<span class="line" id="L333">                stderr.print(<span class="tok-str">&quot;{s}\n&quot;</span>, .{msg}) <span class="tok-kw">catch</span> os.abort();</span>
<span class="line" id="L334">                <span class="tok-kw">if</span> (trace) |t| {</span>
<span class="line" id="L335">                    dumpStackTrace(t.*);</span>
<span class="line" id="L336">                }</span>
<span class="line" id="L337">                dumpCurrentStackTrace(first_trace_addr);</span>
<span class="line" id="L338">            }</span>
<span class="line" id="L339"></span>
<span class="line" id="L340">            waitForOtherThreadToFinishPanicking();</span>
<span class="line" id="L341">        },</span>
<span class="line" id="L342">        <span class="tok-number">1</span> =&gt; {</span>
<span class="line" id="L343">            panic_stage = <span class="tok-number">2</span>;</span>
<span class="line" id="L344"></span>
<span class="line" id="L345">            <span class="tok-comment">// A panic happened while trying to print a previous panic message,</span>
</span>
<span class="line" id="L346">            <span class="tok-comment">// we're still holding the mutex but that's fine as we're going to</span>
</span>
<span class="line" id="L347">            <span class="tok-comment">// call abort()</span>
</span>
<span class="line" id="L348">            <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L349">            stderr.print(<span class="tok-str">&quot;Panicked during a panic. Aborting.\n&quot;</span>, .{}) <span class="tok-kw">catch</span> os.abort();</span>
<span class="line" id="L350">        },</span>
<span class="line" id="L351">        <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L352">            <span class="tok-comment">// Panicked while printing &quot;Panicked during a panic.&quot;</span>
</span>
<span class="line" id="L353">        },</span>
<span class="line" id="L354">    };</span>
<span class="line" id="L355"></span>
<span class="line" id="L356">    os.abort();</span>
<span class="line" id="L357">}</span>
<span class="line" id="L358"></span>
<span class="line" id="L359"><span class="tok-comment">/// Must be called only after adding 1 to `panicking`. There are three callsites.</span></span>
<span class="line" id="L360"><span class="tok-kw">fn</span> <span class="tok-fn">waitForOtherThreadToFinishPanicking</span>() <span class="tok-type">void</span> {</span>
<span class="line" id="L361">    <span class="tok-kw">if</span> (panicking.fetchSub(<span class="tok-number">1</span>, .SeqCst) != <span class="tok-number">1</span>) {</span>
<span class="line" id="L362">        <span class="tok-comment">// Another thread is panicking, wait for the last one to finish</span>
</span>
<span class="line" id="L363">        <span class="tok-comment">// and call abort()</span>
</span>
<span class="line" id="L364">        <span class="tok-kw">if</span> (builtin.single_threaded) <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L365"></span>
<span class="line" id="L366">        <span class="tok-comment">// Sleep forever without hammering the CPU</span>
</span>
<span class="line" id="L367">        <span class="tok-kw">var</span> futex = std.atomic.Atomic(<span class="tok-type">u32</span>).init(<span class="tok-number">0</span>);</span>
<span class="line" id="L368">        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) std.Thread.Futex.wait(&amp;futex, <span class="tok-number">0</span>);</span>
<span class="line" id="L369">        <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L370">    }</span>
<span class="line" id="L371">}</span>
<span class="line" id="L372"></span>
<span class="line" id="L373"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeStackTrace</span>(</span>
<span class="line" id="L374">    stack_trace: std.builtin.StackTrace,</span>
<span class="line" id="L375">    out_stream: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L376">    allocator: mem.Allocator,</span>
<span class="line" id="L377">    debug_info: *DebugInfo,</span>
<span class="line" id="L378">    tty_config: io.tty.Config,</span>
<span class="line" id="L379">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L380">    _ = allocator;</span>
<span class="line" id="L381">    <span class="tok-kw">if</span> (builtin.strip_debug_info) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L382">    <span class="tok-kw">var</span> frame_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L383">    <span class="tok-kw">var</span> frames_left: <span class="tok-type">usize</span> = <span class="tok-builtin">@min</span>(stack_trace.index, stack_trace.instruction_addresses.len);</span>
<span class="line" id="L384"></span>
<span class="line" id="L385">    <span class="tok-kw">while</span> (frames_left != <span class="tok-number">0</span>) : ({</span>
<span class="line" id="L386">        frames_left -= <span class="tok-number">1</span>;</span>
<span class="line" id="L387">        frame_index = (frame_index + <span class="tok-number">1</span>) % stack_trace.instruction_addresses.len;</span>
<span class="line" id="L388">    }) {</span>
<span class="line" id="L389">        <span class="tok-kw">const</span> return_address = stack_trace.instruction_addresses[frame_index];</span>
<span class="line" id="L390">        <span class="tok-kw">try</span> printSourceAtAddress(debug_info, out_stream, return_address - <span class="tok-number">1</span>, tty_config);</span>
<span class="line" id="L391">    }</span>
<span class="line" id="L392"></span>
<span class="line" id="L393">    <span class="tok-kw">if</span> (stack_trace.index &gt; stack_trace.instruction_addresses.len) {</span>
<span class="line" id="L394">        <span class="tok-kw">const</span> dropped_frames = stack_trace.index - stack_trace.instruction_addresses.len;</span>
<span class="line" id="L395"></span>
<span class="line" id="L396">        tty_config.setColor(out_stream, .bold) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L397">        <span class="tok-kw">try</span> out_stream.print(<span class="tok-str">&quot;({d} additional stack frames skipped...)\n&quot;</span>, .{dropped_frames});</span>
<span class="line" id="L398">        tty_config.setColor(out_stream, .reset) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L399">    }</span>
<span class="line" id="L400">}</span>
<span class="line" id="L401"></span>
<span class="line" id="L402"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> StackIterator = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L403">    <span class="tok-comment">// Skip every frame before this address is found.</span>
</span>
<span class="line" id="L404">    first_address: ?<span class="tok-type">usize</span>,</span>
<span class="line" id="L405">    <span class="tok-comment">// Last known value of the frame pointer register.</span>
</span>
<span class="line" id="L406">    fp: <span class="tok-type">usize</span>,</span>
<span class="line" id="L407"></span>
<span class="line" id="L408">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(first_address: ?<span class="tok-type">usize</span>, fp: ?<span class="tok-type">usize</span>) StackIterator {</span>
<span class="line" id="L409">        <span class="tok-kw">if</span> (native_arch == .sparc64) {</span>
<span class="line" id="L410">            <span class="tok-comment">// Flush all the register windows on stack.</span>
</span>
<span class="line" id="L411">            <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (</span>
<span class="line" id="L412">                <span class="tok-str">\\ flushw</span></span>

<span class="line" id="L413">                ::: <span class="tok-str">&quot;memory&quot;</span>);</span>
<span class="line" id="L414">        }</span>
<span class="line" id="L415"></span>
<span class="line" id="L416">        <span class="tok-kw">return</span> StackIterator{</span>
<span class="line" id="L417">            .first_address = first_address,</span>
<span class="line" id="L418">            .fp = fp <span class="tok-kw">orelse</span> <span class="tok-builtin">@frameAddress</span>(),</span>
<span class="line" id="L419">        };</span>
<span class="line" id="L420">    }</span>
<span class="line" id="L421"></span>
<span class="line" id="L422">    <span class="tok-comment">// Offset of the saved BP wrt the frame pointer.</span>
</span>
<span class="line" id="L423">    <span class="tok-kw">const</span> fp_offset = <span class="tok-kw">if</span> (native_arch.isRISCV())</span>
<span class="line" id="L424">        <span class="tok-comment">// On RISC-V the frame pointer points to the top of the saved register</span>
</span>
<span class="line" id="L425">        <span class="tok-comment">// area, on pretty much every other architecture it points to the stack</span>
</span>
<span class="line" id="L426">        <span class="tok-comment">// slot where the previous frame pointer is saved.</span>
</span>
<span class="line" id="L427">        <span class="tok-number">2</span> * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)</span>
<span class="line" id="L428">    <span class="tok-kw">else</span> <span class="tok-kw">if</span> (native_arch.isSPARC())</span>
<span class="line" id="L429">        <span class="tok-comment">// On SPARC the previous frame pointer is stored at 14 slots past %fp+BIAS.</span>
</span>
<span class="line" id="L430">        <span class="tok-number">14</span> * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)</span>
<span class="line" id="L431">    <span class="tok-kw">else</span></span>
<span class="line" id="L432">        <span class="tok-number">0</span>;</span>
<span class="line" id="L433"></span>
<span class="line" id="L434">    <span class="tok-kw">const</span> fp_bias = <span class="tok-kw">if</span> (native_arch.isSPARC())</span>
<span class="line" id="L435">        <span class="tok-comment">// On SPARC frame pointers are biased by a constant.</span>
</span>
<span class="line" id="L436">        <span class="tok-number">2047</span></span>
<span class="line" id="L437">    <span class="tok-kw">else</span></span>
<span class="line" id="L438">        <span class="tok-number">0</span>;</span>
<span class="line" id="L439"></span>
<span class="line" id="L440">    <span class="tok-comment">// Positive offset of the saved PC wrt the frame pointer.</span>
</span>
<span class="line" id="L441">    <span class="tok-kw">const</span> pc_offset = <span class="tok-kw">if</span> (native_arch == .powerpc64le)</span>
<span class="line" id="L442">        <span class="tok-number">2</span> * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)</span>
<span class="line" id="L443">    <span class="tok-kw">else</span></span>
<span class="line" id="L444">        <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);</span>
<span class="line" id="L445"></span>
<span class="line" id="L446">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *StackIterator) ?<span class="tok-type">usize</span> {</span>
<span class="line" id="L447">        <span class="tok-kw">var</span> address = self.next_internal() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L448"></span>
<span class="line" id="L449">        <span class="tok-kw">if</span> (self.first_address) |first_address| {</span>
<span class="line" id="L450">            <span class="tok-kw">while</span> (address != first_address) {</span>
<span class="line" id="L451">                address = self.next_internal() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L452">            }</span>
<span class="line" id="L453">            self.first_address = <span class="tok-null">null</span>;</span>
<span class="line" id="L454">        }</span>
<span class="line" id="L455"></span>
<span class="line" id="L456">        <span class="tok-kw">return</span> address;</span>
<span class="line" id="L457">    }</span>
<span class="line" id="L458"></span>
<span class="line" id="L459">    <span class="tok-kw">fn</span> <span class="tok-fn">isValidMemory</span>(address: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L460">        <span class="tok-comment">// We are unable to determine validity of memory for freestanding targets</span>
</span>
<span class="line" id="L461">        <span class="tok-kw">if</span> (native_os == .freestanding) <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L462"></span>
<span class="line" id="L463">        <span class="tok-kw">const</span> aligned_address = address &amp; ~<span class="tok-builtin">@intCast</span>(<span class="tok-type">usize</span>, (mem.page_size - <span class="tok-number">1</span>));</span>
<span class="line" id="L464">        <span class="tok-kw">const</span> aligned_memory = <span class="tok-builtin">@ptrFromInt</span>([*]<span class="tok-kw">align</span>(mem.page_size) <span class="tok-type">u8</span>, aligned_address)[<span class="tok-number">0</span>..mem.page_size];</span>
<span class="line" id="L465"></span>
<span class="line" id="L466">        <span class="tok-kw">if</span> (native_os != .windows) {</span>
<span class="line" id="L467">            <span class="tok-kw">if</span> (native_os != .wasi) {</span>
<span class="line" id="L468">                os.msync(aligned_memory, os.MSF.ASYNC) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L469">                    <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L470">                        os.MSyncError.UnmappedMemory =&gt; {</span>
<span class="line" id="L471">                            <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L472">                        },</span>
<span class="line" id="L473">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L474">                    }</span>
<span class="line" id="L475">                };</span>
<span class="line" id="L476">            }</span>
<span class="line" id="L477"></span>
<span class="line" id="L478">            <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L479">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L480">            <span class="tok-kw">const</span> w = os.windows;</span>
<span class="line" id="L481">            <span class="tok-kw">var</span> memory_info: w.MEMORY_BASIC_INFORMATION = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L482"></span>
<span class="line" id="L483">            <span class="tok-comment">// The only error this function can throw is ERROR_INVALID_PARAMETER.</span>
</span>
<span class="line" id="L484">            <span class="tok-comment">// supply an address that invalid i'll be thrown.</span>
</span>
<span class="line" id="L485">            <span class="tok-kw">const</span> rc = w.VirtualQuery(aligned_memory, &amp;memory_info, aligned_memory.len) <span class="tok-kw">catch</span> {</span>
<span class="line" id="L486">                <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L487">            };</span>
<span class="line" id="L488"></span>
<span class="line" id="L489">            <span class="tok-comment">// Result code has to be bigger than zero (number of bytes written)</span>
</span>
<span class="line" id="L490">            <span class="tok-kw">if</span> (rc == <span class="tok-number">0</span>) {</span>
<span class="line" id="L491">                <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L492">            }</span>
<span class="line" id="L493"></span>
<span class="line" id="L494">            <span class="tok-comment">// Free pages cannot be read, they are unmapped</span>
</span>
<span class="line" id="L495">            <span class="tok-kw">if</span> (memory_info.State == w.MEM_FREE) {</span>
<span class="line" id="L496">                <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L497">            }</span>
<span class="line" id="L498"></span>
<span class="line" id="L499">            <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L500">        }</span>
<span class="line" id="L501">    }</span>
<span class="line" id="L502"></span>
<span class="line" id="L503">    <span class="tok-kw">fn</span> <span class="tok-fn">next_internal</span>(self: *StackIterator) ?<span class="tok-type">usize</span> {</span>
<span class="line" id="L504">        <span class="tok-kw">const</span> fp = <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> native_arch.isSPARC())</span>
<span class="line" id="L505">            <span class="tok-comment">// On SPARC the offset is positive. (!)</span>
</span>
<span class="line" id="L506">            math.add(<span class="tok-type">usize</span>, self.fp, fp_offset) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">null</span></span>
<span class="line" id="L507">        <span class="tok-kw">else</span></span>
<span class="line" id="L508">            math.sub(<span class="tok-type">usize</span>, self.fp, fp_offset) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L509"></span>
<span class="line" id="L510">        <span class="tok-comment">// Sanity check.</span>
</span>
<span class="line" id="L511">        <span class="tok-kw">if</span> (fp == <span class="tok-number">0</span> <span class="tok-kw">or</span> !mem.isAligned(fp, <span class="tok-builtin">@alignOf</span>(<span class="tok-type">usize</span>)) <span class="tok-kw">or</span> !isValidMemory(fp))</span>
<span class="line" id="L512">            <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L513"></span>
<span class="line" id="L514">        <span class="tok-kw">const</span> new_fp = math.add(<span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, fp).*, fp_bias) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L515"></span>
<span class="line" id="L516">        <span class="tok-comment">// Sanity check: the stack grows down thus all the parent frames must be</span>
</span>
<span class="line" id="L517">        <span class="tok-comment">// be at addresses that are greater (or equal) than the previous one.</span>
</span>
<span class="line" id="L518">        <span class="tok-comment">// A zero frame pointer often signals this is the last frame, that case</span>
</span>
<span class="line" id="L519">        <span class="tok-comment">// is gracefully handled by the next call to next_internal.</span>
</span>
<span class="line" id="L520">        <span class="tok-kw">if</span> (new_fp != <span class="tok-number">0</span> <span class="tok-kw">and</span> new_fp &lt; self.fp)</span>
<span class="line" id="L521">            <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L522"></span>
<span class="line" id="L523">        <span class="tok-kw">const</span> new_pc = <span class="tok-builtin">@ptrFromInt</span>(</span>
<span class="line" id="L524">            *<span class="tok-kw">const</span> <span class="tok-type">usize</span>,</span>
<span class="line" id="L525">            math.add(<span class="tok-type">usize</span>, fp, pc_offset) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>,</span>
<span class="line" id="L526">        ).*;</span>
<span class="line" id="L527"></span>
<span class="line" id="L528">        self.fp = new_fp;</span>
<span class="line" id="L529"></span>
<span class="line" id="L530">        <span class="tok-kw">return</span> new_pc;</span>
<span class="line" id="L531">    }</span>
<span class="line" id="L532">};</span>
<span class="line" id="L533"></span>
<span class="line" id="L534"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeCurrentStackTrace</span>(</span>
<span class="line" id="L535">    out_stream: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L536">    debug_info: *DebugInfo,</span>
<span class="line" id="L537">    tty_config: io.tty.Config,</span>
<span class="line" id="L538">    start_addr: ?<span class="tok-type">usize</span>,</span>
<span class="line" id="L539">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L540">    <span class="tok-kw">if</span> (native_os == .windows) {</span>
<span class="line" id="L541">        <span class="tok-kw">return</span> writeCurrentStackTraceWindows(out_stream, debug_info, tty_config, start_addr);</span>
<span class="line" id="L542">    }</span>
<span class="line" id="L543">    <span class="tok-kw">var</span> it = StackIterator.init(start_addr, <span class="tok-null">null</span>);</span>
<span class="line" id="L544">    <span class="tok-kw">while</span> (it.next()) |return_address| {</span>
<span class="line" id="L545">        <span class="tok-comment">// On arm64 macOS, the address of the last frame is 0x0 rather than 0x1 as on x86_64 macOS,</span>
</span>
<span class="line" id="L546">        <span class="tok-comment">// therefore, we do a check for `return_address == 0` before subtracting 1 from it to avoid</span>
</span>
<span class="line" id="L547">        <span class="tok-comment">// an overflow. We do not need to signal `StackIterator` as it will correctly detect this</span>
</span>
<span class="line" id="L548">        <span class="tok-comment">// condition on the subsequent iteration and return `null` thus terminating the loop.</span>
</span>
<span class="line" id="L549">        <span class="tok-comment">// same behaviour for x86-windows-msvc</span>
</span>
<span class="line" id="L550">        <span class="tok-kw">const</span> address = <span class="tok-kw">if</span> (return_address == <span class="tok-number">0</span>) return_address <span class="tok-kw">else</span> return_address - <span class="tok-number">1</span>;</span>
<span class="line" id="L551">        <span class="tok-kw">try</span> printSourceAtAddress(debug_info, out_stream, address, tty_config);</span>
<span class="line" id="L552">    }</span>
<span class="line" id="L553">}</span>
<span class="line" id="L554"></span>
<span class="line" id="L555"><span class="tok-kw">pub</span> <span class="tok-kw">noinline</span> <span class="tok-kw">fn</span> <span class="tok-fn">walkStackWindows</span>(addresses: []<span class="tok-type">usize</span>) <span class="tok-type">usize</span> {</span>
<span class="line" id="L556">    <span class="tok-kw">if</span> (builtin.cpu.arch == .x86) {</span>
<span class="line" id="L557">        <span class="tok-comment">// RtlVirtualUnwind doesn't exist on x86</span>
</span>
<span class="line" id="L558">        <span class="tok-kw">return</span> windows.ntdll.RtlCaptureStackBackTrace(<span class="tok-number">0</span>, addresses.len, <span class="tok-builtin">@ptrCast</span>(**<span class="tok-type">anyopaque</span>, addresses.ptr), <span class="tok-null">null</span>);</span>
<span class="line" id="L559">    }</span>
<span class="line" id="L560"></span>
<span class="line" id="L561">    <span class="tok-kw">const</span> tib = <span class="tok-builtin">@ptrCast</span>(*<span class="tok-kw">const</span> windows.NT_TIB, &amp;windows.teb().Reserved1);</span>
<span class="line" id="L562"></span>
<span class="line" id="L563">    <span class="tok-kw">var</span> context: windows.CONTEXT = std.mem.zeroes(windows.CONTEXT);</span>
<span class="line" id="L564">    windows.ntdll.RtlCaptureContext(&amp;context);</span>
<span class="line" id="L565"></span>
<span class="line" id="L566">    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L567">    <span class="tok-kw">var</span> image_base: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L568">    <span class="tok-kw">var</span> history_table: windows.UNWIND_HISTORY_TABLE = std.mem.zeroes(windows.UNWIND_HISTORY_TABLE);</span>
<span class="line" id="L569"></span>
<span class="line" id="L570">    <span class="tok-kw">while</span> (i &lt; addresses.len) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L571">        <span class="tok-kw">const</span> current_regs = context.getRegs();</span>
<span class="line" id="L572">        <span class="tok-kw">if</span> (windows.ntdll.RtlLookupFunctionEntry(current_regs.ip, &amp;image_base, &amp;history_table)) |runtime_function| {</span>
<span class="line" id="L573">            <span class="tok-kw">var</span> handler_data: ?*<span class="tok-type">anyopaque</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L574">            <span class="tok-kw">var</span> establisher_frame: <span class="tok-type">u64</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L575">            _ = windows.ntdll.RtlVirtualUnwind(</span>
<span class="line" id="L576">                windows.UNW_FLAG_NHANDLER,</span>
<span class="line" id="L577">                image_base,</span>
<span class="line" id="L578">                current_regs.ip,</span>
<span class="line" id="L579">                runtime_function,</span>
<span class="line" id="L580">                &amp;context,</span>
<span class="line" id="L581">                &amp;handler_data,</span>
<span class="line" id="L582">                &amp;establisher_frame,</span>
<span class="line" id="L583">                <span class="tok-null">null</span>,</span>
<span class="line" id="L584">            );</span>
<span class="line" id="L585">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L586">            <span class="tok-comment">// leaf function</span>
</span>
<span class="line" id="L587">            context.setIp(<span class="tok-builtin">@ptrFromInt</span>(*<span class="tok-type">u64</span>, current_regs.sp).*);</span>
<span class="line" id="L588">            context.setSp(current_regs.sp + <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>));</span>
<span class="line" id="L589">        }</span>
<span class="line" id="L590"></span>
<span class="line" id="L591">        <span class="tok-kw">const</span> next_regs = context.getRegs();</span>
<span class="line" id="L592">        <span class="tok-kw">if</span> (next_regs.sp &lt; <span class="tok-builtin">@intFromPtr</span>(tib.StackLimit) <span class="tok-kw">or</span> next_regs.sp &gt; <span class="tok-builtin">@intFromPtr</span>(tib.StackBase)) {</span>
<span class="line" id="L593">            <span class="tok-kw">break</span>;</span>
<span class="line" id="L594">        }</span>
<span class="line" id="L595"></span>
<span class="line" id="L596">        <span class="tok-kw">if</span> (next_regs.ip == <span class="tok-number">0</span>) {</span>
<span class="line" id="L597">            <span class="tok-kw">break</span>;</span>
<span class="line" id="L598">        }</span>
<span class="line" id="L599"></span>
<span class="line" id="L600">        addresses[i] = next_regs.ip;</span>
<span class="line" id="L601">    }</span>
<span class="line" id="L602"></span>
<span class="line" id="L603">    <span class="tok-kw">return</span> i;</span>
<span class="line" id="L604">}</span>
<span class="line" id="L605"></span>
<span class="line" id="L606"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeCurrentStackTraceWindows</span>(</span>
<span class="line" id="L607">    out_stream: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L608">    debug_info: *DebugInfo,</span>
<span class="line" id="L609">    tty_config: io.tty.Config,</span>
<span class="line" id="L610">    start_addr: ?<span class="tok-type">usize</span>,</span>
<span class="line" id="L611">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L612">    <span class="tok-kw">var</span> addr_buf: [<span class="tok-number">1024</span>]<span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L613">    <span class="tok-kw">const</span> n = walkStackWindows(addr_buf[<span class="tok-number">0</span>..]);</span>
<span class="line" id="L614">    <span class="tok-kw">const</span> addrs = addr_buf[<span class="tok-number">0</span>..n];</span>
<span class="line" id="L615">    <span class="tok-kw">var</span> start_i: <span class="tok-type">usize</span> = <span class="tok-kw">if</span> (start_addr) |saddr| blk: {</span>
<span class="line" id="L616">        <span class="tok-kw">for</span> (addrs, <span class="tok-number">0</span>..) |addr, i| {</span>
<span class="line" id="L617">            <span class="tok-kw">if</span> (addr == saddr) <span class="tok-kw">break</span> :blk i;</span>
<span class="line" id="L618">        }</span>
<span class="line" id="L619">        <span class="tok-kw">return</span>;</span>
<span class="line" id="L620">    } <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L621">    <span class="tok-kw">for</span> (addrs[start_i..]) |addr| {</span>
<span class="line" id="L622">        <span class="tok-kw">try</span> printSourceAtAddress(debug_info, out_stream, addr - <span class="tok-number">1</span>, tty_config);</span>
<span class="line" id="L623">    }</span>
<span class="line" id="L624">}</span>
<span class="line" id="L625"></span>
<span class="line" id="L626"><span class="tok-kw">fn</span> <span class="tok-fn">machoSearchSymbols</span>(symbols: []<span class="tok-kw">const</span> MachoSymbol, address: <span class="tok-type">usize</span>) ?*<span class="tok-kw">const</span> MachoSymbol {</span>
<span class="line" id="L627">    <span class="tok-kw">var</span> min: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L628">    <span class="tok-kw">var</span> max: <span class="tok-type">usize</span> = symbols.len - <span class="tok-number">1</span>;</span>
<span class="line" id="L629">    <span class="tok-kw">while</span> (min &lt; max) {</span>
<span class="line" id="L630">        <span class="tok-kw">const</span> mid = min + (max - min) / <span class="tok-number">2</span>;</span>
<span class="line" id="L631">        <span class="tok-kw">const</span> curr = &amp;symbols[mid];</span>
<span class="line" id="L632">        <span class="tok-kw">const</span> next = &amp;symbols[mid + <span class="tok-number">1</span>];</span>
<span class="line" id="L633">        <span class="tok-kw">if</span> (address &gt;= next.address()) {</span>
<span class="line" id="L634">            min = mid + <span class="tok-number">1</span>;</span>
<span class="line" id="L635">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (address &lt; curr.address()) {</span>
<span class="line" id="L636">            max = mid;</span>
<span class="line" id="L637">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L638">            <span class="tok-kw">return</span> curr;</span>
<span class="line" id="L639">        }</span>
<span class="line" id="L640">    }</span>
<span class="line" id="L641"></span>
<span class="line" id="L642">    <span class="tok-kw">const</span> max_sym = &amp;symbols[symbols.len - <span class="tok-number">1</span>];</span>
<span class="line" id="L643">    <span class="tok-kw">if</span> (address &gt;= max_sym.address())</span>
<span class="line" id="L644">        <span class="tok-kw">return</span> max_sym;</span>
<span class="line" id="L645"></span>
<span class="line" id="L646">    <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L647">}</span>
<span class="line" id="L648"></span>
<span class="line" id="L649"><span class="tok-kw">test</span> <span class="tok-str">&quot;machoSearchSymbols&quot;</span> {</span>
<span class="line" id="L650">    <span class="tok-kw">const</span> symbols = [_]MachoSymbol{</span>
<span class="line" id="L651">        .{ .addr = <span class="tok-number">100</span>, .strx = <span class="tok-null">undefined</span>, .size = <span class="tok-null">undefined</span>, .ofile = <span class="tok-null">undefined</span> },</span>
<span class="line" id="L652">        .{ .addr = <span class="tok-number">200</span>, .strx = <span class="tok-null">undefined</span>, .size = <span class="tok-null">undefined</span>, .ofile = <span class="tok-null">undefined</span> },</span>
<span class="line" id="L653">        .{ .addr = <span class="tok-number">300</span>, .strx = <span class="tok-null">undefined</span>, .size = <span class="tok-null">undefined</span>, .ofile = <span class="tok-null">undefined</span> },</span>
<span class="line" id="L654">    };</span>
<span class="line" id="L655"></span>
<span class="line" id="L656">    <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(?*<span class="tok-kw">const</span> MachoSymbol, <span class="tok-null">null</span>), machoSearchSymbols(&amp;symbols, <span class="tok-number">0</span>));</span>
<span class="line" id="L657">    <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(?*<span class="tok-kw">const</span> MachoSymbol, <span class="tok-null">null</span>), machoSearchSymbols(&amp;symbols, <span class="tok-number">99</span>));</span>
<span class="line" id="L658">    <span class="tok-kw">try</span> testing.expectEqual(&amp;symbols[<span class="tok-number">0</span>], machoSearchSymbols(&amp;symbols, <span class="tok-number">100</span>).?);</span>
<span class="line" id="L659">    <span class="tok-kw">try</span> testing.expectEqual(&amp;symbols[<span class="tok-number">0</span>], machoSearchSymbols(&amp;symbols, <span class="tok-number">150</span>).?);</span>
<span class="line" id="L660">    <span class="tok-kw">try</span> testing.expectEqual(&amp;symbols[<span class="tok-number">0</span>], machoSearchSymbols(&amp;symbols, <span class="tok-number">199</span>).?);</span>
<span class="line" id="L661"></span>
<span class="line" id="L662">    <span class="tok-kw">try</span> testing.expectEqual(&amp;symbols[<span class="tok-number">1</span>], machoSearchSymbols(&amp;symbols, <span class="tok-number">200</span>).?);</span>
<span class="line" id="L663">    <span class="tok-kw">try</span> testing.expectEqual(&amp;symbols[<span class="tok-number">1</span>], machoSearchSymbols(&amp;symbols, <span class="tok-number">250</span>).?);</span>
<span class="line" id="L664">    <span class="tok-kw">try</span> testing.expectEqual(&amp;symbols[<span class="tok-number">1</span>], machoSearchSymbols(&amp;symbols, <span class="tok-number">299</span>).?);</span>
<span class="line" id="L665"></span>
<span class="line" id="L666">    <span class="tok-kw">try</span> testing.expectEqual(&amp;symbols[<span class="tok-number">2</span>], machoSearchSymbols(&amp;symbols, <span class="tok-number">300</span>).?);</span>
<span class="line" id="L667">    <span class="tok-kw">try</span> testing.expectEqual(&amp;symbols[<span class="tok-number">2</span>], machoSearchSymbols(&amp;symbols, <span class="tok-number">301</span>).?);</span>
<span class="line" id="L668">    <span class="tok-kw">try</span> testing.expectEqual(&amp;symbols[<span class="tok-number">2</span>], machoSearchSymbols(&amp;symbols, <span class="tok-number">5000</span>).?);</span>
<span class="line" id="L669">}</span>
<span class="line" id="L670"></span>
<span class="line" id="L671"><span class="tok-kw">fn</span> <span class="tok-fn">printUnknownSource</span>(debug_info: *DebugInfo, out_stream: <span class="tok-kw">anytype</span>, address: <span class="tok-type">usize</span>, tty_config: io.tty.Config) !<span class="tok-type">void</span> {</span>
<span class="line" id="L672">    <span class="tok-kw">const</span> module_name = debug_info.getModuleNameForAddress(address);</span>
<span class="line" id="L673">    <span class="tok-kw">return</span> printLineInfo(</span>
<span class="line" id="L674">        out_stream,</span>
<span class="line" id="L675">        <span class="tok-null">null</span>,</span>
<span class="line" id="L676">        address,</span>
<span class="line" id="L677">        <span class="tok-str">&quot;???&quot;</span>,</span>
<span class="line" id="L678">        module_name <span class="tok-kw">orelse</span> <span class="tok-str">&quot;???&quot;</span>,</span>
<span class="line" id="L679">        tty_config,</span>
<span class="line" id="L680">        printLineFromFileAnyOs,</span>
<span class="line" id="L681">    );</span>
<span class="line" id="L682">}</span>
<span class="line" id="L683"></span>
<span class="line" id="L684"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">printSourceAtAddress</span>(debug_info: *DebugInfo, out_stream: <span class="tok-kw">anytype</span>, address: <span class="tok-type">usize</span>, tty_config: io.tty.Config) !<span class="tok-type">void</span> {</span>
<span class="line" id="L685">    <span class="tok-kw">const</span> module = debug_info.getModuleForAddress(address) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L686">        <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; <span class="tok-kw">return</span> printUnknownSource(debug_info, out_stream, address, tty_config),</span>
<span class="line" id="L687">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L688">    };</span>
<span class="line" id="L689"></span>
<span class="line" id="L690">    <span class="tok-kw">const</span> symbol_info = module.getSymbolAtAddress(debug_info.allocator, address) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L691">        <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; <span class="tok-kw">return</span> printUnknownSource(debug_info, out_stream, address, tty_config),</span>
<span class="line" id="L692">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L693">    };</span>
<span class="line" id="L694">    <span class="tok-kw">defer</span> symbol_info.deinit(debug_info.allocator);</span>
<span class="line" id="L695"></span>
<span class="line" id="L696">    <span class="tok-kw">return</span> printLineInfo(</span>
<span class="line" id="L697">        out_stream,</span>
<span class="line" id="L698">        symbol_info.line_info,</span>
<span class="line" id="L699">        address,</span>
<span class="line" id="L700">        symbol_info.symbol_name,</span>
<span class="line" id="L701">        symbol_info.compile_unit_name,</span>
<span class="line" id="L702">        tty_config,</span>
<span class="line" id="L703">        printLineFromFileAnyOs,</span>
<span class="line" id="L704">    );</span>
<span class="line" id="L705">}</span>
<span class="line" id="L706"></span>
<span class="line" id="L707"><span class="tok-kw">fn</span> <span class="tok-fn">printLineInfo</span>(</span>
<span class="line" id="L708">    out_stream: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L709">    line_info: ?LineInfo,</span>
<span class="line" id="L710">    address: <span class="tok-type">usize</span>,</span>
<span class="line" id="L711">    symbol_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L712">    compile_unit_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L713">    tty_config: io.tty.Config,</span>
<span class="line" id="L714">    <span class="tok-kw">comptime</span> printLineFromFile: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L715">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L716">    <span class="tok-kw">nosuspend</span> {</span>
<span class="line" id="L717">        <span class="tok-kw">try</span> tty_config.setColor(out_stream, .bold);</span>
<span class="line" id="L718"></span>
<span class="line" id="L719">        <span class="tok-kw">if</span> (line_info) |*li| {</span>
<span class="line" id="L720">            <span class="tok-kw">try</span> out_stream.print(<span class="tok-str">&quot;{s}:{d}:{d}&quot;</span>, .{ li.file_name, li.line, li.column });</span>
<span class="line" id="L721">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L722">            <span class="tok-kw">try</span> out_stream.writeAll(<span class="tok-str">&quot;???:?:?&quot;</span>);</span>
<span class="line" id="L723">        }</span>
<span class="line" id="L724"></span>
<span class="line" id="L725">        <span class="tok-kw">try</span> tty_config.setColor(out_stream, .reset);</span>
<span class="line" id="L726">        <span class="tok-kw">try</span> out_stream.writeAll(<span class="tok-str">&quot;: &quot;</span>);</span>
<span class="line" id="L727">        <span class="tok-kw">try</span> tty_config.setColor(out_stream, .dim);</span>
<span class="line" id="L728">        <span class="tok-kw">try</span> out_stream.print(<span class="tok-str">&quot;0x{x} in {s} ({s})&quot;</span>, .{ address, symbol_name, compile_unit_name });</span>
<span class="line" id="L729">        <span class="tok-kw">try</span> tty_config.setColor(out_stream, .reset);</span>
<span class="line" id="L730">        <span class="tok-kw">try</span> out_stream.writeAll(<span class="tok-str">&quot;\n&quot;</span>);</span>
<span class="line" id="L731"></span>
<span class="line" id="L732">        <span class="tok-comment">// Show the matching source code line if possible</span>
</span>
<span class="line" id="L733">        <span class="tok-kw">if</span> (line_info) |li| {</span>
<span class="line" id="L734">            <span class="tok-kw">if</span> (printLineFromFile(out_stream, li)) {</span>
<span class="line" id="L735">                <span class="tok-kw">if</span> (li.column &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L736">                    <span class="tok-comment">// The caret already takes one char</span>
</span>
<span class="line" id="L737">                    <span class="tok-kw">const</span> space_needed = <span class="tok-builtin">@intCast</span>(<span class="tok-type">usize</span>, li.column - <span class="tok-number">1</span>);</span>
<span class="line" id="L738"></span>
<span class="line" id="L739">                    <span class="tok-kw">try</span> out_stream.writeByteNTimes(<span class="tok-str">' '</span>, space_needed);</span>
<span class="line" id="L740">                    <span class="tok-kw">try</span> tty_config.setColor(out_stream, .green);</span>
<span class="line" id="L741">                    <span class="tok-kw">try</span> out_stream.writeAll(<span class="tok-str">&quot;^&quot;</span>);</span>
<span class="line" id="L742">                    <span class="tok-kw">try</span> tty_config.setColor(out_stream, .reset);</span>
<span class="line" id="L743">                }</span>
<span class="line" id="L744">                <span class="tok-kw">try</span> out_stream.writeAll(<span class="tok-str">&quot;\n&quot;</span>);</span>
<span class="line" id="L745">            } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L746">                <span class="tok-kw">error</span>.EndOfFile, <span class="tok-kw">error</span>.FileNotFound =&gt; {},</span>
<span class="line" id="L747">                <span class="tok-kw">error</span>.BadPathName =&gt; {},</span>
<span class="line" id="L748">                <span class="tok-kw">error</span>.AccessDenied =&gt; {},</span>
<span class="line" id="L749">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L750">            }</span>
<span class="line" id="L751">        }</span>
<span class="line" id="L752">    }</span>
<span class="line" id="L753">}</span>
<span class="line" id="L754"></span>
<span class="line" id="L755"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> OpenSelfDebugInfoError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L756">    MissingDebugInfo,</span>
<span class="line" id="L757">    UnsupportedOperatingSystem,</span>
<span class="line" id="L758">} || <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(DebugInfo.init)).Fn.return_type.?).ErrorUnion.error_set;</span>
<span class="line" id="L759"></span>
<span class="line" id="L760"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openSelfDebugInfo</span>(allocator: mem.Allocator) OpenSelfDebugInfoError!DebugInfo {</span>
<span class="line" id="L761">    <span class="tok-kw">nosuspend</span> {</span>
<span class="line" id="L762">        <span class="tok-kw">if</span> (builtin.strip_debug_info)</span>
<span class="line" id="L763">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L764">        <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(root, <span class="tok-str">&quot;os&quot;</span>) <span class="tok-kw">and</span> <span class="tok-builtin">@hasDecl</span>(root.os, <span class="tok-str">&quot;debug&quot;</span>) <span class="tok-kw">and</span> <span class="tok-builtin">@hasDecl</span>(root.os.debug, <span class="tok-str">&quot;openSelfDebugInfo&quot;</span>)) {</span>
<span class="line" id="L765">            <span class="tok-kw">return</span> root.os.debug.openSelfDebugInfo(allocator);</span>
<span class="line" id="L766">        }</span>
<span class="line" id="L767">        <span class="tok-kw">switch</span> (native_os) {</span>
<span class="line" id="L768">            .linux,</span>
<span class="line" id="L769">            .freebsd,</span>
<span class="line" id="L770">            .netbsd,</span>
<span class="line" id="L771">            .dragonfly,</span>
<span class="line" id="L772">            .openbsd,</span>
<span class="line" id="L773">            .macos,</span>
<span class="line" id="L774">            .solaris,</span>
<span class="line" id="L775">            .windows,</span>
<span class="line" id="L776">            =&gt; <span class="tok-kw">return</span> <span class="tok-kw">try</span> DebugInfo.init(allocator),</span>
<span class="line" id="L777">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedOperatingSystem,</span>
<span class="line" id="L778">        }</span>
<span class="line" id="L779">    }</span>
<span class="line" id="L780">}</span>
<span class="line" id="L781"></span>
<span class="line" id="L782"><span class="tok-kw">fn</span> <span class="tok-fn">readCoffDebugInfo</span>(allocator: mem.Allocator, coff_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !ModuleDebugInfo {</span>
<span class="line" id="L783">    <span class="tok-kw">nosuspend</span> {</span>
<span class="line" id="L784">        <span class="tok-kw">const</span> coff_obj = <span class="tok-kw">try</span> allocator.create(coff.Coff);</span>
<span class="line" id="L785">        <span class="tok-kw">defer</span> allocator.destroy(coff_obj);</span>
<span class="line" id="L786">        coff_obj.* = <span class="tok-kw">try</span> coff.Coff.init(coff_bytes);</span>
<span class="line" id="L787"></span>
<span class="line" id="L788">        <span class="tok-kw">var</span> di = ModuleDebugInfo{</span>
<span class="line" id="L789">            .base_address = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L790">            .coff_image_base = coff_obj.getImageBase(),</span>
<span class="line" id="L791">            .coff_section_headers = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L792">            .debug_data = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L793">        };</span>
<span class="line" id="L794"></span>
<span class="line" id="L795">        <span class="tok-kw">if</span> (coff_obj.getSectionByName(<span class="tok-str">&quot;.debug_info&quot;</span>)) |sec| {</span>
<span class="line" id="L796">            <span class="tok-comment">// This coff file has embedded DWARF debug info</span>
</span>
<span class="line" id="L797">            _ = sec;</span>
<span class="line" id="L798"></span>
<span class="line" id="L799">            <span class="tok-kw">const</span> debug_info = coff_obj.getSectionDataAlloc(<span class="tok-str">&quot;.debug_info&quot;</span>, allocator) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L800">            <span class="tok-kw">errdefer</span> allocator.free(debug_info);</span>
<span class="line" id="L801">            <span class="tok-kw">const</span> debug_abbrev = coff_obj.getSectionDataAlloc(<span class="tok-str">&quot;.debug_abbrev&quot;</span>, allocator) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L802">            <span class="tok-kw">errdefer</span> allocator.free(debug_abbrev);</span>
<span class="line" id="L803">            <span class="tok-kw">const</span> debug_str = coff_obj.getSectionDataAlloc(<span class="tok-str">&quot;.debug_str&quot;</span>, allocator) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L804">            <span class="tok-kw">errdefer</span> allocator.free(debug_str);</span>
<span class="line" id="L805">            <span class="tok-kw">const</span> debug_line = coff_obj.getSectionDataAlloc(<span class="tok-str">&quot;.debug_line&quot;</span>, allocator) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L806">            <span class="tok-kw">errdefer</span> allocator.free(debug_line);</span>
<span class="line" id="L807"></span>
<span class="line" id="L808">            <span class="tok-kw">const</span> debug_str_offsets = coff_obj.getSectionDataAlloc(<span class="tok-str">&quot;.debug_str_offsets&quot;</span>, allocator) <span class="tok-kw">catch</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L809">            <span class="tok-kw">const</span> debug_line_str = coff_obj.getSectionDataAlloc(<span class="tok-str">&quot;.debug_line_str&quot;</span>, allocator) <span class="tok-kw">catch</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L810">            <span class="tok-kw">const</span> debug_ranges = coff_obj.getSectionDataAlloc(<span class="tok-str">&quot;.debug_ranges&quot;</span>, allocator) <span class="tok-kw">catch</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L811">            <span class="tok-kw">const</span> debug_loclists = coff_obj.getSectionDataAlloc(<span class="tok-str">&quot;.debug_loclists&quot;</span>, allocator) <span class="tok-kw">catch</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L812">            <span class="tok-kw">const</span> debug_rnglists = coff_obj.getSectionDataAlloc(<span class="tok-str">&quot;.debug_rnglists&quot;</span>, allocator) <span class="tok-kw">catch</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L813">            <span class="tok-kw">const</span> debug_addr = coff_obj.getSectionDataAlloc(<span class="tok-str">&quot;.debug_addr&quot;</span>, allocator) <span class="tok-kw">catch</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L814">            <span class="tok-kw">const</span> debug_names = coff_obj.getSectionDataAlloc(<span class="tok-str">&quot;.debug_names&quot;</span>, allocator) <span class="tok-kw">catch</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L815">            <span class="tok-kw">const</span> debug_frame = coff_obj.getSectionDataAlloc(<span class="tok-str">&quot;.debug_frame&quot;</span>, allocator) <span class="tok-kw">catch</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L816"></span>
<span class="line" id="L817">            <span class="tok-kw">var</span> dwarf = DW.DwarfInfo{</span>
<span class="line" id="L818">                .endian = native_endian,</span>
<span class="line" id="L819">                .debug_info = debug_info,</span>
<span class="line" id="L820">                .debug_abbrev = debug_abbrev,</span>
<span class="line" id="L821">                .debug_str = debug_str,</span>
<span class="line" id="L822">                .debug_str_offsets = debug_str_offsets,</span>
<span class="line" id="L823">                .debug_line = debug_line,</span>
<span class="line" id="L824">                .debug_line_str = debug_line_str,</span>
<span class="line" id="L825">                .debug_ranges = debug_ranges,</span>
<span class="line" id="L826">                .debug_loclists = debug_loclists,</span>
<span class="line" id="L827">                .debug_rnglists = debug_rnglists,</span>
<span class="line" id="L828">                .debug_addr = debug_addr,</span>
<span class="line" id="L829">                .debug_names = debug_names,</span>
<span class="line" id="L830">                .debug_frame = debug_frame,</span>
<span class="line" id="L831">            };</span>
<span class="line" id="L832"></span>
<span class="line" id="L833">            DW.openDwarfDebugInfo(&amp;dwarf, allocator) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L834">                <span class="tok-kw">if</span> (debug_str_offsets) |d| allocator.free(d);</span>
<span class="line" id="L835">                <span class="tok-kw">if</span> (debug_line_str) |d| allocator.free(d);</span>
<span class="line" id="L836">                <span class="tok-kw">if</span> (debug_ranges) |d| allocator.free(d);</span>
<span class="line" id="L837">                <span class="tok-kw">if</span> (debug_loclists) |d| allocator.free(d);</span>
<span class="line" id="L838">                <span class="tok-kw">if</span> (debug_rnglists) |d| allocator.free(d);</span>
<span class="line" id="L839">                <span class="tok-kw">if</span> (debug_addr) |d| allocator.free(d);</span>
<span class="line" id="L840">                <span class="tok-kw">if</span> (debug_names) |d| allocator.free(d);</span>
<span class="line" id="L841">                <span class="tok-kw">if</span> (debug_frame) |d| allocator.free(d);</span>
<span class="line" id="L842">                <span class="tok-kw">return</span> err;</span>
<span class="line" id="L843">            };</span>
<span class="line" id="L844"></span>
<span class="line" id="L845">            di.debug_data = PdbOrDwarf{ .dwarf = dwarf };</span>
<span class="line" id="L846">            <span class="tok-kw">return</span> di;</span>
<span class="line" id="L847">        }</span>
<span class="line" id="L848"></span>
<span class="line" id="L849">        <span class="tok-comment">// Only used by pdb path</span>
</span>
<span class="line" id="L850">        di.coff_section_headers = <span class="tok-kw">try</span> coff_obj.getSectionHeadersAlloc(allocator);</span>
<span class="line" id="L851"></span>
<span class="line" id="L852">        <span class="tok-kw">var</span> path_buf: [windows.MAX_PATH]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L853">        <span class="tok-kw">const</span> len = <span class="tok-kw">try</span> coff_obj.getPdbPath(path_buf[<span class="tok-number">0</span>..]);</span>
<span class="line" id="L854">        <span class="tok-kw">const</span> raw_path = path_buf[<span class="tok-number">0</span>..len];</span>
<span class="line" id="L855"></span>
<span class="line" id="L856">        <span class="tok-kw">const</span> path = <span class="tok-kw">try</span> fs.path.resolve(allocator, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{raw_path});</span>
<span class="line" id="L857">        <span class="tok-kw">defer</span> allocator.free(path);</span>
<span class="line" id="L858"></span>
<span class="line" id="L859">        di.debug_data = PdbOrDwarf{ .pdb = <span class="tok-null">undefined</span> };</span>
<span class="line" id="L860">        di.debug_data.pdb = pdb.Pdb.init(allocator, path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L861">            <span class="tok-kw">error</span>.FileNotFound, <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo,</span>
<span class="line" id="L862">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L863">        };</span>
<span class="line" id="L864">        <span class="tok-kw">try</span> di.debug_data.pdb.parseInfoStream();</span>
<span class="line" id="L865">        <span class="tok-kw">try</span> di.debug_data.pdb.parseDbiStream();</span>
<span class="line" id="L866"></span>
<span class="line" id="L867">        <span class="tok-kw">if</span> (!mem.eql(<span class="tok-type">u8</span>, &amp;coff_obj.guid, &amp;di.debug_data.pdb.guid) <span class="tok-kw">or</span> coff_obj.age != di.debug_data.pdb.age)</span>
<span class="line" id="L868">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo;</span>
<span class="line" id="L869"></span>
<span class="line" id="L870">        <span class="tok-kw">return</span> di;</span>
<span class="line" id="L871">    }</span>
<span class="line" id="L872">}</span>
<span class="line" id="L873"></span>
<span class="line" id="L874"><span class="tok-kw">fn</span> <span class="tok-fn">chopSlice</span>(ptr: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, offset: <span class="tok-type">u64</span>, size: <span class="tok-type">u64</span>) <span class="tok-kw">error</span>{Overflow}![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L875">    <span class="tok-kw">const</span> start = math.cast(<span class="tok-type">usize</span>, offset) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;</span>
<span class="line" id="L876">    <span class="tok-kw">const</span> end = start + (math.cast(<span class="tok-type">usize</span>, size) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow);</span>
<span class="line" id="L877">    <span class="tok-kw">return</span> ptr[start..end];</span>
<span class="line" id="L878">}</span>
<span class="line" id="L879"></span>
<span class="line" id="L880"><span class="tok-comment">/// This takes ownership of elf_file: users of this function should not close</span></span>
<span class="line" id="L881"><span class="tok-comment">/// it themselves, even on error.</span></span>
<span class="line" id="L882"><span class="tok-comment">/// TODO it's weird to take ownership even on error, rework this code.</span></span>
<span class="line" id="L883"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readElfDebugInfo</span>(allocator: mem.Allocator, elf_file: File) !ModuleDebugInfo {</span>
<span class="line" id="L884">    <span class="tok-kw">nosuspend</span> {</span>
<span class="line" id="L885">        <span class="tok-kw">const</span> mapped_mem = <span class="tok-kw">try</span> mapWholeFile(elf_file);</span>
<span class="line" id="L886">        <span class="tok-kw">const</span> hdr = <span class="tok-builtin">@ptrCast</span>(*<span class="tok-kw">const</span> elf.Ehdr, &amp;mapped_mem[<span class="tok-number">0</span>]);</span>
<span class="line" id="L887">        <span class="tok-kw">if</span> (!mem.eql(<span class="tok-type">u8</span>, hdr.e_ident[<span class="tok-number">0</span>..<span class="tok-number">4</span>], elf.MAGIC)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfMagic;</span>
<span class="line" id="L888">        <span class="tok-kw">if</span> (hdr.e_ident[elf.EI_VERSION] != <span class="tok-number">1</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfVersion;</span>
<span class="line" id="L889"></span>
<span class="line" id="L890">        <span class="tok-kw">const</span> endian: std.builtin.Endian = <span class="tok-kw">switch</span> (hdr.e_ident[elf.EI_DATA]) {</span>
<span class="line" id="L891">            elf.ELFDATA2LSB =&gt; .Little,</span>
<span class="line" id="L892">            elf.ELFDATA2MSB =&gt; .Big,</span>
<span class="line" id="L893">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfEndian,</span>
<span class="line" id="L894">        };</span>
<span class="line" id="L895">        assert(endian == native_endian); <span class="tok-comment">// this is our own debug info</span>
</span>
<span class="line" id="L896"></span>
<span class="line" id="L897">        <span class="tok-kw">const</span> shoff = hdr.e_shoff;</span>
<span class="line" id="L898">        <span class="tok-kw">const</span> str_section_off = shoff + <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, hdr.e_shentsize) * <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, hdr.e_shstrndx);</span>
<span class="line" id="L899">        <span class="tok-kw">const</span> str_shdr = <span class="tok-builtin">@ptrCast</span>(</span>
<span class="line" id="L900">            *<span class="tok-kw">const</span> elf.Shdr,</span>
<span class="line" id="L901">            <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@alignOf</span>(elf.Shdr), &amp;mapped_mem[math.cast(<span class="tok-type">usize</span>, str_section_off) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow]),</span>
<span class="line" id="L902">        );</span>
<span class="line" id="L903">        <span class="tok-kw">const</span> header_strings = mapped_mem[str_shdr.sh_offset .. str_shdr.sh_offset + str_shdr.sh_size];</span>
<span class="line" id="L904">        <span class="tok-kw">const</span> shdrs = <span class="tok-builtin">@ptrCast</span>(</span>
<span class="line" id="L905">            [*]<span class="tok-kw">const</span> elf.Shdr,</span>
<span class="line" id="L906">            <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@alignOf</span>(elf.Shdr), &amp;mapped_mem[shoff]),</span>
<span class="line" id="L907">        )[<span class="tok-number">0</span>..hdr.e_shnum];</span>
<span class="line" id="L908"></span>
<span class="line" id="L909">        <span class="tok-kw">var</span> opt_debug_info: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L910">        <span class="tok-kw">var</span> opt_debug_abbrev: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L911">        <span class="tok-kw">var</span> opt_debug_str: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L912">        <span class="tok-kw">var</span> opt_debug_str_offsets: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L913">        <span class="tok-kw">var</span> opt_debug_line: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L914">        <span class="tok-kw">var</span> opt_debug_line_str: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L915">        <span class="tok-kw">var</span> opt_debug_ranges: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L916">        <span class="tok-kw">var</span> opt_debug_loclists: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L917">        <span class="tok-kw">var</span> opt_debug_rnglists: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L918">        <span class="tok-kw">var</span> opt_debug_addr: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L919">        <span class="tok-kw">var</span> opt_debug_names: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L920">        <span class="tok-kw">var</span> opt_debug_frame: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L921"></span>
<span class="line" id="L922">        <span class="tok-kw">for</span> (shdrs) |*shdr| {</span>
<span class="line" id="L923">            <span class="tok-kw">if</span> (shdr.sh_type == elf.SHT_NULL) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L924"></span>
<span class="line" id="L925">            <span class="tok-kw">const</span> name = mem.sliceTo(header_strings[shdr.sh_name..], <span class="tok-number">0</span>);</span>
<span class="line" id="L926">            <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.debug_info&quot;</span>)) {</span>
<span class="line" id="L927">                opt_debug_info = <span class="tok-kw">try</span> chopSlice(mapped_mem, shdr.sh_offset, shdr.sh_size);</span>
<span class="line" id="L928">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.debug_abbrev&quot;</span>)) {</span>
<span class="line" id="L929">                opt_debug_abbrev = <span class="tok-kw">try</span> chopSlice(mapped_mem, shdr.sh_offset, shdr.sh_size);</span>
<span class="line" id="L930">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.debug_str&quot;</span>)) {</span>
<span class="line" id="L931">                opt_debug_str = <span class="tok-kw">try</span> chopSlice(mapped_mem, shdr.sh_offset, shdr.sh_size);</span>
<span class="line" id="L932">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.debug_str_offsets&quot;</span>)) {</span>
<span class="line" id="L933">                opt_debug_str_offsets = <span class="tok-kw">try</span> chopSlice(mapped_mem, shdr.sh_offset, shdr.sh_size);</span>
<span class="line" id="L934">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.debug_line&quot;</span>)) {</span>
<span class="line" id="L935">                opt_debug_line = <span class="tok-kw">try</span> chopSlice(mapped_mem, shdr.sh_offset, shdr.sh_size);</span>
<span class="line" id="L936">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.debug_line_str&quot;</span>)) {</span>
<span class="line" id="L937">                opt_debug_line_str = <span class="tok-kw">try</span> chopSlice(mapped_mem, shdr.sh_offset, shdr.sh_size);</span>
<span class="line" id="L938">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.debug_ranges&quot;</span>)) {</span>
<span class="line" id="L939">                opt_debug_ranges = <span class="tok-kw">try</span> chopSlice(mapped_mem, shdr.sh_offset, shdr.sh_size);</span>
<span class="line" id="L940">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.debug_loclists&quot;</span>)) {</span>
<span class="line" id="L941">                opt_debug_loclists = <span class="tok-kw">try</span> chopSlice(mapped_mem, shdr.sh_offset, shdr.sh_size);</span>
<span class="line" id="L942">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.debug_rnglists&quot;</span>)) {</span>
<span class="line" id="L943">                opt_debug_rnglists = <span class="tok-kw">try</span> chopSlice(mapped_mem, shdr.sh_offset, shdr.sh_size);</span>
<span class="line" id="L944">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.debug_addr&quot;</span>)) {</span>
<span class="line" id="L945">                opt_debug_addr = <span class="tok-kw">try</span> chopSlice(mapped_mem, shdr.sh_offset, shdr.sh_size);</span>
<span class="line" id="L946">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.debug_names&quot;</span>)) {</span>
<span class="line" id="L947">                opt_debug_names = <span class="tok-kw">try</span> chopSlice(mapped_mem, shdr.sh_offset, shdr.sh_size);</span>
<span class="line" id="L948">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.debug_frame&quot;</span>)) {</span>
<span class="line" id="L949">                opt_debug_frame = <span class="tok-kw">try</span> chopSlice(mapped_mem, shdr.sh_offset, shdr.sh_size);</span>
<span class="line" id="L950">            }</span>
<span class="line" id="L951">        }</span>
<span class="line" id="L952"></span>
<span class="line" id="L953">        <span class="tok-kw">var</span> di = DW.DwarfInfo{</span>
<span class="line" id="L954">            .endian = endian,</span>
<span class="line" id="L955">            .debug_info = opt_debug_info <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo,</span>
<span class="line" id="L956">            .debug_abbrev = opt_debug_abbrev <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo,</span>
<span class="line" id="L957">            .debug_str = opt_debug_str <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo,</span>
<span class="line" id="L958">            .debug_str_offsets = opt_debug_str_offsets,</span>
<span class="line" id="L959">            .debug_line = opt_debug_line <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo,</span>
<span class="line" id="L960">            .debug_line_str = opt_debug_line_str,</span>
<span class="line" id="L961">            .debug_ranges = opt_debug_ranges,</span>
<span class="line" id="L962">            .debug_loclists = opt_debug_loclists,</span>
<span class="line" id="L963">            .debug_rnglists = opt_debug_rnglists,</span>
<span class="line" id="L964">            .debug_addr = opt_debug_addr,</span>
<span class="line" id="L965">            .debug_names = opt_debug_names,</span>
<span class="line" id="L966">            .debug_frame = opt_debug_frame,</span>
<span class="line" id="L967">        };</span>
<span class="line" id="L968"></span>
<span class="line" id="L969">        <span class="tok-kw">try</span> DW.openDwarfDebugInfo(&amp;di, allocator);</span>
<span class="line" id="L970"></span>
<span class="line" id="L971">        <span class="tok-kw">return</span> ModuleDebugInfo{</span>
<span class="line" id="L972">            .base_address = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L973">            .dwarf = di,</span>
<span class="line" id="L974">            .mapped_memory = mapped_mem,</span>
<span class="line" id="L975">        };</span>
<span class="line" id="L976">    }</span>
<span class="line" id="L977">}</span>
<span class="line" id="L978"></span>
<span class="line" id="L979"><span class="tok-comment">/// This takes ownership of macho_file: users of this function should not close</span></span>
<span class="line" id="L980"><span class="tok-comment">/// it themselves, even on error.</span></span>
<span class="line" id="L981"><span class="tok-comment">/// TODO it's weird to take ownership even on error, rework this code.</span></span>
<span class="line" id="L982"><span class="tok-kw">fn</span> <span class="tok-fn">readMachODebugInfo</span>(allocator: mem.Allocator, macho_file: File) !ModuleDebugInfo {</span>
<span class="line" id="L983">    <span class="tok-kw">const</span> mapped_mem = <span class="tok-kw">try</span> mapWholeFile(macho_file);</span>
<span class="line" id="L984"></span>
<span class="line" id="L985">    <span class="tok-kw">const</span> hdr = <span class="tok-builtin">@ptrCast</span>(</span>
<span class="line" id="L986">        *<span class="tok-kw">const</span> macho.mach_header_64,</span>
<span class="line" id="L987">        <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@alignOf</span>(macho.mach_header_64), mapped_mem.ptr),</span>
<span class="line" id="L988">    );</span>
<span class="line" id="L989">    <span class="tok-kw">if</span> (hdr.magic != macho.MH_MAGIC_64)</span>
<span class="line" id="L990">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo;</span>
<span class="line" id="L991"></span>
<span class="line" id="L992">    <span class="tok-kw">var</span> it = macho.LoadCommandIterator{</span>
<span class="line" id="L993">        .ncmds = hdr.ncmds,</span>
<span class="line" id="L994">        .buffer = mapped_mem[<span class="tok-builtin">@sizeOf</span>(macho.mach_header_64)..][<span class="tok-number">0</span>..hdr.sizeofcmds],</span>
<span class="line" id="L995">    };</span>
<span class="line" id="L996">    <span class="tok-kw">const</span> symtab = <span class="tok-kw">while</span> (it.next()) |cmd| <span class="tok-kw">switch</span> (cmd.cmd()) {</span>
<span class="line" id="L997">        .SYMTAB =&gt; <span class="tok-kw">break</span> cmd.cast(macho.symtab_command).?,</span>
<span class="line" id="L998">        <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L999">    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1000"></span>
<span class="line" id="L1001">    <span class="tok-kw">const</span> syms = <span class="tok-builtin">@ptrCast</span>(</span>
<span class="line" id="L1002">        [*]<span class="tok-kw">const</span> macho.nlist_64,</span>
<span class="line" id="L1003">        <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@alignOf</span>(macho.nlist_64), &amp;mapped_mem[symtab.symoff]),</span>
<span class="line" id="L1004">    )[<span class="tok-number">0</span>..symtab.nsyms];</span>
<span class="line" id="L1005">    <span class="tok-kw">const</span> strings = mapped_mem[symtab.stroff..][<span class="tok-number">0</span> .. symtab.strsize - <span class="tok-number">1</span> :<span class="tok-number">0</span>];</span>
<span class="line" id="L1006"></span>
<span class="line" id="L1007">    <span class="tok-kw">const</span> symbols_buf = <span class="tok-kw">try</span> allocator.alloc(MachoSymbol, syms.len);</span>
<span class="line" id="L1008"></span>
<span class="line" id="L1009">    <span class="tok-kw">var</span> ofile: <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1010">    <span class="tok-kw">var</span> last_sym: MachoSymbol = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1011">    <span class="tok-kw">var</span> symbol_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1012">    <span class="tok-kw">var</span> state: <span class="tok-kw">enum</span> {</span>
<span class="line" id="L1013">        init,</span>
<span class="line" id="L1014">        oso_open,</span>
<span class="line" id="L1015">        oso_close,</span>
<span class="line" id="L1016">        bnsym,</span>
<span class="line" id="L1017">        fun_strx,</span>
<span class="line" id="L1018">        fun_size,</span>
<span class="line" id="L1019">        ensym,</span>
<span class="line" id="L1020">    } = .init;</span>
<span class="line" id="L1021"></span>
<span class="line" id="L1022">    <span class="tok-kw">for</span> (syms) |*sym| {</span>
<span class="line" id="L1023">        <span class="tok-kw">if</span> (!sym.stab()) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1024"></span>
<span class="line" id="L1025">        <span class="tok-comment">// TODO handle globals N_GSYM, and statics N_STSYM</span>
</span>
<span class="line" id="L1026">        <span class="tok-kw">switch</span> (sym.n_type) {</span>
<span class="line" id="L1027">            macho.N_OSO =&gt; {</span>
<span class="line" id="L1028">                <span class="tok-kw">switch</span> (state) {</span>
<span class="line" id="L1029">                    .init, .oso_close =&gt; {</span>
<span class="line" id="L1030">                        state = .oso_open;</span>
<span class="line" id="L1031">                        ofile = sym.n_strx;</span>
<span class="line" id="L1032">                    },</span>
<span class="line" id="L1033">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo,</span>
<span class="line" id="L1034">                }</span>
<span class="line" id="L1035">            },</span>
<span class="line" id="L1036">            macho.N_BNSYM =&gt; {</span>
<span class="line" id="L1037">                <span class="tok-kw">switch</span> (state) {</span>
<span class="line" id="L1038">                    .oso_open, .ensym =&gt; {</span>
<span class="line" id="L1039">                        state = .bnsym;</span>
<span class="line" id="L1040">                        last_sym = .{</span>
<span class="line" id="L1041">                            .strx = <span class="tok-number">0</span>,</span>
<span class="line" id="L1042">                            .addr = sym.n_value,</span>
<span class="line" id="L1043">                            .size = <span class="tok-number">0</span>,</span>
<span class="line" id="L1044">                            .ofile = ofile,</span>
<span class="line" id="L1045">                        };</span>
<span class="line" id="L1046">                    },</span>
<span class="line" id="L1047">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo,</span>
<span class="line" id="L1048">                }</span>
<span class="line" id="L1049">            },</span>
<span class="line" id="L1050">            macho.N_FUN =&gt; {</span>
<span class="line" id="L1051">                <span class="tok-kw">switch</span> (state) {</span>
<span class="line" id="L1052">                    .bnsym =&gt; {</span>
<span class="line" id="L1053">                        state = .fun_strx;</span>
<span class="line" id="L1054">                        last_sym.strx = sym.n_strx;</span>
<span class="line" id="L1055">                    },</span>
<span class="line" id="L1056">                    .fun_strx =&gt; {</span>
<span class="line" id="L1057">                        state = .fun_size;</span>
<span class="line" id="L1058">                        last_sym.size = <span class="tok-builtin">@intCast</span>(<span class="tok-type">u32</span>, sym.n_value);</span>
<span class="line" id="L1059">                    },</span>
<span class="line" id="L1060">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo,</span>
<span class="line" id="L1061">                }</span>
<span class="line" id="L1062">            },</span>
<span class="line" id="L1063">            macho.N_ENSYM =&gt; {</span>
<span class="line" id="L1064">                <span class="tok-kw">switch</span> (state) {</span>
<span class="line" id="L1065">                    .fun_size =&gt; {</span>
<span class="line" id="L1066">                        state = .ensym;</span>
<span class="line" id="L1067">                        symbols_buf[symbol_index] = last_sym;</span>
<span class="line" id="L1068">                        symbol_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L1069">                    },</span>
<span class="line" id="L1070">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo,</span>
<span class="line" id="L1071">                }</span>
<span class="line" id="L1072">            },</span>
<span class="line" id="L1073">            macho.N_SO =&gt; {</span>
<span class="line" id="L1074">                <span class="tok-kw">switch</span> (state) {</span>
<span class="line" id="L1075">                    .init, .oso_close =&gt; {},</span>
<span class="line" id="L1076">                    .oso_open, .ensym =&gt; {</span>
<span class="line" id="L1077">                        state = .oso_close;</span>
<span class="line" id="L1078">                    },</span>
<span class="line" id="L1079">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo,</span>
<span class="line" id="L1080">                }</span>
<span class="line" id="L1081">            },</span>
<span class="line" id="L1082">            <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L1083">        }</span>
<span class="line" id="L1084">    }</span>
<span class="line" id="L1085"></span>
<span class="line" id="L1086">    <span class="tok-kw">switch</span> (state) {</span>
<span class="line" id="L1087">        .init =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo,</span>
<span class="line" id="L1088">        .oso_close =&gt; {},</span>
<span class="line" id="L1089">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo,</span>
<span class="line" id="L1090">    }</span>
<span class="line" id="L1091"></span>
<span class="line" id="L1092">    <span class="tok-kw">const</span> symbols = <span class="tok-kw">try</span> allocator.realloc(symbols_buf, symbol_index);</span>
<span class="line" id="L1093"></span>
<span class="line" id="L1094">    <span class="tok-comment">// Even though lld emits symbols in ascending order, this debug code</span>
</span>
<span class="line" id="L1095">    <span class="tok-comment">// should work for programs linked in any valid way.</span>
</span>
<span class="line" id="L1096">    <span class="tok-comment">// This sort is so that we can binary search later.</span>
</span>
<span class="line" id="L1097">    mem.sort(MachoSymbol, symbols, {}, MachoSymbol.addressLessThan);</span>
<span class="line" id="L1098"></span>
<span class="line" id="L1099">    <span class="tok-kw">return</span> ModuleDebugInfo{</span>
<span class="line" id="L1100">        .base_address = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L1101">        .mapped_memory = mapped_mem,</span>
<span class="line" id="L1102">        .ofiles = ModuleDebugInfo.OFileTable.init(allocator),</span>
<span class="line" id="L1103">        .symbols = symbols,</span>
<span class="line" id="L1104">        .strings = strings,</span>
<span class="line" id="L1105">    };</span>
<span class="line" id="L1106">}</span>
<span class="line" id="L1107"></span>
<span class="line" id="L1108"><span class="tok-kw">fn</span> <span class="tok-fn">printLineFromFileAnyOs</span>(out_stream: <span class="tok-kw">anytype</span>, line_info: LineInfo) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1109">    <span class="tok-comment">// Need this to always block even in async I/O mode, because this could potentially</span>
</span>
<span class="line" id="L1110">    <span class="tok-comment">// be called from e.g. the event loop code crashing.</span>
</span>
<span class="line" id="L1111">    <span class="tok-kw">var</span> f = <span class="tok-kw">try</span> fs.cwd().openFile(line_info.file_name, .{ .intended_io_mode = .blocking });</span>
<span class="line" id="L1112">    <span class="tok-kw">defer</span> f.close();</span>
<span class="line" id="L1113">    <span class="tok-comment">// TODO fstat and make sure that the file has the correct size</span>
</span>
<span class="line" id="L1114"></span>
<span class="line" id="L1115">    <span class="tok-kw">var</span> buf: [mem.page_size]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1116">    <span class="tok-kw">var</span> line: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;</span>
<span class="line" id="L1117">    <span class="tok-kw">var</span> column: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;</span>
<span class="line" id="L1118">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L1119">        <span class="tok-kw">const</span> amt_read = <span class="tok-kw">try</span> f.read(buf[<span class="tok-number">0</span>..]);</span>
<span class="line" id="L1120">        <span class="tok-kw">const</span> slice = buf[<span class="tok-number">0</span>..amt_read];</span>
<span class="line" id="L1121"></span>
<span class="line" id="L1122">        <span class="tok-kw">for</span> (slice) |byte| {</span>
<span class="line" id="L1123">            <span class="tok-kw">if</span> (line == line_info.line) {</span>
<span class="line" id="L1124">                <span class="tok-kw">switch</span> (byte) {</span>
<span class="line" id="L1125">                    <span class="tok-str">'\t'</span> =&gt; <span class="tok-kw">try</span> out_stream.writeByte(<span class="tok-str">' '</span>),</span>
<span class="line" id="L1126">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">try</span> out_stream.writeByte(byte),</span>
<span class="line" id="L1127">                }</span>
<span class="line" id="L1128">                <span class="tok-kw">if</span> (byte == <span class="tok-str">'\n'</span>) {</span>
<span class="line" id="L1129">                    <span class="tok-kw">return</span>;</span>
<span class="line" id="L1130">                }</span>
<span class="line" id="L1131">            }</span>
<span class="line" id="L1132">            <span class="tok-kw">if</span> (byte == <span class="tok-str">'\n'</span>) {</span>
<span class="line" id="L1133">                line += <span class="tok-number">1</span>;</span>
<span class="line" id="L1134">                column = <span class="tok-number">1</span>;</span>
<span class="line" id="L1135">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1136">                column += <span class="tok-number">1</span>;</span>
<span class="line" id="L1137">            }</span>
<span class="line" id="L1138">        }</span>
<span class="line" id="L1139"></span>
<span class="line" id="L1140">        <span class="tok-kw">if</span> (amt_read &lt; buf.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EndOfFile;</span>
<span class="line" id="L1141">    }</span>
<span class="line" id="L1142">}</span>
<span class="line" id="L1143"></span>
<span class="line" id="L1144"><span class="tok-kw">const</span> MachoSymbol = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1145">    strx: <span class="tok-type">u32</span>,</span>
<span class="line" id="L1146">    addr: <span class="tok-type">u64</span>,</span>
<span class="line" id="L1147">    size: <span class="tok-type">u32</span>,</span>
<span class="line" id="L1148">    ofile: <span class="tok-type">u32</span>,</span>
<span class="line" id="L1149"></span>
<span class="line" id="L1150">    <span class="tok-comment">/// Returns the address from the macho file</span></span>
<span class="line" id="L1151">    <span class="tok-kw">fn</span> <span class="tok-fn">address</span>(self: MachoSymbol) <span class="tok-type">u64</span> {</span>
<span class="line" id="L1152">        <span class="tok-kw">return</span> self.addr;</span>
<span class="line" id="L1153">    }</span>
<span class="line" id="L1154"></span>
<span class="line" id="L1155">    <span class="tok-kw">fn</span> <span class="tok-fn">addressLessThan</span>(context: <span class="tok-type">void</span>, lhs: MachoSymbol, rhs: MachoSymbol) <span class="tok-type">bool</span> {</span>
<span class="line" id="L1156">        _ = context;</span>
<span class="line" id="L1157">        <span class="tok-kw">return</span> lhs.addr &lt; rhs.addr;</span>
<span class="line" id="L1158">    }</span>
<span class="line" id="L1159">};</span>
<span class="line" id="L1160"></span>
<span class="line" id="L1161"><span class="tok-comment">/// `file` is expected to have been opened with .intended_io_mode == .blocking.</span></span>
<span class="line" id="L1162"><span class="tok-comment">/// Takes ownership of file, even on error.</span></span>
<span class="line" id="L1163"><span class="tok-comment">/// TODO it's weird to take ownership even on error, rework this code.</span></span>
<span class="line" id="L1164"><span class="tok-kw">fn</span> <span class="tok-fn">mapWholeFile</span>(file: File) ![]<span class="tok-kw">align</span>(mem.page_size) <span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1165">    <span class="tok-kw">nosuspend</span> {</span>
<span class="line" id="L1166">        <span class="tok-kw">defer</span> file.close();</span>
<span class="line" id="L1167"></span>
<span class="line" id="L1168">        <span class="tok-kw">const</span> file_len = math.cast(<span class="tok-type">usize</span>, <span class="tok-kw">try</span> file.getEndPos()) <span class="tok-kw">orelse</span> math.maxInt(<span class="tok-type">usize</span>);</span>
<span class="line" id="L1169">        <span class="tok-kw">const</span> mapped_mem = <span class="tok-kw">try</span> os.mmap(</span>
<span class="line" id="L1170">            <span class="tok-null">null</span>,</span>
<span class="line" id="L1171">            file_len,</span>
<span class="line" id="L1172">            os.PROT.READ,</span>
<span class="line" id="L1173">            os.MAP.SHARED,</span>
<span class="line" id="L1174">            file.handle,</span>
<span class="line" id="L1175">            <span class="tok-number">0</span>,</span>
<span class="line" id="L1176">        );</span>
<span class="line" id="L1177">        <span class="tok-kw">errdefer</span> os.munmap(mapped_mem);</span>
<span class="line" id="L1178"></span>
<span class="line" id="L1179">        <span class="tok-kw">return</span> mapped_mem;</span>
<span class="line" id="L1180">    }</span>
<span class="line" id="L1181">}</span>
<span class="line" id="L1182"></span>
<span class="line" id="L1183"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> WindowsModuleInfo = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1184">    base_address: <span class="tok-type">usize</span>,</span>
<span class="line" id="L1185">    size: <span class="tok-type">u32</span>,</span>
<span class="line" id="L1186">    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1187">};</span>
<span class="line" id="L1188"></span>
<span class="line" id="L1189"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DebugInfo = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1190">    allocator: mem.Allocator,</span>
<span class="line" id="L1191">    address_map: std.AutoHashMap(<span class="tok-type">usize</span>, *ModuleDebugInfo),</span>
<span class="line" id="L1192">    modules: <span class="tok-kw">if</span> (native_os == .windows) std.ArrayListUnmanaged(WindowsModuleInfo) <span class="tok-kw">else</span> <span class="tok-type">void</span>,</span>
<span class="line" id="L1193"></span>
<span class="line" id="L1194">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: mem.Allocator) !DebugInfo {</span>
<span class="line" id="L1195">        <span class="tok-kw">var</span> debug_info = DebugInfo{</span>
<span class="line" id="L1196">            .allocator = allocator,</span>
<span class="line" id="L1197">            .address_map = std.AutoHashMap(<span class="tok-type">usize</span>, *ModuleDebugInfo).init(allocator),</span>
<span class="line" id="L1198">            .modules = <span class="tok-kw">if</span> (native_os == .windows) .{} <span class="tok-kw">else</span> {},</span>
<span class="line" id="L1199">        };</span>
<span class="line" id="L1200"></span>
<span class="line" id="L1201">        <span class="tok-kw">if</span> (native_os == .windows) {</span>
<span class="line" id="L1202">            <span class="tok-kw">const</span> handle = windows.kernel32.CreateToolhelp32Snapshot(windows.TH32CS_SNAPMODULE | windows.TH32CS_SNAPMODULE32, <span class="tok-number">0</span>);</span>
<span class="line" id="L1203">            <span class="tok-kw">if</span> (handle == windows.INVALID_HANDLE_VALUE) {</span>
<span class="line" id="L1204">                <span class="tok-kw">switch</span> (windows.kernel32.GetLastError()) {</span>
<span class="line" id="L1205">                    <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> windows.unexpectedError(err),</span>
<span class="line" id="L1206">                }</span>
<span class="line" id="L1207">            }</span>
<span class="line" id="L1208">            <span class="tok-kw">defer</span> windows.CloseHandle(handle);</span>
<span class="line" id="L1209"></span>
<span class="line" id="L1210">            <span class="tok-kw">var</span> module_entry: windows.MODULEENTRY32 = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1211">            module_entry.dwSize = <span class="tok-builtin">@sizeOf</span>(windows.MODULEENTRY32);</span>
<span class="line" id="L1212">            <span class="tok-kw">if</span> (windows.kernel32.Module32First(handle, &amp;module_entry) == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1213">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1214">            }</span>
<span class="line" id="L1215"></span>
<span class="line" id="L1216">            <span class="tok-kw">var</span> module_valid = <span class="tok-null">true</span>;</span>
<span class="line" id="L1217">            <span class="tok-kw">while</span> (module_valid) {</span>
<span class="line" id="L1218">                <span class="tok-kw">const</span> module_info = <span class="tok-kw">try</span> debug_info.modules.addOne(allocator);</span>
<span class="line" id="L1219">                module_info.base_address = <span class="tok-builtin">@intFromPtr</span>(module_entry.modBaseAddr);</span>
<span class="line" id="L1220">                module_info.size = module_entry.modBaseSize;</span>
<span class="line" id="L1221">                module_info.name = allocator.dupe(<span class="tok-type">u8</span>, mem.sliceTo(&amp;module_entry.szModule, <span class="tok-number">0</span>)) <span class="tok-kw">catch</span> &amp;.{};</span>
<span class="line" id="L1222">                module_valid = windows.kernel32.Module32Next(handle, &amp;module_entry) == <span class="tok-number">1</span>;</span>
<span class="line" id="L1223">            }</span>
<span class="line" id="L1224">        }</span>
<span class="line" id="L1225"></span>
<span class="line" id="L1226">        <span class="tok-kw">return</span> debug_info;</span>
<span class="line" id="L1227">    }</span>
<span class="line" id="L1228"></span>
<span class="line" id="L1229">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *DebugInfo) <span class="tok-type">void</span> {</span>
<span class="line" id="L1230">        <span class="tok-kw">var</span> it = self.address_map.iterator();</span>
<span class="line" id="L1231">        <span class="tok-kw">while</span> (it.next()) |entry| {</span>
<span class="line" id="L1232">            <span class="tok-kw">const</span> mdi = entry.value_ptr.*;</span>
<span class="line" id="L1233">            mdi.deinit(self.allocator);</span>
<span class="line" id="L1234">            self.allocator.destroy(mdi);</span>
<span class="line" id="L1235">        }</span>
<span class="line" id="L1236">        self.address_map.deinit();</span>
<span class="line" id="L1237">        <span class="tok-kw">if</span> (native_os == .windows) {</span>
<span class="line" id="L1238">            <span class="tok-kw">for</span> (self.modules.items) |module| {</span>
<span class="line" id="L1239">                self.allocator.free(module.name);</span>
<span class="line" id="L1240">            }</span>
<span class="line" id="L1241">            self.modules.deinit(self.allocator);</span>
<span class="line" id="L1242">        }</span>
<span class="line" id="L1243">    }</span>
<span class="line" id="L1244"></span>
<span class="line" id="L1245">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getModuleForAddress</span>(self: *DebugInfo, address: <span class="tok-type">usize</span>) !*ModuleDebugInfo {</span>
<span class="line" id="L1246">        <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> builtin.target.isDarwin()) {</span>
<span class="line" id="L1247">            <span class="tok-kw">return</span> self.lookupModuleDyld(address);</span>
<span class="line" id="L1248">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (native_os == .windows) {</span>
<span class="line" id="L1249">            <span class="tok-kw">return</span> self.lookupModuleWin32(address);</span>
<span class="line" id="L1250">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (native_os == .haiku) {</span>
<span class="line" id="L1251">            <span class="tok-kw">return</span> self.lookupModuleHaiku(address);</span>
<span class="line" id="L1252">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> builtin.target.isWasm()) {</span>
<span class="line" id="L1253">            <span class="tok-kw">return</span> self.lookupModuleWasm(address);</span>
<span class="line" id="L1254">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1255">            <span class="tok-kw">return</span> self.lookupModuleDl(address);</span>
<span class="line" id="L1256">        }</span>
<span class="line" id="L1257">    }</span>
<span class="line" id="L1258"></span>
<span class="line" id="L1259">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getModuleNameForAddress</span>(self: *DebugInfo, address: <span class="tok-type">usize</span>) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1260">        <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> builtin.target.isDarwin()) {</span>
<span class="line" id="L1261">            <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1262">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (native_os == .windows) {</span>
<span class="line" id="L1263">            <span class="tok-kw">return</span> self.lookupModuleNameWin32(address);</span>
<span class="line" id="L1264">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (native_os == .haiku) {</span>
<span class="line" id="L1265">            <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1266">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> builtin.target.isWasm()) {</span>
<span class="line" id="L1267">            <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1268">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1269">            <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1270">        }</span>
<span class="line" id="L1271">    }</span>
<span class="line" id="L1272"></span>
<span class="line" id="L1273">    <span class="tok-kw">fn</span> <span class="tok-fn">lookupModuleDyld</span>(self: *DebugInfo, address: <span class="tok-type">usize</span>) !*ModuleDebugInfo {</span>
<span class="line" id="L1274">        <span class="tok-kw">const</span> image_count = std.c._dyld_image_count();</span>
<span class="line" id="L1275"></span>
<span class="line" id="L1276">        <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1277">        <span class="tok-kw">while</span> (i &lt; image_count) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L1278">            <span class="tok-kw">const</span> base_address = std.c._dyld_get_image_vmaddr_slide(i);</span>
<span class="line" id="L1279"></span>
<span class="line" id="L1280">            <span class="tok-kw">if</span> (address &lt; base_address) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1281"></span>
<span class="line" id="L1282">            <span class="tok-kw">const</span> header = std.c._dyld_get_image_header(i) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1283"></span>
<span class="line" id="L1284">            <span class="tok-kw">var</span> it = macho.LoadCommandIterator{</span>
<span class="line" id="L1285">                .ncmds = header.ncmds,</span>
<span class="line" id="L1286">                .buffer = <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@alignOf</span>(<span class="tok-type">u64</span>), <span class="tok-builtin">@ptrFromInt</span>(</span>
<span class="line" id="L1287">                    [*]<span class="tok-type">u8</span>,</span>
<span class="line" id="L1288">                    <span class="tok-builtin">@intFromPtr</span>(header) + <span class="tok-builtin">@sizeOf</span>(macho.mach_header_64),</span>
<span class="line" id="L1289">                ))[<span class="tok-number">0</span>..header.sizeofcmds],</span>
<span class="line" id="L1290">            };</span>
<span class="line" id="L1291">            <span class="tok-kw">while</span> (it.next()) |cmd| <span class="tok-kw">switch</span> (cmd.cmd()) {</span>
<span class="line" id="L1292">                .SEGMENT_64 =&gt; {</span>
<span class="line" id="L1293">                    <span class="tok-kw">const</span> segment_cmd = cmd.cast(macho.segment_command_64).?;</span>
<span class="line" id="L1294">                    <span class="tok-kw">const</span> rebased_address = address - base_address;</span>
<span class="line" id="L1295">                    <span class="tok-kw">const</span> seg_start = segment_cmd.vmaddr;</span>
<span class="line" id="L1296">                    <span class="tok-kw">const</span> seg_end = seg_start + segment_cmd.vmsize;</span>
<span class="line" id="L1297"></span>
<span class="line" id="L1298">                    <span class="tok-kw">if</span> (rebased_address &gt;= seg_start <span class="tok-kw">and</span> rebased_address &lt; seg_end) {</span>
<span class="line" id="L1299">                        <span class="tok-kw">if</span> (self.address_map.get(base_address)) |obj_di| {</span>
<span class="line" id="L1300">                            <span class="tok-kw">return</span> obj_di;</span>
<span class="line" id="L1301">                        }</span>
<span class="line" id="L1302"></span>
<span class="line" id="L1303">                        <span class="tok-kw">const</span> obj_di = <span class="tok-kw">try</span> self.allocator.create(ModuleDebugInfo);</span>
<span class="line" id="L1304">                        <span class="tok-kw">errdefer</span> self.allocator.destroy(obj_di);</span>
<span class="line" id="L1305"></span>
<span class="line" id="L1306">                        <span class="tok-kw">const</span> macho_path = mem.sliceTo(std.c._dyld_get_image_name(i), <span class="tok-number">0</span>);</span>
<span class="line" id="L1307">                        <span class="tok-kw">const</span> macho_file = fs.cwd().openFile(macho_path, .{</span>
<span class="line" id="L1308">                            .intended_io_mode = .blocking,</span>
<span class="line" id="L1309">                        }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1310">                            <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo,</span>
<span class="line" id="L1311">                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L1312">                        };</span>
<span class="line" id="L1313">                        obj_di.* = <span class="tok-kw">try</span> readMachODebugInfo(self.allocator, macho_file);</span>
<span class="line" id="L1314">                        obj_di.base_address = base_address;</span>
<span class="line" id="L1315"></span>
<span class="line" id="L1316">                        <span class="tok-kw">try</span> self.address_map.putNoClobber(base_address, obj_di);</span>
<span class="line" id="L1317"></span>
<span class="line" id="L1318">                        <span class="tok-kw">return</span> obj_di;</span>
<span class="line" id="L1319">                    }</span>
<span class="line" id="L1320">                },</span>
<span class="line" id="L1321">                <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L1322">            };</span>
<span class="line" id="L1323">        }</span>
<span class="line" id="L1324"></span>
<span class="line" id="L1325">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1326">    }</span>
<span class="line" id="L1327"></span>
<span class="line" id="L1328">    <span class="tok-kw">fn</span> <span class="tok-fn">lookupModuleWin32</span>(self: *DebugInfo, address: <span class="tok-type">usize</span>) !*ModuleDebugInfo {</span>
<span class="line" id="L1329">        <span class="tok-kw">for</span> (self.modules.items) |module| {</span>
<span class="line" id="L1330">            <span class="tok-kw">if</span> (address &gt;= module.base_address <span class="tok-kw">and</span> address &lt; module.base_address + module.size) {</span>
<span class="line" id="L1331">                <span class="tok-kw">if</span> (self.address_map.get(module.base_address)) |obj_di| {</span>
<span class="line" id="L1332">                    <span class="tok-kw">return</span> obj_di;</span>
<span class="line" id="L1333">                }</span>
<span class="line" id="L1334"></span>
<span class="line" id="L1335">                <span class="tok-kw">const</span> mapped_module = <span class="tok-builtin">@ptrFromInt</span>([*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, module.base_address)[<span class="tok-number">0</span>..module.size];</span>
<span class="line" id="L1336">                <span class="tok-kw">const</span> obj_di = <span class="tok-kw">try</span> self.allocator.create(ModuleDebugInfo);</span>
<span class="line" id="L1337">                <span class="tok-kw">errdefer</span> self.allocator.destroy(obj_di);</span>
<span class="line" id="L1338"></span>
<span class="line" id="L1339">                obj_di.* = <span class="tok-kw">try</span> readCoffDebugInfo(self.allocator, mapped_module);</span>
<span class="line" id="L1340">                obj_di.base_address = module.base_address;</span>
<span class="line" id="L1341"></span>
<span class="line" id="L1342">                <span class="tok-kw">try</span> self.address_map.putNoClobber(module.base_address, obj_di);</span>
<span class="line" id="L1343">                <span class="tok-kw">return</span> obj_di;</span>
<span class="line" id="L1344">            }</span>
<span class="line" id="L1345">        }</span>
<span class="line" id="L1346"></span>
<span class="line" id="L1347">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1348">    }</span>
<span class="line" id="L1349"></span>
<span class="line" id="L1350">    <span class="tok-kw">fn</span> <span class="tok-fn">lookupModuleNameWin32</span>(self: *DebugInfo, address: <span class="tok-type">usize</span>) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1351">        <span class="tok-kw">for</span> (self.modules.items) |module| {</span>
<span class="line" id="L1352">            <span class="tok-kw">if</span> (address &gt;= module.base_address <span class="tok-kw">and</span> address &lt; module.base_address + module.size) {</span>
<span class="line" id="L1353">                <span class="tok-kw">return</span> module.name;</span>
<span class="line" id="L1354">            }</span>
<span class="line" id="L1355">        }</span>
<span class="line" id="L1356">        <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1357">    }</span>
<span class="line" id="L1358"></span>
<span class="line" id="L1359">    <span class="tok-kw">fn</span> <span class="tok-fn">lookupModuleDl</span>(self: *DebugInfo, address: <span class="tok-type">usize</span>) !*ModuleDebugInfo {</span>
<span class="line" id="L1360">        <span class="tok-kw">var</span> ctx: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1361">            <span class="tok-comment">// Input</span>
</span>
<span class="line" id="L1362">            address: <span class="tok-type">usize</span>,</span>
<span class="line" id="L1363">            <span class="tok-comment">// Output</span>
</span>
<span class="line" id="L1364">            base_address: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L1365">            name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L1366">        } = .{ .address = address };</span>
<span class="line" id="L1367">        <span class="tok-kw">const</span> CtxTy = <span class="tok-builtin">@TypeOf</span>(ctx);</span>
<span class="line" id="L1368"></span>
<span class="line" id="L1369">        <span class="tok-kw">if</span> (os.dl_iterate_phdr(&amp;ctx, <span class="tok-kw">error</span>{Found}, <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1370">            <span class="tok-kw">fn</span> <span class="tok-fn">callback</span>(info: *os.dl_phdr_info, size: <span class="tok-type">usize</span>, context: *CtxTy) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1371">                _ = size;</span>
<span class="line" id="L1372">                <span class="tok-comment">// The base address is too high</span>
</span>
<span class="line" id="L1373">                <span class="tok-kw">if</span> (context.address &lt; info.dlpi_addr)</span>
<span class="line" id="L1374">                    <span class="tok-kw">return</span>;</span>
<span class="line" id="L1375"></span>
<span class="line" id="L1376">                <span class="tok-kw">const</span> phdrs = info.dlpi_phdr[<span class="tok-number">0</span>..info.dlpi_phnum];</span>
<span class="line" id="L1377">                <span class="tok-kw">for</span> (phdrs) |*phdr| {</span>
<span class="line" id="L1378">                    <span class="tok-kw">if</span> (phdr.p_type != elf.PT_LOAD) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1379"></span>
<span class="line" id="L1380">                    <span class="tok-kw">const</span> seg_start = info.dlpi_addr + phdr.p_vaddr;</span>
<span class="line" id="L1381">                    <span class="tok-kw">const</span> seg_end = seg_start + phdr.p_memsz;</span>
<span class="line" id="L1382"></span>
<span class="line" id="L1383">                    <span class="tok-kw">if</span> (context.address &gt;= seg_start <span class="tok-kw">and</span> context.address &lt; seg_end) {</span>
<span class="line" id="L1384">                        <span class="tok-comment">// Android libc uses NULL instead of an empty string to mark the</span>
</span>
<span class="line" id="L1385">                        <span class="tok-comment">// main program</span>
</span>
<span class="line" id="L1386">                        context.name = mem.sliceTo(info.dlpi_name, <span class="tok-number">0</span>) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;&quot;</span>;</span>
<span class="line" id="L1387">                        context.base_address = info.dlpi_addr;</span>
<span class="line" id="L1388">                        <span class="tok-comment">// Stop the iteration</span>
</span>
<span class="line" id="L1389">                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Found;</span>
<span class="line" id="L1390">                    }</span>
<span class="line" id="L1391">                }</span>
<span class="line" id="L1392">            }</span>
<span class="line" id="L1393">        }.callback)) {</span>
<span class="line" id="L1394">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1395">        } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1396">            <span class="tok-kw">error</span>.Found =&gt; {},</span>
<span class="line" id="L1397">        }</span>
<span class="line" id="L1398"></span>
<span class="line" id="L1399">        <span class="tok-kw">if</span> (self.address_map.get(ctx.base_address)) |obj_di| {</span>
<span class="line" id="L1400">            <span class="tok-kw">return</span> obj_di;</span>
<span class="line" id="L1401">        }</span>
<span class="line" id="L1402"></span>
<span class="line" id="L1403">        <span class="tok-kw">const</span> obj_di = <span class="tok-kw">try</span> self.allocator.create(ModuleDebugInfo);</span>
<span class="line" id="L1404">        <span class="tok-kw">errdefer</span> self.allocator.destroy(obj_di);</span>
<span class="line" id="L1405"></span>
<span class="line" id="L1406">        <span class="tok-comment">// TODO https://github.com/ziglang/zig/issues/5525</span>
</span>
<span class="line" id="L1407">        <span class="tok-kw">const</span> copy = <span class="tok-kw">if</span> (ctx.name.len &gt; <span class="tok-number">0</span>)</span>
<span class="line" id="L1408">            fs.cwd().openFile(ctx.name, .{ .intended_io_mode = .blocking })</span>
<span class="line" id="L1409">        <span class="tok-kw">else</span></span>
<span class="line" id="L1410">            fs.openSelfExe(.{ .intended_io_mode = .blocking });</span>
<span class="line" id="L1411"></span>
<span class="line" id="L1412">        <span class="tok-kw">const</span> elf_file = copy <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1413">            <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo,</span>
<span class="line" id="L1414">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L1415">        };</span>
<span class="line" id="L1416"></span>
<span class="line" id="L1417">        obj_di.* = <span class="tok-kw">try</span> readElfDebugInfo(self.allocator, elf_file);</span>
<span class="line" id="L1418">        obj_di.base_address = ctx.base_address;</span>
<span class="line" id="L1419"></span>
<span class="line" id="L1420">        <span class="tok-kw">try</span> self.address_map.putNoClobber(ctx.base_address, obj_di);</span>
<span class="line" id="L1421"></span>
<span class="line" id="L1422">        <span class="tok-kw">return</span> obj_di;</span>
<span class="line" id="L1423">    }</span>
<span class="line" id="L1424"></span>
<span class="line" id="L1425">    <span class="tok-kw">fn</span> <span class="tok-fn">lookupModuleHaiku</span>(self: *DebugInfo, address: <span class="tok-type">usize</span>) !*ModuleDebugInfo {</span>
<span class="line" id="L1426">        _ = self;</span>
<span class="line" id="L1427">        _ = address;</span>
<span class="line" id="L1428">        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;TODO implement lookup module for Haiku&quot;</span>);</span>
<span class="line" id="L1429">    }</span>
<span class="line" id="L1430"></span>
<span class="line" id="L1431">    <span class="tok-kw">fn</span> <span class="tok-fn">lookupModuleWasm</span>(self: *DebugInfo, address: <span class="tok-type">usize</span>) !*ModuleDebugInfo {</span>
<span class="line" id="L1432">        _ = self;</span>
<span class="line" id="L1433">        _ = address;</span>
<span class="line" id="L1434">        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;TODO implement lookup module for Wasm&quot;</span>);</span>
<span class="line" id="L1435">    }</span>
<span class="line" id="L1436">};</span>
<span class="line" id="L1437"></span>
<span class="line" id="L1438"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ModuleDebugInfo = <span class="tok-kw">switch</span> (native_os) {</span>
<span class="line" id="L1439">    .macos, .ios, .watchos, .tvos =&gt; <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1440">        base_address: <span class="tok-type">usize</span>,</span>
<span class="line" id="L1441">        mapped_memory: []<span class="tok-kw">align</span>(mem.page_size) <span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1442">        symbols: []<span class="tok-kw">const</span> MachoSymbol,</span>
<span class="line" id="L1443">        strings: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1444">        ofiles: OFileTable,</span>
<span class="line" id="L1445"></span>
<span class="line" id="L1446">        <span class="tok-kw">const</span> OFileTable = std.StringHashMap(OFileInfo);</span>
<span class="line" id="L1447">        <span class="tok-kw">const</span> OFileInfo = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1448">            di: DW.DwarfInfo,</span>
<span class="line" id="L1449">            addr_table: std.StringHashMap(<span class="tok-type">u64</span>),</span>
<span class="line" id="L1450">        };</span>
<span class="line" id="L1451"></span>
<span class="line" id="L1452">        <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L1453">            <span class="tok-kw">var</span> it = self.ofiles.iterator();</span>
<span class="line" id="L1454">            <span class="tok-kw">while</span> (it.next()) |entry| {</span>
<span class="line" id="L1455">                <span class="tok-kw">const</span> ofile = entry.value_ptr;</span>
<span class="line" id="L1456">                ofile.di.deinit(allocator);</span>
<span class="line" id="L1457">                ofile.addr_table.deinit();</span>
<span class="line" id="L1458">            }</span>
<span class="line" id="L1459">            self.ofiles.deinit();</span>
<span class="line" id="L1460">            allocator.free(self.symbols);</span>
<span class="line" id="L1461">            os.munmap(self.mapped_memory);</span>
<span class="line" id="L1462">        }</span>
<span class="line" id="L1463"></span>
<span class="line" id="L1464">        <span class="tok-kw">fn</span> <span class="tok-fn">loadOFile</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator, o_file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !OFileInfo {</span>
<span class="line" id="L1465">            <span class="tok-kw">const</span> o_file = <span class="tok-kw">try</span> fs.cwd().openFile(o_file_path, .{ .intended_io_mode = .blocking });</span>
<span class="line" id="L1466">            <span class="tok-kw">const</span> mapped_mem = <span class="tok-kw">try</span> mapWholeFile(o_file);</span>
<span class="line" id="L1467"></span>
<span class="line" id="L1468">            <span class="tok-kw">const</span> hdr = <span class="tok-builtin">@ptrCast</span>(</span>
<span class="line" id="L1469">                *<span class="tok-kw">const</span> macho.mach_header_64,</span>
<span class="line" id="L1470">                <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@alignOf</span>(macho.mach_header_64), mapped_mem.ptr),</span>
<span class="line" id="L1471">            );</span>
<span class="line" id="L1472">            <span class="tok-kw">if</span> (hdr.magic != std.macho.MH_MAGIC_64)</span>
<span class="line" id="L1473">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo;</span>
<span class="line" id="L1474"></span>
<span class="line" id="L1475">            <span class="tok-kw">var</span> segcmd: ?macho.LoadCommandIterator.LoadCommand = <span class="tok-null">null</span>;</span>
<span class="line" id="L1476">            <span class="tok-kw">var</span> symtabcmd: ?macho.symtab_command = <span class="tok-null">null</span>;</span>
<span class="line" id="L1477">            <span class="tok-kw">var</span> it = macho.LoadCommandIterator{</span>
<span class="line" id="L1478">                .ncmds = hdr.ncmds,</span>
<span class="line" id="L1479">                .buffer = mapped_mem[<span class="tok-builtin">@sizeOf</span>(macho.mach_header_64)..][<span class="tok-number">0</span>..hdr.sizeofcmds],</span>
<span class="line" id="L1480">            };</span>
<span class="line" id="L1481">            <span class="tok-kw">while</span> (it.next()) |cmd| <span class="tok-kw">switch</span> (cmd.cmd()) {</span>
<span class="line" id="L1482">                .SEGMENT_64 =&gt; segcmd = cmd,</span>
<span class="line" id="L1483">                .SYMTAB =&gt; symtabcmd = cmd.cast(macho.symtab_command).?,</span>
<span class="line" id="L1484">                <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L1485">            };</span>
<span class="line" id="L1486"></span>
<span class="line" id="L1487">            <span class="tok-kw">if</span> (segcmd == <span class="tok-null">null</span> <span class="tok-kw">or</span> symtabcmd == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1488"></span>
<span class="line" id="L1489">            <span class="tok-comment">// Parse symbols</span>
</span>
<span class="line" id="L1490">            <span class="tok-kw">const</span> strtab = <span class="tok-builtin">@ptrCast</span>(</span>
<span class="line" id="L1491">                [*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1492">                &amp;mapped_mem[symtabcmd.?.stroff],</span>
<span class="line" id="L1493">            )[<span class="tok-number">0</span> .. symtabcmd.?.strsize - <span class="tok-number">1</span> :<span class="tok-number">0</span>];</span>
<span class="line" id="L1494">            <span class="tok-kw">const</span> symtab = <span class="tok-builtin">@ptrCast</span>(</span>
<span class="line" id="L1495">                [*]<span class="tok-kw">const</span> macho.nlist_64,</span>
<span class="line" id="L1496">                <span class="tok-builtin">@alignCast</span>(</span>
<span class="line" id="L1497">                    <span class="tok-builtin">@alignOf</span>(macho.nlist_64),</span>
<span class="line" id="L1498">                    &amp;mapped_mem[symtabcmd.?.symoff],</span>
<span class="line" id="L1499">                ),</span>
<span class="line" id="L1500">            )[<span class="tok-number">0</span>..symtabcmd.?.nsyms];</span>
<span class="line" id="L1501"></span>
<span class="line" id="L1502">            <span class="tok-comment">// TODO handle tentative (common) symbols</span>
</span>
<span class="line" id="L1503">            <span class="tok-kw">var</span> addr_table = std.StringHashMap(<span class="tok-type">u64</span>).init(allocator);</span>
<span class="line" id="L1504">            <span class="tok-kw">try</span> addr_table.ensureTotalCapacity(<span class="tok-builtin">@intCast</span>(<span class="tok-type">u32</span>, symtab.len));</span>
<span class="line" id="L1505">            <span class="tok-kw">for</span> (symtab) |sym| {</span>
<span class="line" id="L1506">                <span class="tok-kw">if</span> (sym.n_strx == <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1507">                <span class="tok-kw">if</span> (sym.undf() <span class="tok-kw">or</span> sym.tentative() <span class="tok-kw">or</span> sym.abs()) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1508">                <span class="tok-kw">const</span> sym_name = mem.sliceTo(strtab[sym.n_strx..], <span class="tok-number">0</span>);</span>
<span class="line" id="L1509">                <span class="tok-comment">// TODO is it possible to have a symbol collision?</span>
</span>
<span class="line" id="L1510">                addr_table.putAssumeCapacityNoClobber(sym_name, sym.n_value);</span>
<span class="line" id="L1511">            }</span>
<span class="line" id="L1512"></span>
<span class="line" id="L1513">            <span class="tok-kw">var</span> opt_debug_line: ?macho.section_64 = <span class="tok-null">null</span>;</span>
<span class="line" id="L1514">            <span class="tok-kw">var</span> opt_debug_info: ?macho.section_64 = <span class="tok-null">null</span>;</span>
<span class="line" id="L1515">            <span class="tok-kw">var</span> opt_debug_abbrev: ?macho.section_64 = <span class="tok-null">null</span>;</span>
<span class="line" id="L1516">            <span class="tok-kw">var</span> opt_debug_str: ?macho.section_64 = <span class="tok-null">null</span>;</span>
<span class="line" id="L1517">            <span class="tok-kw">var</span> opt_debug_str_offsets: ?macho.section_64 = <span class="tok-null">null</span>;</span>
<span class="line" id="L1518">            <span class="tok-kw">var</span> opt_debug_line_str: ?macho.section_64 = <span class="tok-null">null</span>;</span>
<span class="line" id="L1519">            <span class="tok-kw">var</span> opt_debug_ranges: ?macho.section_64 = <span class="tok-null">null</span>;</span>
<span class="line" id="L1520">            <span class="tok-kw">var</span> opt_debug_loclists: ?macho.section_64 = <span class="tok-null">null</span>;</span>
<span class="line" id="L1521">            <span class="tok-kw">var</span> opt_debug_rnglists: ?macho.section_64 = <span class="tok-null">null</span>;</span>
<span class="line" id="L1522">            <span class="tok-kw">var</span> opt_debug_addr: ?macho.section_64 = <span class="tok-null">null</span>;</span>
<span class="line" id="L1523">            <span class="tok-kw">var</span> opt_debug_names: ?macho.section_64 = <span class="tok-null">null</span>;</span>
<span class="line" id="L1524">            <span class="tok-kw">var</span> opt_debug_frame: ?macho.section_64 = <span class="tok-null">null</span>;</span>
<span class="line" id="L1525"></span>
<span class="line" id="L1526">            <span class="tok-kw">for</span> (segcmd.?.getSections()) |sect| {</span>
<span class="line" id="L1527">                <span class="tok-kw">const</span> name = sect.sectName();</span>
<span class="line" id="L1528">                <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;__debug_line&quot;</span>)) {</span>
<span class="line" id="L1529">                    opt_debug_line = sect;</span>
<span class="line" id="L1530">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;__debug_info&quot;</span>)) {</span>
<span class="line" id="L1531">                    opt_debug_info = sect;</span>
<span class="line" id="L1532">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;__debug_abbrev&quot;</span>)) {</span>
<span class="line" id="L1533">                    opt_debug_abbrev = sect;</span>
<span class="line" id="L1534">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;__debug_str&quot;</span>)) {</span>
<span class="line" id="L1535">                    opt_debug_str = sect;</span>
<span class="line" id="L1536">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;__debug_str_offsets&quot;</span>)) {</span>
<span class="line" id="L1537">                    opt_debug_str_offsets = sect;</span>
<span class="line" id="L1538">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;__debug_line_str&quot;</span>)) {</span>
<span class="line" id="L1539">                    opt_debug_line_str = sect;</span>
<span class="line" id="L1540">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;__debug_ranges&quot;</span>)) {</span>
<span class="line" id="L1541">                    opt_debug_ranges = sect;</span>
<span class="line" id="L1542">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;__debug_loclists&quot;</span>)) {</span>
<span class="line" id="L1543">                    opt_debug_loclists = sect;</span>
<span class="line" id="L1544">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;__debug_rnglists&quot;</span>)) {</span>
<span class="line" id="L1545">                    opt_debug_rnglists = sect;</span>
<span class="line" id="L1546">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;__debug_addr&quot;</span>)) {</span>
<span class="line" id="L1547">                    opt_debug_addr = sect;</span>
<span class="line" id="L1548">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;__debug_names&quot;</span>)) {</span>
<span class="line" id="L1549">                    opt_debug_names = sect;</span>
<span class="line" id="L1550">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;__debug_frame&quot;</span>)) {</span>
<span class="line" id="L1551">                    opt_debug_frame = sect;</span>
<span class="line" id="L1552">                }</span>
<span class="line" id="L1553">            }</span>
<span class="line" id="L1554"></span>
<span class="line" id="L1555">            <span class="tok-kw">const</span> debug_line = opt_debug_line <span class="tok-kw">orelse</span></span>
<span class="line" id="L1556">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1557">            <span class="tok-kw">const</span> debug_info = opt_debug_info <span class="tok-kw">orelse</span></span>
<span class="line" id="L1558">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1559">            <span class="tok-kw">const</span> debug_str = opt_debug_str <span class="tok-kw">orelse</span></span>
<span class="line" id="L1560">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1561">            <span class="tok-kw">const</span> debug_abbrev = opt_debug_abbrev <span class="tok-kw">orelse</span></span>
<span class="line" id="L1562">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1563"></span>
<span class="line" id="L1564">            <span class="tok-kw">var</span> di = DW.DwarfInfo{</span>
<span class="line" id="L1565">                .endian = .Little,</span>
<span class="line" id="L1566">                .debug_info = <span class="tok-kw">try</span> chopSlice(mapped_mem, debug_info.offset, debug_info.size),</span>
<span class="line" id="L1567">                .debug_abbrev = <span class="tok-kw">try</span> chopSlice(mapped_mem, debug_abbrev.offset, debug_abbrev.size),</span>
<span class="line" id="L1568">                .debug_str = <span class="tok-kw">try</span> chopSlice(mapped_mem, debug_str.offset, debug_str.size),</span>
<span class="line" id="L1569">                .debug_str_offsets = <span class="tok-kw">if</span> (opt_debug_str_offsets) |debug_str_offsets|</span>
<span class="line" id="L1570">                    <span class="tok-kw">try</span> chopSlice(mapped_mem, debug_str_offsets.offset, debug_str_offsets.size)</span>
<span class="line" id="L1571">                <span class="tok-kw">else</span></span>
<span class="line" id="L1572">                    <span class="tok-null">null</span>,</span>
<span class="line" id="L1573">                .debug_line = <span class="tok-kw">try</span> chopSlice(mapped_mem, debug_line.offset, debug_line.size),</span>
<span class="line" id="L1574">                .debug_line_str = <span class="tok-kw">if</span> (opt_debug_line_str) |debug_line_str|</span>
<span class="line" id="L1575">                    <span class="tok-kw">try</span> chopSlice(mapped_mem, debug_line_str.offset, debug_line_str.size)</span>
<span class="line" id="L1576">                <span class="tok-kw">else</span></span>
<span class="line" id="L1577">                    <span class="tok-null">null</span>,</span>
<span class="line" id="L1578">                .debug_ranges = <span class="tok-kw">if</span> (opt_debug_ranges) |debug_ranges|</span>
<span class="line" id="L1579">                    <span class="tok-kw">try</span> chopSlice(mapped_mem, debug_ranges.offset, debug_ranges.size)</span>
<span class="line" id="L1580">                <span class="tok-kw">else</span></span>
<span class="line" id="L1581">                    <span class="tok-null">null</span>,</span>
<span class="line" id="L1582">                .debug_loclists = <span class="tok-kw">if</span> (opt_debug_loclists) |debug_loclists|</span>
<span class="line" id="L1583">                    <span class="tok-kw">try</span> chopSlice(mapped_mem, debug_loclists.offset, debug_loclists.size)</span>
<span class="line" id="L1584">                <span class="tok-kw">else</span></span>
<span class="line" id="L1585">                    <span class="tok-null">null</span>,</span>
<span class="line" id="L1586">                .debug_rnglists = <span class="tok-kw">if</span> (opt_debug_rnglists) |debug_rnglists|</span>
<span class="line" id="L1587">                    <span class="tok-kw">try</span> chopSlice(mapped_mem, debug_rnglists.offset, debug_rnglists.size)</span>
<span class="line" id="L1588">                <span class="tok-kw">else</span></span>
<span class="line" id="L1589">                    <span class="tok-null">null</span>,</span>
<span class="line" id="L1590">                .debug_addr = <span class="tok-kw">if</span> (opt_debug_addr) |debug_addr|</span>
<span class="line" id="L1591">                    <span class="tok-kw">try</span> chopSlice(mapped_mem, debug_addr.offset, debug_addr.size)</span>
<span class="line" id="L1592">                <span class="tok-kw">else</span></span>
<span class="line" id="L1593">                    <span class="tok-null">null</span>,</span>
<span class="line" id="L1594">                .debug_names = <span class="tok-kw">if</span> (opt_debug_names) |debug_names|</span>
<span class="line" id="L1595">                    <span class="tok-kw">try</span> chopSlice(mapped_mem, debug_names.offset, debug_names.size)</span>
<span class="line" id="L1596">                <span class="tok-kw">else</span></span>
<span class="line" id="L1597">                    <span class="tok-null">null</span>,</span>
<span class="line" id="L1598">                .debug_frame = <span class="tok-kw">if</span> (opt_debug_frame) |debug_frame|</span>
<span class="line" id="L1599">                    <span class="tok-kw">try</span> chopSlice(mapped_mem, debug_frame.offset, debug_frame.size)</span>
<span class="line" id="L1600">                <span class="tok-kw">else</span></span>
<span class="line" id="L1601">                    <span class="tok-null">null</span>,</span>
<span class="line" id="L1602">            };</span>
<span class="line" id="L1603"></span>
<span class="line" id="L1604">            <span class="tok-kw">try</span> DW.openDwarfDebugInfo(&amp;di, allocator);</span>
<span class="line" id="L1605">            <span class="tok-kw">var</span> info = OFileInfo{</span>
<span class="line" id="L1606">                .di = di,</span>
<span class="line" id="L1607">                .addr_table = addr_table,</span>
<span class="line" id="L1608">            };</span>
<span class="line" id="L1609"></span>
<span class="line" id="L1610">            <span class="tok-comment">// Add the debug info to the cache</span>
</span>
<span class="line" id="L1611">            <span class="tok-kw">try</span> self.ofiles.putNoClobber(o_file_path, info);</span>
<span class="line" id="L1612"></span>
<span class="line" id="L1613">            <span class="tok-kw">return</span> info;</span>
<span class="line" id="L1614">        }</span>
<span class="line" id="L1615"></span>
<span class="line" id="L1616">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSymbolAtAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator, address: <span class="tok-type">usize</span>) !SymbolInfo {</span>
<span class="line" id="L1617">            <span class="tok-kw">nosuspend</span> {</span>
<span class="line" id="L1618">                <span class="tok-comment">// Translate the VA into an address into this object</span>
</span>
<span class="line" id="L1619">                <span class="tok-kw">const</span> relocated_address = address - self.base_address;</span>
<span class="line" id="L1620"></span>
<span class="line" id="L1621">                <span class="tok-comment">// Find the .o file where this symbol is defined</span>
</span>
<span class="line" id="L1622">                <span class="tok-kw">const</span> symbol = machoSearchSymbols(self.symbols, relocated_address) <span class="tok-kw">orelse</span></span>
<span class="line" id="L1623">                    <span class="tok-kw">return</span> SymbolInfo{};</span>
<span class="line" id="L1624">                <span class="tok-kw">const</span> addr_off = relocated_address - symbol.addr;</span>
<span class="line" id="L1625"></span>
<span class="line" id="L1626">                <span class="tok-comment">// Take the symbol name from the N_FUN STAB entry, we're going to</span>
</span>
<span class="line" id="L1627">                <span class="tok-comment">// use it if we fail to find the DWARF infos</span>
</span>
<span class="line" id="L1628">                <span class="tok-kw">const</span> stab_symbol = mem.sliceTo(self.strings[symbol.strx..], <span class="tok-number">0</span>);</span>
<span class="line" id="L1629">                <span class="tok-kw">const</span> o_file_path = mem.sliceTo(self.strings[symbol.ofile..], <span class="tok-number">0</span>);</span>
<span class="line" id="L1630"></span>
<span class="line" id="L1631">                <span class="tok-comment">// Check if its debug infos are already in the cache</span>
</span>
<span class="line" id="L1632">                <span class="tok-kw">var</span> o_file_info = self.ofiles.get(o_file_path) <span class="tok-kw">orelse</span></span>
<span class="line" id="L1633">                    (self.loadOFile(allocator, o_file_path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1634">                    <span class="tok-kw">error</span>.FileNotFound,</span>
<span class="line" id="L1635">                    <span class="tok-kw">error</span>.MissingDebugInfo,</span>
<span class="line" id="L1636">                    <span class="tok-kw">error</span>.InvalidDebugInfo,</span>
<span class="line" id="L1637">                    =&gt; {</span>
<span class="line" id="L1638">                        <span class="tok-kw">return</span> SymbolInfo{ .symbol_name = stab_symbol };</span>
<span class="line" id="L1639">                    },</span>
<span class="line" id="L1640">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L1641">                });</span>
<span class="line" id="L1642">                <span class="tok-kw">const</span> o_file_di = &amp;o_file_info.di;</span>
<span class="line" id="L1643"></span>
<span class="line" id="L1644">                <span class="tok-comment">// Translate again the address, this time into an address inside the</span>
</span>
<span class="line" id="L1645">                <span class="tok-comment">// .o file</span>
</span>
<span class="line" id="L1646">                <span class="tok-kw">const</span> relocated_address_o = o_file_info.addr_table.get(stab_symbol) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> SymbolInfo{</span>
<span class="line" id="L1647">                    .symbol_name = <span class="tok-str">&quot;???&quot;</span>,</span>
<span class="line" id="L1648">                };</span>
<span class="line" id="L1649"></span>
<span class="line" id="L1650">                <span class="tok-kw">if</span> (o_file_di.findCompileUnit(relocated_address_o)) |compile_unit| {</span>
<span class="line" id="L1651">                    <span class="tok-kw">return</span> SymbolInfo{</span>
<span class="line" id="L1652">                        .symbol_name = o_file_di.getSymbolName(relocated_address_o) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;???&quot;</span>,</span>
<span class="line" id="L1653">                        .compile_unit_name = compile_unit.die.getAttrString(</span>
<span class="line" id="L1654">                            o_file_di,</span>
<span class="line" id="L1655">                            DW.AT.name,</span>
<span class="line" id="L1656">                            o_file_di.debug_str,</span>
<span class="line" id="L1657">                            compile_unit.*,</span>
<span class="line" id="L1658">                        ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1659">                            <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; <span class="tok-str">&quot;???&quot;</span>,</span>
<span class="line" id="L1660">                        },</span>
<span class="line" id="L1661">                        .line_info = o_file_di.getLineNumberInfo(</span>
<span class="line" id="L1662">                            allocator,</span>
<span class="line" id="L1663">                            compile_unit.*,</span>
<span class="line" id="L1664">                            relocated_address_o + addr_off,</span>
<span class="line" id="L1665">                        ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1666">                            <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; <span class="tok-null">null</span>,</span>
<span class="line" id="L1667">                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L1668">                        },</span>
<span class="line" id="L1669">                    };</span>
<span class="line" id="L1670">                } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1671">                    <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; {</span>
<span class="line" id="L1672">                        <span class="tok-kw">return</span> SymbolInfo{ .symbol_name = stab_symbol };</span>
<span class="line" id="L1673">                    },</span>
<span class="line" id="L1674">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L1675">                }</span>
<span class="line" id="L1676"></span>
<span class="line" id="L1677">                <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L1678">            }</span>
<span class="line" id="L1679">        }</span>
<span class="line" id="L1680">    },</span>
<span class="line" id="L1681">    .uefi, .windows =&gt; <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1682">        base_address: <span class="tok-type">usize</span>,</span>
<span class="line" id="L1683">        debug_data: PdbOrDwarf,</span>
<span class="line" id="L1684">        coff_image_base: <span class="tok-type">u64</span>,</span>
<span class="line" id="L1685">        coff_section_headers: []coff.SectionHeader,</span>
<span class="line" id="L1686"></span>
<span class="line" id="L1687">        <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L1688">            <span class="tok-kw">switch</span> (self.debug_data) {</span>
<span class="line" id="L1689">                .dwarf =&gt; |*dwarf| {</span>
<span class="line" id="L1690">                    allocator.free(dwarf.debug_info);</span>
<span class="line" id="L1691">                    allocator.free(dwarf.debug_abbrev);</span>
<span class="line" id="L1692">                    allocator.free(dwarf.debug_str);</span>
<span class="line" id="L1693">                    allocator.free(dwarf.debug_line);</span>
<span class="line" id="L1694">                    <span class="tok-kw">if</span> (dwarf.debug_str_offsets) |d| allocator.free(d);</span>
<span class="line" id="L1695">                    <span class="tok-kw">if</span> (dwarf.debug_line_str) |d| allocator.free(d);</span>
<span class="line" id="L1696">                    <span class="tok-kw">if</span> (dwarf.debug_ranges) |d| allocator.free(d);</span>
<span class="line" id="L1697">                    <span class="tok-kw">if</span> (dwarf.debug_loclists) |d| allocator.free(d);</span>
<span class="line" id="L1698">                    <span class="tok-kw">if</span> (dwarf.debug_rnglists) |d| allocator.free(d);</span>
<span class="line" id="L1699">                    <span class="tok-kw">if</span> (dwarf.debug_addr) |d| allocator.free(d);</span>
<span class="line" id="L1700">                    <span class="tok-kw">if</span> (dwarf.debug_names) |d| allocator.free(d);</span>
<span class="line" id="L1701">                    <span class="tok-kw">if</span> (dwarf.debug_frame) |d| allocator.free(d);</span>
<span class="line" id="L1702">                },</span>
<span class="line" id="L1703">                .pdb =&gt; {</span>
<span class="line" id="L1704">                    allocator.free(self.coff_section_headers);</span>
<span class="line" id="L1705">                },</span>
<span class="line" id="L1706">            }</span>
<span class="line" id="L1707"></span>
<span class="line" id="L1708">            self.debug_data.deinit(allocator);</span>
<span class="line" id="L1709">        }</span>
<span class="line" id="L1710"></span>
<span class="line" id="L1711">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSymbolAtAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator, address: <span class="tok-type">usize</span>) !SymbolInfo {</span>
<span class="line" id="L1712">            <span class="tok-comment">// Translate the VA into an address into this object</span>
</span>
<span class="line" id="L1713">            <span class="tok-kw">const</span> relocated_address = address - self.base_address;</span>
<span class="line" id="L1714"></span>
<span class="line" id="L1715">            <span class="tok-kw">switch</span> (self.debug_data) {</span>
<span class="line" id="L1716">                .dwarf =&gt; |*dwarf| {</span>
<span class="line" id="L1717">                    <span class="tok-kw">const</span> dwarf_address = relocated_address + self.coff_image_base;</span>
<span class="line" id="L1718">                    <span class="tok-kw">return</span> getSymbolFromDwarf(allocator, dwarf_address, dwarf);</span>
<span class="line" id="L1719">                },</span>
<span class="line" id="L1720">                .pdb =&gt; {</span>
<span class="line" id="L1721">                    <span class="tok-comment">// fallthrough to pdb handling</span>
</span>
<span class="line" id="L1722">                },</span>
<span class="line" id="L1723">            }</span>
<span class="line" id="L1724"></span>
<span class="line" id="L1725">            <span class="tok-kw">var</span> coff_section: *<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> coff.SectionHeader = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1726">            <span class="tok-kw">const</span> mod_index = <span class="tok-kw">for</span> (self.debug_data.pdb.sect_contribs) |sect_contrib| {</span>
<span class="line" id="L1727">                <span class="tok-kw">if</span> (sect_contrib.Section &gt; self.coff_section_headers.len) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1728">                <span class="tok-comment">// Remember that SectionContribEntry.Section is 1-based.</span>
</span>
<span class="line" id="L1729">                coff_section = &amp;self.coff_section_headers[sect_contrib.Section - <span class="tok-number">1</span>];</span>
<span class="line" id="L1730"></span>
<span class="line" id="L1731">                <span class="tok-kw">const</span> vaddr_start = coff_section.virtual_address + sect_contrib.Offset;</span>
<span class="line" id="L1732">                <span class="tok-kw">const</span> vaddr_end = vaddr_start + sect_contrib.Size;</span>
<span class="line" id="L1733">                <span class="tok-kw">if</span> (relocated_address &gt;= vaddr_start <span class="tok-kw">and</span> relocated_address &lt; vaddr_end) {</span>
<span class="line" id="L1734">                    <span class="tok-kw">break</span> sect_contrib.ModuleIndex;</span>
<span class="line" id="L1735">                }</span>
<span class="line" id="L1736">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1737">                <span class="tok-comment">// we have no information to add to the address</span>
</span>
<span class="line" id="L1738">                <span class="tok-kw">return</span> SymbolInfo{};</span>
<span class="line" id="L1739">            };</span>
<span class="line" id="L1740"></span>
<span class="line" id="L1741">            <span class="tok-kw">const</span> module = (<span class="tok-kw">try</span> self.debug_data.pdb.getModule(mod_index)) <span class="tok-kw">orelse</span></span>
<span class="line" id="L1742">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo;</span>
<span class="line" id="L1743">            <span class="tok-kw">const</span> obj_basename = fs.path.basename(module.obj_file_name);</span>
<span class="line" id="L1744"></span>
<span class="line" id="L1745">            <span class="tok-kw">const</span> symbol_name = self.debug_data.pdb.getSymbolName(</span>
<span class="line" id="L1746">                module,</span>
<span class="line" id="L1747">                relocated_address - coff_section.virtual_address,</span>
<span class="line" id="L1748">            ) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;???&quot;</span>;</span>
<span class="line" id="L1749">            <span class="tok-kw">const</span> opt_line_info = <span class="tok-kw">try</span> self.debug_data.pdb.getLineNumberInfo(</span>
<span class="line" id="L1750">                module,</span>
<span class="line" id="L1751">                relocated_address - coff_section.virtual_address,</span>
<span class="line" id="L1752">            );</span>
<span class="line" id="L1753"></span>
<span class="line" id="L1754">            <span class="tok-kw">return</span> SymbolInfo{</span>
<span class="line" id="L1755">                .symbol_name = symbol_name,</span>
<span class="line" id="L1756">                .compile_unit_name = obj_basename,</span>
<span class="line" id="L1757">                .line_info = opt_line_info,</span>
<span class="line" id="L1758">            };</span>
<span class="line" id="L1759">        }</span>
<span class="line" id="L1760">    },</span>
<span class="line" id="L1761">    .linux, .netbsd, .freebsd, .dragonfly, .openbsd, .haiku, .solaris =&gt; <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1762">        base_address: <span class="tok-type">usize</span>,</span>
<span class="line" id="L1763">        dwarf: DW.DwarfInfo,</span>
<span class="line" id="L1764">        mapped_memory: []<span class="tok-kw">align</span>(mem.page_size) <span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1765"></span>
<span class="line" id="L1766">        <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L1767">            self.dwarf.deinit(allocator);</span>
<span class="line" id="L1768">            os.munmap(self.mapped_memory);</span>
<span class="line" id="L1769">        }</span>
<span class="line" id="L1770"></span>
<span class="line" id="L1771">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSymbolAtAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator, address: <span class="tok-type">usize</span>) !SymbolInfo {</span>
<span class="line" id="L1772">            <span class="tok-comment">// Translate the VA into an address into this object</span>
</span>
<span class="line" id="L1773">            <span class="tok-kw">const</span> relocated_address = address - self.base_address;</span>
<span class="line" id="L1774">            <span class="tok-kw">return</span> getSymbolFromDwarf(allocator, relocated_address, &amp;self.dwarf);</span>
<span class="line" id="L1775">        }</span>
<span class="line" id="L1776">    },</span>
<span class="line" id="L1777">    .wasi =&gt; <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1778">        <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L1779">            _ = self;</span>
<span class="line" id="L1780">            _ = allocator;</span>
<span class="line" id="L1781">        }</span>
<span class="line" id="L1782"></span>
<span class="line" id="L1783">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSymbolAtAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator, address: <span class="tok-type">usize</span>) !SymbolInfo {</span>
<span class="line" id="L1784">            _ = self;</span>
<span class="line" id="L1785">            _ = allocator;</span>
<span class="line" id="L1786">            _ = address;</span>
<span class="line" id="L1787">            <span class="tok-kw">return</span> SymbolInfo{};</span>
<span class="line" id="L1788">        }</span>
<span class="line" id="L1789">    },</span>
<span class="line" id="L1790">    <span class="tok-kw">else</span> =&gt; DW.DwarfInfo,</span>
<span class="line" id="L1791">};</span>
<span class="line" id="L1792"></span>
<span class="line" id="L1793"><span class="tok-kw">fn</span> <span class="tok-fn">getSymbolFromDwarf</span>(allocator: mem.Allocator, address: <span class="tok-type">u64</span>, di: *DW.DwarfInfo) !SymbolInfo {</span>
<span class="line" id="L1794">    <span class="tok-kw">if</span> (<span class="tok-kw">nosuspend</span> di.findCompileUnit(address)) |compile_unit| {</span>
<span class="line" id="L1795">        <span class="tok-kw">return</span> SymbolInfo{</span>
<span class="line" id="L1796">            .symbol_name = <span class="tok-kw">nosuspend</span> di.getSymbolName(address) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;???&quot;</span>,</span>
<span class="line" id="L1797">            .compile_unit_name = compile_unit.die.getAttrString(di, DW.AT.name, di.debug_str, compile_unit.*) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1798">                <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; <span class="tok-str">&quot;???&quot;</span>,</span>
<span class="line" id="L1799">            },</span>
<span class="line" id="L1800">            .line_info = <span class="tok-kw">nosuspend</span> di.getLineNumberInfo(allocator, compile_unit.*, address) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1801">                <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; <span class="tok-null">null</span>,</span>
<span class="line" id="L1802">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L1803">            },</span>
<span class="line" id="L1804">        };</span>
<span class="line" id="L1805">    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1806">        <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; {</span>
<span class="line" id="L1807">            <span class="tok-kw">return</span> SymbolInfo{};</span>
<span class="line" id="L1808">        },</span>
<span class="line" id="L1809">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L1810">    }</span>
<span class="line" id="L1811">}</span>
<span class="line" id="L1812"></span>
<span class="line" id="L1813"><span class="tok-comment">/// TODO multithreaded awareness</span></span>
<span class="line" id="L1814"><span class="tok-kw">var</span> debug_info_allocator: ?mem.Allocator = <span class="tok-null">null</span>;</span>
<span class="line" id="L1815"><span class="tok-kw">var</span> debug_info_arena_allocator: std.heap.ArenaAllocator = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1816"><span class="tok-kw">fn</span> <span class="tok-fn">getDebugInfoAllocator</span>() mem.Allocator {</span>
<span class="line" id="L1817">    <span class="tok-kw">if</span> (debug_info_allocator) |a| <span class="tok-kw">return</span> a;</span>
<span class="line" id="L1818"></span>
<span class="line" id="L1819">    debug_info_arena_allocator = std.heap.ArenaAllocator.init(std.heap.page_allocator);</span>
<span class="line" id="L1820">    <span class="tok-kw">const</span> allocator = debug_info_arena_allocator.allocator();</span>
<span class="line" id="L1821">    debug_info_allocator = allocator;</span>
<span class="line" id="L1822">    <span class="tok-kw">return</span> allocator;</span>
<span class="line" id="L1823">}</span>
<span class="line" id="L1824"></span>
<span class="line" id="L1825"><span class="tok-comment">/// Whether or not the current target can print useful debug information when a segfault occurs.</span></span>
<span class="line" id="L1826"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> have_segfault_handling_support = <span class="tok-kw">switch</span> (native_os) {</span>
<span class="line" id="L1827">    .linux,</span>
<span class="line" id="L1828">    .macos,</span>
<span class="line" id="L1829">    .netbsd,</span>
<span class="line" id="L1830">    .solaris,</span>
<span class="line" id="L1831">    .windows,</span>
<span class="line" id="L1832">    =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L1833"></span>
<span class="line" id="L1834">    .freebsd, .openbsd =&gt; <span class="tok-builtin">@hasDecl</span>(os.system, <span class="tok-str">&quot;ucontext_t&quot;</span>),</span>
<span class="line" id="L1835">    <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L1836">};</span>
<span class="line" id="L1837"></span>
<span class="line" id="L1838"><span class="tok-kw">const</span> enable_segfault_handler = std.options.enable_segfault_handler;</span>
<span class="line" id="L1839"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> default_enable_segfault_handler = runtime_safety <span class="tok-kw">and</span> have_segfault_handling_support;</span>
<span class="line" id="L1840"></span>
<span class="line" id="L1841"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">maybeEnableSegfaultHandler</span>() <span class="tok-type">void</span> {</span>
<span class="line" id="L1842">    <span class="tok-kw">if</span> (enable_segfault_handler) {</span>
<span class="line" id="L1843">        std.debug.attachSegfaultHandler();</span>
<span class="line" id="L1844">    }</span>
<span class="line" id="L1845">}</span>
<span class="line" id="L1846"></span>
<span class="line" id="L1847"><span class="tok-kw">var</span> windows_segfault_handle: ?windows.HANDLE = <span class="tok-null">null</span>;</span>
<span class="line" id="L1848"></span>
<span class="line" id="L1849"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">updateSegfaultHandler</span>(act: ?*<span class="tok-kw">const</span> os.Sigaction) <span class="tok-kw">error</span>{OperationNotSupported}!<span class="tok-type">void</span> {</span>
<span class="line" id="L1850">    <span class="tok-kw">try</span> os.sigaction(os.SIG.SEGV, act, <span class="tok-null">null</span>);</span>
<span class="line" id="L1851">    <span class="tok-kw">try</span> os.sigaction(os.SIG.ILL, act, <span class="tok-null">null</span>);</span>
<span class="line" id="L1852">    <span class="tok-kw">try</span> os.sigaction(os.SIG.BUS, act, <span class="tok-null">null</span>);</span>
<span class="line" id="L1853">    <span class="tok-kw">try</span> os.sigaction(os.SIG.FPE, act, <span class="tok-null">null</span>);</span>
<span class="line" id="L1854">}</span>
<span class="line" id="L1855"></span>
<span class="line" id="L1856"><span class="tok-comment">/// Attaches a global SIGSEGV handler which calls @panic(&quot;segmentation fault&quot;);</span></span>
<span class="line" id="L1857"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">attachSegfaultHandler</span>() <span class="tok-type">void</span> {</span>
<span class="line" id="L1858">    <span class="tok-kw">if</span> (!have_segfault_handling_support) {</span>
<span class="line" id="L1859">        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;segfault handler not supported for this target&quot;</span>);</span>
<span class="line" id="L1860">    }</span>
<span class="line" id="L1861">    <span class="tok-kw">if</span> (native_os == .windows) {</span>
<span class="line" id="L1862">        windows_segfault_handle = windows.kernel32.AddVectoredExceptionHandler(<span class="tok-number">0</span>, handleSegfaultWindows);</span>
<span class="line" id="L1863">        <span class="tok-kw">return</span>;</span>
<span class="line" id="L1864">    }</span>
<span class="line" id="L1865">    <span class="tok-kw">var</span> act = os.Sigaction{</span>
<span class="line" id="L1866">        .handler = .{ .sigaction = handleSegfaultPosix },</span>
<span class="line" id="L1867">        .mask = os.empty_sigset,</span>
<span class="line" id="L1868">        .flags = (os.SA.SIGINFO | os.SA.RESTART | os.SA.RESETHAND),</span>
<span class="line" id="L1869">    };</span>
<span class="line" id="L1870"></span>
<span class="line" id="L1871">    updateSegfaultHandler(&amp;act) <span class="tok-kw">catch</span> {</span>
<span class="line" id="L1872">        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;unable to install segfault handler, maybe adjust have_segfault_handling_support in std/debug.zig&quot;</span>);</span>
<span class="line" id="L1873">    };</span>
<span class="line" id="L1874">}</span>
<span class="line" id="L1875"></span>
<span class="line" id="L1876"><span class="tok-kw">fn</span> <span class="tok-fn">resetSegfaultHandler</span>() <span class="tok-type">void</span> {</span>
<span class="line" id="L1877">    <span class="tok-kw">if</span> (native_os == .windows) {</span>
<span class="line" id="L1878">        <span class="tok-kw">if</span> (windows_segfault_handle) |handle| {</span>
<span class="line" id="L1879">            assert(windows.kernel32.RemoveVectoredExceptionHandler(handle) != <span class="tok-number">0</span>);</span>
<span class="line" id="L1880">            windows_segfault_handle = <span class="tok-null">null</span>;</span>
<span class="line" id="L1881">        }</span>
<span class="line" id="L1882">        <span class="tok-kw">return</span>;</span>
<span class="line" id="L1883">    }</span>
<span class="line" id="L1884">    <span class="tok-kw">var</span> act = os.Sigaction{</span>
<span class="line" id="L1885">        .handler = .{ .handler = os.SIG.DFL },</span>
<span class="line" id="L1886">        .mask = os.empty_sigset,</span>
<span class="line" id="L1887">        .flags = <span class="tok-number">0</span>,</span>
<span class="line" id="L1888">    };</span>
<span class="line" id="L1889">    <span class="tok-comment">// To avoid a double-panic, do nothing if an error happens here.</span>
</span>
<span class="line" id="L1890">    updateSegfaultHandler(&amp;act) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L1891">}</span>
<span class="line" id="L1892"></span>
<span class="line" id="L1893"><span class="tok-kw">fn</span> <span class="tok-fn">handleSegfaultPosix</span>(sig: <span class="tok-type">i32</span>, info: *<span class="tok-kw">const</span> os.siginfo_t, ctx_ptr: ?*<span class="tok-kw">const</span> <span class="tok-type">anyopaque</span>) <span class="tok-kw">callconv</span>(.C) <span class="tok-type">noreturn</span> {</span>
<span class="line" id="L1894">    <span class="tok-comment">// Reset to the default handler so that if a segfault happens in this handler it will crash</span>
</span>
<span class="line" id="L1895">    <span class="tok-comment">// the process. Also when this handler returns, the original instruction will be repeated</span>
</span>
<span class="line" id="L1896">    <span class="tok-comment">// and the resulting segfault will crash the process rather than continually dump stack traces.</span>
</span>
<span class="line" id="L1897">    resetSegfaultHandler();</span>
<span class="line" id="L1898"></span>
<span class="line" id="L1899">    <span class="tok-kw">const</span> addr = <span class="tok-kw">switch</span> (native_os) {</span>
<span class="line" id="L1900">        .linux =&gt; <span class="tok-builtin">@intFromPtr</span>(info.fields.sigfault.addr),</span>
<span class="line" id="L1901">        .freebsd, .macos =&gt; <span class="tok-builtin">@intFromPtr</span>(info.addr),</span>
<span class="line" id="L1902">        .netbsd =&gt; <span class="tok-builtin">@intFromPtr</span>(info.info.reason.fault.addr),</span>
<span class="line" id="L1903">        .openbsd =&gt; <span class="tok-builtin">@intFromPtr</span>(info.data.fault.addr),</span>
<span class="line" id="L1904">        .solaris =&gt; <span class="tok-builtin">@intFromPtr</span>(info.reason.fault.addr),</span>
<span class="line" id="L1905">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1906">    };</span>
<span class="line" id="L1907"></span>
<span class="line" id="L1908">    <span class="tok-kw">nosuspend</span> <span class="tok-kw">switch</span> (panic_stage) {</span>
<span class="line" id="L1909">        <span class="tok-number">0</span> =&gt; {</span>
<span class="line" id="L1910">            panic_stage = <span class="tok-number">1</span>;</span>
<span class="line" id="L1911">            _ = panicking.fetchAdd(<span class="tok-number">1</span>, .SeqCst);</span>
<span class="line" id="L1912"></span>
<span class="line" id="L1913">            {</span>
<span class="line" id="L1914">                panic_mutex.lock();</span>
<span class="line" id="L1915">                <span class="tok-kw">defer</span> panic_mutex.unlock();</span>
<span class="line" id="L1916"></span>
<span class="line" id="L1917">                dumpSegfaultInfoPosix(sig, addr, ctx_ptr);</span>
<span class="line" id="L1918">            }</span>
<span class="line" id="L1919"></span>
<span class="line" id="L1920">            waitForOtherThreadToFinishPanicking();</span>
<span class="line" id="L1921">        },</span>
<span class="line" id="L1922">        <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L1923">            <span class="tok-comment">// panic mutex already locked</span>
</span>
<span class="line" id="L1924">            dumpSegfaultInfoPosix(sig, addr, ctx_ptr);</span>
<span class="line" id="L1925">        },</span>
<span class="line" id="L1926">    };</span>
<span class="line" id="L1927"></span>
<span class="line" id="L1928">    <span class="tok-comment">// We cannot allow the signal handler to return because when it runs the original instruction</span>
</span>
<span class="line" id="L1929">    <span class="tok-comment">// again, the memory may be mapped and undefined behavior would occur rather than repeating</span>
</span>
<span class="line" id="L1930">    <span class="tok-comment">// the segfault. So we simply abort here.</span>
</span>
<span class="line" id="L1931">    os.abort();</span>
<span class="line" id="L1932">}</span>
<span class="line" id="L1933"></span>
<span class="line" id="L1934"><span class="tok-kw">fn</span> <span class="tok-fn">dumpSegfaultInfoPosix</span>(sig: <span class="tok-type">i32</span>, addr: <span class="tok-type">usize</span>, ctx_ptr: ?*<span class="tok-kw">const</span> <span class="tok-type">anyopaque</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L1935">    <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L1936">    _ = <span class="tok-kw">switch</span> (sig) {</span>
<span class="line" id="L1937">        os.SIG.SEGV =&gt; stderr.print(<span class="tok-str">&quot;Segmentation fault at address 0x{x}\n&quot;</span>, .{addr}),</span>
<span class="line" id="L1938">        os.SIG.ILL =&gt; stderr.print(<span class="tok-str">&quot;Illegal instruction at address 0x{x}\n&quot;</span>, .{addr}),</span>
<span class="line" id="L1939">        os.SIG.BUS =&gt; stderr.print(<span class="tok-str">&quot;Bus error at address 0x{x}\n&quot;</span>, .{addr}),</span>
<span class="line" id="L1940">        os.SIG.FPE =&gt; stderr.print(<span class="tok-str">&quot;Arithmetic exception at address 0x{x}\n&quot;</span>, .{addr}),</span>
<span class="line" id="L1941">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1942">    } <span class="tok-kw">catch</span> os.abort();</span>
<span class="line" id="L1943"></span>
<span class="line" id="L1944">    <span class="tok-kw">switch</span> (native_arch) {</span>
<span class="line" id="L1945">        .x86 =&gt; {</span>
<span class="line" id="L1946">            <span class="tok-kw">const</span> ctx = <span class="tok-builtin">@ptrCast</span>(*<span class="tok-kw">const</span> os.ucontext_t, <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@alignOf</span>(os.ucontext_t), ctx_ptr));</span>
<span class="line" id="L1947">            <span class="tok-kw">const</span> ip = <span class="tok-builtin">@intCast</span>(<span class="tok-type">usize</span>, ctx.mcontext.gregs[os.REG.EIP]);</span>
<span class="line" id="L1948">            <span class="tok-kw">const</span> bp = <span class="tok-builtin">@intCast</span>(<span class="tok-type">usize</span>, ctx.mcontext.gregs[os.REG.EBP]);</span>
<span class="line" id="L1949">            dumpStackTraceFromBase(bp, ip);</span>
<span class="line" id="L1950">        },</span>
<span class="line" id="L1951">        .x86_64 =&gt; {</span>
<span class="line" id="L1952">            <span class="tok-kw">const</span> ctx = <span class="tok-builtin">@ptrCast</span>(*<span class="tok-kw">const</span> os.ucontext_t, <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@alignOf</span>(os.ucontext_t), ctx_ptr));</span>
<span class="line" id="L1953">            <span class="tok-kw">const</span> ip = <span class="tok-kw">switch</span> (native_os) {</span>
<span class="line" id="L1954">                .linux, .netbsd, .solaris =&gt; <span class="tok-builtin">@intCast</span>(<span class="tok-type">usize</span>, ctx.mcontext.gregs[os.REG.RIP]),</span>
<span class="line" id="L1955">                .freebsd =&gt; <span class="tok-builtin">@intCast</span>(<span class="tok-type">usize</span>, ctx.mcontext.rip),</span>
<span class="line" id="L1956">                .openbsd =&gt; <span class="tok-builtin">@intCast</span>(<span class="tok-type">usize</span>, ctx.sc_rip),</span>
<span class="line" id="L1957">                .macos =&gt; <span class="tok-builtin">@intCast</span>(<span class="tok-type">usize</span>, ctx.mcontext.ss.rip),</span>
<span class="line" id="L1958">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1959">            };</span>
<span class="line" id="L1960">            <span class="tok-kw">const</span> bp = <span class="tok-kw">switch</span> (native_os) {</span>
<span class="line" id="L1961">                .linux, .netbsd, .solaris =&gt; <span class="tok-builtin">@intCast</span>(<span class="tok-type">usize</span>, ctx.mcontext.gregs[os.REG.RBP]),</span>
<span class="line" id="L1962">                .openbsd =&gt; <span class="tok-builtin">@intCast</span>(<span class="tok-type">usize</span>, ctx.sc_rbp),</span>
<span class="line" id="L1963">                .freebsd =&gt; <span class="tok-builtin">@intCast</span>(<span class="tok-type">usize</span>, ctx.mcontext.rbp),</span>
<span class="line" id="L1964">                .macos =&gt; <span class="tok-builtin">@intCast</span>(<span class="tok-type">usize</span>, ctx.mcontext.ss.rbp),</span>
<span class="line" id="L1965">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1966">            };</span>
<span class="line" id="L1967">            dumpStackTraceFromBase(bp, ip);</span>
<span class="line" id="L1968">        },</span>
<span class="line" id="L1969">        .arm =&gt; {</span>
<span class="line" id="L1970">            <span class="tok-kw">const</span> ctx = <span class="tok-builtin">@ptrCast</span>(*<span class="tok-kw">const</span> os.ucontext_t, <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@alignOf</span>(os.ucontext_t), ctx_ptr));</span>
<span class="line" id="L1971">            <span class="tok-kw">const</span> ip = <span class="tok-builtin">@intCast</span>(<span class="tok-type">usize</span>, ctx.mcontext.arm_pc);</span>
<span class="line" id="L1972">            <span class="tok-kw">const</span> bp = <span class="tok-builtin">@intCast</span>(<span class="tok-type">usize</span>, ctx.mcontext.arm_fp);</span>
<span class="line" id="L1973">            dumpStackTraceFromBase(bp, ip);</span>
<span class="line" id="L1974">        },</span>
<span class="line" id="L1975">        .aarch64 =&gt; {</span>
<span class="line" id="L1976">            <span class="tok-kw">const</span> ctx = <span class="tok-builtin">@ptrCast</span>(*<span class="tok-kw">const</span> os.ucontext_t, <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@alignOf</span>(os.ucontext_t), ctx_ptr));</span>
<span class="line" id="L1977">            <span class="tok-kw">const</span> ip = <span class="tok-kw">switch</span> (native_os) {</span>
<span class="line" id="L1978">                .macos =&gt; <span class="tok-builtin">@intCast</span>(<span class="tok-type">usize</span>, ctx.mcontext.ss.pc),</span>
<span class="line" id="L1979">                .netbsd =&gt; <span class="tok-builtin">@intCast</span>(<span class="tok-type">usize</span>, ctx.mcontext.gregs[os.REG.PC]),</span>
<span class="line" id="L1980">                .freebsd =&gt; <span class="tok-builtin">@intCast</span>(<span class="tok-type">usize</span>, ctx.mcontext.gpregs.elr),</span>
<span class="line" id="L1981">                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@intCast</span>(<span class="tok-type">usize</span>, ctx.mcontext.pc),</span>
<span class="line" id="L1982">            };</span>
<span class="line" id="L1983">            <span class="tok-comment">// x29 is the ABI-designated frame pointer</span>
</span>
<span class="line" id="L1984">            <span class="tok-kw">const</span> bp = <span class="tok-kw">switch</span> (native_os) {</span>
<span class="line" id="L1985">                .macos =&gt; <span class="tok-builtin">@intCast</span>(<span class="tok-type">usize</span>, ctx.mcontext.ss.fp),</span>
<span class="line" id="L1986">                .netbsd =&gt; <span class="tok-builtin">@intCast</span>(<span class="tok-type">usize</span>, ctx.mcontext.gregs[os.REG.FP]),</span>
<span class="line" id="L1987">                .freebsd =&gt; <span class="tok-builtin">@intCast</span>(<span class="tok-type">usize</span>, ctx.mcontext.gpregs.x[os.REG.FP]),</span>
<span class="line" id="L1988">                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@intCast</span>(<span class="tok-type">usize</span>, ctx.mcontext.regs[<span class="tok-number">29</span>]),</span>
<span class="line" id="L1989">            };</span>
<span class="line" id="L1990">            dumpStackTraceFromBase(bp, ip);</span>
<span class="line" id="L1991">        },</span>
<span class="line" id="L1992">        <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L1993">    }</span>
<span class="line" id="L1994">}</span>
<span class="line" id="L1995"></span>
<span class="line" id="L1996"><span class="tok-kw">fn</span> <span class="tok-fn">handleSegfaultWindows</span>(info: *windows.EXCEPTION_POINTERS) <span class="tok-kw">callconv</span>(windows.WINAPI) <span class="tok-type">c_long</span> {</span>
<span class="line" id="L1997">    <span class="tok-kw">switch</span> (info.ExceptionRecord.ExceptionCode) {</span>
<span class="line" id="L1998">        windows.EXCEPTION_DATATYPE_MISALIGNMENT =&gt; handleSegfaultWindowsExtra(info, <span class="tok-number">0</span>, <span class="tok-str">&quot;Unaligned Memory Access&quot;</span>),</span>
<span class="line" id="L1999">        windows.EXCEPTION_ACCESS_VIOLATION =&gt; handleSegfaultWindowsExtra(info, <span class="tok-number">1</span>, <span class="tok-null">null</span>),</span>
<span class="line" id="L2000">        windows.EXCEPTION_ILLEGAL_INSTRUCTION =&gt; handleSegfaultWindowsExtra(info, <span class="tok-number">2</span>, <span class="tok-null">null</span>),</span>
<span class="line" id="L2001">        windows.EXCEPTION_STACK_OVERFLOW =&gt; handleSegfaultWindowsExtra(info, <span class="tok-number">0</span>, <span class="tok-str">&quot;Stack Overflow&quot;</span>),</span>
<span class="line" id="L2002">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> windows.EXCEPTION_CONTINUE_SEARCH,</span>
<span class="line" id="L2003">    }</span>
<span class="line" id="L2004">}</span>
<span class="line" id="L2005"></span>
<span class="line" id="L2006"><span class="tok-kw">fn</span> <span class="tok-fn">handleSegfaultWindowsExtra</span>(</span>
<span class="line" id="L2007">    info: *windows.EXCEPTION_POINTERS,</span>
<span class="line" id="L2008">    msg: <span class="tok-type">u8</span>,</span>
<span class="line" id="L2009">    label: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2010">) <span class="tok-type">noreturn</span> {</span>
<span class="line" id="L2011">    <span class="tok-kw">const</span> exception_address = <span class="tok-builtin">@intFromPtr</span>(info.ExceptionRecord.ExceptionAddress);</span>
<span class="line" id="L2012">    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(windows, <span class="tok-str">&quot;CONTEXT&quot;</span>)) {</span>
<span class="line" id="L2013">        <span class="tok-kw">nosuspend</span> <span class="tok-kw">switch</span> (panic_stage) {</span>
<span class="line" id="L2014">            <span class="tok-number">0</span> =&gt; {</span>
<span class="line" id="L2015">                panic_stage = <span class="tok-number">1</span>;</span>
<span class="line" id="L2016">                _ = panicking.fetchAdd(<span class="tok-number">1</span>, .SeqCst);</span>
<span class="line" id="L2017"></span>
<span class="line" id="L2018">                {</span>
<span class="line" id="L2019">                    panic_mutex.lock();</span>
<span class="line" id="L2020">                    <span class="tok-kw">defer</span> panic_mutex.unlock();</span>
<span class="line" id="L2021"></span>
<span class="line" id="L2022">                    dumpSegfaultInfoWindows(info, msg, label);</span>
<span class="line" id="L2023">                }</span>
<span class="line" id="L2024"></span>
<span class="line" id="L2025">                waitForOtherThreadToFinishPanicking();</span>
<span class="line" id="L2026">            },</span>
<span class="line" id="L2027">            <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L2028">                <span class="tok-comment">// panic mutex already locked</span>
</span>
<span class="line" id="L2029">                dumpSegfaultInfoWindows(info, msg, label);</span>
<span class="line" id="L2030">            },</span>
<span class="line" id="L2031">        };</span>
<span class="line" id="L2032">        os.abort();</span>
<span class="line" id="L2033">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2034">        <span class="tok-kw">switch</span> (msg) {</span>
<span class="line" id="L2035">            <span class="tok-number">0</span> =&gt; panicImpl(<span class="tok-null">null</span>, exception_address, <span class="tok-str">&quot;{s}&quot;</span>, label.?),</span>
<span class="line" id="L2036">            <span class="tok-number">1</span> =&gt; {</span>
<span class="line" id="L2037">                <span class="tok-kw">const</span> format_item = <span class="tok-str">&quot;Segmentation fault at address 0x{x}&quot;</span>;</span>
<span class="line" id="L2038">                <span class="tok-kw">var</span> buf: [format_item.len + <span class="tok-number">64</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>; <span class="tok-comment">// 64 is arbitrary, but sufficiently large</span>
</span>
<span class="line" id="L2039">                <span class="tok-kw">const</span> to_print = std.fmt.bufPrint(buf[<span class="tok-number">0</span>..buf.len], format_item, .{info.ExceptionRecord.ExceptionInformation[<span class="tok-number">1</span>]}) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L2040">                panicImpl(<span class="tok-null">null</span>, exception_address, to_print);</span>
<span class="line" id="L2041">            },</span>
<span class="line" id="L2042">            <span class="tok-number">2</span> =&gt; panicImpl(<span class="tok-null">null</span>, exception_address, <span class="tok-str">&quot;Illegal Instruction&quot;</span>),</span>
<span class="line" id="L2043">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L2044">        }</span>
<span class="line" id="L2045">    }</span>
<span class="line" id="L2046">}</span>
<span class="line" id="L2047"></span>
<span class="line" id="L2048"><span class="tok-kw">fn</span> <span class="tok-fn">dumpSegfaultInfoWindows</span>(info: *windows.EXCEPTION_POINTERS, msg: <span class="tok-type">u8</span>, label: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L2049">    <span class="tok-kw">const</span> regs = info.ContextRecord.getRegs();</span>
<span class="line" id="L2050">    <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L2051">    _ = <span class="tok-kw">switch</span> (msg) {</span>
<span class="line" id="L2052">        <span class="tok-number">0</span> =&gt; stderr.print(<span class="tok-str">&quot;{s}\n&quot;</span>, .{label.?}),</span>
<span class="line" id="L2053">        <span class="tok-number">1</span> =&gt; stderr.print(<span class="tok-str">&quot;Segmentation fault at address 0x{x}\n&quot;</span>, .{info.ExceptionRecord.ExceptionInformation[<span class="tok-number">1</span>]}),</span>
<span class="line" id="L2054">        <span class="tok-number">2</span> =&gt; stderr.print(<span class="tok-str">&quot;Illegal instruction at address 0x{x}\n&quot;</span>, .{regs.ip}),</span>
<span class="line" id="L2055">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L2056">    } <span class="tok-kw">catch</span> os.abort();</span>
<span class="line" id="L2057"></span>
<span class="line" id="L2058">    dumpStackTraceFromBase(regs.bp, regs.ip);</span>
<span class="line" id="L2059">}</span>
<span class="line" id="L2060"></span>
<span class="line" id="L2061"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpStackPointerAddr</span>(prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L2062">    <span class="tok-kw">const</span> sp = <span class="tok-kw">asm</span> (<span class="tok-str">&quot;&quot;</span></span>
<span class="line" id="L2063">        : [argc] <span class="tok-str">&quot;={rsp}&quot;</span> (-&gt; <span class="tok-type">usize</span>),</span>
<span class="line" id="L2064">    );</span>
<span class="line" id="L2065">    std.debug.print(<span class="tok-str">&quot;{} sp = 0x{x}\n&quot;</span>, .{ prefix, sp });</span>
<span class="line" id="L2066">}</span>
<span class="line" id="L2067"></span>
<span class="line" id="L2068"><span class="tok-kw">test</span> <span class="tok-str">&quot;manage resources correctly&quot;</span> {</span>
<span class="line" id="L2069">    <span class="tok-kw">if</span> (builtin.os.tag == .wasi) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;</span>
<span class="line" id="L2070"></span>
<span class="line" id="L2071">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L2072">        <span class="tok-comment">// https://github.com/ziglang/zig/issues/13963</span>
</span>
<span class="line" id="L2073">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;</span>
<span class="line" id="L2074">    }</span>
<span class="line" id="L2075"></span>
<span class="line" id="L2076">    <span class="tok-kw">const</span> writer = std.io.null_writer;</span>
<span class="line" id="L2077">    <span class="tok-kw">var</span> di = <span class="tok-kw">try</span> openSelfDebugInfo(testing.allocator);</span>
<span class="line" id="L2078">    <span class="tok-kw">defer</span> di.deinit();</span>
<span class="line" id="L2079">    <span class="tok-kw">try</span> printSourceAtAddress(&amp;di, writer, showMyTrace(), io.tty.detectConfig(std.io.getStdErr()));</span>
<span class="line" id="L2080">}</span>
<span class="line" id="L2081"></span>
<span class="line" id="L2082"><span class="tok-kw">noinline</span> <span class="tok-kw">fn</span> <span class="tok-fn">showMyTrace</span>() <span class="tok-type">usize</span> {</span>
<span class="line" id="L2083">    <span class="tok-kw">return</span> <span class="tok-builtin">@returnAddress</span>();</span>
<span class="line" id="L2084">}</span>
<span class="line" id="L2085"></span>
<span class="line" id="L2086"><span class="tok-comment">/// This API helps you track where a value originated and where it was mutated,</span></span>
<span class="line" id="L2087"><span class="tok-comment">/// or any other points of interest.</span></span>
<span class="line" id="L2088"><span class="tok-comment">/// In debug mode, it adds a small size penalty (104 bytes on 64-bit architectures)</span></span>
<span class="line" id="L2089"><span class="tok-comment">/// to the aggregate that you add it to.</span></span>
<span class="line" id="L2090"><span class="tok-comment">/// In release mode, it is size 0 and all methods are no-ops.</span></span>
<span class="line" id="L2091"><span class="tok-comment">/// This is a pre-made type with default settings.</span></span>
<span class="line" id="L2092"><span class="tok-comment">/// For more advanced usage, see `ConfigurableTrace`.</span></span>
<span class="line" id="L2093"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Trace = ConfigurableTrace(<span class="tok-number">2</span>, <span class="tok-number">4</span>, builtin.mode == .Debug);</span>
<span class="line" id="L2094"></span>
<span class="line" id="L2095"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ConfigurableTrace</span>(<span class="tok-kw">comptime</span> size: <span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> stack_frame_count: <span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> is_enabled: <span class="tok-type">bool</span>) <span class="tok-type">type</span> {</span>
<span class="line" id="L2096">    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2097">        addrs: [actual_size][stack_frame_count]<span class="tok-type">usize</span> = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L2098">        notes: [actual_size][]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L2099">        index: Index = <span class="tok-number">0</span>,</span>
<span class="line" id="L2100"></span>
<span class="line" id="L2101">        <span class="tok-kw">const</span> actual_size = <span class="tok-kw">if</span> (enabled) size <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L2102">        <span class="tok-kw">const</span> Index = <span class="tok-kw">if</span> (enabled) <span class="tok-type">usize</span> <span class="tok-kw">else</span> <span class="tok-type">u0</span>;</span>
<span class="line" id="L2103"></span>
<span class="line" id="L2104">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> enabled = is_enabled;</span>
<span class="line" id="L2105"></span>
<span class="line" id="L2106">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> add = <span class="tok-kw">if</span> (enabled) addNoInline <span class="tok-kw">else</span> addNoOp;</span>
<span class="line" id="L2107"></span>
<span class="line" id="L2108">        <span class="tok-kw">pub</span> <span class="tok-kw">noinline</span> <span class="tok-kw">fn</span> <span class="tok-fn">addNoInline</span>(t: *<span class="tok-builtin">@This</span>(), note: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L2109">            <span class="tok-kw">comptime</span> assert(enabled);</span>
<span class="line" id="L2110">            <span class="tok-kw">return</span> addAddr(t, <span class="tok-builtin">@returnAddress</span>(), note);</span>
<span class="line" id="L2111">        }</span>
<span class="line" id="L2112"></span>
<span class="line" id="L2113">        <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">addNoOp</span>(t: *<span class="tok-builtin">@This</span>(), note: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L2114">            _ = t;</span>
<span class="line" id="L2115">            _ = note;</span>
<span class="line" id="L2116">            <span class="tok-kw">comptime</span> assert(!enabled);</span>
<span class="line" id="L2117">        }</span>
<span class="line" id="L2118"></span>
<span class="line" id="L2119">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addAddr</span>(t: *<span class="tok-builtin">@This</span>(), addr: <span class="tok-type">usize</span>, note: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L2120">            <span class="tok-kw">if</span> (!enabled) <span class="tok-kw">return</span>;</span>
<span class="line" id="L2121"></span>
<span class="line" id="L2122">            <span class="tok-kw">if</span> (t.index &lt; size) {</span>
<span class="line" id="L2123">                t.notes[t.index] = note;</span>
<span class="line" id="L2124">                t.addrs[t.index] = [<span class="tok-number">1</span>]<span class="tok-type">usize</span>{<span class="tok-number">0</span>} ** stack_frame_count;</span>
<span class="line" id="L2125">                <span class="tok-kw">var</span> stack_trace: std.builtin.StackTrace = .{</span>
<span class="line" id="L2126">                    .index = <span class="tok-number">0</span>,</span>
<span class="line" id="L2127">                    .instruction_addresses = &amp;t.addrs[t.index],</span>
<span class="line" id="L2128">                };</span>
<span class="line" id="L2129">                captureStackTrace(addr, &amp;stack_trace);</span>
<span class="line" id="L2130">            }</span>
<span class="line" id="L2131">            <span class="tok-comment">// Keep counting even if the end is reached so that the</span>
</span>
<span class="line" id="L2132">            <span class="tok-comment">// user can find out how much more size they need.</span>
</span>
<span class="line" id="L2133">            t.index += <span class="tok-number">1</span>;</span>
<span class="line" id="L2134">        }</span>
<span class="line" id="L2135"></span>
<span class="line" id="L2136">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dump</span>(t: <span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {</span>
<span class="line" id="L2137">            <span class="tok-kw">if</span> (!enabled) <span class="tok-kw">return</span>;</span>
<span class="line" id="L2138"></span>
<span class="line" id="L2139">            <span class="tok-kw">const</span> tty_config = io.tty.detectConfig(std.io.getStdErr());</span>
<span class="line" id="L2140">            <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L2141">            <span class="tok-kw">const</span> end = <span class="tok-builtin">@min</span>(t.index, size);</span>
<span class="line" id="L2142">            <span class="tok-kw">const</span> debug_info = getSelfDebugInfo() <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L2143">                stderr.print(</span>
<span class="line" id="L2144">                    <span class="tok-str">&quot;Unable to dump stack trace: Unable to open debug info: {s}\n&quot;</span>,</span>
<span class="line" id="L2145">                    .{<span class="tok-builtin">@errorName</span>(err)},</span>
<span class="line" id="L2146">                ) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L2147">                <span class="tok-kw">return</span>;</span>
<span class="line" id="L2148">            };</span>
<span class="line" id="L2149">            <span class="tok-kw">for</span> (t.addrs[<span class="tok-number">0</span>..end], <span class="tok-number">0</span>..) |frames_array, i| {</span>
<span class="line" id="L2150">                stderr.print(<span class="tok-str">&quot;{s}:\n&quot;</span>, .{t.notes[i]}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L2151">                <span class="tok-kw">var</span> frames_array_mutable = frames_array;</span>
<span class="line" id="L2152">                <span class="tok-kw">const</span> frames = mem.sliceTo(frames_array_mutable[<span class="tok-number">0</span>..], <span class="tok-number">0</span>);</span>
<span class="line" id="L2153">                <span class="tok-kw">const</span> stack_trace: std.builtin.StackTrace = .{</span>
<span class="line" id="L2154">                    .index = frames.len,</span>
<span class="line" id="L2155">                    .instruction_addresses = frames,</span>
<span class="line" id="L2156">                };</span>
<span class="line" id="L2157">                writeStackTrace(stack_trace, stderr, getDebugInfoAllocator(), debug_info, tty_config) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L2158">            }</span>
<span class="line" id="L2159">            <span class="tok-kw">if</span> (t.index &gt; end) {</span>
<span class="line" id="L2160">                stderr.print(<span class="tok-str">&quot;{d} more traces not shown; consider increasing trace size\n&quot;</span>, .{</span>
<span class="line" id="L2161">                    t.index - end,</span>
<span class="line" id="L2162">                }) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L2163">            }</span>
<span class="line" id="L2164">        }</span>
<span class="line" id="L2165"></span>
<span class="line" id="L2166">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(</span>
<span class="line" id="L2167">            t: Trace,</span>
<span class="line" id="L2168">            <span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2169">            options: std.fmt.FormatOptions,</span>
<span class="line" id="L2170">            writer: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L2171">        ) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2172">            <span class="tok-kw">if</span> (fmt.len != <span class="tok-number">0</span>) std.fmt.invalidFmtError(fmt, t);</span>
<span class="line" id="L2173">            _ = options;</span>
<span class="line" id="L2174">            <span class="tok-kw">if</span> (enabled) {</span>
<span class="line" id="L2175">                <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;\n&quot;</span>);</span>
<span class="line" id="L2176">                t.dump();</span>
<span class="line" id="L2177">                <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;\n&quot;</span>);</span>
<span class="line" id="L2178">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2179">                <span class="tok-kw">return</span> writer.writeAll(<span class="tok-str">&quot;(value tracing disabled)&quot;</span>);</span>
<span class="line" id="L2180">            }</span>
<span class="line" id="L2181">        }</span>
<span class="line" id="L2182">    };</span>
<span class="line" id="L2183">}</span>
<span class="line" id="L2184"></span>
</code></pre></body>
</html>