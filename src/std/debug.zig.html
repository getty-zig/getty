<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>debug.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAPNJREFUeNpi/P//PwMlgOXHUjly9E0G4hwgZmQiQZMqEK8H4v9QzUEgQSaoADK+zhH9iAGL+C0gDoAaNg9mGLoLfgA1awK9hS9gzgJxA9RQBmQDrgMxJzRMGKE4HYj/Ial5A8QmQLwCJoBsgBYW2+TR1ChDaWt4LOBxKsi/VUh8XiD+gq4IVyzwQAMJBoKwacZlAB8Qf0bi96IZhtOAe1D6LpqaEiz6rmEzQAeIzwGxCJpieFqApo/vQKyJboAaEBsAsSEupwI1MwKjGBTVHOhegMX5UajYRqiBjMgYmj400cVh0XgTiKdC0zhJgJHS7AwQYABm9EAdCKrEfAAAAABJRU5ErkJggg=="/>
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std.zig&quot;</span>);</span>
<span class="line" id="L2"><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);</span>
<span class="line" id="L3"><span class="tok-kw">const</span> math = std.math;</span>
<span class="line" id="L4"><span class="tok-kw">const</span> mem = std.mem;</span>
<span class="line" id="L5"><span class="tok-kw">const</span> io = std.io;</span>
<span class="line" id="L6"><span class="tok-kw">const</span> os = std.os;</span>
<span class="line" id="L7"><span class="tok-kw">const</span> fs = std.fs;</span>
<span class="line" id="L8"><span class="tok-kw">const</span> testing = std.testing;</span>
<span class="line" id="L9"><span class="tok-kw">const</span> elf = std.elf;</span>
<span class="line" id="L10"><span class="tok-kw">const</span> DW = std.dwarf;</span>
<span class="line" id="L11"><span class="tok-kw">const</span> macho = std.macho;</span>
<span class="line" id="L12"><span class="tok-kw">const</span> coff = std.coff;</span>
<span class="line" id="L13"><span class="tok-kw">const</span> pdb = std.pdb;</span>
<span class="line" id="L14"><span class="tok-kw">const</span> ArrayList = std.ArrayList;</span>
<span class="line" id="L15"><span class="tok-kw">const</span> root = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;root&quot;</span>);</span>
<span class="line" id="L16"><span class="tok-kw">const</span> maxInt = std.math.maxInt;</span>
<span class="line" id="L17"><span class="tok-kw">const</span> File = std.fs.File;</span>
<span class="line" id="L18"><span class="tok-kw">const</span> windows = std.os.windows;</span>
<span class="line" id="L19"><span class="tok-kw">const</span> native_arch = builtin.cpu.arch;</span>
<span class="line" id="L20"><span class="tok-kw">const</span> native_os = builtin.os.tag;</span>
<span class="line" id="L21"><span class="tok-kw">const</span> native_endian = native_arch.endian();</span>
<span class="line" id="L22"></span>
<span class="line" id="L23"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> runtime_safety = <span class="tok-kw">switch</span> (builtin.mode) {</span>
<span class="line" id="L24">    .Debug, .ReleaseSafe =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L25">    .ReleaseFast, .ReleaseSmall =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L26">};</span>
<span class="line" id="L27"></span>
<span class="line" id="L28"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> sys_can_stack_trace = <span class="tok-kw">switch</span> (builtin.cpu.arch) {</span>
<span class="line" id="L29">    <span class="tok-comment">// Observed to go into an infinite loop.</span>
</span>
<span class="line" id="L30">    <span class="tok-comment">// TODO: Make this work.</span>
</span>
<span class="line" id="L31">    .mips,</span>
<span class="line" id="L32">    .mipsel,</span>
<span class="line" id="L33">    =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L34"></span>
<span class="line" id="L35">    <span class="tok-comment">// `@returnAddress()` in LLVM 10 gives</span>
</span>
<span class="line" id="L36">    <span class="tok-comment">// &quot;Non-Emscripten WebAssembly hasn't implemented __builtin_return_address&quot;.</span>
</span>
<span class="line" id="L37">    .wasm32,</span>
<span class="line" id="L38">    .wasm64,</span>
<span class="line" id="L39">    =&gt; builtin.os.tag == .emscripten,</span>
<span class="line" id="L40"></span>
<span class="line" id="L41">    <span class="tok-comment">// `@returnAddress()` is unsupported in LLVM 13.</span>
</span>
<span class="line" id="L42">    .bpfel,</span>
<span class="line" id="L43">    .bpfeb,</span>
<span class="line" id="L44">    =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L45"></span>
<span class="line" id="L46">    <span class="tok-kw">else</span> =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L47">};</span>
<span class="line" id="L48"></span>
<span class="line" id="L49"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> LineInfo = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L50">    line: <span class="tok-type">u64</span>,</span>
<span class="line" id="L51">    column: <span class="tok-type">u64</span>,</span>
<span class="line" id="L52">    file_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L53"></span>
<span class="line" id="L54">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: LineInfo, allocator: mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L55">        allocator.free(self.file_name);</span>
<span class="line" id="L56">    }</span>
<span class="line" id="L57">};</span>
<span class="line" id="L58"></span>
<span class="line" id="L59"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SymbolInfo = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L60">    symbol_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;???&quot;</span>,</span>
<span class="line" id="L61">    compile_unit_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;???&quot;</span>,</span>
<span class="line" id="L62">    line_info: ?LineInfo = <span class="tok-null">null</span>,</span>
<span class="line" id="L63"></span>
<span class="line" id="L64">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: SymbolInfo, allocator: mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L65">        <span class="tok-kw">if</span> (self.line_info) |li| {</span>
<span class="line" id="L66">            li.deinit(allocator);</span>
<span class="line" id="L67">        }</span>
<span class="line" id="L68">    }</span>
<span class="line" id="L69">};</span>
<span class="line" id="L70"><span class="tok-kw">const</span> PdbOrDwarf = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L71">    pdb: pdb.Pdb,</span>
<span class="line" id="L72">    dwarf: DW.DwarfInfo,</span>
<span class="line" id="L73"></span>
<span class="line" id="L74">    <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *PdbOrDwarf, allocator: mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L75">        <span class="tok-kw">switch</span> (self.*) {</span>
<span class="line" id="L76">            .pdb =&gt; |*inner| inner.deinit(),</span>
<span class="line" id="L77">            .dwarf =&gt; |*inner| inner.deinit(allocator),</span>
<span class="line" id="L78">        }</span>
<span class="line" id="L79">    }</span>
<span class="line" id="L80">};</span>
<span class="line" id="L81"></span>
<span class="line" id="L82"><span class="tok-kw">var</span> stderr_mutex = std.Thread.Mutex{};</span>
<span class="line" id="L83"></span>
<span class="line" id="L84"><span class="tok-comment">/// Print to stderr, unbuffered, and silently returning on failure. Intended</span></span>
<span class="line" id="L85"><span class="tok-comment">/// for use in &quot;printf debugging.&quot; Use `std.log` functions for proper logging.</span></span>
<span class="line" id="L86"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">print</span>(<span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L87">    stderr_mutex.lock();</span>
<span class="line" id="L88">    <span class="tok-kw">defer</span> stderr_mutex.unlock();</span>
<span class="line" id="L89">    <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L90">    <span class="tok-kw">nosuspend</span> stderr.print(fmt, args) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L91">}</span>
<span class="line" id="L92"></span>
<span class="line" id="L93"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getStderrMutex</span>() *std.Thread.Mutex {</span>
<span class="line" id="L94">    <span class="tok-kw">return</span> &amp;stderr_mutex;</span>
<span class="line" id="L95">}</span>
<span class="line" id="L96"></span>
<span class="line" id="L97"><span class="tok-comment">/// TODO multithreaded awareness</span></span>
<span class="line" id="L98"><span class="tok-kw">var</span> self_debug_info: ?DebugInfo = <span class="tok-null">null</span>;</span>
<span class="line" id="L99"></span>
<span class="line" id="L100"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSelfDebugInfo</span>() !*DebugInfo {</span>
<span class="line" id="L101">    <span class="tok-kw">if</span> (self_debug_info) |*info| {</span>
<span class="line" id="L102">        <span class="tok-kw">return</span> info;</span>
<span class="line" id="L103">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L104">        self_debug_info = <span class="tok-kw">try</span> openSelfDebugInfo(getDebugInfoAllocator());</span>
<span class="line" id="L105">        <span class="tok-kw">return</span> &amp;self_debug_info.?;</span>
<span class="line" id="L106">    }</span>
<span class="line" id="L107">}</span>
<span class="line" id="L108"></span>
<span class="line" id="L109"><span class="tok-comment">/// Tries to print the current stack trace to stderr, unbuffered, and ignores any error returned.</span></span>
<span class="line" id="L110"><span class="tok-comment">/// TODO multithreaded awareness</span></span>
<span class="line" id="L111"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpCurrentStackTrace</span>(start_addr: ?<span class="tok-type">usize</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L112">    <span class="tok-kw">nosuspend</span> {</span>
<span class="line" id="L113">        <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> builtin.target.isWasm()) {</span>
<span class="line" id="L114">            <span class="tok-kw">if</span> (native_os == .wasi) {</span>
<span class="line" id="L115">                <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L116">                stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: not implemented for Wasm\n&quot;</span>, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L117">            }</span>
<span class="line" id="L118">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L119">        }</span>
<span class="line" id="L120">        <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L121">        <span class="tok-kw">if</span> (builtin.strip_debug_info) {</span>
<span class="line" id="L122">            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: debug info stripped\n&quot;</span>, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L123">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L124">        }</span>
<span class="line" id="L125">        <span class="tok-kw">const</span> debug_info = getSelfDebugInfo() <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L126">            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: Unable to open debug info: {s}\n&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L127">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L128">        };</span>
<span class="line" id="L129">        writeCurrentStackTrace(stderr, debug_info, io.tty.detectConfig(io.getStdErr()), start_addr) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L130">            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: {s}\n&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L131">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L132">        };</span>
<span class="line" id="L133">    }</span>
<span class="line" id="L134">}</span>
<span class="line" id="L135"></span>
<span class="line" id="L136"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> have_ucontext = <span class="tok-builtin">@hasDecl</span>(os.system, <span class="tok-str">&quot;ucontext_t&quot;</span>) <span class="tok-kw">and</span></span>
<span class="line" id="L137">    (builtin.os.tag != .linux <span class="tok-kw">or</span> <span class="tok-kw">switch</span> (builtin.cpu.arch) {</span>
<span class="line" id="L138">    .mips, .mipsel, .mips64, .mips64el, .riscv64 =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L139">    <span class="tok-kw">else</span> =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L140">});</span>
<span class="line" id="L141"></span>
<span class="line" id="L142"><span class="tok-comment">/// Platform-specific thread state. This contains register state, and on some platforms</span></span>
<span class="line" id="L143"><span class="tok-comment">/// information about the stack. This is not safe to trivially copy, because some platforms</span></span>
<span class="line" id="L144"><span class="tok-comment">/// use internal pointers within this structure. To make a copy, use `copyContext`.</span></span>
<span class="line" id="L145"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ThreadContext = blk: {</span>
<span class="line" id="L146">    <span class="tok-kw">if</span> (native_os == .windows) {</span>
<span class="line" id="L147">        <span class="tok-kw">break</span> :blk std.os.windows.CONTEXT;</span>
<span class="line" id="L148">    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (have_ucontext) {</span>
<span class="line" id="L149">        <span class="tok-kw">break</span> :blk os.ucontext_t;</span>
<span class="line" id="L150">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L151">        <span class="tok-kw">break</span> :blk <span class="tok-type">void</span>;</span>
<span class="line" id="L152">    }</span>
<span class="line" id="L153">};</span>
<span class="line" id="L154"></span>
<span class="line" id="L155"><span class="tok-comment">/// Copies one context to another, updating any internal pointers</span></span>
<span class="line" id="L156"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copyContext</span>(source: *<span class="tok-kw">const</span> ThreadContext, dest: *ThreadContext) <span class="tok-type">void</span> {</span>
<span class="line" id="L157">    <span class="tok-kw">if</span> (!have_ucontext) <span class="tok-kw">return</span> {};</span>
<span class="line" id="L158">    dest.* = source.*;</span>
<span class="line" id="L159">    relocateContext(dest);</span>
<span class="line" id="L160">}</span>
<span class="line" id="L161"></span>
<span class="line" id="L162"><span class="tok-comment">/// Updates any internal pointers in the context to reflect its current location</span></span>
<span class="line" id="L163"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">relocateContext</span>(context: *ThreadContext) <span class="tok-type">void</span> {</span>
<span class="line" id="L164">    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (native_os) {</span>
<span class="line" id="L165">        .macos =&gt; {</span>
<span class="line" id="L166">            context.mcontext = &amp;context.__mcontext_data;</span>
<span class="line" id="L167">        },</span>
<span class="line" id="L168">        <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L169">    };</span>
<span class="line" id="L170">}</span>
<span class="line" id="L171"></span>
<span class="line" id="L172"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> have_getcontext = <span class="tok-builtin">@hasDecl</span>(os.system, <span class="tok-str">&quot;getcontext&quot;</span>) <span class="tok-kw">and</span></span>
<span class="line" id="L173">    (builtin.os.tag != .linux <span class="tok-kw">or</span> <span class="tok-kw">switch</span> (builtin.cpu.arch) {</span>
<span class="line" id="L174">    .x86,</span>
<span class="line" id="L175">    .x86_64,</span>
<span class="line" id="L176">    =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L177">    <span class="tok-kw">else</span> =&gt; builtin.link_libc <span class="tok-kw">and</span> !builtin.target.isMusl(),</span>
<span class="line" id="L178">});</span>
<span class="line" id="L179"></span>
<span class="line" id="L180"><span class="tok-comment">/// Capture the current context. The register values in the context will reflect the</span></span>
<span class="line" id="L181"><span class="tok-comment">/// state after the platform `getcontext` function returns.</span></span>
<span class="line" id="L182"><span class="tok-comment">///</span></span>
<span class="line" id="L183"><span class="tok-comment">/// It is valid to call this if the platform doesn't have context capturing support,</span></span>
<span class="line" id="L184"><span class="tok-comment">/// in that case false will be returned.</span></span>
<span class="line" id="L185"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">getContext</span>(context: *ThreadContext) <span class="tok-type">bool</span> {</span>
<span class="line" id="L186">    <span class="tok-kw">if</span> (native_os == .windows) {</span>
<span class="line" id="L187">        context.* = std.mem.zeroes(windows.CONTEXT);</span>
<span class="line" id="L188">        windows.ntdll.RtlCaptureContext(context);</span>
<span class="line" id="L189">        <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L190">    }</span>
<span class="line" id="L191"></span>
<span class="line" id="L192">    <span class="tok-kw">const</span> result = have_getcontext <span class="tok-kw">and</span> os.system.getcontext(context) == <span class="tok-number">0</span>;</span>
<span class="line" id="L193">    <span class="tok-kw">if</span> (native_os == .macos) {</span>
<span class="line" id="L194">        assert(context.mcsize == <span class="tok-builtin">@sizeOf</span>(std.c.mcontext_t));</span>
<span class="line" id="L195"></span>
<span class="line" id="L196">        <span class="tok-comment">// On aarch64-macos, the system getcontext doesn't write anything into the pc</span>
</span>
<span class="line" id="L197">        <span class="tok-comment">// register slot, it only writes lr. This makes the context consistent with</span>
</span>
<span class="line" id="L198">        <span class="tok-comment">// other aarch64 getcontext implementations which write the current lr</span>
</span>
<span class="line" id="L199">        <span class="tok-comment">// (where getcontext will return to) into both the lr and pc slot of the context.</span>
</span>
<span class="line" id="L200">        <span class="tok-kw">if</span> (native_arch == .aarch64) context.mcontext.ss.pc = context.mcontext.ss.lr;</span>
<span class="line" id="L201">    }</span>
<span class="line" id="L202"></span>
<span class="line" id="L203">    <span class="tok-kw">return</span> result;</span>
<span class="line" id="L204">}</span>
<span class="line" id="L205"></span>
<span class="line" id="L206"><span class="tok-comment">/// Tries to print the stack trace starting from the supplied base pointer to stderr,</span></span>
<span class="line" id="L207"><span class="tok-comment">/// unbuffered, and ignores any error returned.</span></span>
<span class="line" id="L208"><span class="tok-comment">/// TODO multithreaded awareness</span></span>
<span class="line" id="L209"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpStackTraceFromBase</span>(context: *<span class="tok-kw">const</span> ThreadContext) <span class="tok-type">void</span> {</span>
<span class="line" id="L210">    <span class="tok-kw">nosuspend</span> {</span>
<span class="line" id="L211">        <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> builtin.target.isWasm()) {</span>
<span class="line" id="L212">            <span class="tok-kw">if</span> (native_os == .wasi) {</span>
<span class="line" id="L213">                <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L214">                stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: not implemented for Wasm\n&quot;</span>, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L215">            }</span>
<span class="line" id="L216">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L217">        }</span>
<span class="line" id="L218">        <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L219">        <span class="tok-kw">if</span> (builtin.strip_debug_info) {</span>
<span class="line" id="L220">            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: debug info stripped\n&quot;</span>, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L221">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L222">        }</span>
<span class="line" id="L223">        <span class="tok-kw">const</span> debug_info = getSelfDebugInfo() <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L224">            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: Unable to open debug info: {s}\n&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L225">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L226">        };</span>
<span class="line" id="L227">        <span class="tok-kw">const</span> tty_config = io.tty.detectConfig(io.getStdErr());</span>
<span class="line" id="L228">        <span class="tok-kw">if</span> (native_os == .windows) {</span>
<span class="line" id="L229">            <span class="tok-comment">// On x86_64 and aarch64, the stack will be unwound using RtlVirtualUnwind using the context</span>
</span>
<span class="line" id="L230">            <span class="tok-comment">// provided by the exception handler. On x86, RtlVirtualUnwind doesn't exist. Instead, a new backtrace</span>
</span>
<span class="line" id="L231">            <span class="tok-comment">// will be captured and frames prior to the exception will be filtered.</span>
</span>
<span class="line" id="L232">            <span class="tok-comment">// The caveat is that RtlCaptureStackBackTrace does not include the KiUserExceptionDispatcher frame,</span>
</span>
<span class="line" id="L233">            <span class="tok-comment">// which is where the IP in `context` points to, so it can't be used as start_addr.</span>
</span>
<span class="line" id="L234">            <span class="tok-comment">// Instead, start_addr is recovered from the stack.</span>
</span>
<span class="line" id="L235">            <span class="tok-kw">const</span> start_addr = <span class="tok-kw">if</span> (builtin.cpu.arch == .x86) <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(context.getRegs().bp + <span class="tok-number">4</span>)).* <span class="tok-kw">else</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L236">            writeStackTraceWindows(stderr, debug_info, tty_config, context, start_addr) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L237">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L238">        }</span>
<span class="line" id="L239"></span>
<span class="line" id="L240">        <span class="tok-kw">var</span> it = StackIterator.initWithContext(<span class="tok-null">null</span>, debug_info, context) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L241">        <span class="tok-kw">defer</span> it.deinit();</span>
<span class="line" id="L242">        printSourceAtAddress(debug_info, stderr, it.unwind_state.?.dwarf_context.pc, tty_config) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L243"></span>
<span class="line" id="L244">        <span class="tok-kw">while</span> (it.next()) |return_address| {</span>
<span class="line" id="L245">            printLastUnwindError(&amp;it, debug_info, stderr, tty_config);</span>
<span class="line" id="L246"></span>
<span class="line" id="L247">            <span class="tok-comment">// On arm64 macOS, the address of the last frame is 0x0 rather than 0x1 as on x86_64 macOS,</span>
</span>
<span class="line" id="L248">            <span class="tok-comment">// therefore, we do a check for `return_address == 0` before subtracting 1 from it to avoid</span>
</span>
<span class="line" id="L249">            <span class="tok-comment">// an overflow. We do not need to signal `StackIterator` as it will correctly detect this</span>
</span>
<span class="line" id="L250">            <span class="tok-comment">// condition on the subsequent iteration and return `null` thus terminating the loop.</span>
</span>
<span class="line" id="L251">            <span class="tok-comment">// same behaviour for x86-windows-msvc</span>
</span>
<span class="line" id="L252">            <span class="tok-kw">const</span> address = <span class="tok-kw">if</span> (return_address == <span class="tok-number">0</span>) return_address <span class="tok-kw">else</span> return_address - <span class="tok-number">1</span>;</span>
<span class="line" id="L253">            printSourceAtAddress(debug_info, stderr, address, tty_config) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L254">        } <span class="tok-kw">else</span> printLastUnwindError(&amp;it, debug_info, stderr, tty_config);</span>
<span class="line" id="L255">    }</span>
<span class="line" id="L256">}</span>
<span class="line" id="L257"></span>
<span class="line" id="L258"><span class="tok-comment">/// Returns a slice with the same pointer as addresses, with a potentially smaller len.</span></span>
<span class="line" id="L259"><span class="tok-comment">/// On Windows, when first_address is not null, we ask for at least 32 stack frames,</span></span>
<span class="line" id="L260"><span class="tok-comment">/// and then try to find the first address. If addresses.len is more than 32, we</span></span>
<span class="line" id="L261"><span class="tok-comment">/// capture that many stack frames exactly, and then look for the first address,</span></span>
<span class="line" id="L262"><span class="tok-comment">/// chopping off the irrelevant frames and shifting so that the returned addresses pointer</span></span>
<span class="line" id="L263"><span class="tok-comment">/// equals the passed in addresses pointer.</span></span>
<span class="line" id="L264"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">captureStackTrace</span>(first_address: ?<span class="tok-type">usize</span>, stack_trace: *std.builtin.StackTrace) <span class="tok-type">void</span> {</span>
<span class="line" id="L265">    <span class="tok-kw">if</span> (native_os == .windows) {</span>
<span class="line" id="L266">        <span class="tok-kw">const</span> addrs = stack_trace.instruction_addresses;</span>
<span class="line" id="L267">        <span class="tok-kw">const</span> first_addr = first_address <span class="tok-kw">orelse</span> {</span>
<span class="line" id="L268">            stack_trace.index = walkStackWindows(addrs[<span class="tok-number">0</span>..], <span class="tok-null">null</span>);</span>
<span class="line" id="L269">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L270">        };</span>
<span class="line" id="L271">        <span class="tok-kw">var</span> addr_buf_stack: [<span class="tok-number">32</span>]<span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L272">        <span class="tok-kw">const</span> addr_buf = <span class="tok-kw">if</span> (addr_buf_stack.len &gt; addrs.len) addr_buf_stack[<span class="tok-number">0</span>..] <span class="tok-kw">else</span> addrs;</span>
<span class="line" id="L273">        <span class="tok-kw">const</span> n = walkStackWindows(addr_buf[<span class="tok-number">0</span>..], <span class="tok-null">null</span>);</span>
<span class="line" id="L274">        <span class="tok-kw">const</span> first_index = <span class="tok-kw">for</span> (addr_buf[<span class="tok-number">0</span>..n], <span class="tok-number">0</span>..) |addr, i| {</span>
<span class="line" id="L275">            <span class="tok-kw">if</span> (addr == first_addr) {</span>
<span class="line" id="L276">                <span class="tok-kw">break</span> i;</span>
<span class="line" id="L277">            }</span>
<span class="line" id="L278">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L279">            stack_trace.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L280">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L281">        };</span>
<span class="line" id="L282">        <span class="tok-kw">const</span> end_index = <span class="tok-builtin">@min</span>(first_index + addrs.len, n);</span>
<span class="line" id="L283">        <span class="tok-kw">const</span> slice = addr_buf[first_index..end_index];</span>
<span class="line" id="L284">        <span class="tok-comment">// We use a for loop here because slice and addrs may alias.</span>
</span>
<span class="line" id="L285">        <span class="tok-kw">for</span> (slice, <span class="tok-number">0</span>..) |addr, i| {</span>
<span class="line" id="L286">            addrs[i] = addr;</span>
<span class="line" id="L287">        }</span>
<span class="line" id="L288">        stack_trace.index = slice.len;</span>
<span class="line" id="L289">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L290">        <span class="tok-comment">// TODO: This should use the DWARF unwinder if .eh_frame_hdr is available (so that full debug info parsing isn't required).</span>
</span>
<span class="line" id="L291">        <span class="tok-comment">//       A new path for loading DebugInfo needs to be created which will only attempt to parse in-memory sections, because</span>
</span>
<span class="line" id="L292">        <span class="tok-comment">//       stopping to load other debug info (ie. source line info) from disk here is not required for unwinding.</span>
</span>
<span class="line" id="L293">        <span class="tok-kw">var</span> it = StackIterator.init(first_address, <span class="tok-null">null</span>);</span>
<span class="line" id="L294">        <span class="tok-kw">defer</span> it.deinit();</span>
<span class="line" id="L295">        <span class="tok-kw">for</span> (stack_trace.instruction_addresses, <span class="tok-number">0</span>..) |*addr, i| {</span>
<span class="line" id="L296">            addr.* = it.next() <span class="tok-kw">orelse</span> {</span>
<span class="line" id="L297">                stack_trace.index = i;</span>
<span class="line" id="L298">                <span class="tok-kw">return</span>;</span>
<span class="line" id="L299">            };</span>
<span class="line" id="L300">        }</span>
<span class="line" id="L301">        stack_trace.index = stack_trace.instruction_addresses.len;</span>
<span class="line" id="L302">    }</span>
<span class="line" id="L303">}</span>
<span class="line" id="L304"></span>
<span class="line" id="L305"><span class="tok-comment">/// Tries to print a stack trace to stderr, unbuffered, and ignores any error returned.</span></span>
<span class="line" id="L306"><span class="tok-comment">/// TODO multithreaded awareness</span></span>
<span class="line" id="L307"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpStackTrace</span>(stack_trace: std.builtin.StackTrace) <span class="tok-type">void</span> {</span>
<span class="line" id="L308">    <span class="tok-kw">nosuspend</span> {</span>
<span class="line" id="L309">        <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> builtin.target.isWasm()) {</span>
<span class="line" id="L310">            <span class="tok-kw">if</span> (native_os == .wasi) {</span>
<span class="line" id="L311">                <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L312">                stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: not implemented for Wasm\n&quot;</span>, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L313">            }</span>
<span class="line" id="L314">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L315">        }</span>
<span class="line" id="L316">        <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L317">        <span class="tok-kw">if</span> (builtin.strip_debug_info) {</span>
<span class="line" id="L318">            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: debug info stripped\n&quot;</span>, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L319">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L320">        }</span>
<span class="line" id="L321">        <span class="tok-kw">const</span> debug_info = getSelfDebugInfo() <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L322">            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: Unable to open debug info: {s}\n&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L323">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L324">        };</span>
<span class="line" id="L325">        writeStackTrace(stack_trace, stderr, getDebugInfoAllocator(), debug_info, io.tty.detectConfig(io.getStdErr())) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L326">            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: {s}\n&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L327">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L328">        };</span>
<span class="line" id="L329">    }</span>
<span class="line" id="L330">}</span>
<span class="line" id="L331"></span>
<span class="line" id="L332"><span class="tok-comment">/// This function invokes undefined behavior when `ok` is `false`.</span></span>
<span class="line" id="L333"><span class="tok-comment">/// In Debug and ReleaseSafe modes, calls to this function are always</span></span>
<span class="line" id="L334"><span class="tok-comment">/// generated, and the `unreachable` statement triggers a panic.</span></span>
<span class="line" id="L335"><span class="tok-comment">/// In ReleaseFast and ReleaseSmall modes, calls to this function are</span></span>
<span class="line" id="L336"><span class="tok-comment">/// optimized away, and in fact the optimizer is able to use the assertion</span></span>
<span class="line" id="L337"><span class="tok-comment">/// in its heuristics.</span></span>
<span class="line" id="L338"><span class="tok-comment">/// Inside a test block, it is best to use the `std.testing` module rather</span></span>
<span class="line" id="L339"><span class="tok-comment">/// than this function, because this function may not detect a test failure</span></span>
<span class="line" id="L340"><span class="tok-comment">/// in ReleaseFast and ReleaseSmall mode. Outside of a test block, this assert</span></span>
<span class="line" id="L341"><span class="tok-comment">/// function is the correct function to use.</span></span>
<span class="line" id="L342"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">assert</span>(ok: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L343">    <span class="tok-kw">if</span> (!ok) <span class="tok-kw">unreachable</span>; <span class="tok-comment">// assertion failure</span>
</span>
<span class="line" id="L344">}</span>
<span class="line" id="L345"></span>
<span class="line" id="L346"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">panic</span>(<span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) <span class="tok-type">noreturn</span> {</span>
<span class="line" id="L347">    <span class="tok-builtin">@setCold</span>(<span class="tok-null">true</span>);</span>
<span class="line" id="L348"></span>
<span class="line" id="L349">    panicExtra(<span class="tok-null">null</span>, <span class="tok-null">null</span>, format, args);</span>
<span class="line" id="L350">}</span>
<span class="line" id="L351"></span>
<span class="line" id="L352"><span class="tok-comment">/// `panicExtra` is useful when you want to print out an `@errorReturnTrace`</span></span>
<span class="line" id="L353"><span class="tok-comment">/// and also print out some values.</span></span>
<span class="line" id="L354"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">panicExtra</span>(</span>
<span class="line" id="L355">    trace: ?*std.builtin.StackTrace,</span>
<span class="line" id="L356">    ret_addr: ?<span class="tok-type">usize</span>,</span>
<span class="line" id="L357">    <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L358">    args: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L359">) <span class="tok-type">noreturn</span> {</span>
<span class="line" id="L360">    <span class="tok-builtin">@setCold</span>(<span class="tok-null">true</span>);</span>
<span class="line" id="L361"></span>
<span class="line" id="L362">    <span class="tok-kw">const</span> size = <span class="tok-number">0x1000</span>;</span>
<span class="line" id="L363">    <span class="tok-kw">const</span> trunc_msg = <span class="tok-str">&quot;(msg truncated)&quot;</span>;</span>
<span class="line" id="L364">    <span class="tok-kw">var</span> buf: [size + trunc_msg.len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L365">    <span class="tok-comment">// a minor annoyance with this is that it will result in the NoSpaceLeft</span>
</span>
<span class="line" id="L366">    <span class="tok-comment">// error being part of the @panic stack trace (but that error should</span>
</span>
<span class="line" id="L367">    <span class="tok-comment">// only happen rarely)</span>
</span>
<span class="line" id="L368">    <span class="tok-kw">const</span> msg = std.fmt.bufPrint(buf[<span class="tok-number">0</span>..size], format, args) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L369">        <span class="tok-kw">error</span>.NoSpaceLeft =&gt; blk: {</span>
<span class="line" id="L370">            <span class="tok-builtin">@memcpy</span>(buf[size..], trunc_msg);</span>
<span class="line" id="L371">            <span class="tok-kw">break</span> :blk &amp;buf;</span>
<span class="line" id="L372">        },</span>
<span class="line" id="L373">    };</span>
<span class="line" id="L374">    std.builtin.panic(msg, trace, ret_addr);</span>
<span class="line" id="L375">}</span>
<span class="line" id="L376"></span>
<span class="line" id="L377"><span class="tok-comment">/// Non-zero whenever the program triggered a panic.</span></span>
<span class="line" id="L378"><span class="tok-comment">/// The counter is incremented/decremented atomically.</span></span>
<span class="line" id="L379"><span class="tok-kw">var</span> panicking = std.atomic.Atomic(<span class="tok-type">u8</span>).init(<span class="tok-number">0</span>);</span>
<span class="line" id="L380"></span>
<span class="line" id="L381"><span class="tok-comment">// Locked to avoid interleaving panic messages from multiple threads.</span>
</span>
<span class="line" id="L382"><span class="tok-kw">var</span> panic_mutex = std.Thread.Mutex{};</span>
<span class="line" id="L383"></span>
<span class="line" id="L384"><span class="tok-comment">/// Counts how many times the panic handler is invoked by this thread.</span></span>
<span class="line" id="L385"><span class="tok-comment">/// This is used to catch and handle panics triggered by the panic handler.</span></span>
<span class="line" id="L386"><span class="tok-kw">threadlocal</span> <span class="tok-kw">var</span> panic_stage: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L387"></span>
<span class="line" id="L388"><span class="tok-comment">// `panicImpl` could be useful in implementing a custom panic handler which</span>
</span>
<span class="line" id="L389"><span class="tok-comment">// calls the default handler (on supported platforms)</span>
</span>
<span class="line" id="L390"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">panicImpl</span>(trace: ?*<span class="tok-kw">const</span> std.builtin.StackTrace, first_trace_addr: ?<span class="tok-type">usize</span>, msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">noreturn</span> {</span>
<span class="line" id="L391">    <span class="tok-builtin">@setCold</span>(<span class="tok-null">true</span>);</span>
<span class="line" id="L392"></span>
<span class="line" id="L393">    <span class="tok-kw">if</span> (enable_segfault_handler) {</span>
<span class="line" id="L394">        <span class="tok-comment">// If a segfault happens while panicking, we want it to actually segfault, not trigger</span>
</span>
<span class="line" id="L395">        <span class="tok-comment">// the handler.</span>
</span>
<span class="line" id="L396">        resetSegfaultHandler();</span>
<span class="line" id="L397">    }</span>
<span class="line" id="L398"></span>
<span class="line" id="L399">    <span class="tok-comment">// Note there is similar logic in handleSegfaultPosix and handleSegfaultWindowsExtra.</span>
</span>
<span class="line" id="L400">    <span class="tok-kw">nosuspend</span> <span class="tok-kw">switch</span> (panic_stage) {</span>
<span class="line" id="L401">        <span class="tok-number">0</span> =&gt; {</span>
<span class="line" id="L402">            panic_stage = <span class="tok-number">1</span>;</span>
<span class="line" id="L403"></span>
<span class="line" id="L404">            _ = panicking.fetchAdd(<span class="tok-number">1</span>, .SeqCst);</span>
<span class="line" id="L405"></span>
<span class="line" id="L406">            <span class="tok-comment">// Make sure to release the mutex when done</span>
</span>
<span class="line" id="L407">            {</span>
<span class="line" id="L408">                panic_mutex.lock();</span>
<span class="line" id="L409">                <span class="tok-kw">defer</span> panic_mutex.unlock();</span>
<span class="line" id="L410"></span>
<span class="line" id="L411">                <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L412">                <span class="tok-kw">if</span> (builtin.single_threaded) {</span>
<span class="line" id="L413">                    stderr.print(<span class="tok-str">&quot;panic: &quot;</span>, .{}) <span class="tok-kw">catch</span> os.abort();</span>
<span class="line" id="L414">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L415">                    <span class="tok-kw">const</span> current_thread_id = std.Thread.getCurrentId();</span>
<span class="line" id="L416">                    stderr.print(<span class="tok-str">&quot;thread {} panic: &quot;</span>, .{current_thread_id}) <span class="tok-kw">catch</span> os.abort();</span>
<span class="line" id="L417">                }</span>
<span class="line" id="L418">                stderr.print(<span class="tok-str">&quot;{s}\n&quot;</span>, .{msg}) <span class="tok-kw">catch</span> os.abort();</span>
<span class="line" id="L419">                <span class="tok-kw">if</span> (trace) |t| {</span>
<span class="line" id="L420">                    dumpStackTrace(t.*);</span>
<span class="line" id="L421">                }</span>
<span class="line" id="L422">                dumpCurrentStackTrace(first_trace_addr);</span>
<span class="line" id="L423">            }</span>
<span class="line" id="L424"></span>
<span class="line" id="L425">            waitForOtherThreadToFinishPanicking();</span>
<span class="line" id="L426">        },</span>
<span class="line" id="L427">        <span class="tok-number">1</span> =&gt; {</span>
<span class="line" id="L428">            panic_stage = <span class="tok-number">2</span>;</span>
<span class="line" id="L429"></span>
<span class="line" id="L430">            <span class="tok-comment">// A panic happened while trying to print a previous panic message,</span>
</span>
<span class="line" id="L431">            <span class="tok-comment">// we're still holding the mutex but that's fine as we're going to</span>
</span>
<span class="line" id="L432">            <span class="tok-comment">// call abort()</span>
</span>
<span class="line" id="L433">            <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L434">            stderr.print(<span class="tok-str">&quot;Panicked during a panic. Aborting.\n&quot;</span>, .{}) <span class="tok-kw">catch</span> os.abort();</span>
<span class="line" id="L435">        },</span>
<span class="line" id="L436">        <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L437">            <span class="tok-comment">// Panicked while printing &quot;Panicked during a panic.&quot;</span>
</span>
<span class="line" id="L438">        },</span>
<span class="line" id="L439">    };</span>
<span class="line" id="L440"></span>
<span class="line" id="L441">    os.abort();</span>
<span class="line" id="L442">}</span>
<span class="line" id="L443"></span>
<span class="line" id="L444"><span class="tok-comment">/// Must be called only after adding 1 to `panicking`. There are three callsites.</span></span>
<span class="line" id="L445"><span class="tok-kw">fn</span> <span class="tok-fn">waitForOtherThreadToFinishPanicking</span>() <span class="tok-type">void</span> {</span>
<span class="line" id="L446">    <span class="tok-kw">if</span> (panicking.fetchSub(<span class="tok-number">1</span>, .SeqCst) != <span class="tok-number">1</span>) {</span>
<span class="line" id="L447">        <span class="tok-comment">// Another thread is panicking, wait for the last one to finish</span>
</span>
<span class="line" id="L448">        <span class="tok-comment">// and call abort()</span>
</span>
<span class="line" id="L449">        <span class="tok-kw">if</span> (builtin.single_threaded) <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L450"></span>
<span class="line" id="L451">        <span class="tok-comment">// Sleep forever without hammering the CPU</span>
</span>
<span class="line" id="L452">        <span class="tok-kw">var</span> futex = std.atomic.Atomic(<span class="tok-type">u32</span>).init(<span class="tok-number">0</span>);</span>
<span class="line" id="L453">        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) std.Thread.Futex.wait(&amp;futex, <span class="tok-number">0</span>);</span>
<span class="line" id="L454">        <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L455">    }</span>
<span class="line" id="L456">}</span>
<span class="line" id="L457"></span>
<span class="line" id="L458"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeStackTrace</span>(</span>
<span class="line" id="L459">    stack_trace: std.builtin.StackTrace,</span>
<span class="line" id="L460">    out_stream: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L461">    allocator: mem.Allocator,</span>
<span class="line" id="L462">    debug_info: *DebugInfo,</span>
<span class="line" id="L463">    tty_config: io.tty.Config,</span>
<span class="line" id="L464">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L465">    _ = allocator;</span>
<span class="line" id="L466">    <span class="tok-kw">if</span> (builtin.strip_debug_info) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L467">    <span class="tok-kw">var</span> frame_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L468">    <span class="tok-kw">var</span> frames_left: <span class="tok-type">usize</span> = <span class="tok-builtin">@min</span>(stack_trace.index, stack_trace.instruction_addresses.len);</span>
<span class="line" id="L469"></span>
<span class="line" id="L470">    <span class="tok-kw">while</span> (frames_left != <span class="tok-number">0</span>) : ({</span>
<span class="line" id="L471">        frames_left -= <span class="tok-number">1</span>;</span>
<span class="line" id="L472">        frame_index = (frame_index + <span class="tok-number">1</span>) % stack_trace.instruction_addresses.len;</span>
<span class="line" id="L473">    }) {</span>
<span class="line" id="L474">        <span class="tok-kw">const</span> return_address = stack_trace.instruction_addresses[frame_index];</span>
<span class="line" id="L475">        <span class="tok-kw">try</span> printSourceAtAddress(debug_info, out_stream, return_address - <span class="tok-number">1</span>, tty_config);</span>
<span class="line" id="L476">    }</span>
<span class="line" id="L477"></span>
<span class="line" id="L478">    <span class="tok-kw">if</span> (stack_trace.index &gt; stack_trace.instruction_addresses.len) {</span>
<span class="line" id="L479">        <span class="tok-kw">const</span> dropped_frames = stack_trace.index - stack_trace.instruction_addresses.len;</span>
<span class="line" id="L480"></span>
<span class="line" id="L481">        tty_config.setColor(out_stream, .bold) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L482">        <span class="tok-kw">try</span> out_stream.print(<span class="tok-str">&quot;({d} additional stack frames skipped...)\n&quot;</span>, .{dropped_frames});</span>
<span class="line" id="L483">        tty_config.setColor(out_stream, .reset) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L484">    }</span>
<span class="line" id="L485">}</span>
<span class="line" id="L486"></span>
<span class="line" id="L487"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> UnwindError = <span class="tok-kw">if</span> (have_ucontext)</span>
<span class="line" id="L488">    <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(StackIterator.next_unwind)).Fn.return_type.?).ErrorUnion.error_set</span>
<span class="line" id="L489"><span class="tok-kw">else</span></span>
<span class="line" id="L490">    <span class="tok-type">void</span>;</span>
<span class="line" id="L491"></span>
<span class="line" id="L492"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> StackIterator = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L493">    <span class="tok-comment">// Skip every frame before this address is found.</span>
</span>
<span class="line" id="L494">    first_address: ?<span class="tok-type">usize</span>,</span>
<span class="line" id="L495">    <span class="tok-comment">// Last known value of the frame pointer register.</span>
</span>
<span class="line" id="L496">    fp: <span class="tok-type">usize</span>,</span>
<span class="line" id="L497"></span>
<span class="line" id="L498">    <span class="tok-comment">// When DebugInfo and a register context is available, this iterator can unwind</span>
</span>
<span class="line" id="L499">    <span class="tok-comment">// stacks with frames that don't use a frame pointer (ie. -fomit-frame-pointer),</span>
</span>
<span class="line" id="L500">    <span class="tok-comment">// using DWARF and MachO unwind info.</span>
</span>
<span class="line" id="L501">    unwind_state: <span class="tok-kw">if</span> (have_ucontext) ?<span class="tok-kw">struct</span> {</span>
<span class="line" id="L502">        debug_info: *DebugInfo,</span>
<span class="line" id="L503">        dwarf_context: DW.UnwindContext,</span>
<span class="line" id="L504">        last_error: ?UnwindError = <span class="tok-null">null</span>,</span>
<span class="line" id="L505">        failed: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L506">    } <span class="tok-kw">else</span> <span class="tok-type">void</span> = <span class="tok-kw">if</span> (have_ucontext) <span class="tok-null">null</span> <span class="tok-kw">else</span> {},</span>
<span class="line" id="L507"></span>
<span class="line" id="L508">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(first_address: ?<span class="tok-type">usize</span>, fp: ?<span class="tok-type">usize</span>) StackIterator {</span>
<span class="line" id="L509">        <span class="tok-kw">if</span> (native_arch == .sparc64) {</span>
<span class="line" id="L510">            <span class="tok-comment">// Flush all the register windows on stack.</span>
</span>
<span class="line" id="L511">            <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (</span>
<span class="line" id="L512">                <span class="tok-str">\\ flushw</span></span>

<span class="line" id="L513">                ::: <span class="tok-str">&quot;memory&quot;</span>);</span>
<span class="line" id="L514">        }</span>
<span class="line" id="L515"></span>
<span class="line" id="L516">        <span class="tok-kw">return</span> StackIterator{</span>
<span class="line" id="L517">            .first_address = first_address,</span>
<span class="line" id="L518">            .fp = fp <span class="tok-kw">orelse</span> <span class="tok-builtin">@frameAddress</span>(),</span>
<span class="line" id="L519">        };</span>
<span class="line" id="L520">    }</span>
<span class="line" id="L521"></span>
<span class="line" id="L522">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initWithContext</span>(first_address: ?<span class="tok-type">usize</span>, debug_info: *DebugInfo, context: *<span class="tok-kw">const</span> os.ucontext_t) !StackIterator {</span>
<span class="line" id="L523">        <span class="tok-comment">// The implementation of DWARF unwinding on aarch64-macos is not complete. However, Apple mandates that</span>
</span>
<span class="line" id="L524">        <span class="tok-comment">// the frame pointer register is always used, so on this platform we can safely use the FP-based unwinder.</span>
</span>
<span class="line" id="L525">        <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> builtin.target.isDarwin() <span class="tok-kw">and</span> native_arch == .aarch64) {</span>
<span class="line" id="L526">            <span class="tok-kw">return</span> init(first_address, context.mcontext.ss.fp);</span>
<span class="line" id="L527">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L528">            <span class="tok-kw">var</span> iterator = init(first_address, <span class="tok-null">null</span>);</span>
<span class="line" id="L529">            iterator.unwind_state = .{</span>
<span class="line" id="L530">                .debug_info = debug_info,</span>
<span class="line" id="L531">                .dwarf_context = <span class="tok-kw">try</span> DW.UnwindContext.init(debug_info.allocator, context, &amp;isValidMemory),</span>
<span class="line" id="L532">            };</span>
<span class="line" id="L533"></span>
<span class="line" id="L534">            <span class="tok-kw">return</span> iterator;</span>
<span class="line" id="L535">        }</span>
<span class="line" id="L536">    }</span>
<span class="line" id="L537"></span>
<span class="line" id="L538">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *StackIterator) <span class="tok-type">void</span> {</span>
<span class="line" id="L539">        <span class="tok-kw">if</span> (have_ucontext <span class="tok-kw">and</span> self.unwind_state != <span class="tok-null">null</span>) self.unwind_state.?.dwarf_context.deinit();</span>
<span class="line" id="L540">    }</span>
<span class="line" id="L541"></span>
<span class="line" id="L542">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLastError</span>(self: *StackIterator) ?<span class="tok-kw">struct</span> {</span>
<span class="line" id="L543">        err: UnwindError,</span>
<span class="line" id="L544">        address: <span class="tok-type">usize</span>,</span>
<span class="line" id="L545">    } {</span>
<span class="line" id="L546">        <span class="tok-kw">if</span> (!have_ucontext) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L547">        <span class="tok-kw">if</span> (self.unwind_state) |*unwind_state| {</span>
<span class="line" id="L548">            <span class="tok-kw">if</span> (unwind_state.last_error) |err| {</span>
<span class="line" id="L549">                unwind_state.last_error = <span class="tok-null">null</span>;</span>
<span class="line" id="L550">                <span class="tok-kw">return</span> .{</span>
<span class="line" id="L551">                    .err = err,</span>
<span class="line" id="L552">                    .address = unwind_state.dwarf_context.pc,</span>
<span class="line" id="L553">                };</span>
<span class="line" id="L554">            }</span>
<span class="line" id="L555">        }</span>
<span class="line" id="L556"></span>
<span class="line" id="L557">        <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L558">    }</span>
<span class="line" id="L559"></span>
<span class="line" id="L560">    <span class="tok-comment">// Offset of the saved BP wrt the frame pointer.</span>
</span>
<span class="line" id="L561">    <span class="tok-kw">const</span> fp_offset = <span class="tok-kw">if</span> (native_arch.isRISCV())</span>
<span class="line" id="L562">        <span class="tok-comment">// On RISC-V the frame pointer points to the top of the saved register</span>
</span>
<span class="line" id="L563">        <span class="tok-comment">// area, on pretty much every other architecture it points to the stack</span>
</span>
<span class="line" id="L564">        <span class="tok-comment">// slot where the previous frame pointer is saved.</span>
</span>
<span class="line" id="L565">        <span class="tok-number">2</span> * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)</span>
<span class="line" id="L566">    <span class="tok-kw">else</span> <span class="tok-kw">if</span> (native_arch.isSPARC())</span>
<span class="line" id="L567">        <span class="tok-comment">// On SPARC the previous frame pointer is stored at 14 slots past %fp+BIAS.</span>
</span>
<span class="line" id="L568">        <span class="tok-number">14</span> * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)</span>
<span class="line" id="L569">    <span class="tok-kw">else</span></span>
<span class="line" id="L570">        <span class="tok-number">0</span>;</span>
<span class="line" id="L571"></span>
<span class="line" id="L572">    <span class="tok-kw">const</span> fp_bias = <span class="tok-kw">if</span> (native_arch.isSPARC())</span>
<span class="line" id="L573">        <span class="tok-comment">// On SPARC frame pointers are biased by a constant.</span>
</span>
<span class="line" id="L574">        <span class="tok-number">2047</span></span>
<span class="line" id="L575">    <span class="tok-kw">else</span></span>
<span class="line" id="L576">        <span class="tok-number">0</span>;</span>
<span class="line" id="L577"></span>
<span class="line" id="L578">    <span class="tok-comment">// Positive offset of the saved PC wrt the frame pointer.</span>
</span>
<span class="line" id="L579">    <span class="tok-kw">const</span> pc_offset = <span class="tok-kw">if</span> (native_arch == .powerpc64le)</span>
<span class="line" id="L580">        <span class="tok-number">2</span> * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)</span>
<span class="line" id="L581">    <span class="tok-kw">else</span></span>
<span class="line" id="L582">        <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);</span>
<span class="line" id="L583"></span>
<span class="line" id="L584">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *StackIterator) ?<span class="tok-type">usize</span> {</span>
<span class="line" id="L585">        <span class="tok-kw">var</span> address = self.next_internal() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L586"></span>
<span class="line" id="L587">        <span class="tok-kw">if</span> (self.first_address) |first_address| {</span>
<span class="line" id="L588">            <span class="tok-kw">while</span> (address != first_address) {</span>
<span class="line" id="L589">                address = self.next_internal() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L590">            }</span>
<span class="line" id="L591">            self.first_address = <span class="tok-null">null</span>;</span>
<span class="line" id="L592">        }</span>
<span class="line" id="L593"></span>
<span class="line" id="L594">        <span class="tok-kw">return</span> address;</span>
<span class="line" id="L595">    }</span>
<span class="line" id="L596"></span>
<span class="line" id="L597">    <span class="tok-kw">fn</span> <span class="tok-fn">isValidMemory</span>(address: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L598">        <span class="tok-comment">// We are unable to determine validity of memory for freestanding targets</span>
</span>
<span class="line" id="L599">        <span class="tok-kw">if</span> (native_os == .freestanding) <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L600"></span>
<span class="line" id="L601">        <span class="tok-kw">const</span> aligned_address = address &amp; ~<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>((mem.page_size - <span class="tok-number">1</span>)));</span>
<span class="line" id="L602">        <span class="tok-kw">if</span> (aligned_address == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L603">        <span class="tok-kw">const</span> aligned_memory = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">align</span>(mem.page_size) <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(aligned_address))[<span class="tok-number">0</span>..mem.page_size];</span>
<span class="line" id="L604"></span>
<span class="line" id="L605">        <span class="tok-kw">if</span> (native_os != .windows) {</span>
<span class="line" id="L606">            <span class="tok-kw">if</span> (native_os != .wasi) {</span>
<span class="line" id="L607">                os.msync(aligned_memory, os.MSF.ASYNC) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L608">                    <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L609">                        os.MSyncError.UnmappedMemory =&gt; {</span>
<span class="line" id="L610">                            <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L611">                        },</span>
<span class="line" id="L612">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L613">                    }</span>
<span class="line" id="L614">                };</span>
<span class="line" id="L615">            }</span>
<span class="line" id="L616"></span>
<span class="line" id="L617">            <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L618">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L619">            <span class="tok-kw">const</span> w = os.windows;</span>
<span class="line" id="L620">            <span class="tok-kw">var</span> memory_info: w.MEMORY_BASIC_INFORMATION = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L621"></span>
<span class="line" id="L622">            <span class="tok-comment">// The only error this function can throw is ERROR_INVALID_PARAMETER.</span>
</span>
<span class="line" id="L623">            <span class="tok-comment">// supply an address that invalid i'll be thrown.</span>
</span>
<span class="line" id="L624">            <span class="tok-kw">const</span> rc = w.VirtualQuery(aligned_memory, &amp;memory_info, aligned_memory.len) <span class="tok-kw">catch</span> {</span>
<span class="line" id="L625">                <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L626">            };</span>
<span class="line" id="L627"></span>
<span class="line" id="L628">            <span class="tok-comment">// Result code has to be bigger than zero (number of bytes written)</span>
</span>
<span class="line" id="L629">            <span class="tok-kw">if</span> (rc == <span class="tok-number">0</span>) {</span>
<span class="line" id="L630">                <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L631">            }</span>
<span class="line" id="L632"></span>
<span class="line" id="L633">            <span class="tok-comment">// Free pages cannot be read, they are unmapped</span>
</span>
<span class="line" id="L634">            <span class="tok-kw">if</span> (memory_info.State == w.MEM_FREE) {</span>
<span class="line" id="L635">                <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L636">            }</span>
<span class="line" id="L637"></span>
<span class="line" id="L638">            <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L639">        }</span>
<span class="line" id="L640">    }</span>
<span class="line" id="L641"></span>
<span class="line" id="L642">    <span class="tok-kw">fn</span> <span class="tok-fn">next_unwind</span>(self: *StackIterator) !<span class="tok-type">usize</span> {</span>
<span class="line" id="L643">        <span class="tok-kw">const</span> unwind_state = &amp;self.unwind_state.?;</span>
<span class="line" id="L644">        <span class="tok-kw">const</span> module = <span class="tok-kw">try</span> unwind_state.debug_info.getModuleForAddress(unwind_state.dwarf_context.pc);</span>
<span class="line" id="L645">        <span class="tok-kw">switch</span> (native_os) {</span>
<span class="line" id="L646">            .macos, .ios, .watchos, .tvos =&gt; {</span>
<span class="line" id="L647">                <span class="tok-comment">// __unwind_info is a requirement for unwinding on Darwin. It may fall back to DWARF, but unwinding</span>
</span>
<span class="line" id="L648">                <span class="tok-comment">// via DWARF before attempting to use the compact unwind info will produce incorrect results.</span>
</span>
<span class="line" id="L649">                <span class="tok-kw">if</span> (module.unwind_info) |unwind_info| {</span>
<span class="line" id="L650">                    <span class="tok-kw">if</span> (DW.unwindFrameMachO(&amp;unwind_state.dwarf_context, unwind_info, module.eh_frame, module.base_address)) |return_address| {</span>
<span class="line" id="L651">                        <span class="tok-kw">return</span> return_address;</span>
<span class="line" id="L652">                    } <span class="tok-kw">else</span> |err| {</span>
<span class="line" id="L653">                        <span class="tok-kw">if</span> (err != <span class="tok-kw">error</span>.RequiresDWARFUnwind) <span class="tok-kw">return</span> err;</span>
<span class="line" id="L654">                    }</span>
<span class="line" id="L655">                } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingUnwindInfo;</span>
<span class="line" id="L656">            },</span>
<span class="line" id="L657">            <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L658">        }</span>
<span class="line" id="L659"></span>
<span class="line" id="L660">        <span class="tok-kw">if</span> (<span class="tok-kw">try</span> module.getDwarfInfoForAddress(unwind_state.debug_info.allocator, unwind_state.dwarf_context.pc)) |di| {</span>
<span class="line" id="L661">            <span class="tok-kw">return</span> di.unwindFrame(&amp;unwind_state.dwarf_context, <span class="tok-null">null</span>);</span>
<span class="line" id="L662">        } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L663">    }</span>
<span class="line" id="L664"></span>
<span class="line" id="L665">    <span class="tok-kw">fn</span> <span class="tok-fn">next_internal</span>(self: *StackIterator) ?<span class="tok-type">usize</span> {</span>
<span class="line" id="L666">        <span class="tok-kw">if</span> (have_ucontext) {</span>
<span class="line" id="L667">            <span class="tok-kw">if</span> (self.unwind_state) |*unwind_state| {</span>
<span class="line" id="L668">                <span class="tok-kw">if</span> (!unwind_state.failed) {</span>
<span class="line" id="L669">                    <span class="tok-kw">if</span> (unwind_state.dwarf_context.pc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L670">                    <span class="tok-kw">if</span> (self.next_unwind()) |return_address| {</span>
<span class="line" id="L671">                        self.fp = unwind_state.dwarf_context.getFp() <span class="tok-kw">catch</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L672">                        <span class="tok-kw">return</span> return_address;</span>
<span class="line" id="L673">                    } <span class="tok-kw">else</span> |err| {</span>
<span class="line" id="L674">                        unwind_state.last_error = err;</span>
<span class="line" id="L675">                        unwind_state.failed = <span class="tok-null">true</span>;</span>
<span class="line" id="L676"></span>
<span class="line" id="L677">                        <span class="tok-comment">// Fall back to fp-based unwinding on the first failure.</span>
</span>
<span class="line" id="L678">                        <span class="tok-comment">// We can't attempt it again for other modules higher in the</span>
</span>
<span class="line" id="L679">                        <span class="tok-comment">// stack because the full register state won't have been unwound.</span>
</span>
<span class="line" id="L680">                    }</span>
<span class="line" id="L681">                }</span>
<span class="line" id="L682">            }</span>
<span class="line" id="L683">        }</span>
<span class="line" id="L684"></span>
<span class="line" id="L685">        <span class="tok-kw">const</span> fp = <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> native_arch.isSPARC())</span>
<span class="line" id="L686">            <span class="tok-comment">// On SPARC the offset is positive. (!)</span>
</span>
<span class="line" id="L687">            math.add(<span class="tok-type">usize</span>, self.fp, fp_offset) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">null</span></span>
<span class="line" id="L688">        <span class="tok-kw">else</span></span>
<span class="line" id="L689">            math.sub(<span class="tok-type">usize</span>, self.fp, fp_offset) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L690"></span>
<span class="line" id="L691">        <span class="tok-comment">// Sanity check.</span>
</span>
<span class="line" id="L692">        <span class="tok-kw">if</span> (fp == <span class="tok-number">0</span> <span class="tok-kw">or</span> !mem.isAligned(fp, <span class="tok-builtin">@alignOf</span>(<span class="tok-type">usize</span>)) <span class="tok-kw">or</span> !isValidMemory(fp))</span>
<span class="line" id="L693">            <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L694"></span>
<span class="line" id="L695">        <span class="tok-kw">const</span> new_fp = math.add(<span class="tok-type">usize</span>, <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(fp)).*, fp_bias) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L696"></span>
<span class="line" id="L697">        <span class="tok-comment">// Sanity check: the stack grows down thus all the parent frames must be</span>
</span>
<span class="line" id="L698">        <span class="tok-comment">// be at addresses that are greater (or equal) than the previous one.</span>
</span>
<span class="line" id="L699">        <span class="tok-comment">// A zero frame pointer often signals this is the last frame, that case</span>
</span>
<span class="line" id="L700">        <span class="tok-comment">// is gracefully handled by the next call to next_internal.</span>
</span>
<span class="line" id="L701">        <span class="tok-kw">if</span> (new_fp != <span class="tok-number">0</span> <span class="tok-kw">and</span> new_fp &lt; self.fp)</span>
<span class="line" id="L702">            <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L703"></span>
<span class="line" id="L704">        <span class="tok-kw">const</span> new_pc = <span class="tok-builtin">@as</span>(</span>
<span class="line" id="L705">            *<span class="tok-kw">const</span> <span class="tok-type">usize</span>,</span>
<span class="line" id="L706">            <span class="tok-builtin">@ptrFromInt</span>(math.add(<span class="tok-type">usize</span>, fp, pc_offset) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>),</span>
<span class="line" id="L707">        ).*;</span>
<span class="line" id="L708"></span>
<span class="line" id="L709">        self.fp = new_fp;</span>
<span class="line" id="L710"></span>
<span class="line" id="L711">        <span class="tok-kw">return</span> new_pc;</span>
<span class="line" id="L712">    }</span>
<span class="line" id="L713">};</span>
<span class="line" id="L714"></span>
<span class="line" id="L715"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeCurrentStackTrace</span>(</span>
<span class="line" id="L716">    out_stream: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L717">    debug_info: *DebugInfo,</span>
<span class="line" id="L718">    tty_config: io.tty.Config,</span>
<span class="line" id="L719">    start_addr: ?<span class="tok-type">usize</span>,</span>
<span class="line" id="L720">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L721">    <span class="tok-kw">var</span> context: ThreadContext = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L722">    <span class="tok-kw">const</span> has_context = getContext(&amp;context);</span>
<span class="line" id="L723">    <span class="tok-kw">if</span> (native_os == .windows) {</span>
<span class="line" id="L724">        <span class="tok-kw">return</span> writeStackTraceWindows(out_stream, debug_info, tty_config, &amp;context, start_addr);</span>
<span class="line" id="L725">    }</span>
<span class="line" id="L726"></span>
<span class="line" id="L727">    <span class="tok-kw">var</span> it = (<span class="tok-kw">if</span> (has_context) blk: {</span>
<span class="line" id="L728">        <span class="tok-kw">break</span> :blk StackIterator.initWithContext(start_addr, debug_info, &amp;context) <span class="tok-kw">catch</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L729">    } <span class="tok-kw">else</span> <span class="tok-null">null</span>) <span class="tok-kw">orelse</span> StackIterator.init(start_addr, <span class="tok-null">null</span>);</span>
<span class="line" id="L730">    <span class="tok-kw">defer</span> it.deinit();</span>
<span class="line" id="L731"></span>
<span class="line" id="L732">    <span class="tok-kw">while</span> (it.next()) |return_address| {</span>
<span class="line" id="L733">        printLastUnwindError(&amp;it, debug_info, out_stream, tty_config);</span>
<span class="line" id="L734"></span>
<span class="line" id="L735">        <span class="tok-comment">// On arm64 macOS, the address of the last frame is 0x0 rather than 0x1 as on x86_64 macOS,</span>
</span>
<span class="line" id="L736">        <span class="tok-comment">// therefore, we do a check for `return_address == 0` before subtracting 1 from it to avoid</span>
</span>
<span class="line" id="L737">        <span class="tok-comment">// an overflow. We do not need to signal `StackIterator` as it will correctly detect this</span>
</span>
<span class="line" id="L738">        <span class="tok-comment">// condition on the subsequent iteration and return `null` thus terminating the loop.</span>
</span>
<span class="line" id="L739">        <span class="tok-comment">// same behaviour for x86-windows-msvc</span>
</span>
<span class="line" id="L740">        <span class="tok-kw">const</span> address = <span class="tok-kw">if</span> (return_address == <span class="tok-number">0</span>) return_address <span class="tok-kw">else</span> return_address - <span class="tok-number">1</span>;</span>
<span class="line" id="L741">        <span class="tok-kw">try</span> printSourceAtAddress(debug_info, out_stream, address, tty_config);</span>
<span class="line" id="L742">    } <span class="tok-kw">else</span> printLastUnwindError(&amp;it, debug_info, out_stream, tty_config);</span>
<span class="line" id="L743">}</span>
<span class="line" id="L744"></span>
<span class="line" id="L745"><span class="tok-kw">pub</span> <span class="tok-kw">noinline</span> <span class="tok-kw">fn</span> <span class="tok-fn">walkStackWindows</span>(addresses: []<span class="tok-type">usize</span>, existing_context: ?*<span class="tok-kw">const</span> windows.CONTEXT) <span class="tok-type">usize</span> {</span>
<span class="line" id="L746">    <span class="tok-kw">if</span> (builtin.cpu.arch == .x86) {</span>
<span class="line" id="L747">        <span class="tok-comment">// RtlVirtualUnwind doesn't exist on x86</span>
</span>
<span class="line" id="L748">        <span class="tok-kw">return</span> windows.ntdll.RtlCaptureStackBackTrace(<span class="tok-number">0</span>, addresses.len, <span class="tok-builtin">@as</span>(**<span class="tok-type">anyopaque</span>, <span class="tok-builtin">@ptrCast</span>(addresses.ptr)), <span class="tok-null">null</span>);</span>
<span class="line" id="L749">    }</span>
<span class="line" id="L750"></span>
<span class="line" id="L751">    <span class="tok-kw">const</span> tib = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> windows.NT_TIB, <span class="tok-builtin">@ptrCast</span>(&amp;windows.teb().Reserved1));</span>
<span class="line" id="L752"></span>
<span class="line" id="L753">    <span class="tok-kw">var</span> context: windows.CONTEXT = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L754">    <span class="tok-kw">if</span> (existing_context) |context_ptr| {</span>
<span class="line" id="L755">        context = context_ptr.*;</span>
<span class="line" id="L756">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L757">        context = std.mem.zeroes(windows.CONTEXT);</span>
<span class="line" id="L758">        windows.ntdll.RtlCaptureContext(&amp;context);</span>
<span class="line" id="L759">    }</span>
<span class="line" id="L760"></span>
<span class="line" id="L761">    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L762">    <span class="tok-kw">var</span> image_base: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L763">    <span class="tok-kw">var</span> history_table: windows.UNWIND_HISTORY_TABLE = std.mem.zeroes(windows.UNWIND_HISTORY_TABLE);</span>
<span class="line" id="L764"></span>
<span class="line" id="L765">    <span class="tok-kw">while</span> (i &lt; addresses.len) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L766">        <span class="tok-kw">const</span> current_regs = context.getRegs();</span>
<span class="line" id="L767">        <span class="tok-kw">if</span> (windows.ntdll.RtlLookupFunctionEntry(current_regs.ip, &amp;image_base, &amp;history_table)) |runtime_function| {</span>
<span class="line" id="L768">            <span class="tok-kw">var</span> handler_data: ?*<span class="tok-type">anyopaque</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L769">            <span class="tok-kw">var</span> establisher_frame: <span class="tok-type">u64</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L770">            _ = windows.ntdll.RtlVirtualUnwind(</span>
<span class="line" id="L771">                windows.UNW_FLAG_NHANDLER,</span>
<span class="line" id="L772">                image_base,</span>
<span class="line" id="L773">                current_regs.ip,</span>
<span class="line" id="L774">                runtime_function,</span>
<span class="line" id="L775">                &amp;context,</span>
<span class="line" id="L776">                &amp;handler_data,</span>
<span class="line" id="L777">                &amp;establisher_frame,</span>
<span class="line" id="L778">                <span class="tok-null">null</span>,</span>
<span class="line" id="L779">            );</span>
<span class="line" id="L780">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L781">            <span class="tok-comment">// leaf function</span>
</span>
<span class="line" id="L782">            context.setIp(<span class="tok-builtin">@as</span>(*<span class="tok-type">u64</span>, <span class="tok-builtin">@ptrFromInt</span>(current_regs.sp)).*);</span>
<span class="line" id="L783">            context.setSp(current_regs.sp + <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>));</span>
<span class="line" id="L784">        }</span>
<span class="line" id="L785"></span>
<span class="line" id="L786">        <span class="tok-kw">const</span> next_regs = context.getRegs();</span>
<span class="line" id="L787">        <span class="tok-kw">if</span> (next_regs.sp &lt; <span class="tok-builtin">@intFromPtr</span>(tib.StackLimit) <span class="tok-kw">or</span> next_regs.sp &gt; <span class="tok-builtin">@intFromPtr</span>(tib.StackBase)) {</span>
<span class="line" id="L788">            <span class="tok-kw">break</span>;</span>
<span class="line" id="L789">        }</span>
<span class="line" id="L790"></span>
<span class="line" id="L791">        <span class="tok-kw">if</span> (next_regs.ip == <span class="tok-number">0</span>) {</span>
<span class="line" id="L792">            <span class="tok-kw">break</span>;</span>
<span class="line" id="L793">        }</span>
<span class="line" id="L794"></span>
<span class="line" id="L795">        addresses[i] = next_regs.ip;</span>
<span class="line" id="L796">    }</span>
<span class="line" id="L797"></span>
<span class="line" id="L798">    <span class="tok-kw">return</span> i;</span>
<span class="line" id="L799">}</span>
<span class="line" id="L800"></span>
<span class="line" id="L801"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeStackTraceWindows</span>(</span>
<span class="line" id="L802">    out_stream: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L803">    debug_info: *DebugInfo,</span>
<span class="line" id="L804">    tty_config: io.tty.Config,</span>
<span class="line" id="L805">    context: *<span class="tok-kw">const</span> windows.CONTEXT,</span>
<span class="line" id="L806">    start_addr: ?<span class="tok-type">usize</span>,</span>
<span class="line" id="L807">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L808">    <span class="tok-kw">var</span> addr_buf: [<span class="tok-number">1024</span>]<span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L809">    <span class="tok-kw">const</span> n = walkStackWindows(addr_buf[<span class="tok-number">0</span>..], context);</span>
<span class="line" id="L810">    <span class="tok-kw">const</span> addrs = addr_buf[<span class="tok-number">0</span>..n];</span>
<span class="line" id="L811">    <span class="tok-kw">var</span> start_i: <span class="tok-type">usize</span> = <span class="tok-kw">if</span> (start_addr) |saddr| blk: {</span>
<span class="line" id="L812">        <span class="tok-kw">for</span> (addrs, <span class="tok-number">0</span>..) |addr, i| {</span>
<span class="line" id="L813">            <span class="tok-kw">if</span> (addr == saddr) <span class="tok-kw">break</span> :blk i;</span>
<span class="line" id="L814">        }</span>
<span class="line" id="L815">        <span class="tok-kw">return</span>;</span>
<span class="line" id="L816">    } <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L817">    <span class="tok-kw">for</span> (addrs[start_i..]) |addr| {</span>
<span class="line" id="L818">        <span class="tok-kw">try</span> printSourceAtAddress(debug_info, out_stream, addr - <span class="tok-number">1</span>, tty_config);</span>
<span class="line" id="L819">    }</span>
<span class="line" id="L820">}</span>
<span class="line" id="L821"></span>
<span class="line" id="L822"><span class="tok-kw">fn</span> <span class="tok-fn">machoSearchSymbols</span>(symbols: []<span class="tok-kw">const</span> MachoSymbol, address: <span class="tok-type">usize</span>) ?*<span class="tok-kw">const</span> MachoSymbol {</span>
<span class="line" id="L823">    <span class="tok-kw">var</span> min: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L824">    <span class="tok-kw">var</span> max: <span class="tok-type">usize</span> = symbols.len - <span class="tok-number">1</span>;</span>
<span class="line" id="L825">    <span class="tok-kw">while</span> (min &lt; max) {</span>
<span class="line" id="L826">        <span class="tok-kw">const</span> mid = min + (max - min) / <span class="tok-number">2</span>;</span>
<span class="line" id="L827">        <span class="tok-kw">const</span> curr = &amp;symbols[mid];</span>
<span class="line" id="L828">        <span class="tok-kw">const</span> next = &amp;symbols[mid + <span class="tok-number">1</span>];</span>
<span class="line" id="L829">        <span class="tok-kw">if</span> (address &gt;= next.address()) {</span>
<span class="line" id="L830">            min = mid + <span class="tok-number">1</span>;</span>
<span class="line" id="L831">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (address &lt; curr.address()) {</span>
<span class="line" id="L832">            max = mid;</span>
<span class="line" id="L833">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L834">            <span class="tok-kw">return</span> curr;</span>
<span class="line" id="L835">        }</span>
<span class="line" id="L836">    }</span>
<span class="line" id="L837"></span>
<span class="line" id="L838">    <span class="tok-kw">const</span> max_sym = &amp;symbols[symbols.len - <span class="tok-number">1</span>];</span>
<span class="line" id="L839">    <span class="tok-kw">if</span> (address &gt;= max_sym.address())</span>
<span class="line" id="L840">        <span class="tok-kw">return</span> max_sym;</span>
<span class="line" id="L841"></span>
<span class="line" id="L842">    <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L843">}</span>
<span class="line" id="L844"></span>
<span class="line" id="L845"><span class="tok-kw">test</span> <span class="tok-str">&quot;machoSearchSymbols&quot;</span> {</span>
<span class="line" id="L846">    <span class="tok-kw">const</span> symbols = [_]MachoSymbol{</span>
<span class="line" id="L847">        .{ .addr = <span class="tok-number">100</span>, .strx = <span class="tok-null">undefined</span>, .size = <span class="tok-null">undefined</span>, .ofile = <span class="tok-null">undefined</span> },</span>
<span class="line" id="L848">        .{ .addr = <span class="tok-number">200</span>, .strx = <span class="tok-null">undefined</span>, .size = <span class="tok-null">undefined</span>, .ofile = <span class="tok-null">undefined</span> },</span>
<span class="line" id="L849">        .{ .addr = <span class="tok-number">300</span>, .strx = <span class="tok-null">undefined</span>, .size = <span class="tok-null">undefined</span>, .ofile = <span class="tok-null">undefined</span> },</span>
<span class="line" id="L850">    };</span>
<span class="line" id="L851"></span>
<span class="line" id="L852">    <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(?*<span class="tok-kw">const</span> MachoSymbol, <span class="tok-null">null</span>), machoSearchSymbols(&amp;symbols, <span class="tok-number">0</span>));</span>
<span class="line" id="L853">    <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(?*<span class="tok-kw">const</span> MachoSymbol, <span class="tok-null">null</span>), machoSearchSymbols(&amp;symbols, <span class="tok-number">99</span>));</span>
<span class="line" id="L854">    <span class="tok-kw">try</span> testing.expectEqual(&amp;symbols[<span class="tok-number">0</span>], machoSearchSymbols(&amp;symbols, <span class="tok-number">100</span>).?);</span>
<span class="line" id="L855">    <span class="tok-kw">try</span> testing.expectEqual(&amp;symbols[<span class="tok-number">0</span>], machoSearchSymbols(&amp;symbols, <span class="tok-number">150</span>).?);</span>
<span class="line" id="L856">    <span class="tok-kw">try</span> testing.expectEqual(&amp;symbols[<span class="tok-number">0</span>], machoSearchSymbols(&amp;symbols, <span class="tok-number">199</span>).?);</span>
<span class="line" id="L857"></span>
<span class="line" id="L858">    <span class="tok-kw">try</span> testing.expectEqual(&amp;symbols[<span class="tok-number">1</span>], machoSearchSymbols(&amp;symbols, <span class="tok-number">200</span>).?);</span>
<span class="line" id="L859">    <span class="tok-kw">try</span> testing.expectEqual(&amp;symbols[<span class="tok-number">1</span>], machoSearchSymbols(&amp;symbols, <span class="tok-number">250</span>).?);</span>
<span class="line" id="L860">    <span class="tok-kw">try</span> testing.expectEqual(&amp;symbols[<span class="tok-number">1</span>], machoSearchSymbols(&amp;symbols, <span class="tok-number">299</span>).?);</span>
<span class="line" id="L861"></span>
<span class="line" id="L862">    <span class="tok-kw">try</span> testing.expectEqual(&amp;symbols[<span class="tok-number">2</span>], machoSearchSymbols(&amp;symbols, <span class="tok-number">300</span>).?);</span>
<span class="line" id="L863">    <span class="tok-kw">try</span> testing.expectEqual(&amp;symbols[<span class="tok-number">2</span>], machoSearchSymbols(&amp;symbols, <span class="tok-number">301</span>).?);</span>
<span class="line" id="L864">    <span class="tok-kw">try</span> testing.expectEqual(&amp;symbols[<span class="tok-number">2</span>], machoSearchSymbols(&amp;symbols, <span class="tok-number">5000</span>).?);</span>
<span class="line" id="L865">}</span>
<span class="line" id="L866"></span>
<span class="line" id="L867"><span class="tok-kw">fn</span> <span class="tok-fn">printUnknownSource</span>(debug_info: *DebugInfo, out_stream: <span class="tok-kw">anytype</span>, address: <span class="tok-type">usize</span>, tty_config: io.tty.Config) !<span class="tok-type">void</span> {</span>
<span class="line" id="L868">    <span class="tok-kw">const</span> module_name = debug_info.getModuleNameForAddress(address);</span>
<span class="line" id="L869">    <span class="tok-kw">return</span> printLineInfo(</span>
<span class="line" id="L870">        out_stream,</span>
<span class="line" id="L871">        <span class="tok-null">null</span>,</span>
<span class="line" id="L872">        address,</span>
<span class="line" id="L873">        <span class="tok-str">&quot;???&quot;</span>,</span>
<span class="line" id="L874">        module_name <span class="tok-kw">orelse</span> <span class="tok-str">&quot;???&quot;</span>,</span>
<span class="line" id="L875">        tty_config,</span>
<span class="line" id="L876">        printLineFromFileAnyOs,</span>
<span class="line" id="L877">    );</span>
<span class="line" id="L878">}</span>
<span class="line" id="L879"></span>
<span class="line" id="L880"><span class="tok-kw">fn</span> <span class="tok-fn">printLastUnwindError</span>(it: *StackIterator, debug_info: *DebugInfo, out_stream: <span class="tok-kw">anytype</span>, tty_config: io.tty.Config) <span class="tok-type">void</span> {</span>
<span class="line" id="L881">    <span class="tok-kw">if</span> (!have_ucontext) <span class="tok-kw">return</span>;</span>
<span class="line" id="L882">    <span class="tok-kw">if</span> (it.getLastError()) |unwind_error| {</span>
<span class="line" id="L883">        printUnwindError(debug_info, out_stream, unwind_error.address, unwind_error.err, tty_config) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L884">    }</span>
<span class="line" id="L885">}</span>
<span class="line" id="L886"></span>
<span class="line" id="L887"><span class="tok-kw">fn</span> <span class="tok-fn">printUnwindError</span>(debug_info: *DebugInfo, out_stream: <span class="tok-kw">anytype</span>, address: <span class="tok-type">usize</span>, err: UnwindError, tty_config: io.tty.Config) !<span class="tok-type">void</span> {</span>
<span class="line" id="L888">    <span class="tok-kw">const</span> module_name = debug_info.getModuleNameForAddress(address) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;???&quot;</span>;</span>
<span class="line" id="L889">    <span class="tok-kw">try</span> tty_config.setColor(out_stream, .dim);</span>
<span class="line" id="L890">    <span class="tok-kw">if</span> (err == <span class="tok-kw">error</span>.MissingDebugInfo) {</span>
<span class="line" id="L891">        <span class="tok-kw">try</span> out_stream.print(<span class="tok-str">&quot;Unwind information for `{s}:0x{x}` was not available, trace may be incomplete\n\n&quot;</span>, .{ module_name, address });</span>
<span class="line" id="L892">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L893">        <span class="tok-kw">try</span> out_stream.print(<span class="tok-str">&quot;Unwind error at address `{s}:0x{x}` ({}), trace may be incomplete\n\n&quot;</span>, .{ module_name, address, err });</span>
<span class="line" id="L894">    }</span>
<span class="line" id="L895">    <span class="tok-kw">try</span> tty_config.setColor(out_stream, .reset);</span>
<span class="line" id="L896">}</span>
<span class="line" id="L897"></span>
<span class="line" id="L898"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">printSourceAtAddress</span>(debug_info: *DebugInfo, out_stream: <span class="tok-kw">anytype</span>, address: <span class="tok-type">usize</span>, tty_config: io.tty.Config) !<span class="tok-type">void</span> {</span>
<span class="line" id="L899">    <span class="tok-kw">const</span> module = debug_info.getModuleForAddress(address) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L900">        <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; <span class="tok-kw">return</span> printUnknownSource(debug_info, out_stream, address, tty_config),</span>
<span class="line" id="L901">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L902">    };</span>
<span class="line" id="L903"></span>
<span class="line" id="L904">    <span class="tok-kw">const</span> symbol_info = module.getSymbolAtAddress(debug_info.allocator, address) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L905">        <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; <span class="tok-kw">return</span> printUnknownSource(debug_info, out_stream, address, tty_config),</span>
<span class="line" id="L906">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L907">    };</span>
<span class="line" id="L908">    <span class="tok-kw">defer</span> symbol_info.deinit(debug_info.allocator);</span>
<span class="line" id="L909"></span>
<span class="line" id="L910">    <span class="tok-kw">return</span> printLineInfo(</span>
<span class="line" id="L911">        out_stream,</span>
<span class="line" id="L912">        symbol_info.line_info,</span>
<span class="line" id="L913">        address,</span>
<span class="line" id="L914">        symbol_info.symbol_name,</span>
<span class="line" id="L915">        symbol_info.compile_unit_name,</span>
<span class="line" id="L916">        tty_config,</span>
<span class="line" id="L917">        printLineFromFileAnyOs,</span>
<span class="line" id="L918">    );</span>
<span class="line" id="L919">}</span>
<span class="line" id="L920"></span>
<span class="line" id="L921"><span class="tok-kw">fn</span> <span class="tok-fn">printLineInfo</span>(</span>
<span class="line" id="L922">    out_stream: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L923">    line_info: ?LineInfo,</span>
<span class="line" id="L924">    address: <span class="tok-type">usize</span>,</span>
<span class="line" id="L925">    symbol_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L926">    compile_unit_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L927">    tty_config: io.tty.Config,</span>
<span class="line" id="L928">    <span class="tok-kw">comptime</span> printLineFromFile: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L929">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L930">    <span class="tok-kw">nosuspend</span> {</span>
<span class="line" id="L931">        <span class="tok-kw">try</span> tty_config.setColor(out_stream, .bold);</span>
<span class="line" id="L932"></span>
<span class="line" id="L933">        <span class="tok-kw">if</span> (line_info) |*li| {</span>
<span class="line" id="L934">            <span class="tok-kw">try</span> out_stream.print(<span class="tok-str">&quot;{s}:{d}:{d}&quot;</span>, .{ li.file_name, li.line, li.column });</span>
<span class="line" id="L935">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L936">            <span class="tok-kw">try</span> out_stream.writeAll(<span class="tok-str">&quot;???:?:?&quot;</span>);</span>
<span class="line" id="L937">        }</span>
<span class="line" id="L938"></span>
<span class="line" id="L939">        <span class="tok-kw">try</span> tty_config.setColor(out_stream, .reset);</span>
<span class="line" id="L940">        <span class="tok-kw">try</span> out_stream.writeAll(<span class="tok-str">&quot;: &quot;</span>);</span>
<span class="line" id="L941">        <span class="tok-kw">try</span> tty_config.setColor(out_stream, .dim);</span>
<span class="line" id="L942">        <span class="tok-kw">try</span> out_stream.print(<span class="tok-str">&quot;0x{x} in {s} ({s})&quot;</span>, .{ address, symbol_name, compile_unit_name });</span>
<span class="line" id="L943">        <span class="tok-kw">try</span> tty_config.setColor(out_stream, .reset);</span>
<span class="line" id="L944">        <span class="tok-kw">try</span> out_stream.writeAll(<span class="tok-str">&quot;\n&quot;</span>);</span>
<span class="line" id="L945"></span>
<span class="line" id="L946">        <span class="tok-comment">// Show the matching source code line if possible</span>
</span>
<span class="line" id="L947">        <span class="tok-kw">if</span> (line_info) |li| {</span>
<span class="line" id="L948">            <span class="tok-kw">if</span> (printLineFromFile(out_stream, li)) {</span>
<span class="line" id="L949">                <span class="tok-kw">if</span> (li.column &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L950">                    <span class="tok-comment">// The caret already takes one char</span>
</span>
<span class="line" id="L951">                    <span class="tok-kw">const</span> space_needed = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(li.column - <span class="tok-number">1</span>));</span>
<span class="line" id="L952"></span>
<span class="line" id="L953">                    <span class="tok-kw">try</span> out_stream.writeByteNTimes(<span class="tok-str">' '</span>, space_needed);</span>
<span class="line" id="L954">                    <span class="tok-kw">try</span> tty_config.setColor(out_stream, .green);</span>
<span class="line" id="L955">                    <span class="tok-kw">try</span> out_stream.writeAll(<span class="tok-str">&quot;^&quot;</span>);</span>
<span class="line" id="L956">                    <span class="tok-kw">try</span> tty_config.setColor(out_stream, .reset);</span>
<span class="line" id="L957">                }</span>
<span class="line" id="L958">                <span class="tok-kw">try</span> out_stream.writeAll(<span class="tok-str">&quot;\n&quot;</span>);</span>
<span class="line" id="L959">            } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L960">                <span class="tok-kw">error</span>.EndOfFile, <span class="tok-kw">error</span>.FileNotFound =&gt; {},</span>
<span class="line" id="L961">                <span class="tok-kw">error</span>.BadPathName =&gt; {},</span>
<span class="line" id="L962">                <span class="tok-kw">error</span>.AccessDenied =&gt; {},</span>
<span class="line" id="L963">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L964">            }</span>
<span class="line" id="L965">        }</span>
<span class="line" id="L966">    }</span>
<span class="line" id="L967">}</span>
<span class="line" id="L968"></span>
<span class="line" id="L969"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> OpenSelfDebugInfoError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L970">    MissingDebugInfo,</span>
<span class="line" id="L971">    UnsupportedOperatingSystem,</span>
<span class="line" id="L972">} || <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(DebugInfo.init)).Fn.return_type.?).ErrorUnion.error_set;</span>
<span class="line" id="L973"></span>
<span class="line" id="L974"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openSelfDebugInfo</span>(allocator: mem.Allocator) OpenSelfDebugInfoError!DebugInfo {</span>
<span class="line" id="L975">    <span class="tok-kw">nosuspend</span> {</span>
<span class="line" id="L976">        <span class="tok-kw">if</span> (builtin.strip_debug_info)</span>
<span class="line" id="L977">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L978">        <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(root, <span class="tok-str">&quot;os&quot;</span>) <span class="tok-kw">and</span> <span class="tok-builtin">@hasDecl</span>(root.os, <span class="tok-str">&quot;debug&quot;</span>) <span class="tok-kw">and</span> <span class="tok-builtin">@hasDecl</span>(root.os.debug, <span class="tok-str">&quot;openSelfDebugInfo&quot;</span>)) {</span>
<span class="line" id="L979">            <span class="tok-kw">return</span> root.os.debug.openSelfDebugInfo(allocator);</span>
<span class="line" id="L980">        }</span>
<span class="line" id="L981">        <span class="tok-kw">switch</span> (native_os) {</span>
<span class="line" id="L982">            .linux,</span>
<span class="line" id="L983">            .freebsd,</span>
<span class="line" id="L984">            .netbsd,</span>
<span class="line" id="L985">            .dragonfly,</span>
<span class="line" id="L986">            .openbsd,</span>
<span class="line" id="L987">            .macos,</span>
<span class="line" id="L988">            .solaris,</span>
<span class="line" id="L989">            .windows,</span>
<span class="line" id="L990">            =&gt; <span class="tok-kw">return</span> <span class="tok-kw">try</span> DebugInfo.init(allocator),</span>
<span class="line" id="L991">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedOperatingSystem,</span>
<span class="line" id="L992">        }</span>
<span class="line" id="L993">    }</span>
<span class="line" id="L994">}</span>
<span class="line" id="L995"></span>
<span class="line" id="L996"><span class="tok-kw">fn</span> <span class="tok-fn">readCoffDebugInfo</span>(allocator: mem.Allocator, coff_obj: *coff.Coff) !ModuleDebugInfo {</span>
<span class="line" id="L997">    <span class="tok-kw">nosuspend</span> {</span>
<span class="line" id="L998">        <span class="tok-kw">var</span> di = ModuleDebugInfo{</span>
<span class="line" id="L999">            .base_address = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L1000">            .coff_image_base = coff_obj.getImageBase(),</span>
<span class="line" id="L1001">            .coff_section_headers = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L1002">            .debug_data = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L1003">        };</span>
<span class="line" id="L1004"></span>
<span class="line" id="L1005">        <span class="tok-kw">if</span> (coff_obj.getSectionByName(<span class="tok-str">&quot;.debug_info&quot;</span>)) |_| {</span>
<span class="line" id="L1006">            <span class="tok-comment">// This coff file has embedded DWARF debug info</span>
</span>
<span class="line" id="L1007">            <span class="tok-kw">var</span> sections: DW.DwarfInfo.SectionArray = DW.DwarfInfo.null_section_array;</span>
<span class="line" id="L1008">            <span class="tok-kw">errdefer</span> <span class="tok-kw">for</span> (sections) |section| <span class="tok-kw">if</span> (section) |s| <span class="tok-kw">if</span> (s.owned) allocator.free(s.data);</span>
<span class="line" id="L1009"></span>
<span class="line" id="L1010">            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(DW.DwarfSection).Enum.fields, <span class="tok-number">0</span>..) |section, i| {</span>
<span class="line" id="L1011">                sections[i] = <span class="tok-kw">if</span> (coff_obj.getSectionByName(<span class="tok-str">&quot;.&quot;</span> ++ section.name)) |section_header| blk: {</span>
<span class="line" id="L1012">                    <span class="tok-kw">break</span> :blk .{</span>
<span class="line" id="L1013">                        .data = <span class="tok-kw">try</span> coff_obj.getSectionDataAlloc(section_header, allocator),</span>
<span class="line" id="L1014">                        .virtual_address = section_header.virtual_address,</span>
<span class="line" id="L1015">                        .owned = <span class="tok-null">true</span>,</span>
<span class="line" id="L1016">                    };</span>
<span class="line" id="L1017">                } <span class="tok-kw">else</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1018">            }</span>
<span class="line" id="L1019"></span>
<span class="line" id="L1020">            <span class="tok-kw">var</span> dwarf = DW.DwarfInfo{</span>
<span class="line" id="L1021">                .endian = native_endian,</span>
<span class="line" id="L1022">                .sections = sections,</span>
<span class="line" id="L1023">                .is_macho = <span class="tok-null">false</span>,</span>
<span class="line" id="L1024">            };</span>
<span class="line" id="L1025"></span>
<span class="line" id="L1026">            <span class="tok-kw">try</span> DW.openDwarfDebugInfo(&amp;dwarf, allocator);</span>
<span class="line" id="L1027">            di.debug_data = PdbOrDwarf{ .dwarf = dwarf };</span>
<span class="line" id="L1028">            <span class="tok-kw">return</span> di;</span>
<span class="line" id="L1029">        }</span>
<span class="line" id="L1030"></span>
<span class="line" id="L1031">        <span class="tok-comment">// Only used by pdb path</span>
</span>
<span class="line" id="L1032">        di.coff_section_headers = <span class="tok-kw">try</span> coff_obj.getSectionHeadersAlloc(allocator);</span>
<span class="line" id="L1033">        <span class="tok-kw">errdefer</span> allocator.free(di.coff_section_headers);</span>
<span class="line" id="L1034"></span>
<span class="line" id="L1035">        <span class="tok-kw">var</span> path_buf: [windows.MAX_PATH]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1036">        <span class="tok-kw">const</span> len = <span class="tok-kw">try</span> coff_obj.getPdbPath(path_buf[<span class="tok-number">0</span>..]);</span>
<span class="line" id="L1037">        <span class="tok-kw">const</span> raw_path = path_buf[<span class="tok-number">0</span>..len];</span>
<span class="line" id="L1038"></span>
<span class="line" id="L1039">        <span class="tok-kw">const</span> path = <span class="tok-kw">try</span> fs.path.resolve(allocator, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{raw_path});</span>
<span class="line" id="L1040">        <span class="tok-kw">defer</span> allocator.free(path);</span>
<span class="line" id="L1041"></span>
<span class="line" id="L1042">        di.debug_data = PdbOrDwarf{ .pdb = <span class="tok-null">undefined</span> };</span>
<span class="line" id="L1043">        di.debug_data.pdb = pdb.Pdb.init(allocator, path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1044">            <span class="tok-kw">error</span>.FileNotFound, <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo,</span>
<span class="line" id="L1045">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L1046">        };</span>
<span class="line" id="L1047">        <span class="tok-kw">try</span> di.debug_data.pdb.parseInfoStream();</span>
<span class="line" id="L1048">        <span class="tok-kw">try</span> di.debug_data.pdb.parseDbiStream();</span>
<span class="line" id="L1049"></span>
<span class="line" id="L1050">        <span class="tok-kw">if</span> (!mem.eql(<span class="tok-type">u8</span>, &amp;coff_obj.guid, &amp;di.debug_data.pdb.guid) <span class="tok-kw">or</span> coff_obj.age != di.debug_data.pdb.age)</span>
<span class="line" id="L1051">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo;</span>
<span class="line" id="L1052"></span>
<span class="line" id="L1053">        <span class="tok-kw">return</span> di;</span>
<span class="line" id="L1054">    }</span>
<span class="line" id="L1055">}</span>
<span class="line" id="L1056"></span>
<span class="line" id="L1057"><span class="tok-kw">fn</span> <span class="tok-fn">chopSlice</span>(ptr: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, offset: <span class="tok-type">u64</span>, size: <span class="tok-type">u64</span>) <span class="tok-kw">error</span>{Overflow}![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1058">    <span class="tok-kw">const</span> start = math.cast(<span class="tok-type">usize</span>, offset) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;</span>
<span class="line" id="L1059">    <span class="tok-kw">const</span> end = start + (math.cast(<span class="tok-type">usize</span>, size) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow);</span>
<span class="line" id="L1060">    <span class="tok-kw">return</span> ptr[start..end];</span>
<span class="line" id="L1061">}</span>
<span class="line" id="L1062"></span>
<span class="line" id="L1063"><span class="tok-comment">/// Reads debug info from an ELF file, or the current binary if none in specified.</span></span>
<span class="line" id="L1064"><span class="tok-comment">/// If the required sections aren't present but a reference to external debug info is,</span></span>
<span class="line" id="L1065"><span class="tok-comment">/// then this this function will recurse to attempt to load the debug sections from</span></span>
<span class="line" id="L1066"><span class="tok-comment">/// an external file.</span></span>
<span class="line" id="L1067"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readElfDebugInfo</span>(</span>
<span class="line" id="L1068">    allocator: mem.Allocator,</span>
<span class="line" id="L1069">    elf_filename: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1070">    build_id: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1071">    expected_crc: ?<span class="tok-type">u32</span>,</span>
<span class="line" id="L1072">    parent_sections: *DW.DwarfInfo.SectionArray,</span>
<span class="line" id="L1073">    parent_mapped_mem: ?[]<span class="tok-kw">align</span>(mem.page_size) <span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1074">) !ModuleDebugInfo {</span>
<span class="line" id="L1075">    <span class="tok-kw">nosuspend</span> {</span>
<span class="line" id="L1076"></span>
<span class="line" id="L1077">        <span class="tok-comment">// TODO https://github.com/ziglang/zig/issues/5525</span>
</span>
<span class="line" id="L1078">        <span class="tok-kw">const</span> elf_file = (<span class="tok-kw">if</span> (elf_filename) |filename| blk: {</span>
<span class="line" id="L1079">            <span class="tok-kw">break</span> :blk <span class="tok-kw">if</span> (fs.path.isAbsolute(filename))</span>
<span class="line" id="L1080">                fs.openFileAbsolute(filename, .{ .intended_io_mode = .blocking })</span>
<span class="line" id="L1081">            <span class="tok-kw">else</span></span>
<span class="line" id="L1082">                fs.cwd().openFile(filename, .{ .intended_io_mode = .blocking });</span>
<span class="line" id="L1083">        } <span class="tok-kw">else</span> fs.openSelfExe(.{ .intended_io_mode = .blocking })) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1084">            <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo,</span>
<span class="line" id="L1085">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L1086">        };</span>
<span class="line" id="L1087"></span>
<span class="line" id="L1088">        <span class="tok-kw">const</span> mapped_mem = <span class="tok-kw">try</span> mapWholeFile(elf_file);</span>
<span class="line" id="L1089">        <span class="tok-kw">if</span> (expected_crc) |crc| <span class="tok-kw">if</span> (crc != std.hash.crc.Crc32SmallWithPoly(.IEEE).hash(mapped_mem)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo;</span>
<span class="line" id="L1090"></span>
<span class="line" id="L1091">        <span class="tok-kw">const</span> hdr: *<span class="tok-kw">const</span> elf.Ehdr = <span class="tok-builtin">@ptrCast</span>(&amp;mapped_mem[<span class="tok-number">0</span>]);</span>
<span class="line" id="L1092">        <span class="tok-kw">if</span> (!mem.eql(<span class="tok-type">u8</span>, hdr.e_ident[<span class="tok-number">0</span>..<span class="tok-number">4</span>], elf.MAGIC)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfMagic;</span>
<span class="line" id="L1093">        <span class="tok-kw">if</span> (hdr.e_ident[elf.EI_VERSION] != <span class="tok-number">1</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfVersion;</span>
<span class="line" id="L1094"></span>
<span class="line" id="L1095">        <span class="tok-kw">const</span> endian: std.builtin.Endian = <span class="tok-kw">switch</span> (hdr.e_ident[elf.EI_DATA]) {</span>
<span class="line" id="L1096">            elf.ELFDATA2LSB =&gt; .Little,</span>
<span class="line" id="L1097">            elf.ELFDATA2MSB =&gt; .Big,</span>
<span class="line" id="L1098">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfEndian,</span>
<span class="line" id="L1099">        };</span>
<span class="line" id="L1100">        assert(endian == native_endian); <span class="tok-comment">// this is our own debug info</span>
</span>
<span class="line" id="L1101"></span>
<span class="line" id="L1102">        <span class="tok-kw">const</span> shoff = hdr.e_shoff;</span>
<span class="line" id="L1103">        <span class="tok-kw">const</span> str_section_off = shoff + <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, hdr.e_shentsize) * <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, hdr.e_shstrndx);</span>
<span class="line" id="L1104">        <span class="tok-kw">const</span> str_shdr: *<span class="tok-kw">const</span> elf.Shdr = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;mapped_mem[math.cast(<span class="tok-type">usize</span>, str_section_off) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow]));</span>
<span class="line" id="L1105">        <span class="tok-kw">const</span> header_strings = mapped_mem[str_shdr.sh_offset..][<span class="tok-number">0</span>..str_shdr.sh_size];</span>
<span class="line" id="L1106">        <span class="tok-kw">const</span> shdrs = <span class="tok-builtin">@as</span>(</span>
<span class="line" id="L1107">            [*]<span class="tok-kw">const</span> elf.Shdr,</span>
<span class="line" id="L1108">            <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;mapped_mem[shoff])),</span>
<span class="line" id="L1109">        )[<span class="tok-number">0</span>..hdr.e_shnum];</span>
<span class="line" id="L1110"></span>
<span class="line" id="L1111">        <span class="tok-kw">var</span> sections: DW.DwarfInfo.SectionArray = DW.DwarfInfo.null_section_array;</span>
<span class="line" id="L1112"></span>
<span class="line" id="L1113">        <span class="tok-comment">// Combine section list. This takes ownership over any owned sections from the parent scope.</span>
</span>
<span class="line" id="L1114">        <span class="tok-kw">for</span> (parent_sections, &amp;sections) |*parent, *section| {</span>
<span class="line" id="L1115">            <span class="tok-kw">if</span> (parent.*) |*p| {</span>
<span class="line" id="L1116">                section.* = p.*;</span>
<span class="line" id="L1117">                p.owned = <span class="tok-null">false</span>;</span>
<span class="line" id="L1118">            }</span>
<span class="line" id="L1119">        }</span>
<span class="line" id="L1120">        <span class="tok-kw">errdefer</span> <span class="tok-kw">for</span> (sections) |section| <span class="tok-kw">if</span> (section) |s| <span class="tok-kw">if</span> (s.owned) allocator.free(s.data);</span>
<span class="line" id="L1121"></span>
<span class="line" id="L1122">        <span class="tok-kw">var</span> separate_debug_filename: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L1123">        <span class="tok-kw">var</span> separate_debug_crc: ?<span class="tok-type">u32</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L1124"></span>
<span class="line" id="L1125">        <span class="tok-kw">for</span> (shdrs) |*shdr| {</span>
<span class="line" id="L1126">            <span class="tok-kw">if</span> (shdr.sh_type == elf.SHT_NULL <span class="tok-kw">or</span> shdr.sh_type == elf.SHT_NOBITS) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1127">            <span class="tok-kw">const</span> name = mem.sliceTo(header_strings[shdr.sh_name..], <span class="tok-number">0</span>);</span>
<span class="line" id="L1128"></span>
<span class="line" id="L1129">            <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.gnu_debuglink&quot;</span>)) {</span>
<span class="line" id="L1130">                <span class="tok-kw">const</span> gnu_debuglink = <span class="tok-kw">try</span> chopSlice(mapped_mem, shdr.sh_offset, shdr.sh_size);</span>
<span class="line" id="L1131">                <span class="tok-kw">const</span> debug_filename = mem.sliceTo(<span class="tok-builtin">@as</span>([*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(gnu_debuglink.ptr)), <span class="tok-number">0</span>);</span>
<span class="line" id="L1132">                <span class="tok-kw">const</span> crc_offset = mem.alignForward(<span class="tok-type">usize</span>, <span class="tok-builtin">@intFromPtr</span>(&amp;debug_filename[debug_filename.len]) + <span class="tok-number">1</span>, <span class="tok-number">4</span>) - <span class="tok-builtin">@intFromPtr</span>(gnu_debuglink.ptr);</span>
<span class="line" id="L1133">                <span class="tok-kw">const</span> crc_bytes = gnu_debuglink[crc_offset .. crc_offset + <span class="tok-number">4</span>];</span>
<span class="line" id="L1134">                separate_debug_crc = mem.readIntSliceNative(<span class="tok-type">u32</span>, crc_bytes);</span>
<span class="line" id="L1135">                separate_debug_filename = debug_filename;</span>
<span class="line" id="L1136">                <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1137">            }</span>
<span class="line" id="L1138"></span>
<span class="line" id="L1139">            <span class="tok-kw">var</span> section_index: ?<span class="tok-type">usize</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L1140">            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(DW.DwarfSection).Enum.fields, <span class="tok-number">0</span>..) |section, i| {</span>
<span class="line" id="L1141">                <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, <span class="tok-str">&quot;.&quot;</span> ++ section.name, name)) section_index = i;</span>
<span class="line" id="L1142">            }</span>
<span class="line" id="L1143">            <span class="tok-kw">if</span> (section_index == <span class="tok-null">null</span>) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1144">            <span class="tok-kw">if</span> (sections[section_index.?] != <span class="tok-null">null</span>) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1145"></span>
<span class="line" id="L1146">            <span class="tok-kw">const</span> section_bytes = <span class="tok-kw">try</span> chopSlice(mapped_mem, shdr.sh_offset, shdr.sh_size);</span>
<span class="line" id="L1147">            sections[section_index.?] = <span class="tok-kw">if</span> ((shdr.sh_flags &amp; elf.SHF_COMPRESSED) &gt; <span class="tok-number">0</span>) blk: {</span>
<span class="line" id="L1148">                <span class="tok-kw">var</span> section_stream = io.fixedBufferStream(section_bytes);</span>
<span class="line" id="L1149">                <span class="tok-kw">var</span> section_reader = section_stream.reader();</span>
<span class="line" id="L1150">                <span class="tok-kw">const</span> chdr = section_reader.readStruct(elf.Chdr) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1151">                <span class="tok-kw">if</span> (chdr.ch_type != .ZLIB) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1152"></span>
<span class="line" id="L1153">                <span class="tok-kw">var</span> zlib_stream = std.compress.zlib.decompressStream(allocator, section_stream.reader()) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1154">                <span class="tok-kw">defer</span> zlib_stream.deinit();</span>
<span class="line" id="L1155"></span>
<span class="line" id="L1156">                <span class="tok-kw">var</span> decompressed_section = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, chdr.ch_size);</span>
<span class="line" id="L1157">                <span class="tok-kw">errdefer</span> allocator.free(decompressed_section);</span>
<span class="line" id="L1158"></span>
<span class="line" id="L1159">                <span class="tok-kw">const</span> read = zlib_stream.reader().readAll(decompressed_section) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1160">                assert(read == decompressed_section.len);</span>
<span class="line" id="L1161"></span>
<span class="line" id="L1162">                <span class="tok-kw">break</span> :blk .{</span>
<span class="line" id="L1163">                    .data = decompressed_section,</span>
<span class="line" id="L1164">                    .virtual_address = shdr.sh_addr,</span>
<span class="line" id="L1165">                    .owned = <span class="tok-null">true</span>,</span>
<span class="line" id="L1166">                };</span>
<span class="line" id="L1167">            } <span class="tok-kw">else</span> .{</span>
<span class="line" id="L1168">                .data = section_bytes,</span>
<span class="line" id="L1169">                .virtual_address = shdr.sh_addr,</span>
<span class="line" id="L1170">                .owned = <span class="tok-null">false</span>,</span>
<span class="line" id="L1171">            };</span>
<span class="line" id="L1172">        }</span>
<span class="line" id="L1173"></span>
<span class="line" id="L1174">        <span class="tok-kw">const</span> missing_debug_info =</span>
<span class="line" id="L1175">            sections[<span class="tok-builtin">@intFromEnum</span>(DW.DwarfSection.debug_info)] == <span class="tok-null">null</span> <span class="tok-kw">or</span></span>
<span class="line" id="L1176">            sections[<span class="tok-builtin">@intFromEnum</span>(DW.DwarfSection.debug_abbrev)] == <span class="tok-null">null</span> <span class="tok-kw">or</span></span>
<span class="line" id="L1177">            sections[<span class="tok-builtin">@intFromEnum</span>(DW.DwarfSection.debug_str)] == <span class="tok-null">null</span> <span class="tok-kw">or</span></span>
<span class="line" id="L1178">            sections[<span class="tok-builtin">@intFromEnum</span>(DW.DwarfSection.debug_line)] == <span class="tok-null">null</span>;</span>
<span class="line" id="L1179"></span>
<span class="line" id="L1180">        <span class="tok-comment">// Attempt to load debug info from an external file</span>
</span>
<span class="line" id="L1181">        <span class="tok-comment">// See: https://sourceware.org/gdb/onlinedocs/gdb/Separate-Debug-Files.html</span>
</span>
<span class="line" id="L1182">        <span class="tok-kw">if</span> (missing_debug_info) {</span>
<span class="line" id="L1183"></span>
<span class="line" id="L1184">            <span class="tok-comment">// Only allow one level of debug info nesting</span>
</span>
<span class="line" id="L1185">            <span class="tok-kw">if</span> (parent_mapped_mem) |_| {</span>
<span class="line" id="L1186">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1187">            }</span>
<span class="line" id="L1188"></span>
<span class="line" id="L1189">            <span class="tok-kw">const</span> global_debug_directories = [_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{</span>
<span class="line" id="L1190">                <span class="tok-str">&quot;/usr/lib/debug&quot;</span>,</span>
<span class="line" id="L1191">            };</span>
<span class="line" id="L1192"></span>
<span class="line" id="L1193">            <span class="tok-comment">// &lt;global debug directory&gt;/.build-id/&lt;2-character id prefix&gt;/&lt;id remainder&gt;.debug</span>
</span>
<span class="line" id="L1194">            <span class="tok-kw">if</span> (build_id) |id| blk: {</span>
<span class="line" id="L1195">                <span class="tok-kw">if</span> (id.len &lt; <span class="tok-number">3</span>) <span class="tok-kw">break</span> :blk;</span>
<span class="line" id="L1196"></span>
<span class="line" id="L1197">                <span class="tok-comment">// Either md5 (16 bytes) or sha1 (20 bytes) are used here in practice</span>
</span>
<span class="line" id="L1198">                <span class="tok-kw">const</span> extension = <span class="tok-str">&quot;.debug&quot;</span>;</span>
<span class="line" id="L1199">                <span class="tok-kw">var</span> id_prefix_buf: [<span class="tok-number">2</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1200">                <span class="tok-kw">var</span> filename_buf: [<span class="tok-number">38</span> + extension.len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1201"></span>
<span class="line" id="L1202">                _ = std.fmt.bufPrint(&amp;id_prefix_buf, <span class="tok-str">&quot;{s}&quot;</span>, .{std.fmt.fmtSliceHexLower(id[<span class="tok-number">0</span>..<span class="tok-number">1</span>])}) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L1203">                <span class="tok-kw">const</span> filename = std.fmt.bufPrint(</span>
<span class="line" id="L1204">                    &amp;filename_buf,</span>
<span class="line" id="L1205">                    <span class="tok-str">&quot;{s}&quot;</span> ++ extension,</span>
<span class="line" id="L1206">                    .{std.fmt.fmtSliceHexLower(id[<span class="tok-number">1</span>..])},</span>
<span class="line" id="L1207">                ) <span class="tok-kw">catch</span> <span class="tok-kw">break</span> :blk;</span>
<span class="line" id="L1208"></span>
<span class="line" id="L1209">                <span class="tok-kw">for</span> (global_debug_directories) |global_directory| {</span>
<span class="line" id="L1210">                    <span class="tok-kw">const</span> path = <span class="tok-kw">try</span> fs.path.join(allocator, &amp;.{ global_directory, <span class="tok-str">&quot;.build-id&quot;</span>, &amp;id_prefix_buf, filename });</span>
<span class="line" id="L1211">                    <span class="tok-kw">defer</span> allocator.free(path);</span>
<span class="line" id="L1212"></span>
<span class="line" id="L1213">                    <span class="tok-kw">return</span> readElfDebugInfo(allocator, path, <span class="tok-null">null</span>, separate_debug_crc, &amp;sections, mapped_mem) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1214">                }</span>
<span class="line" id="L1215">            }</span>
<span class="line" id="L1216"></span>
<span class="line" id="L1217">            <span class="tok-comment">// use the path from .gnu_debuglink, in the same search order as gdb</span>
</span>
<span class="line" id="L1218">            <span class="tok-kw">if</span> (separate_debug_filename) |separate_filename| blk: {</span>
<span class="line" id="L1219">                <span class="tok-kw">if</span> (elf_filename != <span class="tok-null">null</span> <span class="tok-kw">and</span> mem.eql(<span class="tok-type">u8</span>, elf_filename.?, separate_filename)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1220"></span>
<span class="line" id="L1221">                <span class="tok-comment">// &lt;cwd&gt;/&lt;gnu_debuglink&gt;</span>
</span>
<span class="line" id="L1222">                <span class="tok-kw">if</span> (readElfDebugInfo(allocator, separate_filename, <span class="tok-null">null</span>, separate_debug_crc, &amp;sections, mapped_mem)) |debug_info| <span class="tok-kw">return</span> debug_info <span class="tok-kw">else</span> |_| {}</span>
<span class="line" id="L1223"></span>
<span class="line" id="L1224">                <span class="tok-comment">// &lt;cwd&gt;/.debug/&lt;gnu_debuglink&gt;</span>
</span>
<span class="line" id="L1225">                {</span>
<span class="line" id="L1226">                    <span class="tok-kw">const</span> path = <span class="tok-kw">try</span> fs.path.join(allocator, &amp;.{ <span class="tok-str">&quot;.debug&quot;</span>, separate_filename });</span>
<span class="line" id="L1227">                    <span class="tok-kw">defer</span> allocator.free(path);</span>
<span class="line" id="L1228"></span>
<span class="line" id="L1229">                    <span class="tok-kw">if</span> (readElfDebugInfo(allocator, path, <span class="tok-null">null</span>, separate_debug_crc, &amp;sections, mapped_mem)) |debug_info| <span class="tok-kw">return</span> debug_info <span class="tok-kw">else</span> |_| {}</span>
<span class="line" id="L1230">                }</span>
<span class="line" id="L1231"></span>
<span class="line" id="L1232">                <span class="tok-kw">var</span> cwd_buf: [fs.MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1233">                <span class="tok-kw">const</span> cwd_path = fs.cwd().realpath(<span class="tok-str">&quot;&quot;</span>, &amp;cwd_buf) <span class="tok-kw">catch</span> <span class="tok-kw">break</span> :blk;</span>
<span class="line" id="L1234"></span>
<span class="line" id="L1235">                <span class="tok-comment">// &lt;global debug directory&gt;/&lt;absolute folder of current binary&gt;/&lt;gnu_debuglink&gt;</span>
</span>
<span class="line" id="L1236">                <span class="tok-kw">for</span> (global_debug_directories) |global_directory| {</span>
<span class="line" id="L1237">                    <span class="tok-kw">const</span> path = <span class="tok-kw">try</span> fs.path.join(allocator, &amp;.{ global_directory, cwd_path, separate_filename });</span>
<span class="line" id="L1238">                    <span class="tok-kw">defer</span> allocator.free(path);</span>
<span class="line" id="L1239">                    <span class="tok-kw">if</span> (readElfDebugInfo(allocator, path, <span class="tok-null">null</span>, separate_debug_crc, &amp;sections, mapped_mem)) |debug_info| <span class="tok-kw">return</span> debug_info <span class="tok-kw">else</span> |_| {}</span>
<span class="line" id="L1240">                }</span>
<span class="line" id="L1241">            }</span>
<span class="line" id="L1242"></span>
<span class="line" id="L1243">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1244">        }</span>
<span class="line" id="L1245"></span>
<span class="line" id="L1246">        <span class="tok-kw">var</span> di = DW.DwarfInfo{</span>
<span class="line" id="L1247">            .endian = endian,</span>
<span class="line" id="L1248">            .sections = sections,</span>
<span class="line" id="L1249">            .is_macho = <span class="tok-null">false</span>,</span>
<span class="line" id="L1250">        };</span>
<span class="line" id="L1251"></span>
<span class="line" id="L1252">        <span class="tok-kw">try</span> DW.openDwarfDebugInfo(&amp;di, allocator);</span>
<span class="line" id="L1253"></span>
<span class="line" id="L1254">        <span class="tok-kw">return</span> ModuleDebugInfo{</span>
<span class="line" id="L1255">            .base_address = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L1256">            .dwarf = di,</span>
<span class="line" id="L1257">            .mapped_memory = parent_mapped_mem <span class="tok-kw">orelse</span> mapped_mem,</span>
<span class="line" id="L1258">            .external_mapped_memory = <span class="tok-kw">if</span> (parent_mapped_mem != <span class="tok-null">null</span>) mapped_mem <span class="tok-kw">else</span> <span class="tok-null">null</span>,</span>
<span class="line" id="L1259">        };</span>
<span class="line" id="L1260">    }</span>
<span class="line" id="L1261">}</span>
<span class="line" id="L1262"></span>
<span class="line" id="L1263"><span class="tok-comment">/// This takes ownership of macho_file: users of this function should not close</span></span>
<span class="line" id="L1264"><span class="tok-comment">/// it themselves, even on error.</span></span>
<span class="line" id="L1265"><span class="tok-comment">/// TODO it's weird to take ownership even on error, rework this code.</span></span>
<span class="line" id="L1266"><span class="tok-kw">fn</span> <span class="tok-fn">readMachODebugInfo</span>(allocator: mem.Allocator, macho_file: File) !ModuleDebugInfo {</span>
<span class="line" id="L1267">    <span class="tok-kw">const</span> mapped_mem = <span class="tok-kw">try</span> mapWholeFile(macho_file);</span>
<span class="line" id="L1268"></span>
<span class="line" id="L1269">    <span class="tok-kw">const</span> hdr: *<span class="tok-kw">const</span> macho.mach_header_64 = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(mapped_mem.ptr));</span>
<span class="line" id="L1270">    <span class="tok-kw">if</span> (hdr.magic != macho.MH_MAGIC_64)</span>
<span class="line" id="L1271">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo;</span>
<span class="line" id="L1272"></span>
<span class="line" id="L1273">    <span class="tok-kw">var</span> it = macho.LoadCommandIterator{</span>
<span class="line" id="L1274">        .ncmds = hdr.ncmds,</span>
<span class="line" id="L1275">        .buffer = mapped_mem[<span class="tok-builtin">@sizeOf</span>(macho.mach_header_64)..][<span class="tok-number">0</span>..hdr.sizeofcmds],</span>
<span class="line" id="L1276">    };</span>
<span class="line" id="L1277">    <span class="tok-kw">const</span> symtab = <span class="tok-kw">while</span> (it.next()) |cmd| <span class="tok-kw">switch</span> (cmd.cmd()) {</span>
<span class="line" id="L1278">        .SYMTAB =&gt; <span class="tok-kw">break</span> cmd.cast(macho.symtab_command).?,</span>
<span class="line" id="L1279">        <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L1280">    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1281"></span>
<span class="line" id="L1282">    <span class="tok-kw">const</span> syms = <span class="tok-builtin">@as</span>(</span>
<span class="line" id="L1283">        [*]<span class="tok-kw">const</span> macho.nlist_64,</span>
<span class="line" id="L1284">        <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;mapped_mem[symtab.symoff])),</span>
<span class="line" id="L1285">    )[<span class="tok-number">0</span>..symtab.nsyms];</span>
<span class="line" id="L1286">    <span class="tok-kw">const</span> strings = mapped_mem[symtab.stroff..][<span class="tok-number">0</span> .. symtab.strsize - <span class="tok-number">1</span> :<span class="tok-number">0</span>];</span>
<span class="line" id="L1287"></span>
<span class="line" id="L1288">    <span class="tok-kw">const</span> symbols_buf = <span class="tok-kw">try</span> allocator.alloc(MachoSymbol, syms.len);</span>
<span class="line" id="L1289"></span>
<span class="line" id="L1290">    <span class="tok-kw">var</span> ofile: <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1291">    <span class="tok-kw">var</span> last_sym: MachoSymbol = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1292">    <span class="tok-kw">var</span> symbol_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1293">    <span class="tok-kw">var</span> state: <span class="tok-kw">enum</span> {</span>
<span class="line" id="L1294">        init,</span>
<span class="line" id="L1295">        oso_open,</span>
<span class="line" id="L1296">        oso_close,</span>
<span class="line" id="L1297">        bnsym,</span>
<span class="line" id="L1298">        fun_strx,</span>
<span class="line" id="L1299">        fun_size,</span>
<span class="line" id="L1300">        ensym,</span>
<span class="line" id="L1301">    } = .init;</span>
<span class="line" id="L1302"></span>
<span class="line" id="L1303">    <span class="tok-kw">for</span> (syms) |*sym| {</span>
<span class="line" id="L1304">        <span class="tok-kw">if</span> (!sym.stab()) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1305"></span>
<span class="line" id="L1306">        <span class="tok-comment">// TODO handle globals N_GSYM, and statics N_STSYM</span>
</span>
<span class="line" id="L1307">        <span class="tok-kw">switch</span> (sym.n_type) {</span>
<span class="line" id="L1308">            macho.N_OSO =&gt; {</span>
<span class="line" id="L1309">                <span class="tok-kw">switch</span> (state) {</span>
<span class="line" id="L1310">                    .init, .oso_close =&gt; {</span>
<span class="line" id="L1311">                        state = .oso_open;</span>
<span class="line" id="L1312">                        ofile = sym.n_strx;</span>
<span class="line" id="L1313">                    },</span>
<span class="line" id="L1314">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo,</span>
<span class="line" id="L1315">                }</span>
<span class="line" id="L1316">            },</span>
<span class="line" id="L1317">            macho.N_BNSYM =&gt; {</span>
<span class="line" id="L1318">                <span class="tok-kw">switch</span> (state) {</span>
<span class="line" id="L1319">                    .oso_open, .ensym =&gt; {</span>
<span class="line" id="L1320">                        state = .bnsym;</span>
<span class="line" id="L1321">                        last_sym = .{</span>
<span class="line" id="L1322">                            .strx = <span class="tok-number">0</span>,</span>
<span class="line" id="L1323">                            .addr = sym.n_value,</span>
<span class="line" id="L1324">                            .size = <span class="tok-number">0</span>,</span>
<span class="line" id="L1325">                            .ofile = ofile,</span>
<span class="line" id="L1326">                        };</span>
<span class="line" id="L1327">                    },</span>
<span class="line" id="L1328">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo,</span>
<span class="line" id="L1329">                }</span>
<span class="line" id="L1330">            },</span>
<span class="line" id="L1331">            macho.N_FUN =&gt; {</span>
<span class="line" id="L1332">                <span class="tok-kw">switch</span> (state) {</span>
<span class="line" id="L1333">                    .bnsym =&gt; {</span>
<span class="line" id="L1334">                        state = .fun_strx;</span>
<span class="line" id="L1335">                        last_sym.strx = sym.n_strx;</span>
<span class="line" id="L1336">                    },</span>
<span class="line" id="L1337">                    .fun_strx =&gt; {</span>
<span class="line" id="L1338">                        state = .fun_size;</span>
<span class="line" id="L1339">                        last_sym.size = <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(sym.n_value));</span>
<span class="line" id="L1340">                    },</span>
<span class="line" id="L1341">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo,</span>
<span class="line" id="L1342">                }</span>
<span class="line" id="L1343">            },</span>
<span class="line" id="L1344">            macho.N_ENSYM =&gt; {</span>
<span class="line" id="L1345">                <span class="tok-kw">switch</span> (state) {</span>
<span class="line" id="L1346">                    .fun_size =&gt; {</span>
<span class="line" id="L1347">                        state = .ensym;</span>
<span class="line" id="L1348">                        symbols_buf[symbol_index] = last_sym;</span>
<span class="line" id="L1349">                        symbol_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L1350">                    },</span>
<span class="line" id="L1351">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo,</span>
<span class="line" id="L1352">                }</span>
<span class="line" id="L1353">            },</span>
<span class="line" id="L1354">            macho.N_SO =&gt; {</span>
<span class="line" id="L1355">                <span class="tok-kw">switch</span> (state) {</span>
<span class="line" id="L1356">                    .init, .oso_close =&gt; {},</span>
<span class="line" id="L1357">                    .oso_open, .ensym =&gt; {</span>
<span class="line" id="L1358">                        state = .oso_close;</span>
<span class="line" id="L1359">                    },</span>
<span class="line" id="L1360">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo,</span>
<span class="line" id="L1361">                }</span>
<span class="line" id="L1362">            },</span>
<span class="line" id="L1363">            <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L1364">        }</span>
<span class="line" id="L1365">    }</span>
<span class="line" id="L1366"></span>
<span class="line" id="L1367">    <span class="tok-kw">switch</span> (state) {</span>
<span class="line" id="L1368">        .init =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo,</span>
<span class="line" id="L1369">        .oso_close =&gt; {},</span>
<span class="line" id="L1370">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo,</span>
<span class="line" id="L1371">    }</span>
<span class="line" id="L1372"></span>
<span class="line" id="L1373">    <span class="tok-kw">const</span> symbols = <span class="tok-kw">try</span> allocator.realloc(symbols_buf, symbol_index);</span>
<span class="line" id="L1374"></span>
<span class="line" id="L1375">    <span class="tok-comment">// Even though lld emits symbols in ascending order, this debug code</span>
</span>
<span class="line" id="L1376">    <span class="tok-comment">// should work for programs linked in any valid way.</span>
</span>
<span class="line" id="L1377">    <span class="tok-comment">// This sort is so that we can binary search later.</span>
</span>
<span class="line" id="L1378">    mem.sort(MachoSymbol, symbols, {}, MachoSymbol.addressLessThan);</span>
<span class="line" id="L1379"></span>
<span class="line" id="L1380">    <span class="tok-kw">return</span> ModuleDebugInfo{</span>
<span class="line" id="L1381">        .base_address = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L1382">        .vmaddr_slide = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L1383">        .mapped_memory = mapped_mem,</span>
<span class="line" id="L1384">        .ofiles = ModuleDebugInfo.OFileTable.init(allocator),</span>
<span class="line" id="L1385">        .symbols = symbols,</span>
<span class="line" id="L1386">        .strings = strings,</span>
<span class="line" id="L1387">    };</span>
<span class="line" id="L1388">}</span>
<span class="line" id="L1389"></span>
<span class="line" id="L1390"><span class="tok-kw">fn</span> <span class="tok-fn">printLineFromFileAnyOs</span>(out_stream: <span class="tok-kw">anytype</span>, line_info: LineInfo) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1391">    <span class="tok-comment">// Need this to always block even in async I/O mode, because this could potentially</span>
</span>
<span class="line" id="L1392">    <span class="tok-comment">// be called from e.g. the event loop code crashing.</span>
</span>
<span class="line" id="L1393">    <span class="tok-kw">var</span> f = <span class="tok-kw">try</span> fs.cwd().openFile(line_info.file_name, .{ .intended_io_mode = .blocking });</span>
<span class="line" id="L1394">    <span class="tok-kw">defer</span> f.close();</span>
<span class="line" id="L1395">    <span class="tok-comment">// TODO fstat and make sure that the file has the correct size</span>
</span>
<span class="line" id="L1396"></span>
<span class="line" id="L1397">    <span class="tok-kw">var</span> buf: [mem.page_size]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1398">    <span class="tok-kw">var</span> line: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;</span>
<span class="line" id="L1399">    <span class="tok-kw">var</span> column: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;</span>
<span class="line" id="L1400">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L1401">        <span class="tok-kw">const</span> amt_read = <span class="tok-kw">try</span> f.read(buf[<span class="tok-number">0</span>..]);</span>
<span class="line" id="L1402">        <span class="tok-kw">const</span> slice = buf[<span class="tok-number">0</span>..amt_read];</span>
<span class="line" id="L1403"></span>
<span class="line" id="L1404">        <span class="tok-kw">for</span> (slice) |byte| {</span>
<span class="line" id="L1405">            <span class="tok-kw">if</span> (line == line_info.line) {</span>
<span class="line" id="L1406">                <span class="tok-kw">switch</span> (byte) {</span>
<span class="line" id="L1407">                    <span class="tok-str">'\t'</span> =&gt; <span class="tok-kw">try</span> out_stream.writeByte(<span class="tok-str">' '</span>),</span>
<span class="line" id="L1408">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">try</span> out_stream.writeByte(byte),</span>
<span class="line" id="L1409">                }</span>
<span class="line" id="L1410">                <span class="tok-kw">if</span> (byte == <span class="tok-str">'\n'</span>) {</span>
<span class="line" id="L1411">                    <span class="tok-kw">return</span>;</span>
<span class="line" id="L1412">                }</span>
<span class="line" id="L1413">            }</span>
<span class="line" id="L1414">            <span class="tok-kw">if</span> (byte == <span class="tok-str">'\n'</span>) {</span>
<span class="line" id="L1415">                line += <span class="tok-number">1</span>;</span>
<span class="line" id="L1416">                column = <span class="tok-number">1</span>;</span>
<span class="line" id="L1417">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1418">                column += <span class="tok-number">1</span>;</span>
<span class="line" id="L1419">            }</span>
<span class="line" id="L1420">        }</span>
<span class="line" id="L1421"></span>
<span class="line" id="L1422">        <span class="tok-kw">if</span> (amt_read &lt; buf.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EndOfFile;</span>
<span class="line" id="L1423">    }</span>
<span class="line" id="L1424">}</span>
<span class="line" id="L1425"></span>
<span class="line" id="L1426"><span class="tok-kw">const</span> MachoSymbol = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1427">    strx: <span class="tok-type">u32</span>,</span>
<span class="line" id="L1428">    addr: <span class="tok-type">u64</span>,</span>
<span class="line" id="L1429">    size: <span class="tok-type">u32</span>,</span>
<span class="line" id="L1430">    ofile: <span class="tok-type">u32</span>,</span>
<span class="line" id="L1431"></span>
<span class="line" id="L1432">    <span class="tok-comment">/// Returns the address from the macho file</span></span>
<span class="line" id="L1433">    <span class="tok-kw">fn</span> <span class="tok-fn">address</span>(self: MachoSymbol) <span class="tok-type">u64</span> {</span>
<span class="line" id="L1434">        <span class="tok-kw">return</span> self.addr;</span>
<span class="line" id="L1435">    }</span>
<span class="line" id="L1436"></span>
<span class="line" id="L1437">    <span class="tok-kw">fn</span> <span class="tok-fn">addressLessThan</span>(context: <span class="tok-type">void</span>, lhs: MachoSymbol, rhs: MachoSymbol) <span class="tok-type">bool</span> {</span>
<span class="line" id="L1438">        _ = context;</span>
<span class="line" id="L1439">        <span class="tok-kw">return</span> lhs.addr &lt; rhs.addr;</span>
<span class="line" id="L1440">    }</span>
<span class="line" id="L1441">};</span>
<span class="line" id="L1442"></span>
<span class="line" id="L1443"><span class="tok-comment">/// `file` is expected to have been opened with .intended_io_mode == .blocking.</span></span>
<span class="line" id="L1444"><span class="tok-comment">/// Takes ownership of file, even on error.</span></span>
<span class="line" id="L1445"><span class="tok-comment">/// TODO it's weird to take ownership even on error, rework this code.</span></span>
<span class="line" id="L1446"><span class="tok-kw">fn</span> <span class="tok-fn">mapWholeFile</span>(file: File) ![]<span class="tok-kw">align</span>(mem.page_size) <span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1447">    <span class="tok-kw">nosuspend</span> {</span>
<span class="line" id="L1448">        <span class="tok-kw">defer</span> file.close();</span>
<span class="line" id="L1449"></span>
<span class="line" id="L1450">        <span class="tok-kw">const</span> file_len = math.cast(<span class="tok-type">usize</span>, <span class="tok-kw">try</span> file.getEndPos()) <span class="tok-kw">orelse</span> math.maxInt(<span class="tok-type">usize</span>);</span>
<span class="line" id="L1451">        <span class="tok-kw">const</span> mapped_mem = <span class="tok-kw">try</span> os.mmap(</span>
<span class="line" id="L1452">            <span class="tok-null">null</span>,</span>
<span class="line" id="L1453">            file_len,</span>
<span class="line" id="L1454">            os.PROT.READ,</span>
<span class="line" id="L1455">            os.MAP.SHARED,</span>
<span class="line" id="L1456">            file.handle,</span>
<span class="line" id="L1457">            <span class="tok-number">0</span>,</span>
<span class="line" id="L1458">        );</span>
<span class="line" id="L1459">        <span class="tok-kw">errdefer</span> os.munmap(mapped_mem);</span>
<span class="line" id="L1460"></span>
<span class="line" id="L1461">        <span class="tok-kw">return</span> mapped_mem;</span>
<span class="line" id="L1462">    }</span>
<span class="line" id="L1463">}</span>
<span class="line" id="L1464"></span>
<span class="line" id="L1465"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> WindowsModuleInfo = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1466">    base_address: <span class="tok-type">usize</span>,</span>
<span class="line" id="L1467">    size: <span class="tok-type">u32</span>,</span>
<span class="line" id="L1468">    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1469">    handle: windows.HMODULE,</span>
<span class="line" id="L1470"></span>
<span class="line" id="L1471">    <span class="tok-comment">// Set when the image file needed to be mapped from disk</span>
</span>
<span class="line" id="L1472">    mapped_file: ?<span class="tok-kw">struct</span> {</span>
<span class="line" id="L1473">        file: File,</span>
<span class="line" id="L1474">        section_handle: windows.HANDLE,</span>
<span class="line" id="L1475">        section_view: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1476"></span>
<span class="line" id="L1477">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: <span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {</span>
<span class="line" id="L1478">            <span class="tok-kw">const</span> process_handle = windows.kernel32.GetCurrentProcess();</span>
<span class="line" id="L1479">            assert(windows.ntdll.NtUnmapViewOfSection(process_handle, <span class="tok-builtin">@constCast</span>(<span class="tok-builtin">@ptrCast</span>(self.section_view.ptr))) == .SUCCESS);</span>
<span class="line" id="L1480">            windows.CloseHandle(self.section_handle);</span>
<span class="line" id="L1481">            self.file.close();</span>
<span class="line" id="L1482">        }</span>
<span class="line" id="L1483">    } = <span class="tok-null">null</span>,</span>
<span class="line" id="L1484">};</span>
<span class="line" id="L1485"></span>
<span class="line" id="L1486"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DebugInfo = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1487">    allocator: mem.Allocator,</span>
<span class="line" id="L1488">    address_map: std.AutoHashMap(<span class="tok-type">usize</span>, *ModuleDebugInfo),</span>
<span class="line" id="L1489">    modules: <span class="tok-kw">if</span> (native_os == .windows) std.ArrayListUnmanaged(WindowsModuleInfo) <span class="tok-kw">else</span> <span class="tok-type">void</span>,</span>
<span class="line" id="L1490"></span>
<span class="line" id="L1491">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: mem.Allocator) !DebugInfo {</span>
<span class="line" id="L1492">        <span class="tok-kw">var</span> debug_info = DebugInfo{</span>
<span class="line" id="L1493">            .allocator = allocator,</span>
<span class="line" id="L1494">            .address_map = std.AutoHashMap(<span class="tok-type">usize</span>, *ModuleDebugInfo).init(allocator),</span>
<span class="line" id="L1495">            .modules = <span class="tok-kw">if</span> (native_os == .windows) .{} <span class="tok-kw">else</span> {},</span>
<span class="line" id="L1496">        };</span>
<span class="line" id="L1497"></span>
<span class="line" id="L1498">        <span class="tok-kw">if</span> (native_os == .windows) {</span>
<span class="line" id="L1499">            <span class="tok-kw">errdefer</span> debug_info.modules.deinit(allocator);</span>
<span class="line" id="L1500"></span>
<span class="line" id="L1501">            <span class="tok-kw">const</span> handle = windows.kernel32.CreateToolhelp32Snapshot(windows.TH32CS_SNAPMODULE | windows.TH32CS_SNAPMODULE32, <span class="tok-number">0</span>);</span>
<span class="line" id="L1502">            <span class="tok-kw">if</span> (handle == windows.INVALID_HANDLE_VALUE) {</span>
<span class="line" id="L1503">                <span class="tok-kw">switch</span> (windows.kernel32.GetLastError()) {</span>
<span class="line" id="L1504">                    <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> windows.unexpectedError(err),</span>
<span class="line" id="L1505">                }</span>
<span class="line" id="L1506">            }</span>
<span class="line" id="L1507">            <span class="tok-kw">defer</span> windows.CloseHandle(handle);</span>
<span class="line" id="L1508"></span>
<span class="line" id="L1509">            <span class="tok-kw">var</span> module_entry: windows.MODULEENTRY32 = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1510">            module_entry.dwSize = <span class="tok-builtin">@sizeOf</span>(windows.MODULEENTRY32);</span>
<span class="line" id="L1511">            <span class="tok-kw">if</span> (windows.kernel32.Module32First(handle, &amp;module_entry) == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1512">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1513">            }</span>
<span class="line" id="L1514"></span>
<span class="line" id="L1515">            <span class="tok-kw">var</span> module_valid = <span class="tok-null">true</span>;</span>
<span class="line" id="L1516">            <span class="tok-kw">while</span> (module_valid) {</span>
<span class="line" id="L1517">                <span class="tok-kw">const</span> module_info = <span class="tok-kw">try</span> debug_info.modules.addOne(allocator);</span>
<span class="line" id="L1518">                <span class="tok-kw">const</span> name = allocator.dupe(<span class="tok-type">u8</span>, mem.sliceTo(&amp;module_entry.szModule, <span class="tok-number">0</span>)) <span class="tok-kw">catch</span> &amp;.{};</span>
<span class="line" id="L1519">                <span class="tok-kw">errdefer</span> allocator.free(name);</span>
<span class="line" id="L1520"></span>
<span class="line" id="L1521">                module_info.* = .{</span>
<span class="line" id="L1522">                    .base_address = <span class="tok-builtin">@intFromPtr</span>(module_entry.modBaseAddr),</span>
<span class="line" id="L1523">                    .size = module_entry.modBaseSize,</span>
<span class="line" id="L1524">                    .name = name,</span>
<span class="line" id="L1525">                    .handle = module_entry.hModule,</span>
<span class="line" id="L1526">                };</span>
<span class="line" id="L1527"></span>
<span class="line" id="L1528">                module_valid = windows.kernel32.Module32Next(handle, &amp;module_entry) == <span class="tok-number">1</span>;</span>
<span class="line" id="L1529">            }</span>
<span class="line" id="L1530">        }</span>
<span class="line" id="L1531"></span>
<span class="line" id="L1532">        <span class="tok-kw">return</span> debug_info;</span>
<span class="line" id="L1533">    }</span>
<span class="line" id="L1534"></span>
<span class="line" id="L1535">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *DebugInfo) <span class="tok-type">void</span> {</span>
<span class="line" id="L1536">        <span class="tok-kw">var</span> it = self.address_map.iterator();</span>
<span class="line" id="L1537">        <span class="tok-kw">while</span> (it.next()) |entry| {</span>
<span class="line" id="L1538">            <span class="tok-kw">const</span> mdi = entry.value_ptr.*;</span>
<span class="line" id="L1539">            mdi.deinit(self.allocator);</span>
<span class="line" id="L1540">            self.allocator.destroy(mdi);</span>
<span class="line" id="L1541">        }</span>
<span class="line" id="L1542">        self.address_map.deinit();</span>
<span class="line" id="L1543">        <span class="tok-kw">if</span> (native_os == .windows) {</span>
<span class="line" id="L1544">            <span class="tok-kw">for</span> (self.modules.items) |module| {</span>
<span class="line" id="L1545">                self.allocator.free(module.name);</span>
<span class="line" id="L1546">                <span class="tok-kw">if</span> (module.mapped_file) |mapped_file| mapped_file.deinit();</span>
<span class="line" id="L1547">            }</span>
<span class="line" id="L1548">            self.modules.deinit(self.allocator);</span>
<span class="line" id="L1549">        }</span>
<span class="line" id="L1550">    }</span>
<span class="line" id="L1551"></span>
<span class="line" id="L1552">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getModuleForAddress</span>(self: *DebugInfo, address: <span class="tok-type">usize</span>) !*ModuleDebugInfo {</span>
<span class="line" id="L1553">        <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> builtin.target.isDarwin()) {</span>
<span class="line" id="L1554">            <span class="tok-kw">return</span> self.lookupModuleDyld(address);</span>
<span class="line" id="L1555">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (native_os == .windows) {</span>
<span class="line" id="L1556">            <span class="tok-kw">return</span> self.lookupModuleWin32(address);</span>
<span class="line" id="L1557">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (native_os == .haiku) {</span>
<span class="line" id="L1558">            <span class="tok-kw">return</span> self.lookupModuleHaiku(address);</span>
<span class="line" id="L1559">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> builtin.target.isWasm()) {</span>
<span class="line" id="L1560">            <span class="tok-kw">return</span> self.lookupModuleWasm(address);</span>
<span class="line" id="L1561">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1562">            <span class="tok-kw">return</span> self.lookupModuleDl(address);</span>
<span class="line" id="L1563">        }</span>
<span class="line" id="L1564">    }</span>
<span class="line" id="L1565"></span>
<span class="line" id="L1566">    <span class="tok-comment">// Returns the module name for a given address.</span>
</span>
<span class="line" id="L1567">    <span class="tok-comment">// This can be called when getModuleForAddress fails, so implementations should provide</span>
</span>
<span class="line" id="L1568">    <span class="tok-comment">// a path that doesn't rely on any side-effects of a prior successful module lookup.</span>
</span>
<span class="line" id="L1569">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getModuleNameForAddress</span>(self: *DebugInfo, address: <span class="tok-type">usize</span>) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1570">        <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> builtin.target.isDarwin()) {</span>
<span class="line" id="L1571">            <span class="tok-kw">return</span> self.lookupModuleNameDyld(address);</span>
<span class="line" id="L1572">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (native_os == .windows) {</span>
<span class="line" id="L1573">            <span class="tok-kw">return</span> self.lookupModuleNameWin32(address);</span>
<span class="line" id="L1574">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (native_os == .haiku) {</span>
<span class="line" id="L1575">            <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1576">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> builtin.target.isWasm()) {</span>
<span class="line" id="L1577">            <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1578">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1579">            <span class="tok-kw">return</span> self.lookupModuleNameDl(address);</span>
<span class="line" id="L1580">        }</span>
<span class="line" id="L1581">    }</span>
<span class="line" id="L1582"></span>
<span class="line" id="L1583">    <span class="tok-kw">fn</span> <span class="tok-fn">lookupModuleDyld</span>(self: *DebugInfo, address: <span class="tok-type">usize</span>) !*ModuleDebugInfo {</span>
<span class="line" id="L1584">        <span class="tok-kw">const</span> image_count = std.c._dyld_image_count();</span>
<span class="line" id="L1585"></span>
<span class="line" id="L1586">        <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1587">        <span class="tok-kw">while</span> (i &lt; image_count) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L1588">            <span class="tok-kw">const</span> header = std.c._dyld_get_image_header(i) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1589">            <span class="tok-kw">const</span> base_address = <span class="tok-builtin">@intFromPtr</span>(header);</span>
<span class="line" id="L1590">            <span class="tok-kw">if</span> (address &lt; base_address) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1591">            <span class="tok-kw">const</span> vmaddr_slide = std.c._dyld_get_image_vmaddr_slide(i);</span>
<span class="line" id="L1592"></span>
<span class="line" id="L1593">            <span class="tok-kw">var</span> it = macho.LoadCommandIterator{</span>
<span class="line" id="L1594">                .ncmds = header.ncmds,</span>
<span class="line" id="L1595">                .buffer = <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@as</span>(</span>
<span class="line" id="L1596">                    [*]<span class="tok-type">u8</span>,</span>
<span class="line" id="L1597">                    <span class="tok-builtin">@ptrFromInt</span>(<span class="tok-builtin">@intFromPtr</span>(header) + <span class="tok-builtin">@sizeOf</span>(macho.mach_header_64)),</span>
<span class="line" id="L1598">                )[<span class="tok-number">0</span>..header.sizeofcmds]),</span>
<span class="line" id="L1599">            };</span>
<span class="line" id="L1600"></span>
<span class="line" id="L1601">            <span class="tok-kw">var</span> unwind_info: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L1602">            <span class="tok-kw">var</span> eh_frame: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L1603">            <span class="tok-kw">while</span> (it.next()) |cmd| <span class="tok-kw">switch</span> (cmd.cmd()) {</span>
<span class="line" id="L1604">                .SEGMENT_64 =&gt; {</span>
<span class="line" id="L1605">                    <span class="tok-kw">const</span> segment_cmd = cmd.cast(macho.segment_command_64).?;</span>
<span class="line" id="L1606">                    <span class="tok-kw">if</span> (!mem.eql(<span class="tok-type">u8</span>, <span class="tok-str">&quot;__TEXT&quot;</span>, segment_cmd.segName())) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1607"></span>
<span class="line" id="L1608">                    <span class="tok-kw">const</span> seg_start = segment_cmd.vmaddr + vmaddr_slide;</span>
<span class="line" id="L1609">                    <span class="tok-kw">const</span> seg_end = seg_start + segment_cmd.vmsize;</span>
<span class="line" id="L1610">                    <span class="tok-kw">if</span> (address &gt;= seg_start <span class="tok-kw">and</span> address &lt; seg_end) {</span>
<span class="line" id="L1611">                        <span class="tok-kw">if</span> (self.address_map.get(base_address)) |obj_di| {</span>
<span class="line" id="L1612">                            <span class="tok-kw">return</span> obj_di;</span>
<span class="line" id="L1613">                        }</span>
<span class="line" id="L1614"></span>
<span class="line" id="L1615">                        <span class="tok-kw">for</span> (cmd.getSections()) |sect| {</span>
<span class="line" id="L1616">                            <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, <span class="tok-str">&quot;__unwind_info&quot;</span>, sect.sectName())) {</span>
<span class="line" id="L1617">                                unwind_info = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(sect.addr + vmaddr_slide))[<span class="tok-number">0</span>..sect.size];</span>
<span class="line" id="L1618">                            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, <span class="tok-str">&quot;__eh_frame&quot;</span>, sect.sectName())) {</span>
<span class="line" id="L1619">                                eh_frame = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(sect.addr + vmaddr_slide))[<span class="tok-number">0</span>..sect.size];</span>
<span class="line" id="L1620">                            }</span>
<span class="line" id="L1621">                        }</span>
<span class="line" id="L1622"></span>
<span class="line" id="L1623">                        <span class="tok-kw">const</span> obj_di = <span class="tok-kw">try</span> self.allocator.create(ModuleDebugInfo);</span>
<span class="line" id="L1624">                        <span class="tok-kw">errdefer</span> self.allocator.destroy(obj_di);</span>
<span class="line" id="L1625"></span>
<span class="line" id="L1626">                        <span class="tok-kw">const</span> macho_path = mem.sliceTo(std.c._dyld_get_image_name(i), <span class="tok-number">0</span>);</span>
<span class="line" id="L1627">                        <span class="tok-kw">const</span> macho_file = fs.cwd().openFile(macho_path, .{</span>
<span class="line" id="L1628">                            .intended_io_mode = .blocking,</span>
<span class="line" id="L1629">                        }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1630">                            <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo,</span>
<span class="line" id="L1631">                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L1632">                        };</span>
<span class="line" id="L1633">                        obj_di.* = <span class="tok-kw">try</span> readMachODebugInfo(self.allocator, macho_file);</span>
<span class="line" id="L1634">                        obj_di.base_address = base_address;</span>
<span class="line" id="L1635">                        obj_di.vmaddr_slide = vmaddr_slide;</span>
<span class="line" id="L1636">                        obj_di.unwind_info = unwind_info;</span>
<span class="line" id="L1637">                        obj_di.eh_frame = eh_frame;</span>
<span class="line" id="L1638"></span>
<span class="line" id="L1639">                        <span class="tok-kw">try</span> self.address_map.putNoClobber(base_address, obj_di);</span>
<span class="line" id="L1640"></span>
<span class="line" id="L1641">                        <span class="tok-kw">return</span> obj_di;</span>
<span class="line" id="L1642">                    }</span>
<span class="line" id="L1643">                },</span>
<span class="line" id="L1644">                <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L1645">            };</span>
<span class="line" id="L1646">        }</span>
<span class="line" id="L1647"></span>
<span class="line" id="L1648">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1649">    }</span>
<span class="line" id="L1650"></span>
<span class="line" id="L1651">    <span class="tok-kw">fn</span> <span class="tok-fn">lookupModuleNameDyld</span>(self: *DebugInfo, address: <span class="tok-type">usize</span>) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1652">        _ = self;</span>
<span class="line" id="L1653">        <span class="tok-kw">const</span> image_count = std.c._dyld_image_count();</span>
<span class="line" id="L1654"></span>
<span class="line" id="L1655">        <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1656">        <span class="tok-kw">while</span> (i &lt; image_count) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L1657">            <span class="tok-kw">const</span> header = std.c._dyld_get_image_header(i) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1658">            <span class="tok-kw">const</span> base_address = <span class="tok-builtin">@intFromPtr</span>(header);</span>
<span class="line" id="L1659">            <span class="tok-kw">if</span> (address &lt; base_address) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1660">            <span class="tok-kw">const</span> vmaddr_slide = std.c._dyld_get_image_vmaddr_slide(i);</span>
<span class="line" id="L1661"></span>
<span class="line" id="L1662">            <span class="tok-kw">var</span> it = macho.LoadCommandIterator{</span>
<span class="line" id="L1663">                .ncmds = header.ncmds,</span>
<span class="line" id="L1664">                .buffer = <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@as</span>(</span>
<span class="line" id="L1665">                    [*]<span class="tok-type">u8</span>,</span>
<span class="line" id="L1666">                    <span class="tok-builtin">@ptrFromInt</span>(<span class="tok-builtin">@intFromPtr</span>(header) + <span class="tok-builtin">@sizeOf</span>(macho.mach_header_64)),</span>
<span class="line" id="L1667">                )[<span class="tok-number">0</span>..header.sizeofcmds]),</span>
<span class="line" id="L1668">            };</span>
<span class="line" id="L1669"></span>
<span class="line" id="L1670">            <span class="tok-kw">while</span> (it.next()) |cmd| <span class="tok-kw">switch</span> (cmd.cmd()) {</span>
<span class="line" id="L1671">                .SEGMENT_64 =&gt; {</span>
<span class="line" id="L1672">                    <span class="tok-kw">const</span> segment_cmd = cmd.cast(macho.segment_command_64).?;</span>
<span class="line" id="L1673">                    <span class="tok-kw">if</span> (!mem.eql(<span class="tok-type">u8</span>, <span class="tok-str">&quot;__TEXT&quot;</span>, segment_cmd.segName())) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1674"></span>
<span class="line" id="L1675">                    <span class="tok-kw">const</span> original_address = address - vmaddr_slide;</span>
<span class="line" id="L1676">                    <span class="tok-kw">const</span> seg_start = segment_cmd.vmaddr;</span>
<span class="line" id="L1677">                    <span class="tok-kw">const</span> seg_end = seg_start + segment_cmd.vmsize;</span>
<span class="line" id="L1678">                    <span class="tok-kw">if</span> (original_address &gt;= seg_start <span class="tok-kw">and</span> original_address &lt; seg_end) {</span>
<span class="line" id="L1679">                        <span class="tok-kw">return</span> fs.path.basename(mem.sliceTo(std.c._dyld_get_image_name(i), <span class="tok-number">0</span>));</span>
<span class="line" id="L1680">                    }</span>
<span class="line" id="L1681">                },</span>
<span class="line" id="L1682">                <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L1683">            };</span>
<span class="line" id="L1684">        }</span>
<span class="line" id="L1685"></span>
<span class="line" id="L1686">        <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1687">    }</span>
<span class="line" id="L1688"></span>
<span class="line" id="L1689">    <span class="tok-kw">fn</span> <span class="tok-fn">lookupModuleWin32</span>(self: *DebugInfo, address: <span class="tok-type">usize</span>) !*ModuleDebugInfo {</span>
<span class="line" id="L1690">        <span class="tok-kw">for</span> (self.modules.items) |*module| {</span>
<span class="line" id="L1691">            <span class="tok-kw">if</span> (address &gt;= module.base_address <span class="tok-kw">and</span> address &lt; module.base_address + module.size) {</span>
<span class="line" id="L1692">                <span class="tok-kw">if</span> (self.address_map.get(module.base_address)) |obj_di| {</span>
<span class="line" id="L1693">                    <span class="tok-kw">return</span> obj_di;</span>
<span class="line" id="L1694">                }</span>
<span class="line" id="L1695"></span>
<span class="line" id="L1696">                <span class="tok-kw">const</span> obj_di = <span class="tok-kw">try</span> self.allocator.create(ModuleDebugInfo);</span>
<span class="line" id="L1697">                <span class="tok-kw">errdefer</span> self.allocator.destroy(obj_di);</span>
<span class="line" id="L1698"></span>
<span class="line" id="L1699">                <span class="tok-kw">const</span> mapped_module = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(module.base_address))[<span class="tok-number">0</span>..module.size];</span>
<span class="line" id="L1700">                <span class="tok-kw">var</span> coff_obj = <span class="tok-kw">try</span> coff.Coff.init(mapped_module);</span>
<span class="line" id="L1701"></span>
<span class="line" id="L1702">                <span class="tok-comment">// The string table is not mapped into memory by the loader, so if a section name is in the</span>
</span>
<span class="line" id="L1703">                <span class="tok-comment">// string table then we have to map the full image file from disk. This can happen when</span>
</span>
<span class="line" id="L1704">                <span class="tok-comment">// a binary is produced with -gdwarf, since the section names are longer than 8 bytes.</span>
</span>
<span class="line" id="L1705">                <span class="tok-kw">if</span> (coff_obj.strtabRequired()) {</span>
<span class="line" id="L1706">                    <span class="tok-kw">var</span> name_buffer: [windows.PATH_MAX_WIDE + <span class="tok-number">4</span>:<span class="tok-number">0</span>]<span class="tok-type">u16</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1707">                    <span class="tok-comment">// openFileAbsoluteW requires the prefix to be present</span>
</span>
<span class="line" id="L1708">                    mem.copy(<span class="tok-type">u16</span>, name_buffer[<span class="tok-number">0</span>..<span class="tok-number">4</span>], &amp;[_]<span class="tok-type">u16</span>{ <span class="tok-str">'\\'</span>, <span class="tok-str">'?'</span>, <span class="tok-str">'?'</span>, <span class="tok-str">'\\'</span> });</span>
<span class="line" id="L1709"></span>
<span class="line" id="L1710">                    <span class="tok-kw">const</span> process_handle = windows.kernel32.GetCurrentProcess();</span>
<span class="line" id="L1711">                    <span class="tok-kw">const</span> len = windows.kernel32.K32GetModuleFileNameExW(</span>
<span class="line" id="L1712">                        process_handle,</span>
<span class="line" id="L1713">                        module.handle,</span>
<span class="line" id="L1714">                        <span class="tok-builtin">@ptrCast</span>(&amp;name_buffer[<span class="tok-number">4</span>]),</span>
<span class="line" id="L1715">                        windows.PATH_MAX_WIDE,</span>
<span class="line" id="L1716">                    );</span>
<span class="line" id="L1717"></span>
<span class="line" id="L1718">                    <span class="tok-kw">if</span> (len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1719">                    <span class="tok-kw">const</span> coff_file = fs.openFileAbsoluteW(name_buffer[<span class="tok-number">0</span> .. len + <span class="tok-number">4</span> :<span class="tok-number">0</span>], .{}) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1720">                        <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo,</span>
<span class="line" id="L1721">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L1722">                    };</span>
<span class="line" id="L1723">                    <span class="tok-kw">errdefer</span> coff_file.close();</span>
<span class="line" id="L1724"></span>
<span class="line" id="L1725">                    <span class="tok-kw">var</span> section_handle: windows.HANDLE = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1726">                    <span class="tok-kw">const</span> create_section_rc = windows.ntdll.NtCreateSection(</span>
<span class="line" id="L1727">                        &amp;section_handle,</span>
<span class="line" id="L1728">                        windows.STANDARD_RIGHTS_REQUIRED | windows.SECTION_QUERY | windows.SECTION_MAP_READ,</span>
<span class="line" id="L1729">                        <span class="tok-null">null</span>,</span>
<span class="line" id="L1730">                        <span class="tok-null">null</span>,</span>
<span class="line" id="L1731">                        windows.PAGE_READONLY,</span>
<span class="line" id="L1732">                        <span class="tok-comment">// The documentation states that if no AllocationAttribute is specified, then SEC_COMMIT is the default.</span>
</span>
<span class="line" id="L1733">                        <span class="tok-comment">// In practice, this isn't the case and specifying 0 will result in INVALID_PARAMETER_6.</span>
</span>
<span class="line" id="L1734">                        windows.SEC_COMMIT,</span>
<span class="line" id="L1735">                        coff_file.handle,</span>
<span class="line" id="L1736">                    );</span>
<span class="line" id="L1737">                    <span class="tok-kw">if</span> (create_section_rc != .SUCCESS) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1738">                    <span class="tok-kw">errdefer</span> windows.CloseHandle(section_handle);</span>
<span class="line" id="L1739"></span>
<span class="line" id="L1740">                    <span class="tok-kw">var</span> coff_len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1741">                    <span class="tok-kw">var</span> base_ptr: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1742">                    <span class="tok-kw">const</span> map_section_rc = windows.ntdll.NtMapViewOfSection(</span>
<span class="line" id="L1743">                        section_handle,</span>
<span class="line" id="L1744">                        process_handle,</span>
<span class="line" id="L1745">                        <span class="tok-builtin">@ptrCast</span>(&amp;base_ptr),</span>
<span class="line" id="L1746">                        <span class="tok-null">null</span>,</span>
<span class="line" id="L1747">                        <span class="tok-number">0</span>,</span>
<span class="line" id="L1748">                        <span class="tok-null">null</span>,</span>
<span class="line" id="L1749">                        &amp;coff_len,</span>
<span class="line" id="L1750">                        .ViewUnmap,</span>
<span class="line" id="L1751">                        <span class="tok-number">0</span>,</span>
<span class="line" id="L1752">                        windows.PAGE_READONLY,</span>
<span class="line" id="L1753">                    );</span>
<span class="line" id="L1754">                    <span class="tok-kw">if</span> (map_section_rc != .SUCCESS) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1755">                    <span class="tok-kw">errdefer</span> assert(windows.ntdll.NtUnmapViewOfSection(process_handle, <span class="tok-builtin">@ptrFromInt</span>(base_ptr)) == .SUCCESS);</span>
<span class="line" id="L1756"></span>
<span class="line" id="L1757">                    <span class="tok-kw">const</span> section_view = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(base_ptr))[<span class="tok-number">0</span>..coff_len];</span>
<span class="line" id="L1758">                    coff_obj = <span class="tok-kw">try</span> coff.Coff.init(section_view);</span>
<span class="line" id="L1759"></span>
<span class="line" id="L1760">                    module.mapped_file = .{</span>
<span class="line" id="L1761">                        .file = coff_file,</span>
<span class="line" id="L1762">                        .section_handle = section_handle,</span>
<span class="line" id="L1763">                        .section_view = section_view,</span>
<span class="line" id="L1764">                    };</span>
<span class="line" id="L1765">                }</span>
<span class="line" id="L1766">                <span class="tok-kw">errdefer</span> <span class="tok-kw">if</span> (module.mapped_file) |mapped_file| mapped_file.deinit();</span>
<span class="line" id="L1767"></span>
<span class="line" id="L1768">                obj_di.* = <span class="tok-kw">try</span> readCoffDebugInfo(self.allocator, &amp;coff_obj);</span>
<span class="line" id="L1769">                obj_di.base_address = module.base_address;</span>
<span class="line" id="L1770"></span>
<span class="line" id="L1771">                <span class="tok-kw">try</span> self.address_map.putNoClobber(module.base_address, obj_di);</span>
<span class="line" id="L1772">                <span class="tok-kw">return</span> obj_di;</span>
<span class="line" id="L1773">            }</span>
<span class="line" id="L1774">        }</span>
<span class="line" id="L1775"></span>
<span class="line" id="L1776">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1777">    }</span>
<span class="line" id="L1778"></span>
<span class="line" id="L1779">    <span class="tok-kw">fn</span> <span class="tok-fn">lookupModuleNameWin32</span>(self: *DebugInfo, address: <span class="tok-type">usize</span>) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1780">        <span class="tok-kw">for</span> (self.modules.items) |module| {</span>
<span class="line" id="L1781">            <span class="tok-kw">if</span> (address &gt;= module.base_address <span class="tok-kw">and</span> address &lt; module.base_address + module.size) {</span>
<span class="line" id="L1782">                <span class="tok-kw">return</span> module.name;</span>
<span class="line" id="L1783">            }</span>
<span class="line" id="L1784">        }</span>
<span class="line" id="L1785">        <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1786">    }</span>
<span class="line" id="L1787"></span>
<span class="line" id="L1788">    <span class="tok-kw">fn</span> <span class="tok-fn">lookupModuleNameDl</span>(self: *DebugInfo, address: <span class="tok-type">usize</span>) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1789">        _ = self;</span>
<span class="line" id="L1790"></span>
<span class="line" id="L1791">        <span class="tok-kw">var</span> ctx: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1792">            <span class="tok-comment">// Input</span>
</span>
<span class="line" id="L1793">            address: <span class="tok-type">usize</span>,</span>
<span class="line" id="L1794">            <span class="tok-comment">// Output</span>
</span>
<span class="line" id="L1795">            name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;&quot;</span>,</span>
<span class="line" id="L1796">        } = .{ .address = address };</span>
<span class="line" id="L1797">        <span class="tok-kw">const</span> CtxTy = <span class="tok-builtin">@TypeOf</span>(ctx);</span>
<span class="line" id="L1798"></span>
<span class="line" id="L1799">        <span class="tok-kw">if</span> (os.dl_iterate_phdr(&amp;ctx, <span class="tok-kw">error</span>{Found}, <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1800">            <span class="tok-kw">fn</span> <span class="tok-fn">callback</span>(info: *os.dl_phdr_info, size: <span class="tok-type">usize</span>, context: *CtxTy) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1801">                _ = size;</span>
<span class="line" id="L1802">                <span class="tok-kw">if</span> (context.address &lt; info.dlpi_addr) <span class="tok-kw">return</span>;</span>
<span class="line" id="L1803">                <span class="tok-kw">const</span> phdrs = info.dlpi_phdr[<span class="tok-number">0</span>..info.dlpi_phnum];</span>
<span class="line" id="L1804">                <span class="tok-kw">for</span> (phdrs) |*phdr| {</span>
<span class="line" id="L1805">                    <span class="tok-kw">if</span> (phdr.p_type != elf.PT_LOAD) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1806"></span>
<span class="line" id="L1807">                    <span class="tok-kw">const</span> seg_start = info.dlpi_addr +% phdr.p_vaddr;</span>
<span class="line" id="L1808">                    <span class="tok-kw">const</span> seg_end = seg_start + phdr.p_memsz;</span>
<span class="line" id="L1809">                    <span class="tok-kw">if</span> (context.address &gt;= seg_start <span class="tok-kw">and</span> context.address &lt; seg_end) {</span>
<span class="line" id="L1810">                        context.name = mem.sliceTo(info.dlpi_name, <span class="tok-number">0</span>) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;&quot;</span>;</span>
<span class="line" id="L1811">                        <span class="tok-kw">break</span>;</span>
<span class="line" id="L1812">                    }</span>
<span class="line" id="L1813">                } <span class="tok-kw">else</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L1814"></span>
<span class="line" id="L1815">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Found;</span>
<span class="line" id="L1816">            }</span>
<span class="line" id="L1817">        }.callback)) {</span>
<span class="line" id="L1818">            <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1819">        } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1820">            <span class="tok-kw">error</span>.Found =&gt; <span class="tok-kw">return</span> fs.path.basename(ctx.name),</span>
<span class="line" id="L1821">        }</span>
<span class="line" id="L1822"></span>
<span class="line" id="L1823">        <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1824">    }</span>
<span class="line" id="L1825"></span>
<span class="line" id="L1826">    <span class="tok-kw">fn</span> <span class="tok-fn">lookupModuleDl</span>(self: *DebugInfo, address: <span class="tok-type">usize</span>) !*ModuleDebugInfo {</span>
<span class="line" id="L1827">        <span class="tok-kw">var</span> ctx: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1828">            <span class="tok-comment">// Input</span>
</span>
<span class="line" id="L1829">            address: <span class="tok-type">usize</span>,</span>
<span class="line" id="L1830">            <span class="tok-comment">// Output</span>
</span>
<span class="line" id="L1831">            base_address: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L1832">            name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L1833">            build_id: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L1834">            gnu_eh_frame: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L1835">        } = .{ .address = address };</span>
<span class="line" id="L1836">        <span class="tok-kw">const</span> CtxTy = <span class="tok-builtin">@TypeOf</span>(ctx);</span>
<span class="line" id="L1837"></span>
<span class="line" id="L1838">        <span class="tok-kw">if</span> (os.dl_iterate_phdr(&amp;ctx, <span class="tok-kw">error</span>{Found}, <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1839">            <span class="tok-kw">fn</span> <span class="tok-fn">callback</span>(info: *os.dl_phdr_info, size: <span class="tok-type">usize</span>, context: *CtxTy) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1840">                _ = size;</span>
<span class="line" id="L1841">                <span class="tok-comment">// The base address is too high</span>
</span>
<span class="line" id="L1842">                <span class="tok-kw">if</span> (context.address &lt; info.dlpi_addr)</span>
<span class="line" id="L1843">                    <span class="tok-kw">return</span>;</span>
<span class="line" id="L1844"></span>
<span class="line" id="L1845">                <span class="tok-kw">const</span> phdrs = info.dlpi_phdr[<span class="tok-number">0</span>..info.dlpi_phnum];</span>
<span class="line" id="L1846">                <span class="tok-kw">for</span> (phdrs) |*phdr| {</span>
<span class="line" id="L1847">                    <span class="tok-kw">if</span> (phdr.p_type != elf.PT_LOAD) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1848"></span>
<span class="line" id="L1849">                    <span class="tok-comment">// Overflowing addition is used to handle the case of VSDOs having a p_vaddr = 0xffffffffff700000</span>
</span>
<span class="line" id="L1850">                    <span class="tok-kw">const</span> seg_start = info.dlpi_addr +% phdr.p_vaddr;</span>
<span class="line" id="L1851">                    <span class="tok-kw">const</span> seg_end = seg_start + phdr.p_memsz;</span>
<span class="line" id="L1852">                    <span class="tok-kw">if</span> (context.address &gt;= seg_start <span class="tok-kw">and</span> context.address &lt; seg_end) {</span>
<span class="line" id="L1853">                        <span class="tok-comment">// Android libc uses NULL instead of an empty string to mark the</span>
</span>
<span class="line" id="L1854">                        <span class="tok-comment">// main program</span>
</span>
<span class="line" id="L1855">                        context.name = mem.sliceTo(info.dlpi_name, <span class="tok-number">0</span>) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;&quot;</span>;</span>
<span class="line" id="L1856">                        context.base_address = info.dlpi_addr;</span>
<span class="line" id="L1857">                        <span class="tok-kw">break</span>;</span>
<span class="line" id="L1858">                    }</span>
<span class="line" id="L1859">                } <span class="tok-kw">else</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L1860"></span>
<span class="line" id="L1861">                <span class="tok-kw">for</span> (info.dlpi_phdr[<span class="tok-number">0</span>..info.dlpi_phnum]) |phdr| {</span>
<span class="line" id="L1862">                    <span class="tok-kw">switch</span> (phdr.p_type) {</span>
<span class="line" id="L1863">                        elf.PT_NOTE =&gt; {</span>
<span class="line" id="L1864">                            <span class="tok-comment">// Look for .note.gnu.build-id</span>
</span>
<span class="line" id="L1865">                            <span class="tok-kw">const</span> note_bytes = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(info.dlpi_addr + phdr.p_vaddr))[<span class="tok-number">0</span>..phdr.p_memsz];</span>
<span class="line" id="L1866">                            <span class="tok-kw">const</span> name_size = mem.readIntSliceNative(<span class="tok-type">u32</span>, note_bytes[<span class="tok-number">0</span>..<span class="tok-number">4</span>]);</span>
<span class="line" id="L1867">                            <span class="tok-kw">if</span> (name_size != <span class="tok-number">4</span>) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1868">                            <span class="tok-kw">const</span> desc_size = mem.readIntSliceNative(<span class="tok-type">u32</span>, note_bytes[<span class="tok-number">4</span>..<span class="tok-number">8</span>]);</span>
<span class="line" id="L1869">                            <span class="tok-kw">const</span> note_type = mem.readIntSliceNative(<span class="tok-type">u32</span>, note_bytes[<span class="tok-number">8</span>..<span class="tok-number">12</span>]);</span>
<span class="line" id="L1870">                            <span class="tok-kw">if</span> (note_type != elf.NT_GNU_BUILD_ID) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1871">                            <span class="tok-kw">if</span> (!mem.eql(<span class="tok-type">u8</span>, <span class="tok-str">&quot;GNU\x00&quot;</span>, note_bytes[<span class="tok-number">12</span>..<span class="tok-number">16</span>])) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1872">                            context.build_id = note_bytes[<span class="tok-number">16</span>..][<span class="tok-number">0</span>..desc_size];</span>
<span class="line" id="L1873">                        },</span>
<span class="line" id="L1874">                        elf.PT_GNU_EH_FRAME =&gt; {</span>
<span class="line" id="L1875">                            context.gnu_eh_frame = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(info.dlpi_addr + phdr.p_vaddr))[<span class="tok-number">0</span>..phdr.p_memsz];</span>
<span class="line" id="L1876">                        },</span>
<span class="line" id="L1877">                        <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L1878">                    }</span>
<span class="line" id="L1879">                }</span>
<span class="line" id="L1880"></span>
<span class="line" id="L1881">                <span class="tok-comment">// Stop the iteration</span>
</span>
<span class="line" id="L1882">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Found;</span>
<span class="line" id="L1883">            }</span>
<span class="line" id="L1884">        }.callback)) {</span>
<span class="line" id="L1885">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1886">        } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1887">            <span class="tok-kw">error</span>.Found =&gt; {},</span>
<span class="line" id="L1888">        }</span>
<span class="line" id="L1889"></span>
<span class="line" id="L1890">        <span class="tok-kw">if</span> (self.address_map.get(ctx.base_address)) |obj_di| {</span>
<span class="line" id="L1891">            <span class="tok-kw">return</span> obj_di;</span>
<span class="line" id="L1892">        }</span>
<span class="line" id="L1893"></span>
<span class="line" id="L1894">        <span class="tok-kw">const</span> obj_di = <span class="tok-kw">try</span> self.allocator.create(ModuleDebugInfo);</span>
<span class="line" id="L1895">        <span class="tok-kw">errdefer</span> self.allocator.destroy(obj_di);</span>
<span class="line" id="L1896"></span>
<span class="line" id="L1897">        <span class="tok-kw">var</span> sections: DW.DwarfInfo.SectionArray = DW.DwarfInfo.null_section_array;</span>
<span class="line" id="L1898">        <span class="tok-kw">if</span> (ctx.gnu_eh_frame) |eh_frame_hdr| {</span>
<span class="line" id="L1899">            <span class="tok-comment">// This is a special case - pointer offsets inside .eh_frame_hdr</span>
</span>
<span class="line" id="L1900">            <span class="tok-comment">// are encoded relative to its base address, so we must use the</span>
</span>
<span class="line" id="L1901">            <span class="tok-comment">// version that is already memory mapped, and not the one that</span>
</span>
<span class="line" id="L1902">            <span class="tok-comment">// will be mapped separately from the ELF file.</span>
</span>
<span class="line" id="L1903">            sections[<span class="tok-builtin">@intFromEnum</span>(DW.DwarfSection.eh_frame_hdr)] = .{</span>
<span class="line" id="L1904">                .data = eh_frame_hdr,</span>
<span class="line" id="L1905">                .owned = <span class="tok-null">false</span>,</span>
<span class="line" id="L1906">            };</span>
<span class="line" id="L1907">        }</span>
<span class="line" id="L1908"></span>
<span class="line" id="L1909">        obj_di.* = <span class="tok-kw">try</span> readElfDebugInfo(self.allocator, <span class="tok-kw">if</span> (ctx.name.len &gt; <span class="tok-number">0</span>) ctx.name <span class="tok-kw">else</span> <span class="tok-null">null</span>, ctx.build_id, <span class="tok-null">null</span>, &amp;sections, <span class="tok-null">null</span>);</span>
<span class="line" id="L1910">        obj_di.base_address = ctx.base_address;</span>
<span class="line" id="L1911"></span>
<span class="line" id="L1912">        <span class="tok-comment">// Missing unwind info isn't treated as a failure, as the unwinder will fall back to FP-based unwinding</span>
</span>
<span class="line" id="L1913">        obj_di.dwarf.scanAllUnwindInfo(self.allocator, ctx.base_address) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L1914"></span>
<span class="line" id="L1915">        <span class="tok-kw">try</span> self.address_map.putNoClobber(ctx.base_address, obj_di);</span>
<span class="line" id="L1916"></span>
<span class="line" id="L1917">        <span class="tok-kw">return</span> obj_di;</span>
<span class="line" id="L1918">    }</span>
<span class="line" id="L1919"></span>
<span class="line" id="L1920">    <span class="tok-kw">fn</span> <span class="tok-fn">lookupModuleHaiku</span>(self: *DebugInfo, address: <span class="tok-type">usize</span>) !*ModuleDebugInfo {</span>
<span class="line" id="L1921">        _ = self;</span>
<span class="line" id="L1922">        _ = address;</span>
<span class="line" id="L1923">        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;TODO implement lookup module for Haiku&quot;</span>);</span>
<span class="line" id="L1924">    }</span>
<span class="line" id="L1925"></span>
<span class="line" id="L1926">    <span class="tok-kw">fn</span> <span class="tok-fn">lookupModuleWasm</span>(self: *DebugInfo, address: <span class="tok-type">usize</span>) !*ModuleDebugInfo {</span>
<span class="line" id="L1927">        _ = self;</span>
<span class="line" id="L1928">        _ = address;</span>
<span class="line" id="L1929">        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;TODO implement lookup module for Wasm&quot;</span>);</span>
<span class="line" id="L1930">    }</span>
<span class="line" id="L1931">};</span>
<span class="line" id="L1932"></span>
<span class="line" id="L1933"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ModuleDebugInfo = <span class="tok-kw">switch</span> (native_os) {</span>
<span class="line" id="L1934">    .macos, .ios, .watchos, .tvos =&gt; <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1935">        base_address: <span class="tok-type">usize</span>,</span>
<span class="line" id="L1936">        vmaddr_slide: <span class="tok-type">usize</span>,</span>
<span class="line" id="L1937">        mapped_memory: []<span class="tok-kw">align</span>(mem.page_size) <span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1938">        symbols: []<span class="tok-kw">const</span> MachoSymbol,</span>
<span class="line" id="L1939">        strings: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1940">        ofiles: OFileTable,</span>
<span class="line" id="L1941"></span>
<span class="line" id="L1942">        <span class="tok-comment">// Backed by the in-memory sections mapped by the loader</span>
</span>
<span class="line" id="L1943">        unwind_info: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L1944">        eh_frame: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L1945"></span>
<span class="line" id="L1946">        <span class="tok-kw">const</span> OFileTable = std.StringHashMap(OFileInfo);</span>
<span class="line" id="L1947">        <span class="tok-kw">const</span> OFileInfo = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1948">            di: DW.DwarfInfo,</span>
<span class="line" id="L1949">            addr_table: std.StringHashMap(<span class="tok-type">u64</span>),</span>
<span class="line" id="L1950">        };</span>
<span class="line" id="L1951"></span>
<span class="line" id="L1952">        <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L1953">            <span class="tok-kw">var</span> it = self.ofiles.iterator();</span>
<span class="line" id="L1954">            <span class="tok-kw">while</span> (it.next()) |entry| {</span>
<span class="line" id="L1955">                <span class="tok-kw">const</span> ofile = entry.value_ptr;</span>
<span class="line" id="L1956">                ofile.di.deinit(allocator);</span>
<span class="line" id="L1957">                ofile.addr_table.deinit();</span>
<span class="line" id="L1958">            }</span>
<span class="line" id="L1959">            self.ofiles.deinit();</span>
<span class="line" id="L1960">            allocator.free(self.symbols);</span>
<span class="line" id="L1961">            os.munmap(self.mapped_memory);</span>
<span class="line" id="L1962">        }</span>
<span class="line" id="L1963"></span>
<span class="line" id="L1964">        <span class="tok-kw">fn</span> <span class="tok-fn">loadOFile</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator, o_file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !*OFileInfo {</span>
<span class="line" id="L1965">            <span class="tok-kw">const</span> o_file = <span class="tok-kw">try</span> fs.cwd().openFile(o_file_path, .{ .intended_io_mode = .blocking });</span>
<span class="line" id="L1966">            <span class="tok-kw">const</span> mapped_mem = <span class="tok-kw">try</span> mapWholeFile(o_file);</span>
<span class="line" id="L1967"></span>
<span class="line" id="L1968">            <span class="tok-kw">const</span> hdr: *<span class="tok-kw">const</span> macho.mach_header_64 = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(mapped_mem.ptr));</span>
<span class="line" id="L1969">            <span class="tok-kw">if</span> (hdr.magic != std.macho.MH_MAGIC_64)</span>
<span class="line" id="L1970">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo;</span>
<span class="line" id="L1971"></span>
<span class="line" id="L1972">            <span class="tok-kw">var</span> segcmd: ?macho.LoadCommandIterator.LoadCommand = <span class="tok-null">null</span>;</span>
<span class="line" id="L1973">            <span class="tok-kw">var</span> symtabcmd: ?macho.symtab_command = <span class="tok-null">null</span>;</span>
<span class="line" id="L1974">            <span class="tok-kw">var</span> it = macho.LoadCommandIterator{</span>
<span class="line" id="L1975">                .ncmds = hdr.ncmds,</span>
<span class="line" id="L1976">                .buffer = mapped_mem[<span class="tok-builtin">@sizeOf</span>(macho.mach_header_64)..][<span class="tok-number">0</span>..hdr.sizeofcmds],</span>
<span class="line" id="L1977">            };</span>
<span class="line" id="L1978">            <span class="tok-kw">while</span> (it.next()) |cmd| <span class="tok-kw">switch</span> (cmd.cmd()) {</span>
<span class="line" id="L1979">                .SEGMENT_64 =&gt; segcmd = cmd,</span>
<span class="line" id="L1980">                .SYMTAB =&gt; symtabcmd = cmd.cast(macho.symtab_command).?,</span>
<span class="line" id="L1981">                <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L1982">            };</span>
<span class="line" id="L1983"></span>
<span class="line" id="L1984">            <span class="tok-kw">if</span> (segcmd == <span class="tok-null">null</span> <span class="tok-kw">or</span> symtabcmd == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1985"></span>
<span class="line" id="L1986">            <span class="tok-comment">// Parse symbols</span>
</span>
<span class="line" id="L1987">            <span class="tok-kw">const</span> strtab = <span class="tok-builtin">@as</span>(</span>
<span class="line" id="L1988">                [*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1989">                <span class="tok-builtin">@ptrCast</span>(&amp;mapped_mem[symtabcmd.?.stroff]),</span>
<span class="line" id="L1990">            )[<span class="tok-number">0</span> .. symtabcmd.?.strsize - <span class="tok-number">1</span> :<span class="tok-number">0</span>];</span>
<span class="line" id="L1991">            <span class="tok-kw">const</span> symtab = <span class="tok-builtin">@as</span>(</span>
<span class="line" id="L1992">                [*]<span class="tok-kw">const</span> macho.nlist_64,</span>
<span class="line" id="L1993">                <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;mapped_mem[symtabcmd.?.symoff])),</span>
<span class="line" id="L1994">            )[<span class="tok-number">0</span>..symtabcmd.?.nsyms];</span>
<span class="line" id="L1995"></span>
<span class="line" id="L1996">            <span class="tok-comment">// TODO handle tentative (common) symbols</span>
</span>
<span class="line" id="L1997">            <span class="tok-kw">var</span> addr_table = std.StringHashMap(<span class="tok-type">u64</span>).init(allocator);</span>
<span class="line" id="L1998">            <span class="tok-kw">try</span> addr_table.ensureTotalCapacity(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(symtab.len)));</span>
<span class="line" id="L1999">            <span class="tok-kw">for</span> (symtab) |sym| {</span>
<span class="line" id="L2000">                <span class="tok-kw">if</span> (sym.n_strx == <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L2001">                <span class="tok-kw">if</span> (sym.undf() <span class="tok-kw">or</span> sym.tentative() <span class="tok-kw">or</span> sym.abs()) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L2002">                <span class="tok-kw">const</span> sym_name = mem.sliceTo(strtab[sym.n_strx..], <span class="tok-number">0</span>);</span>
<span class="line" id="L2003">                <span class="tok-comment">// TODO is it possible to have a symbol collision?</span>
</span>
<span class="line" id="L2004">                addr_table.putAssumeCapacityNoClobber(sym_name, sym.n_value);</span>
<span class="line" id="L2005">            }</span>
<span class="line" id="L2006"></span>
<span class="line" id="L2007">            <span class="tok-kw">var</span> sections: DW.DwarfInfo.SectionArray = DW.DwarfInfo.null_section_array;</span>
<span class="line" id="L2008">            <span class="tok-kw">if</span> (self.eh_frame) |eh_frame| sections[<span class="tok-builtin">@intFromEnum</span>(DW.DwarfSection.eh_frame)] = .{</span>
<span class="line" id="L2009">                .data = eh_frame,</span>
<span class="line" id="L2010">                .owned = <span class="tok-null">false</span>,</span>
<span class="line" id="L2011">            };</span>
<span class="line" id="L2012"></span>
<span class="line" id="L2013">            <span class="tok-kw">for</span> (segcmd.?.getSections()) |sect| {</span>
<span class="line" id="L2014">                <span class="tok-kw">if</span> (!std.mem.eql(<span class="tok-type">u8</span>, <span class="tok-str">&quot;__DWARF&quot;</span>, sect.segName())) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L2015"></span>
<span class="line" id="L2016">                <span class="tok-kw">var</span> section_index: ?<span class="tok-type">usize</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L2017">                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(DW.DwarfSection).Enum.fields, <span class="tok-number">0</span>..) |section, i| {</span>
<span class="line" id="L2018">                    <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, <span class="tok-str">&quot;__&quot;</span> ++ section.name, sect.sectName())) section_index = i;</span>
<span class="line" id="L2019">                }</span>
<span class="line" id="L2020">                <span class="tok-kw">if</span> (section_index == <span class="tok-null">null</span>) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L2021"></span>
<span class="line" id="L2022">                <span class="tok-kw">const</span> section_bytes = <span class="tok-kw">try</span> chopSlice(mapped_mem, sect.offset, sect.size);</span>
<span class="line" id="L2023">                sections[section_index.?] = .{</span>
<span class="line" id="L2024">                    .data = section_bytes,</span>
<span class="line" id="L2025">                    .virtual_address = sect.addr,</span>
<span class="line" id="L2026">                    .owned = <span class="tok-null">false</span>,</span>
<span class="line" id="L2027">                };</span>
<span class="line" id="L2028">            }</span>
<span class="line" id="L2029"></span>
<span class="line" id="L2030">            <span class="tok-kw">const</span> missing_debug_info =</span>
<span class="line" id="L2031">                sections[<span class="tok-builtin">@intFromEnum</span>(DW.DwarfSection.debug_info)] == <span class="tok-null">null</span> <span class="tok-kw">or</span></span>
<span class="line" id="L2032">                sections[<span class="tok-builtin">@intFromEnum</span>(DW.DwarfSection.debug_abbrev)] == <span class="tok-null">null</span> <span class="tok-kw">or</span></span>
<span class="line" id="L2033">                sections[<span class="tok-builtin">@intFromEnum</span>(DW.DwarfSection.debug_str)] == <span class="tok-null">null</span> <span class="tok-kw">or</span></span>
<span class="line" id="L2034">                sections[<span class="tok-builtin">@intFromEnum</span>(DW.DwarfSection.debug_line)] == <span class="tok-null">null</span>;</span>
<span class="line" id="L2035">            <span class="tok-kw">if</span> (missing_debug_info) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L2036"></span>
<span class="line" id="L2037">            <span class="tok-kw">var</span> di = DW.DwarfInfo{</span>
<span class="line" id="L2038">                .endian = .Little,</span>
<span class="line" id="L2039">                .sections = sections,</span>
<span class="line" id="L2040">                .is_macho = <span class="tok-null">true</span>,</span>
<span class="line" id="L2041">            };</span>
<span class="line" id="L2042"></span>
<span class="line" id="L2043">            <span class="tok-kw">try</span> DW.openDwarfDebugInfo(&amp;di, allocator);</span>
<span class="line" id="L2044">            <span class="tok-kw">var</span> info = OFileInfo{</span>
<span class="line" id="L2045">                .di = di,</span>
<span class="line" id="L2046">                .addr_table = addr_table,</span>
<span class="line" id="L2047">            };</span>
<span class="line" id="L2048"></span>
<span class="line" id="L2049">            <span class="tok-comment">// Add the debug info to the cache</span>
</span>
<span class="line" id="L2050">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.ofiles.getOrPut(o_file_path);</span>
<span class="line" id="L2051">            assert(!result.found_existing);</span>
<span class="line" id="L2052">            result.value_ptr.* = info;</span>
<span class="line" id="L2053"></span>
<span class="line" id="L2054">            <span class="tok-kw">return</span> result.value_ptr;</span>
<span class="line" id="L2055">        }</span>
<span class="line" id="L2056"></span>
<span class="line" id="L2057">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSymbolAtAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator, address: <span class="tok-type">usize</span>) !SymbolInfo {</span>
<span class="line" id="L2058">            <span class="tok-kw">nosuspend</span> {</span>
<span class="line" id="L2059">                <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.getOFileInfoForAddress(allocator, address);</span>
<span class="line" id="L2060">                <span class="tok-kw">if</span> (result.symbol == <span class="tok-null">null</span>) <span class="tok-kw">return</span> .{};</span>
<span class="line" id="L2061"></span>
<span class="line" id="L2062">                <span class="tok-comment">// Take the symbol name from the N_FUN STAB entry, we're going to</span>
</span>
<span class="line" id="L2063">                <span class="tok-comment">// use it if we fail to find the DWARF infos</span>
</span>
<span class="line" id="L2064">                <span class="tok-kw">const</span> stab_symbol = mem.sliceTo(self.strings[result.symbol.?.strx..], <span class="tok-number">0</span>);</span>
<span class="line" id="L2065">                <span class="tok-kw">if</span> (result.o_file_info == <span class="tok-null">null</span>) <span class="tok-kw">return</span> .{ .symbol_name = stab_symbol };</span>
<span class="line" id="L2066"></span>
<span class="line" id="L2067">                <span class="tok-comment">// Translate again the address, this time into an address inside the</span>
</span>
<span class="line" id="L2068">                <span class="tok-comment">// .o file</span>
</span>
<span class="line" id="L2069">                <span class="tok-kw">const</span> relocated_address_o = result.o_file_info.?.addr_table.get(stab_symbol) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> .{</span>
<span class="line" id="L2070">                    .symbol_name = <span class="tok-str">&quot;???&quot;</span>,</span>
<span class="line" id="L2071">                };</span>
<span class="line" id="L2072"></span>
<span class="line" id="L2073">                <span class="tok-kw">const</span> addr_off = result.relocated_address - result.symbol.?.addr;</span>
<span class="line" id="L2074">                <span class="tok-kw">const</span> o_file_di = &amp;result.o_file_info.?.di;</span>
<span class="line" id="L2075">                <span class="tok-kw">if</span> (o_file_di.findCompileUnit(relocated_address_o)) |compile_unit| {</span>
<span class="line" id="L2076">                    <span class="tok-kw">return</span> SymbolInfo{</span>
<span class="line" id="L2077">                        .symbol_name = o_file_di.getSymbolName(relocated_address_o) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;???&quot;</span>,</span>
<span class="line" id="L2078">                        .compile_unit_name = compile_unit.die.getAttrString(</span>
<span class="line" id="L2079">                            o_file_di,</span>
<span class="line" id="L2080">                            DW.AT.name,</span>
<span class="line" id="L2081">                            o_file_di.section(.debug_str),</span>
<span class="line" id="L2082">                            compile_unit.*,</span>
<span class="line" id="L2083">                        ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2084">                            <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; <span class="tok-str">&quot;???&quot;</span>,</span>
<span class="line" id="L2085">                        },</span>
<span class="line" id="L2086">                        .line_info = o_file_di.getLineNumberInfo(</span>
<span class="line" id="L2087">                            allocator,</span>
<span class="line" id="L2088">                            compile_unit.*,</span>
<span class="line" id="L2089">                            relocated_address_o + addr_off,</span>
<span class="line" id="L2090">                        ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2091">                            <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; <span class="tok-null">null</span>,</span>
<span class="line" id="L2092">                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L2093">                        },</span>
<span class="line" id="L2094">                    };</span>
<span class="line" id="L2095">                } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2096">                    <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; {</span>
<span class="line" id="L2097">                        <span class="tok-kw">return</span> SymbolInfo{ .symbol_name = stab_symbol };</span>
<span class="line" id="L2098">                    },</span>
<span class="line" id="L2099">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L2100">                }</span>
<span class="line" id="L2101">            }</span>
<span class="line" id="L2102">        }</span>
<span class="line" id="L2103"></span>
<span class="line" id="L2104">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOFileInfoForAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator, address: <span class="tok-type">usize</span>) !<span class="tok-kw">struct</span> {</span>
<span class="line" id="L2105">            relocated_address: <span class="tok-type">usize</span>,</span>
<span class="line" id="L2106">            symbol: ?*<span class="tok-kw">const</span> MachoSymbol = <span class="tok-null">null</span>,</span>
<span class="line" id="L2107">            o_file_info: ?*OFileInfo = <span class="tok-null">null</span>,</span>
<span class="line" id="L2108">        } {</span>
<span class="line" id="L2109">            <span class="tok-kw">nosuspend</span> {</span>
<span class="line" id="L2110">                <span class="tok-comment">// Translate the VA into an address into this object</span>
</span>
<span class="line" id="L2111">                <span class="tok-kw">const</span> relocated_address = address - self.vmaddr_slide;</span>
<span class="line" id="L2112"></span>
<span class="line" id="L2113">                <span class="tok-comment">// Find the .o file where this symbol is defined</span>
</span>
<span class="line" id="L2114">                <span class="tok-kw">const</span> symbol = machoSearchSymbols(self.symbols, relocated_address) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> .{</span>
<span class="line" id="L2115">                    .relocated_address = relocated_address,</span>
<span class="line" id="L2116">                };</span>
<span class="line" id="L2117"></span>
<span class="line" id="L2118">                <span class="tok-comment">// Check if its debug infos are already in the cache</span>
</span>
<span class="line" id="L2119">                <span class="tok-kw">const</span> o_file_path = mem.sliceTo(self.strings[symbol.ofile..], <span class="tok-number">0</span>);</span>
<span class="line" id="L2120">                <span class="tok-kw">var</span> o_file_info = self.ofiles.getPtr(o_file_path) <span class="tok-kw">orelse</span></span>
<span class="line" id="L2121">                    (self.loadOFile(allocator, o_file_path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2122">                    <span class="tok-kw">error</span>.FileNotFound,</span>
<span class="line" id="L2123">                    <span class="tok-kw">error</span>.MissingDebugInfo,</span>
<span class="line" id="L2124">                    <span class="tok-kw">error</span>.InvalidDebugInfo,</span>
<span class="line" id="L2125">                    =&gt; <span class="tok-kw">return</span> .{</span>
<span class="line" id="L2126">                        .relocated_address = relocated_address,</span>
<span class="line" id="L2127">                        .symbol = symbol,</span>
<span class="line" id="L2128">                    },</span>
<span class="line" id="L2129">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L2130">                });</span>
<span class="line" id="L2131"></span>
<span class="line" id="L2132">                <span class="tok-kw">return</span> .{</span>
<span class="line" id="L2133">                    .relocated_address = relocated_address,</span>
<span class="line" id="L2134">                    .symbol = symbol,</span>
<span class="line" id="L2135">                    .o_file_info = o_file_info,</span>
<span class="line" id="L2136">                };</span>
<span class="line" id="L2137">            }</span>
<span class="line" id="L2138">        }</span>
<span class="line" id="L2139"></span>
<span class="line" id="L2140">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getDwarfInfoForAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator, address: <span class="tok-type">usize</span>) !?*<span class="tok-kw">const</span> DW.DwarfInfo {</span>
<span class="line" id="L2141">            <span class="tok-kw">return</span> <span class="tok-kw">if</span> ((<span class="tok-kw">try</span> self.getOFileInfoForAddress(allocator, address)).o_file_info) |o_file_info| &amp;o_file_info.di <span class="tok-kw">else</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2142">        }</span>
<span class="line" id="L2143">    },</span>
<span class="line" id="L2144">    .uefi, .windows =&gt; <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2145">        base_address: <span class="tok-type">usize</span>,</span>
<span class="line" id="L2146">        debug_data: PdbOrDwarf,</span>
<span class="line" id="L2147">        coff_image_base: <span class="tok-type">u64</span>,</span>
<span class="line" id="L2148">        <span class="tok-comment">/// Only used if debug_data is .pdb</span></span>
<span class="line" id="L2149">        coff_section_headers: []coff.SectionHeader,</span>
<span class="line" id="L2150"></span>
<span class="line" id="L2151">        <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L2152">            self.debug_data.deinit(allocator);</span>
<span class="line" id="L2153">            <span class="tok-kw">if</span> (self.debug_data == .pdb) {</span>
<span class="line" id="L2154">                allocator.free(self.coff_section_headers);</span>
<span class="line" id="L2155">            }</span>
<span class="line" id="L2156">        }</span>
<span class="line" id="L2157"></span>
<span class="line" id="L2158">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSymbolAtAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator, address: <span class="tok-type">usize</span>) !SymbolInfo {</span>
<span class="line" id="L2159">            <span class="tok-comment">// Translate the VA into an address into this object</span>
</span>
<span class="line" id="L2160">            <span class="tok-kw">const</span> relocated_address = address - self.base_address;</span>
<span class="line" id="L2161"></span>
<span class="line" id="L2162">            <span class="tok-kw">switch</span> (self.debug_data) {</span>
<span class="line" id="L2163">                .dwarf =&gt; |*dwarf| {</span>
<span class="line" id="L2164">                    <span class="tok-kw">const</span> dwarf_address = relocated_address + self.coff_image_base;</span>
<span class="line" id="L2165">                    <span class="tok-kw">return</span> getSymbolFromDwarf(allocator, dwarf_address, dwarf);</span>
<span class="line" id="L2166">                },</span>
<span class="line" id="L2167">                .pdb =&gt; {</span>
<span class="line" id="L2168">                    <span class="tok-comment">// fallthrough to pdb handling</span>
</span>
<span class="line" id="L2169">                },</span>
<span class="line" id="L2170">            }</span>
<span class="line" id="L2171"></span>
<span class="line" id="L2172">            <span class="tok-kw">var</span> coff_section: *<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> coff.SectionHeader = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L2173">            <span class="tok-kw">const</span> mod_index = <span class="tok-kw">for</span> (self.debug_data.pdb.sect_contribs) |sect_contrib| {</span>
<span class="line" id="L2174">                <span class="tok-kw">if</span> (sect_contrib.Section &gt; self.coff_section_headers.len) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L2175">                <span class="tok-comment">// Remember that SectionContribEntry.Section is 1-based.</span>
</span>
<span class="line" id="L2176">                coff_section = &amp;self.coff_section_headers[sect_contrib.Section - <span class="tok-number">1</span>];</span>
<span class="line" id="L2177"></span>
<span class="line" id="L2178">                <span class="tok-kw">const</span> vaddr_start = coff_section.virtual_address + sect_contrib.Offset;</span>
<span class="line" id="L2179">                <span class="tok-kw">const</span> vaddr_end = vaddr_start + sect_contrib.Size;</span>
<span class="line" id="L2180">                <span class="tok-kw">if</span> (relocated_address &gt;= vaddr_start <span class="tok-kw">and</span> relocated_address &lt; vaddr_end) {</span>
<span class="line" id="L2181">                    <span class="tok-kw">break</span> sect_contrib.ModuleIndex;</span>
<span class="line" id="L2182">                }</span>
<span class="line" id="L2183">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2184">                <span class="tok-comment">// we have no information to add to the address</span>
</span>
<span class="line" id="L2185">                <span class="tok-kw">return</span> SymbolInfo{};</span>
<span class="line" id="L2186">            };</span>
<span class="line" id="L2187"></span>
<span class="line" id="L2188">            <span class="tok-kw">const</span> module = (<span class="tok-kw">try</span> self.debug_data.pdb.getModule(mod_index)) <span class="tok-kw">orelse</span></span>
<span class="line" id="L2189">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo;</span>
<span class="line" id="L2190">            <span class="tok-kw">const</span> obj_basename = fs.path.basename(module.obj_file_name);</span>
<span class="line" id="L2191"></span>
<span class="line" id="L2192">            <span class="tok-kw">const</span> symbol_name = self.debug_data.pdb.getSymbolName(</span>
<span class="line" id="L2193">                module,</span>
<span class="line" id="L2194">                relocated_address - coff_section.virtual_address,</span>
<span class="line" id="L2195">            ) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;???&quot;</span>;</span>
<span class="line" id="L2196">            <span class="tok-kw">const</span> opt_line_info = <span class="tok-kw">try</span> self.debug_data.pdb.getLineNumberInfo(</span>
<span class="line" id="L2197">                module,</span>
<span class="line" id="L2198">                relocated_address - coff_section.virtual_address,</span>
<span class="line" id="L2199">            );</span>
<span class="line" id="L2200"></span>
<span class="line" id="L2201">            <span class="tok-kw">return</span> SymbolInfo{</span>
<span class="line" id="L2202">                .symbol_name = symbol_name,</span>
<span class="line" id="L2203">                .compile_unit_name = obj_basename,</span>
<span class="line" id="L2204">                .line_info = opt_line_info,</span>
<span class="line" id="L2205">            };</span>
<span class="line" id="L2206">        }</span>
<span class="line" id="L2207"></span>
<span class="line" id="L2208">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getDwarfInfoForAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator, address: <span class="tok-type">usize</span>) !?*<span class="tok-kw">const</span> DW.DwarfInfo {</span>
<span class="line" id="L2209">            _ = allocator;</span>
<span class="line" id="L2210">            _ = address;</span>
<span class="line" id="L2211"></span>
<span class="line" id="L2212">            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self.debug_data) {</span>
<span class="line" id="L2213">                .dwarf =&gt; |*dwarf| dwarf,</span>
<span class="line" id="L2214">                <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,</span>
<span class="line" id="L2215">            };</span>
<span class="line" id="L2216">        }</span>
<span class="line" id="L2217">    },</span>
<span class="line" id="L2218">    .linux, .netbsd, .freebsd, .dragonfly, .openbsd, .haiku, .solaris =&gt; <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2219">        base_address: <span class="tok-type">usize</span>,</span>
<span class="line" id="L2220">        dwarf: DW.DwarfInfo,</span>
<span class="line" id="L2221">        mapped_memory: []<span class="tok-kw">align</span>(mem.page_size) <span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2222">        external_mapped_memory: ?[]<span class="tok-kw">align</span>(mem.page_size) <span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2223"></span>
<span class="line" id="L2224">        <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L2225">            self.dwarf.deinit(allocator);</span>
<span class="line" id="L2226">            os.munmap(self.mapped_memory);</span>
<span class="line" id="L2227">            <span class="tok-kw">if</span> (self.external_mapped_memory) |m| os.munmap(m);</span>
<span class="line" id="L2228">        }</span>
<span class="line" id="L2229"></span>
<span class="line" id="L2230">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSymbolAtAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator, address: <span class="tok-type">usize</span>) !SymbolInfo {</span>
<span class="line" id="L2231">            <span class="tok-comment">// Translate the VA into an address into this object</span>
</span>
<span class="line" id="L2232">            <span class="tok-kw">const</span> relocated_address = address - self.base_address;</span>
<span class="line" id="L2233">            <span class="tok-kw">return</span> getSymbolFromDwarf(allocator, relocated_address, &amp;self.dwarf);</span>
<span class="line" id="L2234">        }</span>
<span class="line" id="L2235"></span>
<span class="line" id="L2236">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getDwarfInfoForAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator, address: <span class="tok-type">usize</span>) !?*<span class="tok-kw">const</span> DW.DwarfInfo {</span>
<span class="line" id="L2237">            _ = allocator;</span>
<span class="line" id="L2238">            _ = address;</span>
<span class="line" id="L2239">            <span class="tok-kw">return</span> &amp;self.dwarf;</span>
<span class="line" id="L2240">        }</span>
<span class="line" id="L2241">    },</span>
<span class="line" id="L2242">    .wasi =&gt; <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2243">        <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L2244">            _ = self;</span>
<span class="line" id="L2245">            _ = allocator;</span>
<span class="line" id="L2246">        }</span>
<span class="line" id="L2247"></span>
<span class="line" id="L2248">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSymbolAtAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator, address: <span class="tok-type">usize</span>) !SymbolInfo {</span>
<span class="line" id="L2249">            _ = self;</span>
<span class="line" id="L2250">            _ = allocator;</span>
<span class="line" id="L2251">            _ = address;</span>
<span class="line" id="L2252">            <span class="tok-kw">return</span> SymbolInfo{};</span>
<span class="line" id="L2253">        }</span>
<span class="line" id="L2254"></span>
<span class="line" id="L2255">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getDwarfInfoForAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator, address: <span class="tok-type">usize</span>) !?*<span class="tok-kw">const</span> DW.DwarfInfo {</span>
<span class="line" id="L2256">            _ = self;</span>
<span class="line" id="L2257">            _ = allocator;</span>
<span class="line" id="L2258">            _ = address;</span>
<span class="line" id="L2259">            <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2260">        }</span>
<span class="line" id="L2261">    },</span>
<span class="line" id="L2262">    <span class="tok-kw">else</span> =&gt; DW.DwarfInfo,</span>
<span class="line" id="L2263">};</span>
<span class="line" id="L2264"></span>
<span class="line" id="L2265"><span class="tok-kw">fn</span> <span class="tok-fn">getSymbolFromDwarf</span>(allocator: mem.Allocator, address: <span class="tok-type">u64</span>, di: *DW.DwarfInfo) !SymbolInfo {</span>
<span class="line" id="L2266">    <span class="tok-kw">if</span> (<span class="tok-kw">nosuspend</span> di.findCompileUnit(address)) |compile_unit| {</span>
<span class="line" id="L2267">        <span class="tok-kw">return</span> SymbolInfo{</span>
<span class="line" id="L2268">            .symbol_name = <span class="tok-kw">nosuspend</span> di.getSymbolName(address) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;???&quot;</span>,</span>
<span class="line" id="L2269">            .compile_unit_name = compile_unit.die.getAttrString(di, DW.AT.name, di.section(.debug_str), compile_unit.*) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2270">                <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; <span class="tok-str">&quot;???&quot;</span>,</span>
<span class="line" id="L2271">            },</span>
<span class="line" id="L2272">            .line_info = <span class="tok-kw">nosuspend</span> di.getLineNumberInfo(allocator, compile_unit.*, address) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2273">                <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; <span class="tok-null">null</span>,</span>
<span class="line" id="L2274">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L2275">            },</span>
<span class="line" id="L2276">        };</span>
<span class="line" id="L2277">    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2278">        <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; {</span>
<span class="line" id="L2279">            <span class="tok-kw">return</span> SymbolInfo{};</span>
<span class="line" id="L2280">        },</span>
<span class="line" id="L2281">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L2282">    }</span>
<span class="line" id="L2283">}</span>
<span class="line" id="L2284"></span>
<span class="line" id="L2285"><span class="tok-comment">/// TODO multithreaded awareness</span></span>
<span class="line" id="L2286"><span class="tok-kw">var</span> debug_info_allocator: ?mem.Allocator = <span class="tok-null">null</span>;</span>
<span class="line" id="L2287"><span class="tok-kw">var</span> debug_info_arena_allocator: std.heap.ArenaAllocator = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L2288"><span class="tok-kw">fn</span> <span class="tok-fn">getDebugInfoAllocator</span>() mem.Allocator {</span>
<span class="line" id="L2289">    <span class="tok-kw">if</span> (debug_info_allocator) |a| <span class="tok-kw">return</span> a;</span>
<span class="line" id="L2290"></span>
<span class="line" id="L2291">    debug_info_arena_allocator = std.heap.ArenaAllocator.init(std.heap.page_allocator);</span>
<span class="line" id="L2292">    <span class="tok-kw">const</span> allocator = debug_info_arena_allocator.allocator();</span>
<span class="line" id="L2293">    debug_info_allocator = allocator;</span>
<span class="line" id="L2294">    <span class="tok-kw">return</span> allocator;</span>
<span class="line" id="L2295">}</span>
<span class="line" id="L2296"></span>
<span class="line" id="L2297"><span class="tok-comment">/// Whether or not the current target can print useful debug information when a segfault occurs.</span></span>
<span class="line" id="L2298"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> have_segfault_handling_support = <span class="tok-kw">switch</span> (native_os) {</span>
<span class="line" id="L2299">    .linux,</span>
<span class="line" id="L2300">    .macos,</span>
<span class="line" id="L2301">    .netbsd,</span>
<span class="line" id="L2302">    .solaris,</span>
<span class="line" id="L2303">    .windows,</span>
<span class="line" id="L2304">    =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L2305"></span>
<span class="line" id="L2306">    .freebsd, .openbsd =&gt; <span class="tok-builtin">@hasDecl</span>(os.system, <span class="tok-str">&quot;ucontext_t&quot;</span>),</span>
<span class="line" id="L2307">    <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L2308">};</span>
<span class="line" id="L2309"></span>
<span class="line" id="L2310"><span class="tok-kw">const</span> enable_segfault_handler = std.options.enable_segfault_handler;</span>
<span class="line" id="L2311"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> default_enable_segfault_handler = runtime_safety <span class="tok-kw">and</span> have_segfault_handling_support;</span>
<span class="line" id="L2312"></span>
<span class="line" id="L2313"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">maybeEnableSegfaultHandler</span>() <span class="tok-type">void</span> {</span>
<span class="line" id="L2314">    <span class="tok-kw">if</span> (enable_segfault_handler) {</span>
<span class="line" id="L2315">        std.debug.attachSegfaultHandler();</span>
<span class="line" id="L2316">    }</span>
<span class="line" id="L2317">}</span>
<span class="line" id="L2318"></span>
<span class="line" id="L2319"><span class="tok-kw">var</span> windows_segfault_handle: ?windows.HANDLE = <span class="tok-null">null</span>;</span>
<span class="line" id="L2320"></span>
<span class="line" id="L2321"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">updateSegfaultHandler</span>(act: ?*<span class="tok-kw">const</span> os.Sigaction) <span class="tok-kw">error</span>{OperationNotSupported}!<span class="tok-type">void</span> {</span>
<span class="line" id="L2322">    <span class="tok-kw">try</span> os.sigaction(os.SIG.SEGV, act, <span class="tok-null">null</span>);</span>
<span class="line" id="L2323">    <span class="tok-kw">try</span> os.sigaction(os.SIG.ILL, act, <span class="tok-null">null</span>);</span>
<span class="line" id="L2324">    <span class="tok-kw">try</span> os.sigaction(os.SIG.BUS, act, <span class="tok-null">null</span>);</span>
<span class="line" id="L2325">    <span class="tok-kw">try</span> os.sigaction(os.SIG.FPE, act, <span class="tok-null">null</span>);</span>
<span class="line" id="L2326">}</span>
<span class="line" id="L2327"></span>
<span class="line" id="L2328"><span class="tok-comment">/// Attaches a global SIGSEGV handler which calls @panic(&quot;segmentation fault&quot;);</span></span>
<span class="line" id="L2329"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">attachSegfaultHandler</span>() <span class="tok-type">void</span> {</span>
<span class="line" id="L2330">    <span class="tok-kw">if</span> (!have_segfault_handling_support) {</span>
<span class="line" id="L2331">        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;segfault handler not supported for this target&quot;</span>);</span>
<span class="line" id="L2332">    }</span>
<span class="line" id="L2333">    <span class="tok-kw">if</span> (native_os == .windows) {</span>
<span class="line" id="L2334">        windows_segfault_handle = windows.kernel32.AddVectoredExceptionHandler(<span class="tok-number">0</span>, handleSegfaultWindows);</span>
<span class="line" id="L2335">        <span class="tok-kw">return</span>;</span>
<span class="line" id="L2336">    }</span>
<span class="line" id="L2337">    <span class="tok-kw">var</span> act = os.Sigaction{</span>
<span class="line" id="L2338">        .handler = .{ .sigaction = handleSegfaultPosix },</span>
<span class="line" id="L2339">        .mask = os.empty_sigset,</span>
<span class="line" id="L2340">        .flags = (os.SA.SIGINFO | os.SA.RESTART | os.SA.RESETHAND),</span>
<span class="line" id="L2341">    };</span>
<span class="line" id="L2342"></span>
<span class="line" id="L2343">    updateSegfaultHandler(&amp;act) <span class="tok-kw">catch</span> {</span>
<span class="line" id="L2344">        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;unable to install segfault handler, maybe adjust have_segfault_handling_support in std/debug.zig&quot;</span>);</span>
<span class="line" id="L2345">    };</span>
<span class="line" id="L2346">}</span>
<span class="line" id="L2347"></span>
<span class="line" id="L2348"><span class="tok-kw">fn</span> <span class="tok-fn">resetSegfaultHandler</span>() <span class="tok-type">void</span> {</span>
<span class="line" id="L2349">    <span class="tok-kw">if</span> (native_os == .windows) {</span>
<span class="line" id="L2350">        <span class="tok-kw">if</span> (windows_segfault_handle) |handle| {</span>
<span class="line" id="L2351">            assert(windows.kernel32.RemoveVectoredExceptionHandler(handle) != <span class="tok-number">0</span>);</span>
<span class="line" id="L2352">            windows_segfault_handle = <span class="tok-null">null</span>;</span>
<span class="line" id="L2353">        }</span>
<span class="line" id="L2354">        <span class="tok-kw">return</span>;</span>
<span class="line" id="L2355">    }</span>
<span class="line" id="L2356">    <span class="tok-kw">var</span> act = os.Sigaction{</span>
<span class="line" id="L2357">        .handler = .{ .handler = os.SIG.DFL },</span>
<span class="line" id="L2358">        .mask = os.empty_sigset,</span>
<span class="line" id="L2359">        .flags = <span class="tok-number">0</span>,</span>
<span class="line" id="L2360">    };</span>
<span class="line" id="L2361">    <span class="tok-comment">// To avoid a double-panic, do nothing if an error happens here.</span>
</span>
<span class="line" id="L2362">    updateSegfaultHandler(&amp;act) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L2363">}</span>
<span class="line" id="L2364"></span>
<span class="line" id="L2365"><span class="tok-kw">fn</span> <span class="tok-fn">handleSegfaultPosix</span>(sig: <span class="tok-type">i32</span>, info: *<span class="tok-kw">const</span> os.siginfo_t, ctx_ptr: ?*<span class="tok-kw">const</span> <span class="tok-type">anyopaque</span>) <span class="tok-kw">callconv</span>(.C) <span class="tok-type">noreturn</span> {</span>
<span class="line" id="L2366">    <span class="tok-comment">// Reset to the default handler so that if a segfault happens in this handler it will crash</span>
</span>
<span class="line" id="L2367">    <span class="tok-comment">// the process. Also when this handler returns, the original instruction will be repeated</span>
</span>
<span class="line" id="L2368">    <span class="tok-comment">// and the resulting segfault will crash the process rather than continually dump stack traces.</span>
</span>
<span class="line" id="L2369">    resetSegfaultHandler();</span>
<span class="line" id="L2370"></span>
<span class="line" id="L2371">    <span class="tok-kw">const</span> addr = <span class="tok-kw">switch</span> (native_os) {</span>
<span class="line" id="L2372">        .linux =&gt; <span class="tok-builtin">@intFromPtr</span>(info.fields.sigfault.addr),</span>
<span class="line" id="L2373">        .freebsd, .macos =&gt; <span class="tok-builtin">@intFromPtr</span>(info.addr),</span>
<span class="line" id="L2374">        .netbsd =&gt; <span class="tok-builtin">@intFromPtr</span>(info.info.reason.fault.addr),</span>
<span class="line" id="L2375">        .openbsd =&gt; <span class="tok-builtin">@intFromPtr</span>(info.data.fault.addr),</span>
<span class="line" id="L2376">        .solaris =&gt; <span class="tok-builtin">@intFromPtr</span>(info.reason.fault.addr),</span>
<span class="line" id="L2377">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L2378">    };</span>
<span class="line" id="L2379"></span>
<span class="line" id="L2380">    <span class="tok-kw">nosuspend</span> <span class="tok-kw">switch</span> (panic_stage) {</span>
<span class="line" id="L2381">        <span class="tok-number">0</span> =&gt; {</span>
<span class="line" id="L2382">            panic_stage = <span class="tok-number">1</span>;</span>
<span class="line" id="L2383">            _ = panicking.fetchAdd(<span class="tok-number">1</span>, .SeqCst);</span>
<span class="line" id="L2384"></span>
<span class="line" id="L2385">            {</span>
<span class="line" id="L2386">                panic_mutex.lock();</span>
<span class="line" id="L2387">                <span class="tok-kw">defer</span> panic_mutex.unlock();</span>
<span class="line" id="L2388"></span>
<span class="line" id="L2389">                dumpSegfaultInfoPosix(sig, addr, ctx_ptr);</span>
<span class="line" id="L2390">            }</span>
<span class="line" id="L2391"></span>
<span class="line" id="L2392">            waitForOtherThreadToFinishPanicking();</span>
<span class="line" id="L2393">        },</span>
<span class="line" id="L2394">        <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L2395">            <span class="tok-comment">// panic mutex already locked</span>
</span>
<span class="line" id="L2396">            dumpSegfaultInfoPosix(sig, addr, ctx_ptr);</span>
<span class="line" id="L2397">        },</span>
<span class="line" id="L2398">    };</span>
<span class="line" id="L2399"></span>
<span class="line" id="L2400">    <span class="tok-comment">// We cannot allow the signal handler to return because when it runs the original instruction</span>
</span>
<span class="line" id="L2401">    <span class="tok-comment">// again, the memory may be mapped and undefined behavior would occur rather than repeating</span>
</span>
<span class="line" id="L2402">    <span class="tok-comment">// the segfault. So we simply abort here.</span>
</span>
<span class="line" id="L2403">    os.abort();</span>
<span class="line" id="L2404">}</span>
<span class="line" id="L2405"></span>
<span class="line" id="L2406"><span class="tok-kw">fn</span> <span class="tok-fn">dumpSegfaultInfoPosix</span>(sig: <span class="tok-type">i32</span>, addr: <span class="tok-type">usize</span>, ctx_ptr: ?*<span class="tok-kw">const</span> <span class="tok-type">anyopaque</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L2407">    <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L2408">    _ = <span class="tok-kw">switch</span> (sig) {</span>
<span class="line" id="L2409">        os.SIG.SEGV =&gt; stderr.print(<span class="tok-str">&quot;Segmentation fault at address 0x{x}\n&quot;</span>, .{addr}),</span>
<span class="line" id="L2410">        os.SIG.ILL =&gt; stderr.print(<span class="tok-str">&quot;Illegal instruction at address 0x{x}\n&quot;</span>, .{addr}),</span>
<span class="line" id="L2411">        os.SIG.BUS =&gt; stderr.print(<span class="tok-str">&quot;Bus error at address 0x{x}\n&quot;</span>, .{addr}),</span>
<span class="line" id="L2412">        os.SIG.FPE =&gt; stderr.print(<span class="tok-str">&quot;Arithmetic exception at address 0x{x}\n&quot;</span>, .{addr}),</span>
<span class="line" id="L2413">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L2414">    } <span class="tok-kw">catch</span> os.abort();</span>
<span class="line" id="L2415"></span>
<span class="line" id="L2416">    <span class="tok-kw">switch</span> (native_arch) {</span>
<span class="line" id="L2417">        .x86,</span>
<span class="line" id="L2418">        .x86_64,</span>
<span class="line" id="L2419">        .arm,</span>
<span class="line" id="L2420">        .aarch64,</span>
<span class="line" id="L2421">        =&gt; {</span>
<span class="line" id="L2422">            <span class="tok-kw">const</span> ctx: *<span class="tok-kw">const</span> os.ucontext_t = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(ctx_ptr));</span>
<span class="line" id="L2423">            dumpStackTraceFromBase(ctx);</span>
<span class="line" id="L2424">        },</span>
<span class="line" id="L2425">        <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L2426">    }</span>
<span class="line" id="L2427">}</span>
<span class="line" id="L2428"></span>
<span class="line" id="L2429"><span class="tok-kw">fn</span> <span class="tok-fn">handleSegfaultWindows</span>(info: *windows.EXCEPTION_POINTERS) <span class="tok-kw">callconv</span>(windows.WINAPI) <span class="tok-type">c_long</span> {</span>
<span class="line" id="L2430">    <span class="tok-kw">switch</span> (info.ExceptionRecord.ExceptionCode) {</span>
<span class="line" id="L2431">        windows.EXCEPTION_DATATYPE_MISALIGNMENT =&gt; handleSegfaultWindowsExtra(info, <span class="tok-number">0</span>, <span class="tok-str">&quot;Unaligned Memory Access&quot;</span>),</span>
<span class="line" id="L2432">        windows.EXCEPTION_ACCESS_VIOLATION =&gt; handleSegfaultWindowsExtra(info, <span class="tok-number">1</span>, <span class="tok-null">null</span>),</span>
<span class="line" id="L2433">        windows.EXCEPTION_ILLEGAL_INSTRUCTION =&gt; handleSegfaultWindowsExtra(info, <span class="tok-number">2</span>, <span class="tok-null">null</span>),</span>
<span class="line" id="L2434">        windows.EXCEPTION_STACK_OVERFLOW =&gt; handleSegfaultWindowsExtra(info, <span class="tok-number">0</span>, <span class="tok-str">&quot;Stack Overflow&quot;</span>),</span>
<span class="line" id="L2435">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> windows.EXCEPTION_CONTINUE_SEARCH,</span>
<span class="line" id="L2436">    }</span>
<span class="line" id="L2437">}</span>
<span class="line" id="L2438"></span>
<span class="line" id="L2439"><span class="tok-kw">fn</span> <span class="tok-fn">handleSegfaultWindowsExtra</span>(</span>
<span class="line" id="L2440">    info: *windows.EXCEPTION_POINTERS,</span>
<span class="line" id="L2441">    msg: <span class="tok-type">u8</span>,</span>
<span class="line" id="L2442">    label: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2443">) <span class="tok-type">noreturn</span> {</span>
<span class="line" id="L2444">    <span class="tok-kw">const</span> exception_address = <span class="tok-builtin">@intFromPtr</span>(info.ExceptionRecord.ExceptionAddress);</span>
<span class="line" id="L2445">    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(windows, <span class="tok-str">&quot;CONTEXT&quot;</span>)) {</span>
<span class="line" id="L2446">        <span class="tok-kw">nosuspend</span> <span class="tok-kw">switch</span> (panic_stage) {</span>
<span class="line" id="L2447">            <span class="tok-number">0</span> =&gt; {</span>
<span class="line" id="L2448">                panic_stage = <span class="tok-number">1</span>;</span>
<span class="line" id="L2449">                _ = panicking.fetchAdd(<span class="tok-number">1</span>, .SeqCst);</span>
<span class="line" id="L2450"></span>
<span class="line" id="L2451">                {</span>
<span class="line" id="L2452">                    panic_mutex.lock();</span>
<span class="line" id="L2453">                    <span class="tok-kw">defer</span> panic_mutex.unlock();</span>
<span class="line" id="L2454"></span>
<span class="line" id="L2455">                    dumpSegfaultInfoWindows(info, msg, label);</span>
<span class="line" id="L2456">                }</span>
<span class="line" id="L2457"></span>
<span class="line" id="L2458">                waitForOtherThreadToFinishPanicking();</span>
<span class="line" id="L2459">            },</span>
<span class="line" id="L2460">            <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L2461">                <span class="tok-comment">// panic mutex already locked</span>
</span>
<span class="line" id="L2462">                dumpSegfaultInfoWindows(info, msg, label);</span>
<span class="line" id="L2463">            },</span>
<span class="line" id="L2464">        };</span>
<span class="line" id="L2465">        os.abort();</span>
<span class="line" id="L2466">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2467">        <span class="tok-kw">switch</span> (msg) {</span>
<span class="line" id="L2468">            <span class="tok-number">0</span> =&gt; panicImpl(<span class="tok-null">null</span>, exception_address, <span class="tok-str">&quot;{s}&quot;</span>, label.?),</span>
<span class="line" id="L2469">            <span class="tok-number">1</span> =&gt; {</span>
<span class="line" id="L2470">                <span class="tok-kw">const</span> format_item = <span class="tok-str">&quot;Segmentation fault at address 0x{x}&quot;</span>;</span>
<span class="line" id="L2471">                <span class="tok-kw">var</span> buf: [format_item.len + <span class="tok-number">64</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>; <span class="tok-comment">// 64 is arbitrary, but sufficiently large</span>
</span>
<span class="line" id="L2472">                <span class="tok-kw">const</span> to_print = std.fmt.bufPrint(buf[<span class="tok-number">0</span>..buf.len], format_item, .{info.ExceptionRecord.ExceptionInformation[<span class="tok-number">1</span>]}) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L2473">                panicImpl(<span class="tok-null">null</span>, exception_address, to_print);</span>
<span class="line" id="L2474">            },</span>
<span class="line" id="L2475">            <span class="tok-number">2</span> =&gt; panicImpl(<span class="tok-null">null</span>, exception_address, <span class="tok-str">&quot;Illegal Instruction&quot;</span>),</span>
<span class="line" id="L2476">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L2477">        }</span>
<span class="line" id="L2478">    }</span>
<span class="line" id="L2479">}</span>
<span class="line" id="L2480"></span>
<span class="line" id="L2481"><span class="tok-kw">fn</span> <span class="tok-fn">dumpSegfaultInfoWindows</span>(info: *windows.EXCEPTION_POINTERS, msg: <span class="tok-type">u8</span>, label: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L2482">    <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L2483">    _ = <span class="tok-kw">switch</span> (msg) {</span>
<span class="line" id="L2484">        <span class="tok-number">0</span> =&gt; stderr.print(<span class="tok-str">&quot;{s}\n&quot;</span>, .{label.?}),</span>
<span class="line" id="L2485">        <span class="tok-number">1</span> =&gt; stderr.print(<span class="tok-str">&quot;Segmentation fault at address 0x{x}\n&quot;</span>, .{info.ExceptionRecord.ExceptionInformation[<span class="tok-number">1</span>]}),</span>
<span class="line" id="L2486">        <span class="tok-number">2</span> =&gt; stderr.print(<span class="tok-str">&quot;Illegal instruction at address 0x{x}\n&quot;</span>, .{info.ContextRecord.getRegs().ip}),</span>
<span class="line" id="L2487">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L2488">    } <span class="tok-kw">catch</span> os.abort();</span>
<span class="line" id="L2489"></span>
<span class="line" id="L2490">    dumpStackTraceFromBase(info.ContextRecord);</span>
<span class="line" id="L2491">}</span>
<span class="line" id="L2492"></span>
<span class="line" id="L2493"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpStackPointerAddr</span>(prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L2494">    <span class="tok-kw">const</span> sp = <span class="tok-kw">asm</span> (<span class="tok-str">&quot;&quot;</span></span>
<span class="line" id="L2495">        : [argc] <span class="tok-str">&quot;={rsp}&quot;</span> (-&gt; <span class="tok-type">usize</span>),</span>
<span class="line" id="L2496">    );</span>
<span class="line" id="L2497">    std.debug.print(<span class="tok-str">&quot;{} sp = 0x{x}\n&quot;</span>, .{ prefix, sp });</span>
<span class="line" id="L2498">}</span>
<span class="line" id="L2499"></span>
<span class="line" id="L2500"><span class="tok-kw">test</span> <span class="tok-str">&quot;manage resources correctly&quot;</span> {</span>
<span class="line" id="L2501">    <span class="tok-kw">if</span> (builtin.os.tag == .wasi) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;</span>
<span class="line" id="L2502"></span>
<span class="line" id="L2503">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L2504">        <span class="tok-comment">// https://github.com/ziglang/zig/issues/13963</span>
</span>
<span class="line" id="L2505">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;</span>
<span class="line" id="L2506">    }</span>
<span class="line" id="L2507"></span>
<span class="line" id="L2508">    <span class="tok-kw">const</span> writer = std.io.null_writer;</span>
<span class="line" id="L2509">    <span class="tok-kw">var</span> di = <span class="tok-kw">try</span> openSelfDebugInfo(testing.allocator);</span>
<span class="line" id="L2510">    <span class="tok-kw">defer</span> di.deinit();</span>
<span class="line" id="L2511">    <span class="tok-kw">try</span> printSourceAtAddress(&amp;di, writer, showMyTrace(), io.tty.detectConfig(std.io.getStdErr()));</span>
<span class="line" id="L2512">}</span>
<span class="line" id="L2513"></span>
<span class="line" id="L2514"><span class="tok-kw">noinline</span> <span class="tok-kw">fn</span> <span class="tok-fn">showMyTrace</span>() <span class="tok-type">usize</span> {</span>
<span class="line" id="L2515">    <span class="tok-kw">return</span> <span class="tok-builtin">@returnAddress</span>();</span>
<span class="line" id="L2516">}</span>
<span class="line" id="L2517"></span>
<span class="line" id="L2518"><span class="tok-comment">/// This API helps you track where a value originated and where it was mutated,</span></span>
<span class="line" id="L2519"><span class="tok-comment">/// or any other points of interest.</span></span>
<span class="line" id="L2520"><span class="tok-comment">/// In debug mode, it adds a small size penalty (104 bytes on 64-bit architectures)</span></span>
<span class="line" id="L2521"><span class="tok-comment">/// to the aggregate that you add it to.</span></span>
<span class="line" id="L2522"><span class="tok-comment">/// In release mode, it is size 0 and all methods are no-ops.</span></span>
<span class="line" id="L2523"><span class="tok-comment">/// This is a pre-made type with default settings.</span></span>
<span class="line" id="L2524"><span class="tok-comment">/// For more advanced usage, see `ConfigurableTrace`.</span></span>
<span class="line" id="L2525"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Trace = ConfigurableTrace(<span class="tok-number">2</span>, <span class="tok-number">4</span>, builtin.mode == .Debug);</span>
<span class="line" id="L2526"></span>
<span class="line" id="L2527"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ConfigurableTrace</span>(<span class="tok-kw">comptime</span> size: <span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> stack_frame_count: <span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> is_enabled: <span class="tok-type">bool</span>) <span class="tok-type">type</span> {</span>
<span class="line" id="L2528">    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2529">        addrs: [actual_size][stack_frame_count]<span class="tok-type">usize</span> = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L2530">        notes: [actual_size][]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L2531">        index: Index = <span class="tok-number">0</span>,</span>
<span class="line" id="L2532"></span>
<span class="line" id="L2533">        <span class="tok-kw">const</span> actual_size = <span class="tok-kw">if</span> (enabled) size <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L2534">        <span class="tok-kw">const</span> Index = <span class="tok-kw">if</span> (enabled) <span class="tok-type">usize</span> <span class="tok-kw">else</span> <span class="tok-type">u0</span>;</span>
<span class="line" id="L2535"></span>
<span class="line" id="L2536">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> enabled = is_enabled;</span>
<span class="line" id="L2537"></span>
<span class="line" id="L2538">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> add = <span class="tok-kw">if</span> (enabled) addNoInline <span class="tok-kw">else</span> addNoOp;</span>
<span class="line" id="L2539"></span>
<span class="line" id="L2540">        <span class="tok-kw">pub</span> <span class="tok-kw">noinline</span> <span class="tok-kw">fn</span> <span class="tok-fn">addNoInline</span>(t: *<span class="tok-builtin">@This</span>(), note: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L2541">            <span class="tok-kw">comptime</span> assert(enabled);</span>
<span class="line" id="L2542">            <span class="tok-kw">return</span> addAddr(t, <span class="tok-builtin">@returnAddress</span>(), note);</span>
<span class="line" id="L2543">        }</span>
<span class="line" id="L2544"></span>
<span class="line" id="L2545">        <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">addNoOp</span>(t: *<span class="tok-builtin">@This</span>(), note: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L2546">            _ = t;</span>
<span class="line" id="L2547">            _ = note;</span>
<span class="line" id="L2548">            <span class="tok-kw">comptime</span> assert(!enabled);</span>
<span class="line" id="L2549">        }</span>
<span class="line" id="L2550"></span>
<span class="line" id="L2551">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addAddr</span>(t: *<span class="tok-builtin">@This</span>(), addr: <span class="tok-type">usize</span>, note: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L2552">            <span class="tok-kw">if</span> (!enabled) <span class="tok-kw">return</span>;</span>
<span class="line" id="L2553"></span>
<span class="line" id="L2554">            <span class="tok-kw">if</span> (t.index &lt; size) {</span>
<span class="line" id="L2555">                t.notes[t.index] = note;</span>
<span class="line" id="L2556">                t.addrs[t.index] = [<span class="tok-number">1</span>]<span class="tok-type">usize</span>{<span class="tok-number">0</span>} ** stack_frame_count;</span>
<span class="line" id="L2557">                <span class="tok-kw">var</span> stack_trace: std.builtin.StackTrace = .{</span>
<span class="line" id="L2558">                    .index = <span class="tok-number">0</span>,</span>
<span class="line" id="L2559">                    .instruction_addresses = &amp;t.addrs[t.index],</span>
<span class="line" id="L2560">                };</span>
<span class="line" id="L2561">                captureStackTrace(addr, &amp;stack_trace);</span>
<span class="line" id="L2562">            }</span>
<span class="line" id="L2563">            <span class="tok-comment">// Keep counting even if the end is reached so that the</span>
</span>
<span class="line" id="L2564">            <span class="tok-comment">// user can find out how much more size they need.</span>
</span>
<span class="line" id="L2565">            t.index += <span class="tok-number">1</span>;</span>
<span class="line" id="L2566">        }</span>
<span class="line" id="L2567"></span>
<span class="line" id="L2568">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dump</span>(t: <span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {</span>
<span class="line" id="L2569">            <span class="tok-kw">if</span> (!enabled) <span class="tok-kw">return</span>;</span>
<span class="line" id="L2570"></span>
<span class="line" id="L2571">            <span class="tok-kw">const</span> tty_config = io.tty.detectConfig(std.io.getStdErr());</span>
<span class="line" id="L2572">            <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L2573">            <span class="tok-kw">const</span> end = <span class="tok-builtin">@min</span>(t.index, size);</span>
<span class="line" id="L2574">            <span class="tok-kw">const</span> debug_info = getSelfDebugInfo() <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L2575">                stderr.print(</span>
<span class="line" id="L2576">                    <span class="tok-str">&quot;Unable to dump stack trace: Unable to open debug info: {s}\n&quot;</span>,</span>
<span class="line" id="L2577">                    .{<span class="tok-builtin">@errorName</span>(err)},</span>
<span class="line" id="L2578">                ) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L2579">                <span class="tok-kw">return</span>;</span>
<span class="line" id="L2580">            };</span>
<span class="line" id="L2581">            <span class="tok-kw">for</span> (t.addrs[<span class="tok-number">0</span>..end], <span class="tok-number">0</span>..) |frames_array, i| {</span>
<span class="line" id="L2582">                stderr.print(<span class="tok-str">&quot;{s}:\n&quot;</span>, .{t.notes[i]}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L2583">                <span class="tok-kw">var</span> frames_array_mutable = frames_array;</span>
<span class="line" id="L2584">                <span class="tok-kw">const</span> frames = mem.sliceTo(frames_array_mutable[<span class="tok-number">0</span>..], <span class="tok-number">0</span>);</span>
<span class="line" id="L2585">                <span class="tok-kw">const</span> stack_trace: std.builtin.StackTrace = .{</span>
<span class="line" id="L2586">                    .index = frames.len,</span>
<span class="line" id="L2587">                    .instruction_addresses = frames,</span>
<span class="line" id="L2588">                };</span>
<span class="line" id="L2589">                writeStackTrace(stack_trace, stderr, getDebugInfoAllocator(), debug_info, tty_config) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L2590">            }</span>
<span class="line" id="L2591">            <span class="tok-kw">if</span> (t.index &gt; end) {</span>
<span class="line" id="L2592">                stderr.print(<span class="tok-str">&quot;{d} more traces not shown; consider increasing trace size\n&quot;</span>, .{</span>
<span class="line" id="L2593">                    t.index - end,</span>
<span class="line" id="L2594">                }) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L2595">            }</span>
<span class="line" id="L2596">        }</span>
<span class="line" id="L2597"></span>
<span class="line" id="L2598">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(</span>
<span class="line" id="L2599">            t: Trace,</span>
<span class="line" id="L2600">            <span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2601">            options: std.fmt.FormatOptions,</span>
<span class="line" id="L2602">            writer: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L2603">        ) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2604">            <span class="tok-kw">if</span> (fmt.len != <span class="tok-number">0</span>) std.fmt.invalidFmtError(fmt, t);</span>
<span class="line" id="L2605">            _ = options;</span>
<span class="line" id="L2606">            <span class="tok-kw">if</span> (enabled) {</span>
<span class="line" id="L2607">                <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;\n&quot;</span>);</span>
<span class="line" id="L2608">                t.dump();</span>
<span class="line" id="L2609">                <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;\n&quot;</span>);</span>
<span class="line" id="L2610">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2611">                <span class="tok-kw">return</span> writer.writeAll(<span class="tok-str">&quot;(value tracing disabled)&quot;</span>);</span>
<span class="line" id="L2612">            }</span>
<span class="line" id="L2613">        }</span>
<span class="line" id="L2614">    };</span>
<span class="line" id="L2615">}</span>
<span class="line" id="L2616"></span>
</code></pre></body>
</html>