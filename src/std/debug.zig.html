<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>debug.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg==">
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std.zig&quot;</span>);</span>
<span class="line" id="L2"><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);</span>
<span class="line" id="L3"><span class="tok-kw">const</span> math = std.math;</span>
<span class="line" id="L4"><span class="tok-kw">const</span> mem = std.mem;</span>
<span class="line" id="L5"><span class="tok-kw">const</span> io = std.io;</span>
<span class="line" id="L6"><span class="tok-kw">const</span> os = std.os;</span>
<span class="line" id="L7"><span class="tok-kw">const</span> fs = std.fs;</span>
<span class="line" id="L8"><span class="tok-kw">const</span> testing = std.testing;</span>
<span class="line" id="L9"><span class="tok-kw">const</span> elf = std.elf;</span>
<span class="line" id="L10"><span class="tok-kw">const</span> DW = std.dwarf;</span>
<span class="line" id="L11"><span class="tok-kw">const</span> macho = std.macho;</span>
<span class="line" id="L12"><span class="tok-kw">const</span> coff = std.coff;</span>
<span class="line" id="L13"><span class="tok-kw">const</span> pdb = std.pdb;</span>
<span class="line" id="L14"><span class="tok-kw">const</span> root = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;root&quot;</span>);</span>
<span class="line" id="L15"><span class="tok-kw">const</span> File = std.fs.File;</span>
<span class="line" id="L16"><span class="tok-kw">const</span> windows = std.os.windows;</span>
<span class="line" id="L17"><span class="tok-kw">const</span> native_arch = builtin.cpu.arch;</span>
<span class="line" id="L18"><span class="tok-kw">const</span> native_os = builtin.os.tag;</span>
<span class="line" id="L19"><span class="tok-kw">const</span> native_endian = native_arch.endian();</span>
<span class="line" id="L20"></span>
<span class="line" id="L21"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> runtime_safety = <span class="tok-kw">switch</span> (builtin.mode) {</span>
<span class="line" id="L22">    .Debug, .ReleaseSafe =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L23">    .ReleaseFast, .ReleaseSmall =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L24">};</span>
<span class="line" id="L25"></span>
<span class="line" id="L26"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> sys_can_stack_trace = <span class="tok-kw">switch</span> (builtin.cpu.arch) {</span>
<span class="line" id="L27">    <span class="tok-comment">// Observed to go into an infinite loop.</span>
</span>
<span class="line" id="L28">    <span class="tok-comment">// TODO: Make this work.</span>
</span>
<span class="line" id="L29">    .mips,</span>
<span class="line" id="L30">    .mipsel,</span>
<span class="line" id="L31">    =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L32"></span>
<span class="line" id="L33">    <span class="tok-comment">// `@returnAddress()` in LLVM 10 gives</span>
</span>
<span class="line" id="L34">    <span class="tok-comment">// &quot;Non-Emscripten WebAssembly hasn't implemented __builtin_return_address&quot;.</span>
</span>
<span class="line" id="L35">    .wasm32,</span>
<span class="line" id="L36">    .wasm64,</span>
<span class="line" id="L37">    =&gt; builtin.os.tag == .emscripten,</span>
<span class="line" id="L38"></span>
<span class="line" id="L39">    <span class="tok-comment">// `@returnAddress()` is unsupported in LLVM 13.</span>
</span>
<span class="line" id="L40">    .bpfel,</span>
<span class="line" id="L41">    .bpfeb,</span>
<span class="line" id="L42">    =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L43"></span>
<span class="line" id="L44">    <span class="tok-kw">else</span> =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L45">};</span>
<span class="line" id="L46"></span>
<span class="line" id="L47"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> LineInfo = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L48">    line: <span class="tok-type">u64</span>,</span>
<span class="line" id="L49">    column: <span class="tok-type">u64</span>,</span>
<span class="line" id="L50">    file_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L51"></span>
<span class="line" id="L52">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: LineInfo, allocator: mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L53">        allocator.free(self.file_name);</span>
<span class="line" id="L54">    }</span>
<span class="line" id="L55">};</span>
<span class="line" id="L56"></span>
<span class="line" id="L57"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SymbolInfo = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L58">    symbol_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;???&quot;</span>,</span>
<span class="line" id="L59">    compile_unit_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;???&quot;</span>,</span>
<span class="line" id="L60">    line_info: ?LineInfo = <span class="tok-null">null</span>,</span>
<span class="line" id="L61"></span>
<span class="line" id="L62">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: SymbolInfo, allocator: mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L63">        <span class="tok-kw">if</span> (self.line_info) |li| {</span>
<span class="line" id="L64">            li.deinit(allocator);</span>
<span class="line" id="L65">        }</span>
<span class="line" id="L66">    }</span>
<span class="line" id="L67">};</span>
<span class="line" id="L68"><span class="tok-kw">const</span> PdbOrDwarf = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L69">    pdb: pdb.Pdb,</span>
<span class="line" id="L70">    dwarf: DW.DwarfInfo,</span>
<span class="line" id="L71"></span>
<span class="line" id="L72">    <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *PdbOrDwarf, allocator: mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L73">        <span class="tok-kw">switch</span> (self.*) {</span>
<span class="line" id="L74">            .pdb =&gt; |*inner| inner.deinit(),</span>
<span class="line" id="L75">            .dwarf =&gt; |*inner| inner.deinit(allocator),</span>
<span class="line" id="L76">        }</span>
<span class="line" id="L77">    }</span>
<span class="line" id="L78">};</span>
<span class="line" id="L79"></span>
<span class="line" id="L80"><span class="tok-kw">var</span> stderr_mutex = std.Thread.Mutex{};</span>
<span class="line" id="L81"></span>
<span class="line" id="L82"><span class="tok-comment">/// Print to stderr, unbuffered, and silently returning on failure. Intended</span></span>
<span class="line" id="L83"><span class="tok-comment">/// for use in &quot;printf debugging.&quot; Use `std.log` functions for proper logging.</span></span>
<span class="line" id="L84"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">print</span>(<span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L85">    stderr_mutex.lock();</span>
<span class="line" id="L86">    <span class="tok-kw">defer</span> stderr_mutex.unlock();</span>
<span class="line" id="L87">    <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L88">    <span class="tok-kw">nosuspend</span> stderr.print(fmt, args) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L89">}</span>
<span class="line" id="L90"></span>
<span class="line" id="L91"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getStderrMutex</span>() *std.Thread.Mutex {</span>
<span class="line" id="L92">    <span class="tok-kw">return</span> &amp;stderr_mutex;</span>
<span class="line" id="L93">}</span>
<span class="line" id="L94"></span>
<span class="line" id="L95"><span class="tok-comment">/// TODO multithreaded awareness</span></span>
<span class="line" id="L96"><span class="tok-kw">var</span> self_debug_info: ?DebugInfo = <span class="tok-null">null</span>;</span>
<span class="line" id="L97"></span>
<span class="line" id="L98"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSelfDebugInfo</span>() !*DebugInfo {</span>
<span class="line" id="L99">    <span class="tok-kw">if</span> (self_debug_info) |*info| {</span>
<span class="line" id="L100">        <span class="tok-kw">return</span> info;</span>
<span class="line" id="L101">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L102">        self_debug_info = <span class="tok-kw">try</span> openSelfDebugInfo(getDebugInfoAllocator());</span>
<span class="line" id="L103">        <span class="tok-kw">return</span> &amp;self_debug_info.?;</span>
<span class="line" id="L104">    }</span>
<span class="line" id="L105">}</span>
<span class="line" id="L106"></span>
<span class="line" id="L107"><span class="tok-comment">/// Tries to print the current stack trace to stderr, unbuffered, and ignores any error returned.</span></span>
<span class="line" id="L108"><span class="tok-comment">/// TODO multithreaded awareness</span></span>
<span class="line" id="L109"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpCurrentStackTrace</span>(start_addr: ?<span class="tok-type">usize</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L110">    <span class="tok-kw">nosuspend</span> {</span>
<span class="line" id="L111">        <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> builtin.target.isWasm()) {</span>
<span class="line" id="L112">            <span class="tok-kw">if</span> (native_os == .wasi) {</span>
<span class="line" id="L113">                <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L114">                stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: not implemented for Wasm\n&quot;</span>, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L115">            }</span>
<span class="line" id="L116">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L117">        }</span>
<span class="line" id="L118">        <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L119">        <span class="tok-kw">if</span> (builtin.strip_debug_info) {</span>
<span class="line" id="L120">            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: debug info stripped\n&quot;</span>, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L121">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L122">        }</span>
<span class="line" id="L123">        <span class="tok-kw">const</span> debug_info = getSelfDebugInfo() <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L124">            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: Unable to open debug info: {s}\n&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L125">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L126">        };</span>
<span class="line" id="L127">        writeCurrentStackTrace(stderr, debug_info, io.tty.detectConfig(io.getStdErr()), start_addr) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L128">            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: {s}\n&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L129">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L130">        };</span>
<span class="line" id="L131">    }</span>
<span class="line" id="L132">}</span>
<span class="line" id="L133"></span>
<span class="line" id="L134"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> have_ucontext = <span class="tok-builtin">@hasDecl</span>(os.system, <span class="tok-str">&quot;ucontext_t&quot;</span>) <span class="tok-kw">and</span></span>
<span class="line" id="L135">    (builtin.os.tag != .linux <span class="tok-kw">or</span> <span class="tok-kw">switch</span> (builtin.cpu.arch) {</span>
<span class="line" id="L136">    .mips, .mipsel, .mips64, .mips64el, .riscv64 =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L137">    <span class="tok-kw">else</span> =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L138">});</span>
<span class="line" id="L139"></span>
<span class="line" id="L140"><span class="tok-comment">/// Platform-specific thread state. This contains register state, and on some platforms</span></span>
<span class="line" id="L141"><span class="tok-comment">/// information about the stack. This is not safe to trivially copy, because some platforms</span></span>
<span class="line" id="L142"><span class="tok-comment">/// use internal pointers within this structure. To make a copy, use `copyContext`.</span></span>
<span class="line" id="L143"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ThreadContext = blk: {</span>
<span class="line" id="L144">    <span class="tok-kw">if</span> (native_os == .windows) {</span>
<span class="line" id="L145">        <span class="tok-kw">break</span> :blk std.os.windows.CONTEXT;</span>
<span class="line" id="L146">    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (have_ucontext) {</span>
<span class="line" id="L147">        <span class="tok-kw">break</span> :blk os.ucontext_t;</span>
<span class="line" id="L148">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L149">        <span class="tok-kw">break</span> :blk <span class="tok-type">void</span>;</span>
<span class="line" id="L150">    }</span>
<span class="line" id="L151">};</span>
<span class="line" id="L152"></span>
<span class="line" id="L153"><span class="tok-comment">/// Copies one context to another, updating any internal pointers</span></span>
<span class="line" id="L154"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copyContext</span>(source: *<span class="tok-kw">const</span> ThreadContext, dest: *ThreadContext) <span class="tok-type">void</span> {</span>
<span class="line" id="L155">    <span class="tok-kw">if</span> (!have_ucontext) <span class="tok-kw">return</span> {};</span>
<span class="line" id="L156">    dest.* = source.*;</span>
<span class="line" id="L157">    relocateContext(dest);</span>
<span class="line" id="L158">}</span>
<span class="line" id="L159"></span>
<span class="line" id="L160"><span class="tok-comment">/// Updates any internal pointers in the context to reflect its current location</span></span>
<span class="line" id="L161"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">relocateContext</span>(context: *ThreadContext) <span class="tok-type">void</span> {</span>
<span class="line" id="L162">    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (native_os) {</span>
<span class="line" id="L163">        .macos =&gt; {</span>
<span class="line" id="L164">            context.mcontext = &amp;context.__mcontext_data;</span>
<span class="line" id="L165">        },</span>
<span class="line" id="L166">        <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L167">    };</span>
<span class="line" id="L168">}</span>
<span class="line" id="L169"></span>
<span class="line" id="L170"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> have_getcontext = <span class="tok-builtin">@hasDecl</span>(os.system, <span class="tok-str">&quot;getcontext&quot;</span>) <span class="tok-kw">and</span></span>
<span class="line" id="L171">    builtin.os.tag != .openbsd <span class="tok-kw">and</span></span>
<span class="line" id="L172">    (builtin.os.tag != .linux <span class="tok-kw">or</span> <span class="tok-kw">switch</span> (builtin.cpu.arch) {</span>
<span class="line" id="L173">    .x86,</span>
<span class="line" id="L174">    .x86_64,</span>
<span class="line" id="L175">    =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L176">    <span class="tok-kw">else</span> =&gt; builtin.link_libc <span class="tok-kw">and</span> !builtin.target.isMusl(),</span>
<span class="line" id="L177">});</span>
<span class="line" id="L178"></span>
<span class="line" id="L179"><span class="tok-comment">/// Capture the current context. The register values in the context will reflect the</span></span>
<span class="line" id="L180"><span class="tok-comment">/// state after the platform `getcontext` function returns.</span></span>
<span class="line" id="L181"><span class="tok-comment">///</span></span>
<span class="line" id="L182"><span class="tok-comment">/// It is valid to call this if the platform doesn't have context capturing support,</span></span>
<span class="line" id="L183"><span class="tok-comment">/// in that case false will be returned.</span></span>
<span class="line" id="L184"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">getContext</span>(context: *ThreadContext) <span class="tok-type">bool</span> {</span>
<span class="line" id="L185">    <span class="tok-kw">if</span> (native_os == .windows) {</span>
<span class="line" id="L186">        context.* = std.mem.zeroes(windows.CONTEXT);</span>
<span class="line" id="L187">        windows.ntdll.RtlCaptureContext(context);</span>
<span class="line" id="L188">        <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L189">    }</span>
<span class="line" id="L190"></span>
<span class="line" id="L191">    <span class="tok-kw">const</span> result = have_getcontext <span class="tok-kw">and</span> os.system.getcontext(context) == <span class="tok-number">0</span>;</span>
<span class="line" id="L192">    <span class="tok-kw">if</span> (native_os == .macos) {</span>
<span class="line" id="L193">        assert(context.mcsize == <span class="tok-builtin">@sizeOf</span>(std.c.mcontext_t));</span>
<span class="line" id="L194"></span>
<span class="line" id="L195">        <span class="tok-comment">// On aarch64-macos, the system getcontext doesn't write anything into the pc</span>
</span>
<span class="line" id="L196">        <span class="tok-comment">// register slot, it only writes lr. This makes the context consistent with</span>
</span>
<span class="line" id="L197">        <span class="tok-comment">// other aarch64 getcontext implementations which write the current lr</span>
</span>
<span class="line" id="L198">        <span class="tok-comment">// (where getcontext will return to) into both the lr and pc slot of the context.</span>
</span>
<span class="line" id="L199">        <span class="tok-kw">if</span> (native_arch == .aarch64) context.mcontext.ss.pc = context.mcontext.ss.lr;</span>
<span class="line" id="L200">    }</span>
<span class="line" id="L201"></span>
<span class="line" id="L202">    <span class="tok-kw">return</span> result;</span>
<span class="line" id="L203">}</span>
<span class="line" id="L204"></span>
<span class="line" id="L205"><span class="tok-comment">/// Tries to print the stack trace starting from the supplied base pointer to stderr,</span></span>
<span class="line" id="L206"><span class="tok-comment">/// unbuffered, and ignores any error returned.</span></span>
<span class="line" id="L207"><span class="tok-comment">/// TODO multithreaded awareness</span></span>
<span class="line" id="L208"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpStackTraceFromBase</span>(context: *<span class="tok-kw">const</span> ThreadContext) <span class="tok-type">void</span> {</span>
<span class="line" id="L209">    <span class="tok-kw">nosuspend</span> {</span>
<span class="line" id="L210">        <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> builtin.target.isWasm()) {</span>
<span class="line" id="L211">            <span class="tok-kw">if</span> (native_os == .wasi) {</span>
<span class="line" id="L212">                <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L213">                stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: not implemented for Wasm\n&quot;</span>, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L214">            }</span>
<span class="line" id="L215">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L216">        }</span>
<span class="line" id="L217">        <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L218">        <span class="tok-kw">if</span> (builtin.strip_debug_info) {</span>
<span class="line" id="L219">            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: debug info stripped\n&quot;</span>, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L220">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L221">        }</span>
<span class="line" id="L222">        <span class="tok-kw">const</span> debug_info = getSelfDebugInfo() <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L223">            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: Unable to open debug info: {s}\n&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L224">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L225">        };</span>
<span class="line" id="L226">        <span class="tok-kw">const</span> tty_config = io.tty.detectConfig(io.getStdErr());</span>
<span class="line" id="L227">        <span class="tok-kw">if</span> (native_os == .windows) {</span>
<span class="line" id="L228">            <span class="tok-comment">// On x86_64 and aarch64, the stack will be unwound using RtlVirtualUnwind using the context</span>
</span>
<span class="line" id="L229">            <span class="tok-comment">// provided by the exception handler. On x86, RtlVirtualUnwind doesn't exist. Instead, a new backtrace</span>
</span>
<span class="line" id="L230">            <span class="tok-comment">// will be captured and frames prior to the exception will be filtered.</span>
</span>
<span class="line" id="L231">            <span class="tok-comment">// The caveat is that RtlCaptureStackBackTrace does not include the KiUserExceptionDispatcher frame,</span>
</span>
<span class="line" id="L232">            <span class="tok-comment">// which is where the IP in `context` points to, so it can't be used as start_addr.</span>
</span>
<span class="line" id="L233">            <span class="tok-comment">// Instead, start_addr is recovered from the stack.</span>
</span>
<span class="line" id="L234">            <span class="tok-kw">const</span> start_addr = <span class="tok-kw">if</span> (builtin.cpu.arch == .x86) <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(context.getRegs().bp + <span class="tok-number">4</span>)).* <span class="tok-kw">else</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L235">            writeStackTraceWindows(stderr, debug_info, tty_config, context, start_addr) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L236">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L237">        }</span>
<span class="line" id="L238"></span>
<span class="line" id="L239">        <span class="tok-kw">var</span> it = StackIterator.initWithContext(<span class="tok-null">null</span>, debug_info, context) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L240">        <span class="tok-kw">defer</span> it.deinit();</span>
<span class="line" id="L241">        printSourceAtAddress(debug_info, stderr, it.unwind_state.?.dwarf_context.pc, tty_config) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L242"></span>
<span class="line" id="L243">        <span class="tok-kw">while</span> (it.next()) |return_address| {</span>
<span class="line" id="L244">            printLastUnwindError(&amp;it, debug_info, stderr, tty_config);</span>
<span class="line" id="L245"></span>
<span class="line" id="L246">            <span class="tok-comment">// On arm64 macOS, the address of the last frame is 0x0 rather than 0x1 as on x86_64 macOS,</span>
</span>
<span class="line" id="L247">            <span class="tok-comment">// therefore, we do a check for `return_address == 0` before subtracting 1 from it to avoid</span>
</span>
<span class="line" id="L248">            <span class="tok-comment">// an overflow. We do not need to signal `StackIterator` as it will correctly detect this</span>
</span>
<span class="line" id="L249">            <span class="tok-comment">// condition on the subsequent iteration and return `null` thus terminating the loop.</span>
</span>
<span class="line" id="L250">            <span class="tok-comment">// same behaviour for x86-windows-msvc</span>
</span>
<span class="line" id="L251">            <span class="tok-kw">const</span> address = <span class="tok-kw">if</span> (return_address == <span class="tok-number">0</span>) return_address <span class="tok-kw">else</span> return_address - <span class="tok-number">1</span>;</span>
<span class="line" id="L252">            printSourceAtAddress(debug_info, stderr, address, tty_config) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L253">        } <span class="tok-kw">else</span> printLastUnwindError(&amp;it, debug_info, stderr, tty_config);</span>
<span class="line" id="L254">    }</span>
<span class="line" id="L255">}</span>
<span class="line" id="L256"></span>
<span class="line" id="L257"><span class="tok-comment">/// Returns a slice with the same pointer as addresses, with a potentially smaller len.</span></span>
<span class="line" id="L258"><span class="tok-comment">/// On Windows, when first_address is not null, we ask for at least 32 stack frames,</span></span>
<span class="line" id="L259"><span class="tok-comment">/// and then try to find the first address. If addresses.len is more than 32, we</span></span>
<span class="line" id="L260"><span class="tok-comment">/// capture that many stack frames exactly, and then look for the first address,</span></span>
<span class="line" id="L261"><span class="tok-comment">/// chopping off the irrelevant frames and shifting so that the returned addresses pointer</span></span>
<span class="line" id="L262"><span class="tok-comment">/// equals the passed in addresses pointer.</span></span>
<span class="line" id="L263"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">captureStackTrace</span>(first_address: ?<span class="tok-type">usize</span>, stack_trace: *std.builtin.StackTrace) <span class="tok-type">void</span> {</span>
<span class="line" id="L264">    <span class="tok-kw">if</span> (native_os == .windows) {</span>
<span class="line" id="L265">        <span class="tok-kw">const</span> addrs = stack_trace.instruction_addresses;</span>
<span class="line" id="L266">        <span class="tok-kw">const</span> first_addr = first_address <span class="tok-kw">orelse</span> {</span>
<span class="line" id="L267">            stack_trace.index = walkStackWindows(addrs[<span class="tok-number">0</span>..], <span class="tok-null">null</span>);</span>
<span class="line" id="L268">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L269">        };</span>
<span class="line" id="L270">        <span class="tok-kw">var</span> addr_buf_stack: [<span class="tok-number">32</span>]<span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L271">        <span class="tok-kw">const</span> addr_buf = <span class="tok-kw">if</span> (addr_buf_stack.len &gt; addrs.len) addr_buf_stack[<span class="tok-number">0</span>..] <span class="tok-kw">else</span> addrs;</span>
<span class="line" id="L272">        <span class="tok-kw">const</span> n = walkStackWindows(addr_buf[<span class="tok-number">0</span>..], <span class="tok-null">null</span>);</span>
<span class="line" id="L273">        <span class="tok-kw">const</span> first_index = <span class="tok-kw">for</span> (addr_buf[<span class="tok-number">0</span>..n], <span class="tok-number">0</span>..) |addr, i| {</span>
<span class="line" id="L274">            <span class="tok-kw">if</span> (addr == first_addr) {</span>
<span class="line" id="L275">                <span class="tok-kw">break</span> i;</span>
<span class="line" id="L276">            }</span>
<span class="line" id="L277">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L278">            stack_trace.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L279">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L280">        };</span>
<span class="line" id="L281">        <span class="tok-kw">const</span> end_index = <span class="tok-builtin">@min</span>(first_index + addrs.len, n);</span>
<span class="line" id="L282">        <span class="tok-kw">const</span> slice = addr_buf[first_index..end_index];</span>
<span class="line" id="L283">        <span class="tok-comment">// We use a for loop here because slice and addrs may alias.</span>
</span>
<span class="line" id="L284">        <span class="tok-kw">for</span> (slice, <span class="tok-number">0</span>..) |addr, i| {</span>
<span class="line" id="L285">            addrs[i] = addr;</span>
<span class="line" id="L286">        }</span>
<span class="line" id="L287">        stack_trace.index = slice.len;</span>
<span class="line" id="L288">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L289">        <span class="tok-comment">// TODO: This should use the DWARF unwinder if .eh_frame_hdr is available (so that full debug info parsing isn't required).</span>
</span>
<span class="line" id="L290">        <span class="tok-comment">//       A new path for loading DebugInfo needs to be created which will only attempt to parse in-memory sections, because</span>
</span>
<span class="line" id="L291">        <span class="tok-comment">//       stopping to load other debug info (ie. source line info) from disk here is not required for unwinding.</span>
</span>
<span class="line" id="L292">        <span class="tok-kw">var</span> it = StackIterator.init(first_address, <span class="tok-null">null</span>);</span>
<span class="line" id="L293">        <span class="tok-kw">defer</span> it.deinit();</span>
<span class="line" id="L294">        <span class="tok-kw">for</span> (stack_trace.instruction_addresses, <span class="tok-number">0</span>..) |*addr, i| {</span>
<span class="line" id="L295">            addr.* = it.next() <span class="tok-kw">orelse</span> {</span>
<span class="line" id="L296">                stack_trace.index = i;</span>
<span class="line" id="L297">                <span class="tok-kw">return</span>;</span>
<span class="line" id="L298">            };</span>
<span class="line" id="L299">        }</span>
<span class="line" id="L300">        stack_trace.index = stack_trace.instruction_addresses.len;</span>
<span class="line" id="L301">    }</span>
<span class="line" id="L302">}</span>
<span class="line" id="L303"></span>
<span class="line" id="L304"><span class="tok-comment">/// Tries to print a stack trace to stderr, unbuffered, and ignores any error returned.</span></span>
<span class="line" id="L305"><span class="tok-comment">/// TODO multithreaded awareness</span></span>
<span class="line" id="L306"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpStackTrace</span>(stack_trace: std.builtin.StackTrace) <span class="tok-type">void</span> {</span>
<span class="line" id="L307">    <span class="tok-kw">nosuspend</span> {</span>
<span class="line" id="L308">        <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> builtin.target.isWasm()) {</span>
<span class="line" id="L309">            <span class="tok-kw">if</span> (native_os == .wasi) {</span>
<span class="line" id="L310">                <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L311">                stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: not implemented for Wasm\n&quot;</span>, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L312">            }</span>
<span class="line" id="L313">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L314">        }</span>
<span class="line" id="L315">        <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L316">        <span class="tok-kw">if</span> (builtin.strip_debug_info) {</span>
<span class="line" id="L317">            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: debug info stripped\n&quot;</span>, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L318">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L319">        }</span>
<span class="line" id="L320">        <span class="tok-kw">const</span> debug_info = getSelfDebugInfo() <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L321">            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: Unable to open debug info: {s}\n&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L322">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L323">        };</span>
<span class="line" id="L324">        writeStackTrace(stack_trace, stderr, getDebugInfoAllocator(), debug_info, io.tty.detectConfig(io.getStdErr())) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L325">            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: {s}\n&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L326">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L327">        };</span>
<span class="line" id="L328">    }</span>
<span class="line" id="L329">}</span>
<span class="line" id="L330"></span>
<span class="line" id="L331"><span class="tok-comment">/// This function invokes undefined behavior when `ok` is `false`.</span></span>
<span class="line" id="L332"><span class="tok-comment">/// In Debug and ReleaseSafe modes, calls to this function are always</span></span>
<span class="line" id="L333"><span class="tok-comment">/// generated, and the `unreachable` statement triggers a panic.</span></span>
<span class="line" id="L334"><span class="tok-comment">/// In ReleaseFast and ReleaseSmall modes, calls to this function are</span></span>
<span class="line" id="L335"><span class="tok-comment">/// optimized away, and in fact the optimizer is able to use the assertion</span></span>
<span class="line" id="L336"><span class="tok-comment">/// in its heuristics.</span></span>
<span class="line" id="L337"><span class="tok-comment">/// Inside a test block, it is best to use the `std.testing` module rather</span></span>
<span class="line" id="L338"><span class="tok-comment">/// than this function, because this function may not detect a test failure</span></span>
<span class="line" id="L339"><span class="tok-comment">/// in ReleaseFast and ReleaseSmall mode. Outside of a test block, this assert</span></span>
<span class="line" id="L340"><span class="tok-comment">/// function is the correct function to use.</span></span>
<span class="line" id="L341"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">assert</span>(ok: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L342">    <span class="tok-kw">if</span> (!ok) <span class="tok-kw">unreachable</span>; <span class="tok-comment">// assertion failure</span>
</span>
<span class="line" id="L343">}</span>
<span class="line" id="L344"></span>
<span class="line" id="L345"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">panic</span>(<span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) <span class="tok-type">noreturn</span> {</span>
<span class="line" id="L346">    <span class="tok-builtin">@setCold</span>(<span class="tok-null">true</span>);</span>
<span class="line" id="L347"></span>
<span class="line" id="L348">    panicExtra(<span class="tok-null">null</span>, <span class="tok-null">null</span>, format, args);</span>
<span class="line" id="L349">}</span>
<span class="line" id="L350"></span>
<span class="line" id="L351"><span class="tok-comment">/// `panicExtra` is useful when you want to print out an `@errorReturnTrace`</span></span>
<span class="line" id="L352"><span class="tok-comment">/// and also print out some values.</span></span>
<span class="line" id="L353"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">panicExtra</span>(</span>
<span class="line" id="L354">    trace: ?*std.builtin.StackTrace,</span>
<span class="line" id="L355">    ret_addr: ?<span class="tok-type">usize</span>,</span>
<span class="line" id="L356">    <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L357">    args: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L358">) <span class="tok-type">noreturn</span> {</span>
<span class="line" id="L359">    <span class="tok-builtin">@setCold</span>(<span class="tok-null">true</span>);</span>
<span class="line" id="L360"></span>
<span class="line" id="L361">    <span class="tok-kw">const</span> size = <span class="tok-number">0x1000</span>;</span>
<span class="line" id="L362">    <span class="tok-kw">const</span> trunc_msg = <span class="tok-str">&quot;(msg truncated)&quot;</span>;</span>
<span class="line" id="L363">    <span class="tok-kw">var</span> buf: [size + trunc_msg.len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L364">    <span class="tok-comment">// a minor annoyance with this is that it will result in the NoSpaceLeft</span>
</span>
<span class="line" id="L365">    <span class="tok-comment">// error being part of the @panic stack trace (but that error should</span>
</span>
<span class="line" id="L366">    <span class="tok-comment">// only happen rarely)</span>
</span>
<span class="line" id="L367">    <span class="tok-kw">const</span> msg = std.fmt.bufPrint(buf[<span class="tok-number">0</span>..size], format, args) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L368">        <span class="tok-kw">error</span>.NoSpaceLeft =&gt; blk: {</span>
<span class="line" id="L369">            <span class="tok-builtin">@memcpy</span>(buf[size..], trunc_msg);</span>
<span class="line" id="L370">            <span class="tok-kw">break</span> :blk &amp;buf;</span>
<span class="line" id="L371">        },</span>
<span class="line" id="L372">    };</span>
<span class="line" id="L373">    std.builtin.panic(msg, trace, ret_addr);</span>
<span class="line" id="L374">}</span>
<span class="line" id="L375"></span>
<span class="line" id="L376"><span class="tok-comment">/// Non-zero whenever the program triggered a panic.</span></span>
<span class="line" id="L377"><span class="tok-comment">/// The counter is incremented/decremented atomically.</span></span>
<span class="line" id="L378"><span class="tok-kw">var</span> panicking = std.atomic.Atomic(<span class="tok-type">u8</span>).init(<span class="tok-number">0</span>);</span>
<span class="line" id="L379"></span>
<span class="line" id="L380"><span class="tok-comment">// Locked to avoid interleaving panic messages from multiple threads.</span>
</span>
<span class="line" id="L381"><span class="tok-kw">var</span> panic_mutex = std.Thread.Mutex{};</span>
<span class="line" id="L382"></span>
<span class="line" id="L383"><span class="tok-comment">/// Counts how many times the panic handler is invoked by this thread.</span></span>
<span class="line" id="L384"><span class="tok-comment">/// This is used to catch and handle panics triggered by the panic handler.</span></span>
<span class="line" id="L385"><span class="tok-kw">threadlocal</span> <span class="tok-kw">var</span> panic_stage: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L386"></span>
<span class="line" id="L387"><span class="tok-comment">// `panicImpl` could be useful in implementing a custom panic handler which</span>
</span>
<span class="line" id="L388"><span class="tok-comment">// calls the default handler (on supported platforms)</span>
</span>
<span class="line" id="L389"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">panicImpl</span>(trace: ?*<span class="tok-kw">const</span> std.builtin.StackTrace, first_trace_addr: ?<span class="tok-type">usize</span>, msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">noreturn</span> {</span>
<span class="line" id="L390">    <span class="tok-builtin">@setCold</span>(<span class="tok-null">true</span>);</span>
<span class="line" id="L391"></span>
<span class="line" id="L392">    <span class="tok-kw">if</span> (enable_segfault_handler) {</span>
<span class="line" id="L393">        <span class="tok-comment">// If a segfault happens while panicking, we want it to actually segfault, not trigger</span>
</span>
<span class="line" id="L394">        <span class="tok-comment">// the handler.</span>
</span>
<span class="line" id="L395">        resetSegfaultHandler();</span>
<span class="line" id="L396">    }</span>
<span class="line" id="L397"></span>
<span class="line" id="L398">    <span class="tok-comment">// Note there is similar logic in handleSegfaultPosix and handleSegfaultWindowsExtra.</span>
</span>
<span class="line" id="L399">    <span class="tok-kw">nosuspend</span> <span class="tok-kw">switch</span> (panic_stage) {</span>
<span class="line" id="L400">        <span class="tok-number">0</span> =&gt; {</span>
<span class="line" id="L401">            panic_stage = <span class="tok-number">1</span>;</span>
<span class="line" id="L402"></span>
<span class="line" id="L403">            _ = panicking.fetchAdd(<span class="tok-number">1</span>, .SeqCst);</span>
<span class="line" id="L404"></span>
<span class="line" id="L405">            <span class="tok-comment">// Make sure to release the mutex when done</span>
</span>
<span class="line" id="L406">            {</span>
<span class="line" id="L407">                panic_mutex.lock();</span>
<span class="line" id="L408">                <span class="tok-kw">defer</span> panic_mutex.unlock();</span>
<span class="line" id="L409"></span>
<span class="line" id="L410">                <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L411">                <span class="tok-kw">if</span> (builtin.single_threaded) {</span>
<span class="line" id="L412">                    stderr.print(<span class="tok-str">&quot;panic: &quot;</span>, .{}) <span class="tok-kw">catch</span> os.abort();</span>
<span class="line" id="L413">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L414">                    <span class="tok-kw">const</span> current_thread_id = std.Thread.getCurrentId();</span>
<span class="line" id="L415">                    stderr.print(<span class="tok-str">&quot;thread {} panic: &quot;</span>, .{current_thread_id}) <span class="tok-kw">catch</span> os.abort();</span>
<span class="line" id="L416">                }</span>
<span class="line" id="L417">                stderr.print(<span class="tok-str">&quot;{s}\n&quot;</span>, .{msg}) <span class="tok-kw">catch</span> os.abort();</span>
<span class="line" id="L418">                <span class="tok-kw">if</span> (trace) |t| {</span>
<span class="line" id="L419">                    dumpStackTrace(t.*);</span>
<span class="line" id="L420">                }</span>
<span class="line" id="L421">                dumpCurrentStackTrace(first_trace_addr);</span>
<span class="line" id="L422">            }</span>
<span class="line" id="L423"></span>
<span class="line" id="L424">            waitForOtherThreadToFinishPanicking();</span>
<span class="line" id="L425">        },</span>
<span class="line" id="L426">        <span class="tok-number">1</span> =&gt; {</span>
<span class="line" id="L427">            panic_stage = <span class="tok-number">2</span>;</span>
<span class="line" id="L428"></span>
<span class="line" id="L429">            <span class="tok-comment">// A panic happened while trying to print a previous panic message,</span>
</span>
<span class="line" id="L430">            <span class="tok-comment">// we're still holding the mutex but that's fine as we're going to</span>
</span>
<span class="line" id="L431">            <span class="tok-comment">// call abort()</span>
</span>
<span class="line" id="L432">            <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L433">            stderr.print(<span class="tok-str">&quot;Panicked during a panic. Aborting.\n&quot;</span>, .{}) <span class="tok-kw">catch</span> os.abort();</span>
<span class="line" id="L434">        },</span>
<span class="line" id="L435">        <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L436">            <span class="tok-comment">// Panicked while printing &quot;Panicked during a panic.&quot;</span>
</span>
<span class="line" id="L437">        },</span>
<span class="line" id="L438">    };</span>
<span class="line" id="L439"></span>
<span class="line" id="L440">    os.abort();</span>
<span class="line" id="L441">}</span>
<span class="line" id="L442"></span>
<span class="line" id="L443"><span class="tok-comment">/// Must be called only after adding 1 to `panicking`. There are three callsites.</span></span>
<span class="line" id="L444"><span class="tok-kw">fn</span> <span class="tok-fn">waitForOtherThreadToFinishPanicking</span>() <span class="tok-type">void</span> {</span>
<span class="line" id="L445">    <span class="tok-kw">if</span> (panicking.fetchSub(<span class="tok-number">1</span>, .SeqCst) != <span class="tok-number">1</span>) {</span>
<span class="line" id="L446">        <span class="tok-comment">// Another thread is panicking, wait for the last one to finish</span>
</span>
<span class="line" id="L447">        <span class="tok-comment">// and call abort()</span>
</span>
<span class="line" id="L448">        <span class="tok-kw">if</span> (builtin.single_threaded) <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L449"></span>
<span class="line" id="L450">        <span class="tok-comment">// Sleep forever without hammering the CPU</span>
</span>
<span class="line" id="L451">        <span class="tok-kw">var</span> futex = std.atomic.Atomic(<span class="tok-type">u32</span>).init(<span class="tok-number">0</span>);</span>
<span class="line" id="L452">        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) std.Thread.Futex.wait(&amp;futex, <span class="tok-number">0</span>);</span>
<span class="line" id="L453">        <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L454">    }</span>
<span class="line" id="L455">}</span>
<span class="line" id="L456"></span>
<span class="line" id="L457"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeStackTrace</span>(</span>
<span class="line" id="L458">    stack_trace: std.builtin.StackTrace,</span>
<span class="line" id="L459">    out_stream: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L460">    allocator: mem.Allocator,</span>
<span class="line" id="L461">    debug_info: *DebugInfo,</span>
<span class="line" id="L462">    tty_config: io.tty.Config,</span>
<span class="line" id="L463">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L464">    _ = allocator;</span>
<span class="line" id="L465">    <span class="tok-kw">if</span> (builtin.strip_debug_info) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L466">    <span class="tok-kw">var</span> frame_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L467">    <span class="tok-kw">var</span> frames_left: <span class="tok-type">usize</span> = <span class="tok-builtin">@min</span>(stack_trace.index, stack_trace.instruction_addresses.len);</span>
<span class="line" id="L468"></span>
<span class="line" id="L469">    <span class="tok-kw">while</span> (frames_left != <span class="tok-number">0</span>) : ({</span>
<span class="line" id="L470">        frames_left -= <span class="tok-number">1</span>;</span>
<span class="line" id="L471">        frame_index = (frame_index + <span class="tok-number">1</span>) % stack_trace.instruction_addresses.len;</span>
<span class="line" id="L472">    }) {</span>
<span class="line" id="L473">        <span class="tok-kw">const</span> return_address = stack_trace.instruction_addresses[frame_index];</span>
<span class="line" id="L474">        <span class="tok-kw">try</span> printSourceAtAddress(debug_info, out_stream, return_address - <span class="tok-number">1</span>, tty_config);</span>
<span class="line" id="L475">    }</span>
<span class="line" id="L476"></span>
<span class="line" id="L477">    <span class="tok-kw">if</span> (stack_trace.index &gt; stack_trace.instruction_addresses.len) {</span>
<span class="line" id="L478">        <span class="tok-kw">const</span> dropped_frames = stack_trace.index - stack_trace.instruction_addresses.len;</span>
<span class="line" id="L479"></span>
<span class="line" id="L480">        tty_config.setColor(out_stream, .bold) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L481">        <span class="tok-kw">try</span> out_stream.print(<span class="tok-str">&quot;({d} additional stack frames skipped...)\n&quot;</span>, .{dropped_frames});</span>
<span class="line" id="L482">        tty_config.setColor(out_stream, .reset) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L483">    }</span>
<span class="line" id="L484">}</span>
<span class="line" id="L485"></span>
<span class="line" id="L486"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> UnwindError = <span class="tok-kw">if</span> (have_ucontext)</span>
<span class="line" id="L487">    <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(StackIterator.next_unwind)).Fn.return_type.?).ErrorUnion.error_set</span>
<span class="line" id="L488"><span class="tok-kw">else</span></span>
<span class="line" id="L489">    <span class="tok-type">void</span>;</span>
<span class="line" id="L490"></span>
<span class="line" id="L491"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> StackIterator = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L492">    <span class="tok-comment">// Skip every frame before this address is found.</span>
</span>
<span class="line" id="L493">    first_address: ?<span class="tok-type">usize</span>,</span>
<span class="line" id="L494">    <span class="tok-comment">// Last known value of the frame pointer register.</span>
</span>
<span class="line" id="L495">    fp: <span class="tok-type">usize</span>,</span>
<span class="line" id="L496"></span>
<span class="line" id="L497">    <span class="tok-comment">// When DebugInfo and a register context is available, this iterator can unwind</span>
</span>
<span class="line" id="L498">    <span class="tok-comment">// stacks with frames that don't use a frame pointer (ie. -fomit-frame-pointer),</span>
</span>
<span class="line" id="L499">    <span class="tok-comment">// using DWARF and MachO unwind info.</span>
</span>
<span class="line" id="L500">    unwind_state: <span class="tok-kw">if</span> (have_ucontext) ?<span class="tok-kw">struct</span> {</span>
<span class="line" id="L501">        debug_info: *DebugInfo,</span>
<span class="line" id="L502">        dwarf_context: DW.UnwindContext,</span>
<span class="line" id="L503">        last_error: ?UnwindError = <span class="tok-null">null</span>,</span>
<span class="line" id="L504">        failed: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L505">    } <span class="tok-kw">else</span> <span class="tok-type">void</span> = <span class="tok-kw">if</span> (have_ucontext) <span class="tok-null">null</span> <span class="tok-kw">else</span> {},</span>
<span class="line" id="L506"></span>
<span class="line" id="L507">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(first_address: ?<span class="tok-type">usize</span>, fp: ?<span class="tok-type">usize</span>) StackIterator {</span>
<span class="line" id="L508">        <span class="tok-kw">if</span> (native_arch == .sparc64) {</span>
<span class="line" id="L509">            <span class="tok-comment">// Flush all the register windows on stack.</span>
</span>
<span class="line" id="L510">            <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (</span>
<span class="line" id="L511">                <span class="tok-str">\\ flushw</span></span>

<span class="line" id="L512">                ::: <span class="tok-str">&quot;memory&quot;</span>);</span>
<span class="line" id="L513">        }</span>
<span class="line" id="L514"></span>
<span class="line" id="L515">        <span class="tok-kw">return</span> StackIterator{</span>
<span class="line" id="L516">            .first_address = first_address,</span>
<span class="line" id="L517">            <span class="tok-comment">// TODO: this is a workaround for #16876</span>
</span>
<span class="line" id="L518">            <span class="tok-comment">//.fp = fp orelse @frameAddress(),</span>
</span>
<span class="line" id="L519">            .fp = fp <span class="tok-kw">orelse</span> blk: {</span>
<span class="line" id="L520">                <span class="tok-kw">const</span> fa = <span class="tok-builtin">@frameAddress</span>();</span>
<span class="line" id="L521">                <span class="tok-kw">break</span> :blk fa;</span>
<span class="line" id="L522">            },</span>
<span class="line" id="L523">        };</span>
<span class="line" id="L524">    }</span>
<span class="line" id="L525"></span>
<span class="line" id="L526">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initWithContext</span>(first_address: ?<span class="tok-type">usize</span>, debug_info: *DebugInfo, context: *<span class="tok-kw">const</span> os.ucontext_t) !StackIterator {</span>
<span class="line" id="L527">        <span class="tok-comment">// The implementation of DWARF unwinding on aarch64-macos is not complete. However, Apple mandates that</span>
</span>
<span class="line" id="L528">        <span class="tok-comment">// the frame pointer register is always used, so on this platform we can safely use the FP-based unwinder.</span>
</span>
<span class="line" id="L529">        <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> builtin.target.isDarwin() <span class="tok-kw">and</span> native_arch == .aarch64) {</span>
<span class="line" id="L530">            <span class="tok-kw">return</span> init(first_address, context.mcontext.ss.fp);</span>
<span class="line" id="L531">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L532">            <span class="tok-kw">var</span> iterator = init(first_address, <span class="tok-null">null</span>);</span>
<span class="line" id="L533">            iterator.unwind_state = .{</span>
<span class="line" id="L534">                .debug_info = debug_info,</span>
<span class="line" id="L535">                .dwarf_context = <span class="tok-kw">try</span> DW.UnwindContext.init(debug_info.allocator, context, &amp;isValidMemory),</span>
<span class="line" id="L536">            };</span>
<span class="line" id="L537"></span>
<span class="line" id="L538">            <span class="tok-kw">return</span> iterator;</span>
<span class="line" id="L539">        }</span>
<span class="line" id="L540">    }</span>
<span class="line" id="L541"></span>
<span class="line" id="L542">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *StackIterator) <span class="tok-type">void</span> {</span>
<span class="line" id="L543">        <span class="tok-kw">if</span> (have_ucontext <span class="tok-kw">and</span> self.unwind_state != <span class="tok-null">null</span>) self.unwind_state.?.dwarf_context.deinit();</span>
<span class="line" id="L544">    }</span>
<span class="line" id="L545"></span>
<span class="line" id="L546">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLastError</span>(self: *StackIterator) ?<span class="tok-kw">struct</span> {</span>
<span class="line" id="L547">        err: UnwindError,</span>
<span class="line" id="L548">        address: <span class="tok-type">usize</span>,</span>
<span class="line" id="L549">    } {</span>
<span class="line" id="L550">        <span class="tok-kw">if</span> (!have_ucontext) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L551">        <span class="tok-kw">if</span> (self.unwind_state) |*unwind_state| {</span>
<span class="line" id="L552">            <span class="tok-kw">if</span> (unwind_state.last_error) |err| {</span>
<span class="line" id="L553">                unwind_state.last_error = <span class="tok-null">null</span>;</span>
<span class="line" id="L554">                <span class="tok-kw">return</span> .{</span>
<span class="line" id="L555">                    .err = err,</span>
<span class="line" id="L556">                    .address = unwind_state.dwarf_context.pc,</span>
<span class="line" id="L557">                };</span>
<span class="line" id="L558">            }</span>
<span class="line" id="L559">        }</span>
<span class="line" id="L560"></span>
<span class="line" id="L561">        <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L562">    }</span>
<span class="line" id="L563"></span>
<span class="line" id="L564">    <span class="tok-comment">// Offset of the saved BP wrt the frame pointer.</span>
</span>
<span class="line" id="L565">    <span class="tok-kw">const</span> fp_offset = <span class="tok-kw">if</span> (native_arch.isRISCV())</span>
<span class="line" id="L566">        <span class="tok-comment">// On RISC-V the frame pointer points to the top of the saved register</span>
</span>
<span class="line" id="L567">        <span class="tok-comment">// area, on pretty much every other architecture it points to the stack</span>
</span>
<span class="line" id="L568">        <span class="tok-comment">// slot where the previous frame pointer is saved.</span>
</span>
<span class="line" id="L569">        <span class="tok-number">2</span> * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)</span>
<span class="line" id="L570">    <span class="tok-kw">else</span> <span class="tok-kw">if</span> (native_arch.isSPARC())</span>
<span class="line" id="L571">        <span class="tok-comment">// On SPARC the previous frame pointer is stored at 14 slots past %fp+BIAS.</span>
</span>
<span class="line" id="L572">        <span class="tok-number">14</span> * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)</span>
<span class="line" id="L573">    <span class="tok-kw">else</span></span>
<span class="line" id="L574">        <span class="tok-number">0</span>;</span>
<span class="line" id="L575"></span>
<span class="line" id="L576">    <span class="tok-kw">const</span> fp_bias = <span class="tok-kw">if</span> (native_arch.isSPARC())</span>
<span class="line" id="L577">        <span class="tok-comment">// On SPARC frame pointers are biased by a constant.</span>
</span>
<span class="line" id="L578">        <span class="tok-number">2047</span></span>
<span class="line" id="L579">    <span class="tok-kw">else</span></span>
<span class="line" id="L580">        <span class="tok-number">0</span>;</span>
<span class="line" id="L581"></span>
<span class="line" id="L582">    <span class="tok-comment">// Positive offset of the saved PC wrt the frame pointer.</span>
</span>
<span class="line" id="L583">    <span class="tok-kw">const</span> pc_offset = <span class="tok-kw">if</span> (native_arch == .powerpc64le)</span>
<span class="line" id="L584">        <span class="tok-number">2</span> * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)</span>
<span class="line" id="L585">    <span class="tok-kw">else</span></span>
<span class="line" id="L586">        <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);</span>
<span class="line" id="L587"></span>
<span class="line" id="L588">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *StackIterator) ?<span class="tok-type">usize</span> {</span>
<span class="line" id="L589">        <span class="tok-kw">var</span> address = self.next_internal() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L590"></span>
<span class="line" id="L591">        <span class="tok-kw">if</span> (self.first_address) |first_address| {</span>
<span class="line" id="L592">            <span class="tok-kw">while</span> (address != first_address) {</span>
<span class="line" id="L593">                address = self.next_internal() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L594">            }</span>
<span class="line" id="L595">            self.first_address = <span class="tok-null">null</span>;</span>
<span class="line" id="L596">        }</span>
<span class="line" id="L597"></span>
<span class="line" id="L598">        <span class="tok-kw">return</span> address;</span>
<span class="line" id="L599">    }</span>
<span class="line" id="L600"></span>
<span class="line" id="L601">    <span class="tok-kw">fn</span> <span class="tok-fn">isValidMemory</span>(address: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L602">        <span class="tok-comment">// We are unable to determine validity of memory for freestanding targets</span>
</span>
<span class="line" id="L603">        <span class="tok-kw">if</span> (native_os == .freestanding) <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L604"></span>
<span class="line" id="L605">        <span class="tok-kw">const</span> aligned_address = address &amp; ~<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>((mem.page_size - <span class="tok-number">1</span>)));</span>
<span class="line" id="L606">        <span class="tok-kw">if</span> (aligned_address == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L607">        <span class="tok-kw">const</span> aligned_memory = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">align</span>(mem.page_size) <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(aligned_address))[<span class="tok-number">0</span>..mem.page_size];</span>
<span class="line" id="L608"></span>
<span class="line" id="L609">        <span class="tok-kw">if</span> (native_os != .windows) {</span>
<span class="line" id="L610">            <span class="tok-kw">if</span> (native_os != .wasi) {</span>
<span class="line" id="L611">                os.msync(aligned_memory, os.MSF.ASYNC) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L612">                    <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L613">                        os.MSyncError.UnmappedMemory =&gt; {</span>
<span class="line" id="L614">                            <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L615">                        },</span>
<span class="line" id="L616">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L617">                    }</span>
<span class="line" id="L618">                };</span>
<span class="line" id="L619">            }</span>
<span class="line" id="L620"></span>
<span class="line" id="L621">            <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L622">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L623">            <span class="tok-kw">const</span> w = os.windows;</span>
<span class="line" id="L624">            <span class="tok-kw">var</span> memory_info: w.MEMORY_BASIC_INFORMATION = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L625"></span>
<span class="line" id="L626">            <span class="tok-comment">// The only error this function can throw is ERROR_INVALID_PARAMETER.</span>
</span>
<span class="line" id="L627">            <span class="tok-comment">// supply an address that invalid i'll be thrown.</span>
</span>
<span class="line" id="L628">            <span class="tok-kw">const</span> rc = w.VirtualQuery(aligned_memory, &amp;memory_info, aligned_memory.len) <span class="tok-kw">catch</span> {</span>
<span class="line" id="L629">                <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L630">            };</span>
<span class="line" id="L631"></span>
<span class="line" id="L632">            <span class="tok-comment">// Result code has to be bigger than zero (number of bytes written)</span>
</span>
<span class="line" id="L633">            <span class="tok-kw">if</span> (rc == <span class="tok-number">0</span>) {</span>
<span class="line" id="L634">                <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L635">            }</span>
<span class="line" id="L636"></span>
<span class="line" id="L637">            <span class="tok-comment">// Free pages cannot be read, they are unmapped</span>
</span>
<span class="line" id="L638">            <span class="tok-kw">if</span> (memory_info.State == w.MEM_FREE) {</span>
<span class="line" id="L639">                <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L640">            }</span>
<span class="line" id="L641"></span>
<span class="line" id="L642">            <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L643">        }</span>
<span class="line" id="L644">    }</span>
<span class="line" id="L645"></span>
<span class="line" id="L646">    <span class="tok-kw">fn</span> <span class="tok-fn">next_unwind</span>(self: *StackIterator) !<span class="tok-type">usize</span> {</span>
<span class="line" id="L647">        <span class="tok-kw">const</span> unwind_state = &amp;self.unwind_state.?;</span>
<span class="line" id="L648">        <span class="tok-kw">const</span> module = <span class="tok-kw">try</span> unwind_state.debug_info.getModuleForAddress(unwind_state.dwarf_context.pc);</span>
<span class="line" id="L649">        <span class="tok-kw">switch</span> (native_os) {</span>
<span class="line" id="L650">            .macos, .ios, .watchos, .tvos =&gt; {</span>
<span class="line" id="L651">                <span class="tok-comment">// __unwind_info is a requirement for unwinding on Darwin. It may fall back to DWARF, but unwinding</span>
</span>
<span class="line" id="L652">                <span class="tok-comment">// via DWARF before attempting to use the compact unwind info will produce incorrect results.</span>
</span>
<span class="line" id="L653">                <span class="tok-kw">if</span> (module.unwind_info) |unwind_info| {</span>
<span class="line" id="L654">                    <span class="tok-kw">if</span> (DW.unwindFrameMachO(&amp;unwind_state.dwarf_context, unwind_info, module.eh_frame, module.base_address)) |return_address| {</span>
<span class="line" id="L655">                        <span class="tok-kw">return</span> return_address;</span>
<span class="line" id="L656">                    } <span class="tok-kw">else</span> |err| {</span>
<span class="line" id="L657">                        <span class="tok-kw">if</span> (err != <span class="tok-kw">error</span>.RequiresDWARFUnwind) <span class="tok-kw">return</span> err;</span>
<span class="line" id="L658">                    }</span>
<span class="line" id="L659">                } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingUnwindInfo;</span>
<span class="line" id="L660">            },</span>
<span class="line" id="L661">            <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L662">        }</span>
<span class="line" id="L663"></span>
<span class="line" id="L664">        <span class="tok-kw">if</span> (<span class="tok-kw">try</span> module.getDwarfInfoForAddress(unwind_state.debug_info.allocator, unwind_state.dwarf_context.pc)) |di| {</span>
<span class="line" id="L665">            <span class="tok-kw">return</span> di.unwindFrame(&amp;unwind_state.dwarf_context, <span class="tok-null">null</span>);</span>
<span class="line" id="L666">        } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L667">    }</span>
<span class="line" id="L668"></span>
<span class="line" id="L669">    <span class="tok-kw">fn</span> <span class="tok-fn">next_internal</span>(self: *StackIterator) ?<span class="tok-type">usize</span> {</span>
<span class="line" id="L670">        <span class="tok-kw">if</span> (have_ucontext) {</span>
<span class="line" id="L671">            <span class="tok-kw">if</span> (self.unwind_state) |*unwind_state| {</span>
<span class="line" id="L672">                <span class="tok-kw">if</span> (!unwind_state.failed) {</span>
<span class="line" id="L673">                    <span class="tok-kw">if</span> (unwind_state.dwarf_context.pc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L674">                    <span class="tok-kw">defer</span> self.fp = unwind_state.dwarf_context.getFp() <span class="tok-kw">catch</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L675">                    <span class="tok-kw">if</span> (self.next_unwind()) |return_address| {</span>
<span class="line" id="L676">                        <span class="tok-kw">return</span> return_address;</span>
<span class="line" id="L677">                    } <span class="tok-kw">else</span> |err| {</span>
<span class="line" id="L678">                        unwind_state.last_error = err;</span>
<span class="line" id="L679">                        unwind_state.failed = <span class="tok-null">true</span>;</span>
<span class="line" id="L680"></span>
<span class="line" id="L681">                        <span class="tok-comment">// Fall back to fp-based unwinding on the first failure.</span>
</span>
<span class="line" id="L682">                        <span class="tok-comment">// We can't attempt it again for other modules higher in the</span>
</span>
<span class="line" id="L683">                        <span class="tok-comment">// stack because the full register state won't have been unwound.</span>
</span>
<span class="line" id="L684">                    }</span>
<span class="line" id="L685">                }</span>
<span class="line" id="L686">            }</span>
<span class="line" id="L687">        }</span>
<span class="line" id="L688"></span>
<span class="line" id="L689">        <span class="tok-kw">const</span> fp = <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> native_arch.isSPARC())</span>
<span class="line" id="L690">            <span class="tok-comment">// On SPARC the offset is positive. (!)</span>
</span>
<span class="line" id="L691">            math.add(<span class="tok-type">usize</span>, self.fp, fp_offset) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">null</span></span>
<span class="line" id="L692">        <span class="tok-kw">else</span></span>
<span class="line" id="L693">            math.sub(<span class="tok-type">usize</span>, self.fp, fp_offset) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L694"></span>
<span class="line" id="L695">        <span class="tok-comment">// Sanity check.</span>
</span>
<span class="line" id="L696">        <span class="tok-kw">if</span> (fp == <span class="tok-number">0</span> <span class="tok-kw">or</span> !mem.isAligned(fp, <span class="tok-builtin">@alignOf</span>(<span class="tok-type">usize</span>)) <span class="tok-kw">or</span> !isValidMemory(fp))</span>
<span class="line" id="L697">            <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L698"></span>
<span class="line" id="L699">        <span class="tok-kw">const</span> new_fp = math.add(<span class="tok-type">usize</span>, <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(fp)).*, fp_bias) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L700"></span>
<span class="line" id="L701">        <span class="tok-comment">// Sanity check: the stack grows down thus all the parent frames must be</span>
</span>
<span class="line" id="L702">        <span class="tok-comment">// be at addresses that are greater (or equal) than the previous one.</span>
</span>
<span class="line" id="L703">        <span class="tok-comment">// A zero frame pointer often signals this is the last frame, that case</span>
</span>
<span class="line" id="L704">        <span class="tok-comment">// is gracefully handled by the next call to next_internal.</span>
</span>
<span class="line" id="L705">        <span class="tok-kw">if</span> (new_fp != <span class="tok-number">0</span> <span class="tok-kw">and</span> new_fp &lt; self.fp)</span>
<span class="line" id="L706">            <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L707"></span>
<span class="line" id="L708">        <span class="tok-kw">const</span> new_pc = <span class="tok-builtin">@as</span>(</span>
<span class="line" id="L709">            *<span class="tok-kw">const</span> <span class="tok-type">usize</span>,</span>
<span class="line" id="L710">            <span class="tok-builtin">@ptrFromInt</span>(math.add(<span class="tok-type">usize</span>, fp, pc_offset) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>),</span>
<span class="line" id="L711">        ).*;</span>
<span class="line" id="L712"></span>
<span class="line" id="L713">        self.fp = new_fp;</span>
<span class="line" id="L714"></span>
<span class="line" id="L715">        <span class="tok-kw">return</span> new_pc;</span>
<span class="line" id="L716">    }</span>
<span class="line" id="L717">};</span>
<span class="line" id="L718"></span>
<span class="line" id="L719"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeCurrentStackTrace</span>(</span>
<span class="line" id="L720">    out_stream: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L721">    debug_info: *DebugInfo,</span>
<span class="line" id="L722">    tty_config: io.tty.Config,</span>
<span class="line" id="L723">    start_addr: ?<span class="tok-type">usize</span>,</span>
<span class="line" id="L724">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L725">    <span class="tok-kw">var</span> context: ThreadContext = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L726">    <span class="tok-kw">const</span> has_context = getContext(&amp;context);</span>
<span class="line" id="L727">    <span class="tok-kw">if</span> (native_os == .windows) {</span>
<span class="line" id="L728">        <span class="tok-kw">return</span> writeStackTraceWindows(out_stream, debug_info, tty_config, &amp;context, start_addr);</span>
<span class="line" id="L729">    }</span>
<span class="line" id="L730"></span>
<span class="line" id="L731">    <span class="tok-kw">var</span> it = (<span class="tok-kw">if</span> (has_context) blk: {</span>
<span class="line" id="L732">        <span class="tok-kw">break</span> :blk StackIterator.initWithContext(start_addr, debug_info, &amp;context) <span class="tok-kw">catch</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L733">    } <span class="tok-kw">else</span> <span class="tok-null">null</span>) <span class="tok-kw">orelse</span> StackIterator.init(start_addr, <span class="tok-null">null</span>);</span>
<span class="line" id="L734">    <span class="tok-kw">defer</span> it.deinit();</span>
<span class="line" id="L735"></span>
<span class="line" id="L736">    <span class="tok-kw">while</span> (it.next()) |return_address| {</span>
<span class="line" id="L737">        printLastUnwindError(&amp;it, debug_info, out_stream, tty_config);</span>
<span class="line" id="L738"></span>
<span class="line" id="L739">        <span class="tok-comment">// On arm64 macOS, the address of the last frame is 0x0 rather than 0x1 as on x86_64 macOS,</span>
</span>
<span class="line" id="L740">        <span class="tok-comment">// therefore, we do a check for `return_address == 0` before subtracting 1 from it to avoid</span>
</span>
<span class="line" id="L741">        <span class="tok-comment">// an overflow. We do not need to signal `StackIterator` as it will correctly detect this</span>
</span>
<span class="line" id="L742">        <span class="tok-comment">// condition on the subsequent iteration and return `null` thus terminating the loop.</span>
</span>
<span class="line" id="L743">        <span class="tok-comment">// same behaviour for x86-windows-msvc</span>
</span>
<span class="line" id="L744">        <span class="tok-kw">const</span> address = <span class="tok-kw">if</span> (return_address == <span class="tok-number">0</span>) return_address <span class="tok-kw">else</span> return_address - <span class="tok-number">1</span>;</span>
<span class="line" id="L745">        <span class="tok-kw">try</span> printSourceAtAddress(debug_info, out_stream, address, tty_config);</span>
<span class="line" id="L746">    } <span class="tok-kw">else</span> printLastUnwindError(&amp;it, debug_info, out_stream, tty_config);</span>
<span class="line" id="L747">}</span>
<span class="line" id="L748"></span>
<span class="line" id="L749"><span class="tok-kw">pub</span> <span class="tok-kw">noinline</span> <span class="tok-kw">fn</span> <span class="tok-fn">walkStackWindows</span>(addresses: []<span class="tok-type">usize</span>, existing_context: ?*<span class="tok-kw">const</span> windows.CONTEXT) <span class="tok-type">usize</span> {</span>
<span class="line" id="L750">    <span class="tok-kw">if</span> (builtin.cpu.arch == .x86) {</span>
<span class="line" id="L751">        <span class="tok-comment">// RtlVirtualUnwind doesn't exist on x86</span>
</span>
<span class="line" id="L752">        <span class="tok-kw">return</span> windows.ntdll.RtlCaptureStackBackTrace(<span class="tok-number">0</span>, addresses.len, <span class="tok-builtin">@as</span>(**<span class="tok-type">anyopaque</span>, <span class="tok-builtin">@ptrCast</span>(addresses.ptr)), <span class="tok-null">null</span>);</span>
<span class="line" id="L753">    }</span>
<span class="line" id="L754"></span>
<span class="line" id="L755">    <span class="tok-kw">const</span> tib = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> windows.NT_TIB, <span class="tok-builtin">@ptrCast</span>(&amp;windows.teb().Reserved1));</span>
<span class="line" id="L756"></span>
<span class="line" id="L757">    <span class="tok-kw">var</span> context: windows.CONTEXT = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L758">    <span class="tok-kw">if</span> (existing_context) |context_ptr| {</span>
<span class="line" id="L759">        context = context_ptr.*;</span>
<span class="line" id="L760">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L761">        context = std.mem.zeroes(windows.CONTEXT);</span>
<span class="line" id="L762">        windows.ntdll.RtlCaptureContext(&amp;context);</span>
<span class="line" id="L763">    }</span>
<span class="line" id="L764"></span>
<span class="line" id="L765">    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L766">    <span class="tok-kw">var</span> image_base: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L767">    <span class="tok-kw">var</span> history_table: windows.UNWIND_HISTORY_TABLE = std.mem.zeroes(windows.UNWIND_HISTORY_TABLE);</span>
<span class="line" id="L768"></span>
<span class="line" id="L769">    <span class="tok-kw">while</span> (i &lt; addresses.len) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L770">        <span class="tok-kw">const</span> current_regs = context.getRegs();</span>
<span class="line" id="L771">        <span class="tok-kw">if</span> (windows.ntdll.RtlLookupFunctionEntry(current_regs.ip, &amp;image_base, &amp;history_table)) |runtime_function| {</span>
<span class="line" id="L772">            <span class="tok-kw">var</span> handler_data: ?*<span class="tok-type">anyopaque</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L773">            <span class="tok-kw">var</span> establisher_frame: <span class="tok-type">u64</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L774">            _ = windows.ntdll.RtlVirtualUnwind(</span>
<span class="line" id="L775">                windows.UNW_FLAG_NHANDLER,</span>
<span class="line" id="L776">                image_base,</span>
<span class="line" id="L777">                current_regs.ip,</span>
<span class="line" id="L778">                runtime_function,</span>
<span class="line" id="L779">                &amp;context,</span>
<span class="line" id="L780">                &amp;handler_data,</span>
<span class="line" id="L781">                &amp;establisher_frame,</span>
<span class="line" id="L782">                <span class="tok-null">null</span>,</span>
<span class="line" id="L783">            );</span>
<span class="line" id="L784">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L785">            <span class="tok-comment">// leaf function</span>
</span>
<span class="line" id="L786">            context.setIp(<span class="tok-builtin">@as</span>(*<span class="tok-type">u64</span>, <span class="tok-builtin">@ptrFromInt</span>(current_regs.sp)).*);</span>
<span class="line" id="L787">            context.setSp(current_regs.sp + <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>));</span>
<span class="line" id="L788">        }</span>
<span class="line" id="L789"></span>
<span class="line" id="L790">        <span class="tok-kw">const</span> next_regs = context.getRegs();</span>
<span class="line" id="L791">        <span class="tok-kw">if</span> (next_regs.sp &lt; <span class="tok-builtin">@intFromPtr</span>(tib.StackLimit) <span class="tok-kw">or</span> next_regs.sp &gt; <span class="tok-builtin">@intFromPtr</span>(tib.StackBase)) {</span>
<span class="line" id="L792">            <span class="tok-kw">break</span>;</span>
<span class="line" id="L793">        }</span>
<span class="line" id="L794"></span>
<span class="line" id="L795">        <span class="tok-kw">if</span> (next_regs.ip == <span class="tok-number">0</span>) {</span>
<span class="line" id="L796">            <span class="tok-kw">break</span>;</span>
<span class="line" id="L797">        }</span>
<span class="line" id="L798"></span>
<span class="line" id="L799">        addresses[i] = next_regs.ip;</span>
<span class="line" id="L800">    }</span>
<span class="line" id="L801"></span>
<span class="line" id="L802">    <span class="tok-kw">return</span> i;</span>
<span class="line" id="L803">}</span>
<span class="line" id="L804"></span>
<span class="line" id="L805"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeStackTraceWindows</span>(</span>
<span class="line" id="L806">    out_stream: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L807">    debug_info: *DebugInfo,</span>
<span class="line" id="L808">    tty_config: io.tty.Config,</span>
<span class="line" id="L809">    context: *<span class="tok-kw">const</span> windows.CONTEXT,</span>
<span class="line" id="L810">    start_addr: ?<span class="tok-type">usize</span>,</span>
<span class="line" id="L811">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L812">    <span class="tok-kw">var</span> addr_buf: [<span class="tok-number">1024</span>]<span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L813">    <span class="tok-kw">const</span> n = walkStackWindows(addr_buf[<span class="tok-number">0</span>..], context);</span>
<span class="line" id="L814">    <span class="tok-kw">const</span> addrs = addr_buf[<span class="tok-number">0</span>..n];</span>
<span class="line" id="L815">    <span class="tok-kw">var</span> start_i: <span class="tok-type">usize</span> = <span class="tok-kw">if</span> (start_addr) |saddr| blk: {</span>
<span class="line" id="L816">        <span class="tok-kw">for</span> (addrs, <span class="tok-number">0</span>..) |addr, i| {</span>
<span class="line" id="L817">            <span class="tok-kw">if</span> (addr == saddr) <span class="tok-kw">break</span> :blk i;</span>
<span class="line" id="L818">        }</span>
<span class="line" id="L819">        <span class="tok-kw">return</span>;</span>
<span class="line" id="L820">    } <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L821">    <span class="tok-kw">for</span> (addrs[start_i..]) |addr| {</span>
<span class="line" id="L822">        <span class="tok-kw">try</span> printSourceAtAddress(debug_info, out_stream, addr - <span class="tok-number">1</span>, tty_config);</span>
<span class="line" id="L823">    }</span>
<span class="line" id="L824">}</span>
<span class="line" id="L825"></span>
<span class="line" id="L826"><span class="tok-kw">fn</span> <span class="tok-fn">machoSearchSymbols</span>(symbols: []<span class="tok-kw">const</span> MachoSymbol, address: <span class="tok-type">usize</span>) ?*<span class="tok-kw">const</span> MachoSymbol {</span>
<span class="line" id="L827">    <span class="tok-kw">var</span> min: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L828">    <span class="tok-kw">var</span> max: <span class="tok-type">usize</span> = symbols.len - <span class="tok-number">1</span>;</span>
<span class="line" id="L829">    <span class="tok-kw">while</span> (min &lt; max) {</span>
<span class="line" id="L830">        <span class="tok-kw">const</span> mid = min + (max - min) / <span class="tok-number">2</span>;</span>
<span class="line" id="L831">        <span class="tok-kw">const</span> curr = &amp;symbols[mid];</span>
<span class="line" id="L832">        <span class="tok-kw">const</span> next = &amp;symbols[mid + <span class="tok-number">1</span>];</span>
<span class="line" id="L833">        <span class="tok-kw">if</span> (address &gt;= next.address()) {</span>
<span class="line" id="L834">            min = mid + <span class="tok-number">1</span>;</span>
<span class="line" id="L835">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (address &lt; curr.address()) {</span>
<span class="line" id="L836">            max = mid;</span>
<span class="line" id="L837">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L838">            <span class="tok-kw">return</span> curr;</span>
<span class="line" id="L839">        }</span>
<span class="line" id="L840">    }</span>
<span class="line" id="L841"></span>
<span class="line" id="L842">    <span class="tok-kw">const</span> max_sym = &amp;symbols[symbols.len - <span class="tok-number">1</span>];</span>
<span class="line" id="L843">    <span class="tok-kw">if</span> (address &gt;= max_sym.address())</span>
<span class="line" id="L844">        <span class="tok-kw">return</span> max_sym;</span>
<span class="line" id="L845"></span>
<span class="line" id="L846">    <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L847">}</span>
<span class="line" id="L848"></span>
<span class="line" id="L849"><span class="tok-kw">test</span> <span class="tok-str">&quot;machoSearchSymbols&quot;</span> {</span>
<span class="line" id="L850">    <span class="tok-kw">const</span> symbols = [_]MachoSymbol{</span>
<span class="line" id="L851">        .{ .addr = <span class="tok-number">100</span>, .strx = <span class="tok-null">undefined</span>, .size = <span class="tok-null">undefined</span>, .ofile = <span class="tok-null">undefined</span> },</span>
<span class="line" id="L852">        .{ .addr = <span class="tok-number">200</span>, .strx = <span class="tok-null">undefined</span>, .size = <span class="tok-null">undefined</span>, .ofile = <span class="tok-null">undefined</span> },</span>
<span class="line" id="L853">        .{ .addr = <span class="tok-number">300</span>, .strx = <span class="tok-null">undefined</span>, .size = <span class="tok-null">undefined</span>, .ofile = <span class="tok-null">undefined</span> },</span>
<span class="line" id="L854">    };</span>
<span class="line" id="L855"></span>
<span class="line" id="L856">    <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(?*<span class="tok-kw">const</span> MachoSymbol, <span class="tok-null">null</span>), machoSearchSymbols(&amp;symbols, <span class="tok-number">0</span>));</span>
<span class="line" id="L857">    <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(?*<span class="tok-kw">const</span> MachoSymbol, <span class="tok-null">null</span>), machoSearchSymbols(&amp;symbols, <span class="tok-number">99</span>));</span>
<span class="line" id="L858">    <span class="tok-kw">try</span> testing.expectEqual(&amp;symbols[<span class="tok-number">0</span>], machoSearchSymbols(&amp;symbols, <span class="tok-number">100</span>).?);</span>
<span class="line" id="L859">    <span class="tok-kw">try</span> testing.expectEqual(&amp;symbols[<span class="tok-number">0</span>], machoSearchSymbols(&amp;symbols, <span class="tok-number">150</span>).?);</span>
<span class="line" id="L860">    <span class="tok-kw">try</span> testing.expectEqual(&amp;symbols[<span class="tok-number">0</span>], machoSearchSymbols(&amp;symbols, <span class="tok-number">199</span>).?);</span>
<span class="line" id="L861"></span>
<span class="line" id="L862">    <span class="tok-kw">try</span> testing.expectEqual(&amp;symbols[<span class="tok-number">1</span>], machoSearchSymbols(&amp;symbols, <span class="tok-number">200</span>).?);</span>
<span class="line" id="L863">    <span class="tok-kw">try</span> testing.expectEqual(&amp;symbols[<span class="tok-number">1</span>], machoSearchSymbols(&amp;symbols, <span class="tok-number">250</span>).?);</span>
<span class="line" id="L864">    <span class="tok-kw">try</span> testing.expectEqual(&amp;symbols[<span class="tok-number">1</span>], machoSearchSymbols(&amp;symbols, <span class="tok-number">299</span>).?);</span>
<span class="line" id="L865"></span>
<span class="line" id="L866">    <span class="tok-kw">try</span> testing.expectEqual(&amp;symbols[<span class="tok-number">2</span>], machoSearchSymbols(&amp;symbols, <span class="tok-number">300</span>).?);</span>
<span class="line" id="L867">    <span class="tok-kw">try</span> testing.expectEqual(&amp;symbols[<span class="tok-number">2</span>], machoSearchSymbols(&amp;symbols, <span class="tok-number">301</span>).?);</span>
<span class="line" id="L868">    <span class="tok-kw">try</span> testing.expectEqual(&amp;symbols[<span class="tok-number">2</span>], machoSearchSymbols(&amp;symbols, <span class="tok-number">5000</span>).?);</span>
<span class="line" id="L869">}</span>
<span class="line" id="L870"></span>
<span class="line" id="L871"><span class="tok-kw">fn</span> <span class="tok-fn">printUnknownSource</span>(debug_info: *DebugInfo, out_stream: <span class="tok-kw">anytype</span>, address: <span class="tok-type">usize</span>, tty_config: io.tty.Config) !<span class="tok-type">void</span> {</span>
<span class="line" id="L872">    <span class="tok-kw">const</span> module_name = debug_info.getModuleNameForAddress(address);</span>
<span class="line" id="L873">    <span class="tok-kw">return</span> printLineInfo(</span>
<span class="line" id="L874">        out_stream,</span>
<span class="line" id="L875">        <span class="tok-null">null</span>,</span>
<span class="line" id="L876">        address,</span>
<span class="line" id="L877">        <span class="tok-str">&quot;???&quot;</span>,</span>
<span class="line" id="L878">        module_name <span class="tok-kw">orelse</span> <span class="tok-str">&quot;???&quot;</span>,</span>
<span class="line" id="L879">        tty_config,</span>
<span class="line" id="L880">        printLineFromFileAnyOs,</span>
<span class="line" id="L881">    );</span>
<span class="line" id="L882">}</span>
<span class="line" id="L883"></span>
<span class="line" id="L884"><span class="tok-kw">fn</span> <span class="tok-fn">printLastUnwindError</span>(it: *StackIterator, debug_info: *DebugInfo, out_stream: <span class="tok-kw">anytype</span>, tty_config: io.tty.Config) <span class="tok-type">void</span> {</span>
<span class="line" id="L885">    <span class="tok-kw">if</span> (!have_ucontext) <span class="tok-kw">return</span>;</span>
<span class="line" id="L886">    <span class="tok-kw">if</span> (it.getLastError()) |unwind_error| {</span>
<span class="line" id="L887">        printUnwindError(debug_info, out_stream, unwind_error.address, unwind_error.err, tty_config) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L888">    }</span>
<span class="line" id="L889">}</span>
<span class="line" id="L890"></span>
<span class="line" id="L891"><span class="tok-kw">fn</span> <span class="tok-fn">printUnwindError</span>(debug_info: *DebugInfo, out_stream: <span class="tok-kw">anytype</span>, address: <span class="tok-type">usize</span>, err: UnwindError, tty_config: io.tty.Config) !<span class="tok-type">void</span> {</span>
<span class="line" id="L892">    <span class="tok-kw">const</span> module_name = debug_info.getModuleNameForAddress(address) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;???&quot;</span>;</span>
<span class="line" id="L893">    <span class="tok-kw">try</span> tty_config.setColor(out_stream, .dim);</span>
<span class="line" id="L894">    <span class="tok-kw">if</span> (err == <span class="tok-kw">error</span>.MissingDebugInfo) {</span>
<span class="line" id="L895">        <span class="tok-kw">try</span> out_stream.print(<span class="tok-str">&quot;Unwind information for `{s}:0x{x}` was not available, trace may be incomplete\n\n&quot;</span>, .{ module_name, address });</span>
<span class="line" id="L896">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L897">        <span class="tok-kw">try</span> out_stream.print(<span class="tok-str">&quot;Unwind error at address `{s}:0x{x}` ({}), trace may be incomplete\n\n&quot;</span>, .{ module_name, address, err });</span>
<span class="line" id="L898">    }</span>
<span class="line" id="L899">    <span class="tok-kw">try</span> tty_config.setColor(out_stream, .reset);</span>
<span class="line" id="L900">}</span>
<span class="line" id="L901"></span>
<span class="line" id="L902"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">printSourceAtAddress</span>(debug_info: *DebugInfo, out_stream: <span class="tok-kw">anytype</span>, address: <span class="tok-type">usize</span>, tty_config: io.tty.Config) !<span class="tok-type">void</span> {</span>
<span class="line" id="L903">    <span class="tok-kw">const</span> module = debug_info.getModuleForAddress(address) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L904">        <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; <span class="tok-kw">return</span> printUnknownSource(debug_info, out_stream, address, tty_config),</span>
<span class="line" id="L905">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L906">    };</span>
<span class="line" id="L907"></span>
<span class="line" id="L908">    <span class="tok-kw">const</span> symbol_info = module.getSymbolAtAddress(debug_info.allocator, address) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L909">        <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; <span class="tok-kw">return</span> printUnknownSource(debug_info, out_stream, address, tty_config),</span>
<span class="line" id="L910">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L911">    };</span>
<span class="line" id="L912">    <span class="tok-kw">defer</span> symbol_info.deinit(debug_info.allocator);</span>
<span class="line" id="L913"></span>
<span class="line" id="L914">    <span class="tok-kw">return</span> printLineInfo(</span>
<span class="line" id="L915">        out_stream,</span>
<span class="line" id="L916">        symbol_info.line_info,</span>
<span class="line" id="L917">        address,</span>
<span class="line" id="L918">        symbol_info.symbol_name,</span>
<span class="line" id="L919">        symbol_info.compile_unit_name,</span>
<span class="line" id="L920">        tty_config,</span>
<span class="line" id="L921">        printLineFromFileAnyOs,</span>
<span class="line" id="L922">    );</span>
<span class="line" id="L923">}</span>
<span class="line" id="L924"></span>
<span class="line" id="L925"><span class="tok-kw">fn</span> <span class="tok-fn">printLineInfo</span>(</span>
<span class="line" id="L926">    out_stream: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L927">    line_info: ?LineInfo,</span>
<span class="line" id="L928">    address: <span class="tok-type">usize</span>,</span>
<span class="line" id="L929">    symbol_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L930">    compile_unit_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L931">    tty_config: io.tty.Config,</span>
<span class="line" id="L932">    <span class="tok-kw">comptime</span> printLineFromFile: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L933">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L934">    <span class="tok-kw">nosuspend</span> {</span>
<span class="line" id="L935">        <span class="tok-kw">try</span> tty_config.setColor(out_stream, .bold);</span>
<span class="line" id="L936"></span>
<span class="line" id="L937">        <span class="tok-kw">if</span> (line_info) |*li| {</span>
<span class="line" id="L938">            <span class="tok-kw">try</span> out_stream.print(<span class="tok-str">&quot;{s}:{d}:{d}&quot;</span>, .{ li.file_name, li.line, li.column });</span>
<span class="line" id="L939">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L940">            <span class="tok-kw">try</span> out_stream.writeAll(<span class="tok-str">&quot;???:?:?&quot;</span>);</span>
<span class="line" id="L941">        }</span>
<span class="line" id="L942"></span>
<span class="line" id="L943">        <span class="tok-kw">try</span> tty_config.setColor(out_stream, .reset);</span>
<span class="line" id="L944">        <span class="tok-kw">try</span> out_stream.writeAll(<span class="tok-str">&quot;: &quot;</span>);</span>
<span class="line" id="L945">        <span class="tok-kw">try</span> tty_config.setColor(out_stream, .dim);</span>
<span class="line" id="L946">        <span class="tok-kw">try</span> out_stream.print(<span class="tok-str">&quot;0x{x} in {s} ({s})&quot;</span>, .{ address, symbol_name, compile_unit_name });</span>
<span class="line" id="L947">        <span class="tok-kw">try</span> tty_config.setColor(out_stream, .reset);</span>
<span class="line" id="L948">        <span class="tok-kw">try</span> out_stream.writeAll(<span class="tok-str">&quot;\n&quot;</span>);</span>
<span class="line" id="L949"></span>
<span class="line" id="L950">        <span class="tok-comment">// Show the matching source code line if possible</span>
</span>
<span class="line" id="L951">        <span class="tok-kw">if</span> (line_info) |li| {</span>
<span class="line" id="L952">            <span class="tok-kw">if</span> (printLineFromFile(out_stream, li)) {</span>
<span class="line" id="L953">                <span class="tok-kw">if</span> (li.column &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L954">                    <span class="tok-comment">// The caret already takes one char</span>
</span>
<span class="line" id="L955">                    <span class="tok-kw">const</span> space_needed = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(li.column - <span class="tok-number">1</span>));</span>
<span class="line" id="L956"></span>
<span class="line" id="L957">                    <span class="tok-kw">try</span> out_stream.writeByteNTimes(<span class="tok-str">' '</span>, space_needed);</span>
<span class="line" id="L958">                    <span class="tok-kw">try</span> tty_config.setColor(out_stream, .green);</span>
<span class="line" id="L959">                    <span class="tok-kw">try</span> out_stream.writeAll(<span class="tok-str">&quot;^&quot;</span>);</span>
<span class="line" id="L960">                    <span class="tok-kw">try</span> tty_config.setColor(out_stream, .reset);</span>
<span class="line" id="L961">                }</span>
<span class="line" id="L962">                <span class="tok-kw">try</span> out_stream.writeAll(<span class="tok-str">&quot;\n&quot;</span>);</span>
<span class="line" id="L963">            } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L964">                <span class="tok-kw">error</span>.EndOfFile, <span class="tok-kw">error</span>.FileNotFound =&gt; {},</span>
<span class="line" id="L965">                <span class="tok-kw">error</span>.BadPathName =&gt; {},</span>
<span class="line" id="L966">                <span class="tok-kw">error</span>.AccessDenied =&gt; {},</span>
<span class="line" id="L967">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L968">            }</span>
<span class="line" id="L969">        }</span>
<span class="line" id="L970">    }</span>
<span class="line" id="L971">}</span>
<span class="line" id="L972"></span>
<span class="line" id="L973"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> OpenSelfDebugInfoError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L974">    MissingDebugInfo,</span>
<span class="line" id="L975">    UnsupportedOperatingSystem,</span>
<span class="line" id="L976">} || <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(DebugInfo.init)).Fn.return_type.?).ErrorUnion.error_set;</span>
<span class="line" id="L977"></span>
<span class="line" id="L978"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openSelfDebugInfo</span>(allocator: mem.Allocator) OpenSelfDebugInfoError!DebugInfo {</span>
<span class="line" id="L979">    <span class="tok-kw">nosuspend</span> {</span>
<span class="line" id="L980">        <span class="tok-kw">if</span> (builtin.strip_debug_info)</span>
<span class="line" id="L981">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L982">        <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(root, <span class="tok-str">&quot;os&quot;</span>) <span class="tok-kw">and</span> <span class="tok-builtin">@hasDecl</span>(root.os, <span class="tok-str">&quot;debug&quot;</span>) <span class="tok-kw">and</span> <span class="tok-builtin">@hasDecl</span>(root.os.debug, <span class="tok-str">&quot;openSelfDebugInfo&quot;</span>)) {</span>
<span class="line" id="L983">            <span class="tok-kw">return</span> root.os.debug.openSelfDebugInfo(allocator);</span>
<span class="line" id="L984">        }</span>
<span class="line" id="L985">        <span class="tok-kw">switch</span> (native_os) {</span>
<span class="line" id="L986">            .linux,</span>
<span class="line" id="L987">            .freebsd,</span>
<span class="line" id="L988">            .netbsd,</span>
<span class="line" id="L989">            .dragonfly,</span>
<span class="line" id="L990">            .openbsd,</span>
<span class="line" id="L991">            .macos,</span>
<span class="line" id="L992">            .solaris,</span>
<span class="line" id="L993">            .illumos,</span>
<span class="line" id="L994">            .windows,</span>
<span class="line" id="L995">            =&gt; <span class="tok-kw">return</span> <span class="tok-kw">try</span> DebugInfo.init(allocator),</span>
<span class="line" id="L996">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedOperatingSystem,</span>
<span class="line" id="L997">        }</span>
<span class="line" id="L998">    }</span>
<span class="line" id="L999">}</span>
<span class="line" id="L1000"></span>
<span class="line" id="L1001"><span class="tok-kw">fn</span> <span class="tok-fn">readCoffDebugInfo</span>(allocator: mem.Allocator, coff_obj: *coff.Coff) !ModuleDebugInfo {</span>
<span class="line" id="L1002">    <span class="tok-kw">nosuspend</span> {</span>
<span class="line" id="L1003">        <span class="tok-kw">var</span> di = ModuleDebugInfo{</span>
<span class="line" id="L1004">            .base_address = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L1005">            .coff_image_base = coff_obj.getImageBase(),</span>
<span class="line" id="L1006">            .coff_section_headers = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L1007">        };</span>
<span class="line" id="L1008"></span>
<span class="line" id="L1009">        <span class="tok-kw">if</span> (coff_obj.getSectionByName(<span class="tok-str">&quot;.debug_info&quot;</span>)) |_| {</span>
<span class="line" id="L1010">            <span class="tok-comment">// This coff file has embedded DWARF debug info</span>
</span>
<span class="line" id="L1011">            <span class="tok-kw">var</span> sections: DW.DwarfInfo.SectionArray = DW.DwarfInfo.null_section_array;</span>
<span class="line" id="L1012">            <span class="tok-kw">errdefer</span> <span class="tok-kw">for</span> (sections) |section| <span class="tok-kw">if</span> (section) |s| <span class="tok-kw">if</span> (s.owned) allocator.free(s.data);</span>
<span class="line" id="L1013"></span>
<span class="line" id="L1014">            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(DW.DwarfSection).Enum.fields, <span class="tok-number">0</span>..) |section, i| {</span>
<span class="line" id="L1015">                sections[i] = <span class="tok-kw">if</span> (coff_obj.getSectionByName(<span class="tok-str">&quot;.&quot;</span> ++ section.name)) |section_header| blk: {</span>
<span class="line" id="L1016">                    <span class="tok-kw">break</span> :blk .{</span>
<span class="line" id="L1017">                        .data = <span class="tok-kw">try</span> coff_obj.getSectionDataAlloc(section_header, allocator),</span>
<span class="line" id="L1018">                        .virtual_address = section_header.virtual_address,</span>
<span class="line" id="L1019">                        .owned = <span class="tok-null">true</span>,</span>
<span class="line" id="L1020">                    };</span>
<span class="line" id="L1021">                } <span class="tok-kw">else</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1022">            }</span>
<span class="line" id="L1023"></span>
<span class="line" id="L1024">            <span class="tok-kw">var</span> dwarf = DW.DwarfInfo{</span>
<span class="line" id="L1025">                .endian = native_endian,</span>
<span class="line" id="L1026">                .sections = sections,</span>
<span class="line" id="L1027">                .is_macho = <span class="tok-null">false</span>,</span>
<span class="line" id="L1028">            };</span>
<span class="line" id="L1029"></span>
<span class="line" id="L1030">            <span class="tok-kw">try</span> DW.openDwarfDebugInfo(&amp;dwarf, allocator);</span>
<span class="line" id="L1031">            di.dwarf = dwarf;</span>
<span class="line" id="L1032">        }</span>
<span class="line" id="L1033"></span>
<span class="line" id="L1034">        <span class="tok-kw">var</span> path_buf: [windows.MAX_PATH]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1035">        <span class="tok-kw">const</span> len = <span class="tok-kw">try</span> coff_obj.getPdbPath(path_buf[<span class="tok-number">0</span>..]) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> di;</span>
<span class="line" id="L1036">        <span class="tok-kw">const</span> raw_path = path_buf[<span class="tok-number">0</span>..len];</span>
<span class="line" id="L1037"></span>
<span class="line" id="L1038">        <span class="tok-kw">const</span> path = <span class="tok-kw">try</span> fs.path.resolve(allocator, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{raw_path});</span>
<span class="line" id="L1039">        <span class="tok-kw">defer</span> allocator.free(path);</span>
<span class="line" id="L1040"></span>
<span class="line" id="L1041">        di.pdb = pdb.Pdb.init(allocator, path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1042">            <span class="tok-kw">error</span>.FileNotFound, <span class="tok-kw">error</span>.IsDir =&gt; {</span>
<span class="line" id="L1043">                <span class="tok-kw">if</span> (di.dwarf == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1044">                <span class="tok-kw">return</span> di;</span>
<span class="line" id="L1045">            },</span>
<span class="line" id="L1046">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L1047">        };</span>
<span class="line" id="L1048">        <span class="tok-kw">try</span> di.pdb.?.parseInfoStream();</span>
<span class="line" id="L1049">        <span class="tok-kw">try</span> di.pdb.?.parseDbiStream();</span>
<span class="line" id="L1050"></span>
<span class="line" id="L1051">        <span class="tok-kw">if</span> (!mem.eql(<span class="tok-type">u8</span>, &amp;coff_obj.guid, &amp;di.pdb.?.guid) <span class="tok-kw">or</span> coff_obj.age != di.pdb.?.age)</span>
<span class="line" id="L1052">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo;</span>
<span class="line" id="L1053"></span>
<span class="line" id="L1054">        <span class="tok-comment">// Only used by the pdb path</span>
</span>
<span class="line" id="L1055">        di.coff_section_headers = <span class="tok-kw">try</span> coff_obj.getSectionHeadersAlloc(allocator);</span>
<span class="line" id="L1056">        <span class="tok-kw">errdefer</span> allocator.free(di.coff_section_headers);</span>
<span class="line" id="L1057"></span>
<span class="line" id="L1058">        <span class="tok-kw">return</span> di;</span>
<span class="line" id="L1059">    }</span>
<span class="line" id="L1060">}</span>
<span class="line" id="L1061"></span>
<span class="line" id="L1062"><span class="tok-kw">fn</span> <span class="tok-fn">chopSlice</span>(ptr: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, offset: <span class="tok-type">u64</span>, size: <span class="tok-type">u64</span>) <span class="tok-kw">error</span>{Overflow}![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1063">    <span class="tok-kw">const</span> start = math.cast(<span class="tok-type">usize</span>, offset) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;</span>
<span class="line" id="L1064">    <span class="tok-kw">const</span> end = start + (math.cast(<span class="tok-type">usize</span>, size) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow);</span>
<span class="line" id="L1065">    <span class="tok-kw">return</span> ptr[start..end];</span>
<span class="line" id="L1066">}</span>
<span class="line" id="L1067"></span>
<span class="line" id="L1068"><span class="tok-comment">/// Reads debug info from an ELF file, or the current binary if none in specified.</span></span>
<span class="line" id="L1069"><span class="tok-comment">/// If the required sections aren't present but a reference to external debug info is,</span></span>
<span class="line" id="L1070"><span class="tok-comment">/// then this this function will recurse to attempt to load the debug sections from</span></span>
<span class="line" id="L1071"><span class="tok-comment">/// an external file.</span></span>
<span class="line" id="L1072"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readElfDebugInfo</span>(</span>
<span class="line" id="L1073">    allocator: mem.Allocator,</span>
<span class="line" id="L1074">    elf_filename: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1075">    build_id: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1076">    expected_crc: ?<span class="tok-type">u32</span>,</span>
<span class="line" id="L1077">    parent_sections: *DW.DwarfInfo.SectionArray,</span>
<span class="line" id="L1078">    parent_mapped_mem: ?[]<span class="tok-kw">align</span>(mem.page_size) <span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1079">) !ModuleDebugInfo {</span>
<span class="line" id="L1080">    <span class="tok-kw">nosuspend</span> {</span>
<span class="line" id="L1081"></span>
<span class="line" id="L1082">        <span class="tok-comment">// TODO https://github.com/ziglang/zig/issues/5525</span>
</span>
<span class="line" id="L1083">        <span class="tok-kw">const</span> elf_file = (<span class="tok-kw">if</span> (elf_filename) |filename| blk: {</span>
<span class="line" id="L1084">            <span class="tok-kw">break</span> :blk <span class="tok-kw">if</span> (fs.path.isAbsolute(filename))</span>
<span class="line" id="L1085">                fs.openFileAbsolute(filename, .{ .intended_io_mode = .blocking })</span>
<span class="line" id="L1086">            <span class="tok-kw">else</span></span>
<span class="line" id="L1087">                fs.cwd().openFile(filename, .{ .intended_io_mode = .blocking });</span>
<span class="line" id="L1088">        } <span class="tok-kw">else</span> fs.openSelfExe(.{ .intended_io_mode = .blocking })) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1089">            <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo,</span>
<span class="line" id="L1090">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L1091">        };</span>
<span class="line" id="L1092"></span>
<span class="line" id="L1093">        <span class="tok-kw">const</span> mapped_mem = <span class="tok-kw">try</span> mapWholeFile(elf_file);</span>
<span class="line" id="L1094">        <span class="tok-kw">if</span> (expected_crc) |crc| <span class="tok-kw">if</span> (crc != std.hash.crc.Crc32SmallWithPoly(.IEEE).hash(mapped_mem)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo;</span>
<span class="line" id="L1095"></span>
<span class="line" id="L1096">        <span class="tok-kw">const</span> hdr: *<span class="tok-kw">const</span> elf.Ehdr = <span class="tok-builtin">@ptrCast</span>(&amp;mapped_mem[<span class="tok-number">0</span>]);</span>
<span class="line" id="L1097">        <span class="tok-kw">if</span> (!mem.eql(<span class="tok-type">u8</span>, hdr.e_ident[<span class="tok-number">0</span>..<span class="tok-number">4</span>], elf.MAGIC)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfMagic;</span>
<span class="line" id="L1098">        <span class="tok-kw">if</span> (hdr.e_ident[elf.EI_VERSION] != <span class="tok-number">1</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfVersion;</span>
<span class="line" id="L1099"></span>
<span class="line" id="L1100">        <span class="tok-kw">const</span> endian: std.builtin.Endian = <span class="tok-kw">switch</span> (hdr.e_ident[elf.EI_DATA]) {</span>
<span class="line" id="L1101">            elf.ELFDATA2LSB =&gt; .little,</span>
<span class="line" id="L1102">            elf.ELFDATA2MSB =&gt; .big,</span>
<span class="line" id="L1103">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfEndian,</span>
<span class="line" id="L1104">        };</span>
<span class="line" id="L1105">        assert(endian == native_endian); <span class="tok-comment">// this is our own debug info</span>
</span>
<span class="line" id="L1106"></span>
<span class="line" id="L1107">        <span class="tok-kw">const</span> shoff = hdr.e_shoff;</span>
<span class="line" id="L1108">        <span class="tok-kw">const</span> str_section_off = shoff + <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, hdr.e_shentsize) * <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, hdr.e_shstrndx);</span>
<span class="line" id="L1109">        <span class="tok-kw">const</span> str_shdr: *<span class="tok-kw">const</span> elf.Shdr = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;mapped_mem[math.cast(<span class="tok-type">usize</span>, str_section_off) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow]));</span>
<span class="line" id="L1110">        <span class="tok-kw">const</span> header_strings = mapped_mem[str_shdr.sh_offset..][<span class="tok-number">0</span>..str_shdr.sh_size];</span>
<span class="line" id="L1111">        <span class="tok-kw">const</span> shdrs = <span class="tok-builtin">@as</span>(</span>
<span class="line" id="L1112">            [*]<span class="tok-kw">const</span> elf.Shdr,</span>
<span class="line" id="L1113">            <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;mapped_mem[shoff])),</span>
<span class="line" id="L1114">        )[<span class="tok-number">0</span>..hdr.e_shnum];</span>
<span class="line" id="L1115"></span>
<span class="line" id="L1116">        <span class="tok-kw">var</span> sections: DW.DwarfInfo.SectionArray = DW.DwarfInfo.null_section_array;</span>
<span class="line" id="L1117"></span>
<span class="line" id="L1118">        <span class="tok-comment">// Combine section list. This takes ownership over any owned sections from the parent scope.</span>
</span>
<span class="line" id="L1119">        <span class="tok-kw">for</span> (parent_sections, &amp;sections) |*parent, *section| {</span>
<span class="line" id="L1120">            <span class="tok-kw">if</span> (parent.*) |*p| {</span>
<span class="line" id="L1121">                section.* = p.*;</span>
<span class="line" id="L1122">                p.owned = <span class="tok-null">false</span>;</span>
<span class="line" id="L1123">            }</span>
<span class="line" id="L1124">        }</span>
<span class="line" id="L1125">        <span class="tok-kw">errdefer</span> <span class="tok-kw">for</span> (sections) |section| <span class="tok-kw">if</span> (section) |s| <span class="tok-kw">if</span> (s.owned) allocator.free(s.data);</span>
<span class="line" id="L1126"></span>
<span class="line" id="L1127">        <span class="tok-kw">var</span> separate_debug_filename: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L1128">        <span class="tok-kw">var</span> separate_debug_crc: ?<span class="tok-type">u32</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L1129"></span>
<span class="line" id="L1130">        <span class="tok-kw">for</span> (shdrs) |*shdr| {</span>
<span class="line" id="L1131">            <span class="tok-kw">if</span> (shdr.sh_type == elf.SHT_NULL <span class="tok-kw">or</span> shdr.sh_type == elf.SHT_NOBITS) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1132">            <span class="tok-kw">const</span> name = mem.sliceTo(header_strings[shdr.sh_name..], <span class="tok-number">0</span>);</span>
<span class="line" id="L1133"></span>
<span class="line" id="L1134">            <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.gnu_debuglink&quot;</span>)) {</span>
<span class="line" id="L1135">                <span class="tok-kw">const</span> gnu_debuglink = <span class="tok-kw">try</span> chopSlice(mapped_mem, shdr.sh_offset, shdr.sh_size);</span>
<span class="line" id="L1136">                <span class="tok-kw">const</span> debug_filename = mem.sliceTo(<span class="tok-builtin">@as</span>([*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(gnu_debuglink.ptr)), <span class="tok-number">0</span>);</span>
<span class="line" id="L1137">                <span class="tok-kw">const</span> crc_offset = mem.alignForward(<span class="tok-type">usize</span>, <span class="tok-builtin">@intFromPtr</span>(&amp;debug_filename[debug_filename.len]) + <span class="tok-number">1</span>, <span class="tok-number">4</span>) - <span class="tok-builtin">@intFromPtr</span>(gnu_debuglink.ptr);</span>
<span class="line" id="L1138">                <span class="tok-kw">const</span> crc_bytes = gnu_debuglink[crc_offset..][<span class="tok-number">0</span>..<span class="tok-number">4</span>];</span>
<span class="line" id="L1139">                separate_debug_crc = mem.readInt(<span class="tok-type">u32</span>, crc_bytes, native_endian);</span>
<span class="line" id="L1140">                separate_debug_filename = debug_filename;</span>
<span class="line" id="L1141">                <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1142">            }</span>
<span class="line" id="L1143"></span>
<span class="line" id="L1144">            <span class="tok-kw">var</span> section_index: ?<span class="tok-type">usize</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L1145">            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(DW.DwarfSection).Enum.fields, <span class="tok-number">0</span>..) |section, i| {</span>
<span class="line" id="L1146">                <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, <span class="tok-str">&quot;.&quot;</span> ++ section.name, name)) section_index = i;</span>
<span class="line" id="L1147">            }</span>
<span class="line" id="L1148">            <span class="tok-kw">if</span> (section_index == <span class="tok-null">null</span>) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1149">            <span class="tok-kw">if</span> (sections[section_index.?] != <span class="tok-null">null</span>) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1150"></span>
<span class="line" id="L1151">            <span class="tok-kw">const</span> section_bytes = <span class="tok-kw">try</span> chopSlice(mapped_mem, shdr.sh_offset, shdr.sh_size);</span>
<span class="line" id="L1152">            sections[section_index.?] = <span class="tok-kw">if</span> ((shdr.sh_flags &amp; elf.SHF_COMPRESSED) &gt; <span class="tok-number">0</span>) blk: {</span>
<span class="line" id="L1153">                <span class="tok-kw">var</span> section_stream = io.fixedBufferStream(section_bytes);</span>
<span class="line" id="L1154">                <span class="tok-kw">var</span> section_reader = section_stream.reader();</span>
<span class="line" id="L1155">                <span class="tok-kw">const</span> chdr = section_reader.readStruct(elf.Chdr) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1156">                <span class="tok-kw">if</span> (chdr.ch_type != .ZLIB) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1157"></span>
<span class="line" id="L1158">                <span class="tok-kw">var</span> zlib_stream = std.compress.zlib.decompressStream(allocator, section_stream.reader()) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1159">                <span class="tok-kw">defer</span> zlib_stream.deinit();</span>
<span class="line" id="L1160"></span>
<span class="line" id="L1161">                <span class="tok-kw">var</span> decompressed_section = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, chdr.ch_size);</span>
<span class="line" id="L1162">                <span class="tok-kw">errdefer</span> allocator.free(decompressed_section);</span>
<span class="line" id="L1163"></span>
<span class="line" id="L1164">                <span class="tok-kw">const</span> read = zlib_stream.reader().readAll(decompressed_section) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1165">                assert(read == decompressed_section.len);</span>
<span class="line" id="L1166"></span>
<span class="line" id="L1167">                <span class="tok-kw">break</span> :blk .{</span>
<span class="line" id="L1168">                    .data = decompressed_section,</span>
<span class="line" id="L1169">                    .virtual_address = shdr.sh_addr,</span>
<span class="line" id="L1170">                    .owned = <span class="tok-null">true</span>,</span>
<span class="line" id="L1171">                };</span>
<span class="line" id="L1172">            } <span class="tok-kw">else</span> .{</span>
<span class="line" id="L1173">                .data = section_bytes,</span>
<span class="line" id="L1174">                .virtual_address = shdr.sh_addr,</span>
<span class="line" id="L1175">                .owned = <span class="tok-null">false</span>,</span>
<span class="line" id="L1176">            };</span>
<span class="line" id="L1177">        }</span>
<span class="line" id="L1178"></span>
<span class="line" id="L1179">        <span class="tok-kw">const</span> missing_debug_info =</span>
<span class="line" id="L1180">            sections[<span class="tok-builtin">@intFromEnum</span>(DW.DwarfSection.debug_info)] == <span class="tok-null">null</span> <span class="tok-kw">or</span></span>
<span class="line" id="L1181">            sections[<span class="tok-builtin">@intFromEnum</span>(DW.DwarfSection.debug_abbrev)] == <span class="tok-null">null</span> <span class="tok-kw">or</span></span>
<span class="line" id="L1182">            sections[<span class="tok-builtin">@intFromEnum</span>(DW.DwarfSection.debug_str)] == <span class="tok-null">null</span> <span class="tok-kw">or</span></span>
<span class="line" id="L1183">            sections[<span class="tok-builtin">@intFromEnum</span>(DW.DwarfSection.debug_line)] == <span class="tok-null">null</span>;</span>
<span class="line" id="L1184"></span>
<span class="line" id="L1185">        <span class="tok-comment">// Attempt to load debug info from an external file</span>
</span>
<span class="line" id="L1186">        <span class="tok-comment">// See: https://sourceware.org/gdb/onlinedocs/gdb/Separate-Debug-Files.html</span>
</span>
<span class="line" id="L1187">        <span class="tok-kw">if</span> (missing_debug_info) {</span>
<span class="line" id="L1188"></span>
<span class="line" id="L1189">            <span class="tok-comment">// Only allow one level of debug info nesting</span>
</span>
<span class="line" id="L1190">            <span class="tok-kw">if</span> (parent_mapped_mem) |_| {</span>
<span class="line" id="L1191">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1192">            }</span>
<span class="line" id="L1193"></span>
<span class="line" id="L1194">            <span class="tok-kw">const</span> global_debug_directories = [_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{</span>
<span class="line" id="L1195">                <span class="tok-str">&quot;/usr/lib/debug&quot;</span>,</span>
<span class="line" id="L1196">            };</span>
<span class="line" id="L1197"></span>
<span class="line" id="L1198">            <span class="tok-comment">// &lt;global debug directory&gt;/.build-id/&lt;2-character id prefix&gt;/&lt;id remainder&gt;.debug</span>
</span>
<span class="line" id="L1199">            <span class="tok-kw">if</span> (build_id) |id| blk: {</span>
<span class="line" id="L1200">                <span class="tok-kw">if</span> (id.len &lt; <span class="tok-number">3</span>) <span class="tok-kw">break</span> :blk;</span>
<span class="line" id="L1201"></span>
<span class="line" id="L1202">                <span class="tok-comment">// Either md5 (16 bytes) or sha1 (20 bytes) are used here in practice</span>
</span>
<span class="line" id="L1203">                <span class="tok-kw">const</span> extension = <span class="tok-str">&quot;.debug&quot;</span>;</span>
<span class="line" id="L1204">                <span class="tok-kw">var</span> id_prefix_buf: [<span class="tok-number">2</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1205">                <span class="tok-kw">var</span> filename_buf: [<span class="tok-number">38</span> + extension.len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1206"></span>
<span class="line" id="L1207">                _ = std.fmt.bufPrint(&amp;id_prefix_buf, <span class="tok-str">&quot;{s}&quot;</span>, .{std.fmt.fmtSliceHexLower(id[<span class="tok-number">0</span>..<span class="tok-number">1</span>])}) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L1208">                <span class="tok-kw">const</span> filename = std.fmt.bufPrint(</span>
<span class="line" id="L1209">                    &amp;filename_buf,</span>
<span class="line" id="L1210">                    <span class="tok-str">&quot;{s}&quot;</span> ++ extension,</span>
<span class="line" id="L1211">                    .{std.fmt.fmtSliceHexLower(id[<span class="tok-number">1</span>..])},</span>
<span class="line" id="L1212">                ) <span class="tok-kw">catch</span> <span class="tok-kw">break</span> :blk;</span>
<span class="line" id="L1213"></span>
<span class="line" id="L1214">                <span class="tok-kw">for</span> (global_debug_directories) |global_directory| {</span>
<span class="line" id="L1215">                    <span class="tok-kw">const</span> path = <span class="tok-kw">try</span> fs.path.join(allocator, &amp;.{ global_directory, <span class="tok-str">&quot;.build-id&quot;</span>, &amp;id_prefix_buf, filename });</span>
<span class="line" id="L1216">                    <span class="tok-kw">defer</span> allocator.free(path);</span>
<span class="line" id="L1217"></span>
<span class="line" id="L1218">                    <span class="tok-kw">return</span> readElfDebugInfo(allocator, path, <span class="tok-null">null</span>, separate_debug_crc, &amp;sections, mapped_mem) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1219">                }</span>
<span class="line" id="L1220">            }</span>
<span class="line" id="L1221"></span>
<span class="line" id="L1222">            <span class="tok-comment">// use the path from .gnu_debuglink, in the same search order as gdb</span>
</span>
<span class="line" id="L1223">            <span class="tok-kw">if</span> (separate_debug_filename) |separate_filename| blk: {</span>
<span class="line" id="L1224">                <span class="tok-kw">if</span> (elf_filename != <span class="tok-null">null</span> <span class="tok-kw">and</span> mem.eql(<span class="tok-type">u8</span>, elf_filename.?, separate_filename)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1225"></span>
<span class="line" id="L1226">                <span class="tok-comment">// &lt;cwd&gt;/&lt;gnu_debuglink&gt;</span>
</span>
<span class="line" id="L1227">                <span class="tok-kw">if</span> (readElfDebugInfo(allocator, separate_filename, <span class="tok-null">null</span>, separate_debug_crc, &amp;sections, mapped_mem)) |debug_info| <span class="tok-kw">return</span> debug_info <span class="tok-kw">else</span> |_| {}</span>
<span class="line" id="L1228"></span>
<span class="line" id="L1229">                <span class="tok-comment">// &lt;cwd&gt;/.debug/&lt;gnu_debuglink&gt;</span>
</span>
<span class="line" id="L1230">                {</span>
<span class="line" id="L1231">                    <span class="tok-kw">const</span> path = <span class="tok-kw">try</span> fs.path.join(allocator, &amp;.{ <span class="tok-str">&quot;.debug&quot;</span>, separate_filename });</span>
<span class="line" id="L1232">                    <span class="tok-kw">defer</span> allocator.free(path);</span>
<span class="line" id="L1233"></span>
<span class="line" id="L1234">                    <span class="tok-kw">if</span> (readElfDebugInfo(allocator, path, <span class="tok-null">null</span>, separate_debug_crc, &amp;sections, mapped_mem)) |debug_info| <span class="tok-kw">return</span> debug_info <span class="tok-kw">else</span> |_| {}</span>
<span class="line" id="L1235">                }</span>
<span class="line" id="L1236"></span>
<span class="line" id="L1237">                <span class="tok-kw">var</span> cwd_buf: [fs.MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1238">                <span class="tok-kw">const</span> cwd_path = os.realpath(<span class="tok-str">&quot;.&quot;</span>, &amp;cwd_buf) <span class="tok-kw">catch</span> <span class="tok-kw">break</span> :blk;</span>
<span class="line" id="L1239"></span>
<span class="line" id="L1240">                <span class="tok-comment">// &lt;global debug directory&gt;/&lt;absolute folder of current binary&gt;/&lt;gnu_debuglink&gt;</span>
</span>
<span class="line" id="L1241">                <span class="tok-kw">for</span> (global_debug_directories) |global_directory| {</span>
<span class="line" id="L1242">                    <span class="tok-kw">const</span> path = <span class="tok-kw">try</span> fs.path.join(allocator, &amp;.{ global_directory, cwd_path, separate_filename });</span>
<span class="line" id="L1243">                    <span class="tok-kw">defer</span> allocator.free(path);</span>
<span class="line" id="L1244">                    <span class="tok-kw">if</span> (readElfDebugInfo(allocator, path, <span class="tok-null">null</span>, separate_debug_crc, &amp;sections, mapped_mem)) |debug_info| <span class="tok-kw">return</span> debug_info <span class="tok-kw">else</span> |_| {}</span>
<span class="line" id="L1245">                }</span>
<span class="line" id="L1246">            }</span>
<span class="line" id="L1247"></span>
<span class="line" id="L1248">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1249">        }</span>
<span class="line" id="L1250"></span>
<span class="line" id="L1251">        <span class="tok-kw">var</span> di = DW.DwarfInfo{</span>
<span class="line" id="L1252">            .endian = endian,</span>
<span class="line" id="L1253">            .sections = sections,</span>
<span class="line" id="L1254">            .is_macho = <span class="tok-null">false</span>,</span>
<span class="line" id="L1255">        };</span>
<span class="line" id="L1256"></span>
<span class="line" id="L1257">        <span class="tok-kw">try</span> DW.openDwarfDebugInfo(&amp;di, allocator);</span>
<span class="line" id="L1258"></span>
<span class="line" id="L1259">        <span class="tok-kw">return</span> ModuleDebugInfo{</span>
<span class="line" id="L1260">            .base_address = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L1261">            .dwarf = di,</span>
<span class="line" id="L1262">            .mapped_memory = parent_mapped_mem <span class="tok-kw">orelse</span> mapped_mem,</span>
<span class="line" id="L1263">            .external_mapped_memory = <span class="tok-kw">if</span> (parent_mapped_mem != <span class="tok-null">null</span>) mapped_mem <span class="tok-kw">else</span> <span class="tok-null">null</span>,</span>
<span class="line" id="L1264">        };</span>
<span class="line" id="L1265">    }</span>
<span class="line" id="L1266">}</span>
<span class="line" id="L1267"></span>
<span class="line" id="L1268"><span class="tok-comment">/// This takes ownership of macho_file: users of this function should not close</span></span>
<span class="line" id="L1269"><span class="tok-comment">/// it themselves, even on error.</span></span>
<span class="line" id="L1270"><span class="tok-comment">/// TODO it's weird to take ownership even on error, rework this code.</span></span>
<span class="line" id="L1271"><span class="tok-kw">fn</span> <span class="tok-fn">readMachODebugInfo</span>(allocator: mem.Allocator, macho_file: File) !ModuleDebugInfo {</span>
<span class="line" id="L1272">    <span class="tok-kw">const</span> mapped_mem = <span class="tok-kw">try</span> mapWholeFile(macho_file);</span>
<span class="line" id="L1273"></span>
<span class="line" id="L1274">    <span class="tok-kw">const</span> hdr: *<span class="tok-kw">const</span> macho.mach_header_64 = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(mapped_mem.ptr));</span>
<span class="line" id="L1275">    <span class="tok-kw">if</span> (hdr.magic != macho.MH_MAGIC_64)</span>
<span class="line" id="L1276">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo;</span>
<span class="line" id="L1277"></span>
<span class="line" id="L1278">    <span class="tok-kw">var</span> it = macho.LoadCommandIterator{</span>
<span class="line" id="L1279">        .ncmds = hdr.ncmds,</span>
<span class="line" id="L1280">        .buffer = mapped_mem[<span class="tok-builtin">@sizeOf</span>(macho.mach_header_64)..][<span class="tok-number">0</span>..hdr.sizeofcmds],</span>
<span class="line" id="L1281">    };</span>
<span class="line" id="L1282">    <span class="tok-kw">const</span> symtab = <span class="tok-kw">while</span> (it.next()) |cmd| <span class="tok-kw">switch</span> (cmd.cmd()) {</span>
<span class="line" id="L1283">        .SYMTAB =&gt; <span class="tok-kw">break</span> cmd.cast(macho.symtab_command).?,</span>
<span class="line" id="L1284">        <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L1285">    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1286"></span>
<span class="line" id="L1287">    <span class="tok-kw">const</span> syms = <span class="tok-builtin">@as</span>(</span>
<span class="line" id="L1288">        [*]<span class="tok-kw">const</span> macho.nlist_64,</span>
<span class="line" id="L1289">        <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;mapped_mem[symtab.symoff])),</span>
<span class="line" id="L1290">    )[<span class="tok-number">0</span>..symtab.nsyms];</span>
<span class="line" id="L1291">    <span class="tok-kw">const</span> strings = mapped_mem[symtab.stroff..][<span class="tok-number">0</span> .. symtab.strsize - <span class="tok-number">1</span> :<span class="tok-number">0</span>];</span>
<span class="line" id="L1292"></span>
<span class="line" id="L1293">    <span class="tok-kw">const</span> symbols_buf = <span class="tok-kw">try</span> allocator.alloc(MachoSymbol, syms.len);</span>
<span class="line" id="L1294"></span>
<span class="line" id="L1295">    <span class="tok-kw">var</span> ofile: <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1296">    <span class="tok-kw">var</span> last_sym: MachoSymbol = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1297">    <span class="tok-kw">var</span> symbol_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1298">    <span class="tok-kw">var</span> state: <span class="tok-kw">enum</span> {</span>
<span class="line" id="L1299">        init,</span>
<span class="line" id="L1300">        oso_open,</span>
<span class="line" id="L1301">        oso_close,</span>
<span class="line" id="L1302">        bnsym,</span>
<span class="line" id="L1303">        fun_strx,</span>
<span class="line" id="L1304">        fun_size,</span>
<span class="line" id="L1305">        ensym,</span>
<span class="line" id="L1306">    } = .init;</span>
<span class="line" id="L1307"></span>
<span class="line" id="L1308">    <span class="tok-kw">for</span> (syms) |*sym| {</span>
<span class="line" id="L1309">        <span class="tok-kw">if</span> (!sym.stab()) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1310"></span>
<span class="line" id="L1311">        <span class="tok-comment">// TODO handle globals N_GSYM, and statics N_STSYM</span>
</span>
<span class="line" id="L1312">        <span class="tok-kw">switch</span> (sym.n_type) {</span>
<span class="line" id="L1313">            macho.N_OSO =&gt; {</span>
<span class="line" id="L1314">                <span class="tok-kw">switch</span> (state) {</span>
<span class="line" id="L1315">                    .init, .oso_close =&gt; {</span>
<span class="line" id="L1316">                        state = .oso_open;</span>
<span class="line" id="L1317">                        ofile = sym.n_strx;</span>
<span class="line" id="L1318">                    },</span>
<span class="line" id="L1319">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo,</span>
<span class="line" id="L1320">                }</span>
<span class="line" id="L1321">            },</span>
<span class="line" id="L1322">            macho.N_BNSYM =&gt; {</span>
<span class="line" id="L1323">                <span class="tok-kw">switch</span> (state) {</span>
<span class="line" id="L1324">                    .oso_open, .ensym =&gt; {</span>
<span class="line" id="L1325">                        state = .bnsym;</span>
<span class="line" id="L1326">                        last_sym = .{</span>
<span class="line" id="L1327">                            .strx = <span class="tok-number">0</span>,</span>
<span class="line" id="L1328">                            .addr = sym.n_value,</span>
<span class="line" id="L1329">                            .size = <span class="tok-number">0</span>,</span>
<span class="line" id="L1330">                            .ofile = ofile,</span>
<span class="line" id="L1331">                        };</span>
<span class="line" id="L1332">                    },</span>
<span class="line" id="L1333">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo,</span>
<span class="line" id="L1334">                }</span>
<span class="line" id="L1335">            },</span>
<span class="line" id="L1336">            macho.N_FUN =&gt; {</span>
<span class="line" id="L1337">                <span class="tok-kw">switch</span> (state) {</span>
<span class="line" id="L1338">                    .bnsym =&gt; {</span>
<span class="line" id="L1339">                        state = .fun_strx;</span>
<span class="line" id="L1340">                        last_sym.strx = sym.n_strx;</span>
<span class="line" id="L1341">                    },</span>
<span class="line" id="L1342">                    .fun_strx =&gt; {</span>
<span class="line" id="L1343">                        state = .fun_size;</span>
<span class="line" id="L1344">                        last_sym.size = <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(sym.n_value));</span>
<span class="line" id="L1345">                    },</span>
<span class="line" id="L1346">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo,</span>
<span class="line" id="L1347">                }</span>
<span class="line" id="L1348">            },</span>
<span class="line" id="L1349">            macho.N_ENSYM =&gt; {</span>
<span class="line" id="L1350">                <span class="tok-kw">switch</span> (state) {</span>
<span class="line" id="L1351">                    .fun_size =&gt; {</span>
<span class="line" id="L1352">                        state = .ensym;</span>
<span class="line" id="L1353">                        symbols_buf[symbol_index] = last_sym;</span>
<span class="line" id="L1354">                        symbol_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L1355">                    },</span>
<span class="line" id="L1356">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo,</span>
<span class="line" id="L1357">                }</span>
<span class="line" id="L1358">            },</span>
<span class="line" id="L1359">            macho.N_SO =&gt; {</span>
<span class="line" id="L1360">                <span class="tok-kw">switch</span> (state) {</span>
<span class="line" id="L1361">                    .init, .oso_close =&gt; {},</span>
<span class="line" id="L1362">                    .oso_open, .ensym =&gt; {</span>
<span class="line" id="L1363">                        state = .oso_close;</span>
<span class="line" id="L1364">                    },</span>
<span class="line" id="L1365">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo,</span>
<span class="line" id="L1366">                }</span>
<span class="line" id="L1367">            },</span>
<span class="line" id="L1368">            <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L1369">        }</span>
<span class="line" id="L1370">    }</span>
<span class="line" id="L1371"></span>
<span class="line" id="L1372">    <span class="tok-kw">switch</span> (state) {</span>
<span class="line" id="L1373">        .init =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo,</span>
<span class="line" id="L1374">        .oso_close =&gt; {},</span>
<span class="line" id="L1375">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo,</span>
<span class="line" id="L1376">    }</span>
<span class="line" id="L1377"></span>
<span class="line" id="L1378">    <span class="tok-kw">const</span> symbols = <span class="tok-kw">try</span> allocator.realloc(symbols_buf, symbol_index);</span>
<span class="line" id="L1379"></span>
<span class="line" id="L1380">    <span class="tok-comment">// Even though lld emits symbols in ascending order, this debug code</span>
</span>
<span class="line" id="L1381">    <span class="tok-comment">// should work for programs linked in any valid way.</span>
</span>
<span class="line" id="L1382">    <span class="tok-comment">// This sort is so that we can binary search later.</span>
</span>
<span class="line" id="L1383">    mem.sort(MachoSymbol, symbols, {}, MachoSymbol.addressLessThan);</span>
<span class="line" id="L1384"></span>
<span class="line" id="L1385">    <span class="tok-kw">return</span> ModuleDebugInfo{</span>
<span class="line" id="L1386">        .base_address = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L1387">        .vmaddr_slide = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L1388">        .mapped_memory = mapped_mem,</span>
<span class="line" id="L1389">        .ofiles = ModuleDebugInfo.OFileTable.init(allocator),</span>
<span class="line" id="L1390">        .symbols = symbols,</span>
<span class="line" id="L1391">        .strings = strings,</span>
<span class="line" id="L1392">    };</span>
<span class="line" id="L1393">}</span>
<span class="line" id="L1394"></span>
<span class="line" id="L1395"><span class="tok-kw">fn</span> <span class="tok-fn">printLineFromFileAnyOs</span>(out_stream: <span class="tok-kw">anytype</span>, line_info: LineInfo) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1396">    <span class="tok-comment">// Need this to always block even in async I/O mode, because this could potentially</span>
</span>
<span class="line" id="L1397">    <span class="tok-comment">// be called from e.g. the event loop code crashing.</span>
</span>
<span class="line" id="L1398">    <span class="tok-kw">var</span> f = <span class="tok-kw">try</span> fs.cwd().openFile(line_info.file_name, .{ .intended_io_mode = .blocking });</span>
<span class="line" id="L1399">    <span class="tok-kw">defer</span> f.close();</span>
<span class="line" id="L1400">    <span class="tok-comment">// TODO fstat and make sure that the file has the correct size</span>
</span>
<span class="line" id="L1401"></span>
<span class="line" id="L1402">    <span class="tok-kw">var</span> buf: [mem.page_size]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1403">    <span class="tok-kw">var</span> line: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;</span>
<span class="line" id="L1404">    <span class="tok-kw">var</span> column: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;</span>
<span class="line" id="L1405">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L1406">        <span class="tok-kw">const</span> amt_read = <span class="tok-kw">try</span> f.read(buf[<span class="tok-number">0</span>..]);</span>
<span class="line" id="L1407">        <span class="tok-kw">const</span> slice = buf[<span class="tok-number">0</span>..amt_read];</span>
<span class="line" id="L1408"></span>
<span class="line" id="L1409">        <span class="tok-kw">for</span> (slice) |byte| {</span>
<span class="line" id="L1410">            <span class="tok-kw">if</span> (line == line_info.line) {</span>
<span class="line" id="L1411">                <span class="tok-kw">switch</span> (byte) {</span>
<span class="line" id="L1412">                    <span class="tok-str">'\t'</span> =&gt; <span class="tok-kw">try</span> out_stream.writeByte(<span class="tok-str">' '</span>),</span>
<span class="line" id="L1413">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">try</span> out_stream.writeByte(byte),</span>
<span class="line" id="L1414">                }</span>
<span class="line" id="L1415">                <span class="tok-kw">if</span> (byte == <span class="tok-str">'\n'</span>) {</span>
<span class="line" id="L1416">                    <span class="tok-kw">return</span>;</span>
<span class="line" id="L1417">                }</span>
<span class="line" id="L1418">            }</span>
<span class="line" id="L1419">            <span class="tok-kw">if</span> (byte == <span class="tok-str">'\n'</span>) {</span>
<span class="line" id="L1420">                line += <span class="tok-number">1</span>;</span>
<span class="line" id="L1421">                column = <span class="tok-number">1</span>;</span>
<span class="line" id="L1422">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1423">                column += <span class="tok-number">1</span>;</span>
<span class="line" id="L1424">            }</span>
<span class="line" id="L1425">        }</span>
<span class="line" id="L1426"></span>
<span class="line" id="L1427">        <span class="tok-kw">if</span> (amt_read &lt; buf.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EndOfFile;</span>
<span class="line" id="L1428">    }</span>
<span class="line" id="L1429">}</span>
<span class="line" id="L1430"></span>
<span class="line" id="L1431"><span class="tok-kw">const</span> MachoSymbol = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1432">    strx: <span class="tok-type">u32</span>,</span>
<span class="line" id="L1433">    addr: <span class="tok-type">u64</span>,</span>
<span class="line" id="L1434">    size: <span class="tok-type">u32</span>,</span>
<span class="line" id="L1435">    ofile: <span class="tok-type">u32</span>,</span>
<span class="line" id="L1436"></span>
<span class="line" id="L1437">    <span class="tok-comment">/// Returns the address from the macho file</span></span>
<span class="line" id="L1438">    <span class="tok-kw">fn</span> <span class="tok-fn">address</span>(self: MachoSymbol) <span class="tok-type">u64</span> {</span>
<span class="line" id="L1439">        <span class="tok-kw">return</span> self.addr;</span>
<span class="line" id="L1440">    }</span>
<span class="line" id="L1441"></span>
<span class="line" id="L1442">    <span class="tok-kw">fn</span> <span class="tok-fn">addressLessThan</span>(context: <span class="tok-type">void</span>, lhs: MachoSymbol, rhs: MachoSymbol) <span class="tok-type">bool</span> {</span>
<span class="line" id="L1443">        _ = context;</span>
<span class="line" id="L1444">        <span class="tok-kw">return</span> lhs.addr &lt; rhs.addr;</span>
<span class="line" id="L1445">    }</span>
<span class="line" id="L1446">};</span>
<span class="line" id="L1447"></span>
<span class="line" id="L1448"><span class="tok-comment">/// `file` is expected to have been opened with .intended_io_mode == .blocking.</span></span>
<span class="line" id="L1449"><span class="tok-comment">/// Takes ownership of file, even on error.</span></span>
<span class="line" id="L1450"><span class="tok-comment">/// TODO it's weird to take ownership even on error, rework this code.</span></span>
<span class="line" id="L1451"><span class="tok-kw">fn</span> <span class="tok-fn">mapWholeFile</span>(file: File) ![]<span class="tok-kw">align</span>(mem.page_size) <span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1452">    <span class="tok-kw">nosuspend</span> {</span>
<span class="line" id="L1453">        <span class="tok-kw">defer</span> file.close();</span>
<span class="line" id="L1454"></span>
<span class="line" id="L1455">        <span class="tok-kw">const</span> file_len = math.cast(<span class="tok-type">usize</span>, <span class="tok-kw">try</span> file.getEndPos()) <span class="tok-kw">orelse</span> math.maxInt(<span class="tok-type">usize</span>);</span>
<span class="line" id="L1456">        <span class="tok-kw">const</span> mapped_mem = <span class="tok-kw">try</span> os.mmap(</span>
<span class="line" id="L1457">            <span class="tok-null">null</span>,</span>
<span class="line" id="L1458">            file_len,</span>
<span class="line" id="L1459">            os.PROT.READ,</span>
<span class="line" id="L1460">            os.MAP.SHARED,</span>
<span class="line" id="L1461">            file.handle,</span>
<span class="line" id="L1462">            <span class="tok-number">0</span>,</span>
<span class="line" id="L1463">        );</span>
<span class="line" id="L1464">        <span class="tok-kw">errdefer</span> os.munmap(mapped_mem);</span>
<span class="line" id="L1465"></span>
<span class="line" id="L1466">        <span class="tok-kw">return</span> mapped_mem;</span>
<span class="line" id="L1467">    }</span>
<span class="line" id="L1468">}</span>
<span class="line" id="L1469"></span>
<span class="line" id="L1470"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> WindowsModuleInfo = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1471">    base_address: <span class="tok-type">usize</span>,</span>
<span class="line" id="L1472">    size: <span class="tok-type">u32</span>,</span>
<span class="line" id="L1473">    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1474">    handle: windows.HMODULE,</span>
<span class="line" id="L1475"></span>
<span class="line" id="L1476">    <span class="tok-comment">// Set when the image file needed to be mapped from disk</span>
</span>
<span class="line" id="L1477">    mapped_file: ?<span class="tok-kw">struct</span> {</span>
<span class="line" id="L1478">        file: File,</span>
<span class="line" id="L1479">        section_handle: windows.HANDLE,</span>
<span class="line" id="L1480">        section_view: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1481"></span>
<span class="line" id="L1482">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: <span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {</span>
<span class="line" id="L1483">            <span class="tok-kw">const</span> process_handle = windows.kernel32.GetCurrentProcess();</span>
<span class="line" id="L1484">            assert(windows.ntdll.NtUnmapViewOfSection(process_handle, <span class="tok-builtin">@constCast</span>(<span class="tok-builtin">@ptrCast</span>(self.section_view.ptr))) == .SUCCESS);</span>
<span class="line" id="L1485">            windows.CloseHandle(self.section_handle);</span>
<span class="line" id="L1486">            self.file.close();</span>
<span class="line" id="L1487">        }</span>
<span class="line" id="L1488">    } = <span class="tok-null">null</span>,</span>
<span class="line" id="L1489">};</span>
<span class="line" id="L1490"></span>
<span class="line" id="L1491"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DebugInfo = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1492">    allocator: mem.Allocator,</span>
<span class="line" id="L1493">    address_map: std.AutoHashMap(<span class="tok-type">usize</span>, *ModuleDebugInfo),</span>
<span class="line" id="L1494">    modules: <span class="tok-kw">if</span> (native_os == .windows) std.ArrayListUnmanaged(WindowsModuleInfo) <span class="tok-kw">else</span> <span class="tok-type">void</span>,</span>
<span class="line" id="L1495"></span>
<span class="line" id="L1496">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: mem.Allocator) !DebugInfo {</span>
<span class="line" id="L1497">        <span class="tok-kw">var</span> debug_info = DebugInfo{</span>
<span class="line" id="L1498">            .allocator = allocator,</span>
<span class="line" id="L1499">            .address_map = std.AutoHashMap(<span class="tok-type">usize</span>, *ModuleDebugInfo).init(allocator),</span>
<span class="line" id="L1500">            .modules = <span class="tok-kw">if</span> (native_os == .windows) .{} <span class="tok-kw">else</span> {},</span>
<span class="line" id="L1501">        };</span>
<span class="line" id="L1502"></span>
<span class="line" id="L1503">        <span class="tok-kw">if</span> (native_os == .windows) {</span>
<span class="line" id="L1504">            <span class="tok-kw">errdefer</span> debug_info.modules.deinit(allocator);</span>
<span class="line" id="L1505"></span>
<span class="line" id="L1506">            <span class="tok-kw">const</span> handle = windows.kernel32.CreateToolhelp32Snapshot(windows.TH32CS_SNAPMODULE | windows.TH32CS_SNAPMODULE32, <span class="tok-number">0</span>);</span>
<span class="line" id="L1507">            <span class="tok-kw">if</span> (handle == windows.INVALID_HANDLE_VALUE) {</span>
<span class="line" id="L1508">                <span class="tok-kw">switch</span> (windows.kernel32.GetLastError()) {</span>
<span class="line" id="L1509">                    <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> windows.unexpectedError(err),</span>
<span class="line" id="L1510">                }</span>
<span class="line" id="L1511">            }</span>
<span class="line" id="L1512">            <span class="tok-kw">defer</span> windows.CloseHandle(handle);</span>
<span class="line" id="L1513"></span>
<span class="line" id="L1514">            <span class="tok-kw">var</span> module_entry: windows.MODULEENTRY32 = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1515">            module_entry.dwSize = <span class="tok-builtin">@sizeOf</span>(windows.MODULEENTRY32);</span>
<span class="line" id="L1516">            <span class="tok-kw">if</span> (windows.kernel32.Module32First(handle, &amp;module_entry) == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1517">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1518">            }</span>
<span class="line" id="L1519"></span>
<span class="line" id="L1520">            <span class="tok-kw">var</span> module_valid = <span class="tok-null">true</span>;</span>
<span class="line" id="L1521">            <span class="tok-kw">while</span> (module_valid) {</span>
<span class="line" id="L1522">                <span class="tok-kw">const</span> module_info = <span class="tok-kw">try</span> debug_info.modules.addOne(allocator);</span>
<span class="line" id="L1523">                <span class="tok-kw">const</span> name = allocator.dupe(<span class="tok-type">u8</span>, mem.sliceTo(&amp;module_entry.szModule, <span class="tok-number">0</span>)) <span class="tok-kw">catch</span> &amp;.{};</span>
<span class="line" id="L1524">                <span class="tok-kw">errdefer</span> allocator.free(name);</span>
<span class="line" id="L1525"></span>
<span class="line" id="L1526">                module_info.* = .{</span>
<span class="line" id="L1527">                    .base_address = <span class="tok-builtin">@intFromPtr</span>(module_entry.modBaseAddr),</span>
<span class="line" id="L1528">                    .size = module_entry.modBaseSize,</span>
<span class="line" id="L1529">                    .name = name,</span>
<span class="line" id="L1530">                    .handle = module_entry.hModule,</span>
<span class="line" id="L1531">                };</span>
<span class="line" id="L1532"></span>
<span class="line" id="L1533">                module_valid = windows.kernel32.Module32Next(handle, &amp;module_entry) == <span class="tok-number">1</span>;</span>
<span class="line" id="L1534">            }</span>
<span class="line" id="L1535">        }</span>
<span class="line" id="L1536"></span>
<span class="line" id="L1537">        <span class="tok-kw">return</span> debug_info;</span>
<span class="line" id="L1538">    }</span>
<span class="line" id="L1539"></span>
<span class="line" id="L1540">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *DebugInfo) <span class="tok-type">void</span> {</span>
<span class="line" id="L1541">        <span class="tok-kw">var</span> it = self.address_map.iterator();</span>
<span class="line" id="L1542">        <span class="tok-kw">while</span> (it.next()) |entry| {</span>
<span class="line" id="L1543">            <span class="tok-kw">const</span> mdi = entry.value_ptr.*;</span>
<span class="line" id="L1544">            mdi.deinit(self.allocator);</span>
<span class="line" id="L1545">            self.allocator.destroy(mdi);</span>
<span class="line" id="L1546">        }</span>
<span class="line" id="L1547">        self.address_map.deinit();</span>
<span class="line" id="L1548">        <span class="tok-kw">if</span> (native_os == .windows) {</span>
<span class="line" id="L1549">            <span class="tok-kw">for</span> (self.modules.items) |module| {</span>
<span class="line" id="L1550">                self.allocator.free(module.name);</span>
<span class="line" id="L1551">                <span class="tok-kw">if</span> (module.mapped_file) |mapped_file| mapped_file.deinit();</span>
<span class="line" id="L1552">            }</span>
<span class="line" id="L1553">            self.modules.deinit(self.allocator);</span>
<span class="line" id="L1554">        }</span>
<span class="line" id="L1555">    }</span>
<span class="line" id="L1556"></span>
<span class="line" id="L1557">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getModuleForAddress</span>(self: *DebugInfo, address: <span class="tok-type">usize</span>) !*ModuleDebugInfo {</span>
<span class="line" id="L1558">        <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> builtin.target.isDarwin()) {</span>
<span class="line" id="L1559">            <span class="tok-kw">return</span> self.lookupModuleDyld(address);</span>
<span class="line" id="L1560">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (native_os == .windows) {</span>
<span class="line" id="L1561">            <span class="tok-kw">return</span> self.lookupModuleWin32(address);</span>
<span class="line" id="L1562">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (native_os == .haiku) {</span>
<span class="line" id="L1563">            <span class="tok-kw">return</span> self.lookupModuleHaiku(address);</span>
<span class="line" id="L1564">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> builtin.target.isWasm()) {</span>
<span class="line" id="L1565">            <span class="tok-kw">return</span> self.lookupModuleWasm(address);</span>
<span class="line" id="L1566">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1567">            <span class="tok-kw">return</span> self.lookupModuleDl(address);</span>
<span class="line" id="L1568">        }</span>
<span class="line" id="L1569">    }</span>
<span class="line" id="L1570"></span>
<span class="line" id="L1571">    <span class="tok-comment">// Returns the module name for a given address.</span>
</span>
<span class="line" id="L1572">    <span class="tok-comment">// This can be called when getModuleForAddress fails, so implementations should provide</span>
</span>
<span class="line" id="L1573">    <span class="tok-comment">// a path that doesn't rely on any side-effects of a prior successful module lookup.</span>
</span>
<span class="line" id="L1574">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getModuleNameForAddress</span>(self: *DebugInfo, address: <span class="tok-type">usize</span>) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1575">        <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> builtin.target.isDarwin()) {</span>
<span class="line" id="L1576">            <span class="tok-kw">return</span> self.lookupModuleNameDyld(address);</span>
<span class="line" id="L1577">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (native_os == .windows) {</span>
<span class="line" id="L1578">            <span class="tok-kw">return</span> self.lookupModuleNameWin32(address);</span>
<span class="line" id="L1579">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (native_os == .haiku) {</span>
<span class="line" id="L1580">            <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1581">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> builtin.target.isWasm()) {</span>
<span class="line" id="L1582">            <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1583">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1584">            <span class="tok-kw">return</span> self.lookupModuleNameDl(address);</span>
<span class="line" id="L1585">        }</span>
<span class="line" id="L1586">    }</span>
<span class="line" id="L1587"></span>
<span class="line" id="L1588">    <span class="tok-kw">fn</span> <span class="tok-fn">lookupModuleDyld</span>(self: *DebugInfo, address: <span class="tok-type">usize</span>) !*ModuleDebugInfo {</span>
<span class="line" id="L1589">        <span class="tok-kw">const</span> image_count = std.c._dyld_image_count();</span>
<span class="line" id="L1590"></span>
<span class="line" id="L1591">        <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1592">        <span class="tok-kw">while</span> (i &lt; image_count) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L1593">            <span class="tok-kw">const</span> header = std.c._dyld_get_image_header(i) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1594">            <span class="tok-kw">const</span> base_address = <span class="tok-builtin">@intFromPtr</span>(header);</span>
<span class="line" id="L1595">            <span class="tok-kw">if</span> (address &lt; base_address) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1596">            <span class="tok-kw">const</span> vmaddr_slide = std.c._dyld_get_image_vmaddr_slide(i);</span>
<span class="line" id="L1597"></span>
<span class="line" id="L1598">            <span class="tok-kw">var</span> it = macho.LoadCommandIterator{</span>
<span class="line" id="L1599">                .ncmds = header.ncmds,</span>
<span class="line" id="L1600">                .buffer = <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@as</span>(</span>
<span class="line" id="L1601">                    [*]<span class="tok-type">u8</span>,</span>
<span class="line" id="L1602">                    <span class="tok-builtin">@ptrFromInt</span>(<span class="tok-builtin">@intFromPtr</span>(header) + <span class="tok-builtin">@sizeOf</span>(macho.mach_header_64)),</span>
<span class="line" id="L1603">                )[<span class="tok-number">0</span>..header.sizeofcmds]),</span>
<span class="line" id="L1604">            };</span>
<span class="line" id="L1605"></span>
<span class="line" id="L1606">            <span class="tok-kw">var</span> unwind_info: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L1607">            <span class="tok-kw">var</span> eh_frame: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L1608">            <span class="tok-kw">while</span> (it.next()) |cmd| <span class="tok-kw">switch</span> (cmd.cmd()) {</span>
<span class="line" id="L1609">                .SEGMENT_64 =&gt; {</span>
<span class="line" id="L1610">                    <span class="tok-kw">const</span> segment_cmd = cmd.cast(macho.segment_command_64).?;</span>
<span class="line" id="L1611">                    <span class="tok-kw">if</span> (!mem.eql(<span class="tok-type">u8</span>, <span class="tok-str">&quot;__TEXT&quot;</span>, segment_cmd.segName())) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1612"></span>
<span class="line" id="L1613">                    <span class="tok-kw">const</span> seg_start = segment_cmd.vmaddr + vmaddr_slide;</span>
<span class="line" id="L1614">                    <span class="tok-kw">const</span> seg_end = seg_start + segment_cmd.vmsize;</span>
<span class="line" id="L1615">                    <span class="tok-kw">if</span> (address &gt;= seg_start <span class="tok-kw">and</span> address &lt; seg_end) {</span>
<span class="line" id="L1616">                        <span class="tok-kw">if</span> (self.address_map.get(base_address)) |obj_di| {</span>
<span class="line" id="L1617">                            <span class="tok-kw">return</span> obj_di;</span>
<span class="line" id="L1618">                        }</span>
<span class="line" id="L1619"></span>
<span class="line" id="L1620">                        <span class="tok-kw">for</span> (cmd.getSections()) |sect| {</span>
<span class="line" id="L1621">                            <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, <span class="tok-str">&quot;__unwind_info&quot;</span>, sect.sectName())) {</span>
<span class="line" id="L1622">                                unwind_info = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(sect.addr + vmaddr_slide))[<span class="tok-number">0</span>..sect.size];</span>
<span class="line" id="L1623">                            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, <span class="tok-str">&quot;__eh_frame&quot;</span>, sect.sectName())) {</span>
<span class="line" id="L1624">                                eh_frame = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(sect.addr + vmaddr_slide))[<span class="tok-number">0</span>..sect.size];</span>
<span class="line" id="L1625">                            }</span>
<span class="line" id="L1626">                        }</span>
<span class="line" id="L1627"></span>
<span class="line" id="L1628">                        <span class="tok-kw">const</span> obj_di = <span class="tok-kw">try</span> self.allocator.create(ModuleDebugInfo);</span>
<span class="line" id="L1629">                        <span class="tok-kw">errdefer</span> self.allocator.destroy(obj_di);</span>
<span class="line" id="L1630"></span>
<span class="line" id="L1631">                        <span class="tok-kw">const</span> macho_path = mem.sliceTo(std.c._dyld_get_image_name(i), <span class="tok-number">0</span>);</span>
<span class="line" id="L1632">                        <span class="tok-kw">const</span> macho_file = fs.cwd().openFile(macho_path, .{</span>
<span class="line" id="L1633">                            .intended_io_mode = .blocking,</span>
<span class="line" id="L1634">                        }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1635">                            <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo,</span>
<span class="line" id="L1636">                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L1637">                        };</span>
<span class="line" id="L1638">                        obj_di.* = <span class="tok-kw">try</span> readMachODebugInfo(self.allocator, macho_file);</span>
<span class="line" id="L1639">                        obj_di.base_address = base_address;</span>
<span class="line" id="L1640">                        obj_di.vmaddr_slide = vmaddr_slide;</span>
<span class="line" id="L1641">                        obj_di.unwind_info = unwind_info;</span>
<span class="line" id="L1642">                        obj_di.eh_frame = eh_frame;</span>
<span class="line" id="L1643"></span>
<span class="line" id="L1644">                        <span class="tok-kw">try</span> self.address_map.putNoClobber(base_address, obj_di);</span>
<span class="line" id="L1645"></span>
<span class="line" id="L1646">                        <span class="tok-kw">return</span> obj_di;</span>
<span class="line" id="L1647">                    }</span>
<span class="line" id="L1648">                },</span>
<span class="line" id="L1649">                <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L1650">            };</span>
<span class="line" id="L1651">        }</span>
<span class="line" id="L1652"></span>
<span class="line" id="L1653">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1654">    }</span>
<span class="line" id="L1655"></span>
<span class="line" id="L1656">    <span class="tok-kw">fn</span> <span class="tok-fn">lookupModuleNameDyld</span>(self: *DebugInfo, address: <span class="tok-type">usize</span>) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1657">        _ = self;</span>
<span class="line" id="L1658">        <span class="tok-kw">const</span> image_count = std.c._dyld_image_count();</span>
<span class="line" id="L1659"></span>
<span class="line" id="L1660">        <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1661">        <span class="tok-kw">while</span> (i &lt; image_count) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L1662">            <span class="tok-kw">const</span> header = std.c._dyld_get_image_header(i) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1663">            <span class="tok-kw">const</span> base_address = <span class="tok-builtin">@intFromPtr</span>(header);</span>
<span class="line" id="L1664">            <span class="tok-kw">if</span> (address &lt; base_address) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1665">            <span class="tok-kw">const</span> vmaddr_slide = std.c._dyld_get_image_vmaddr_slide(i);</span>
<span class="line" id="L1666"></span>
<span class="line" id="L1667">            <span class="tok-kw">var</span> it = macho.LoadCommandIterator{</span>
<span class="line" id="L1668">                .ncmds = header.ncmds,</span>
<span class="line" id="L1669">                .buffer = <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@as</span>(</span>
<span class="line" id="L1670">                    [*]<span class="tok-type">u8</span>,</span>
<span class="line" id="L1671">                    <span class="tok-builtin">@ptrFromInt</span>(<span class="tok-builtin">@intFromPtr</span>(header) + <span class="tok-builtin">@sizeOf</span>(macho.mach_header_64)),</span>
<span class="line" id="L1672">                )[<span class="tok-number">0</span>..header.sizeofcmds]),</span>
<span class="line" id="L1673">            };</span>
<span class="line" id="L1674"></span>
<span class="line" id="L1675">            <span class="tok-kw">while</span> (it.next()) |cmd| <span class="tok-kw">switch</span> (cmd.cmd()) {</span>
<span class="line" id="L1676">                .SEGMENT_64 =&gt; {</span>
<span class="line" id="L1677">                    <span class="tok-kw">const</span> segment_cmd = cmd.cast(macho.segment_command_64).?;</span>
<span class="line" id="L1678">                    <span class="tok-kw">if</span> (!mem.eql(<span class="tok-type">u8</span>, <span class="tok-str">&quot;__TEXT&quot;</span>, segment_cmd.segName())) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1679"></span>
<span class="line" id="L1680">                    <span class="tok-kw">const</span> original_address = address - vmaddr_slide;</span>
<span class="line" id="L1681">                    <span class="tok-kw">const</span> seg_start = segment_cmd.vmaddr;</span>
<span class="line" id="L1682">                    <span class="tok-kw">const</span> seg_end = seg_start + segment_cmd.vmsize;</span>
<span class="line" id="L1683">                    <span class="tok-kw">if</span> (original_address &gt;= seg_start <span class="tok-kw">and</span> original_address &lt; seg_end) {</span>
<span class="line" id="L1684">                        <span class="tok-kw">return</span> fs.path.basename(mem.sliceTo(std.c._dyld_get_image_name(i), <span class="tok-number">0</span>));</span>
<span class="line" id="L1685">                    }</span>
<span class="line" id="L1686">                },</span>
<span class="line" id="L1687">                <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L1688">            };</span>
<span class="line" id="L1689">        }</span>
<span class="line" id="L1690"></span>
<span class="line" id="L1691">        <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1692">    }</span>
<span class="line" id="L1693"></span>
<span class="line" id="L1694">    <span class="tok-kw">fn</span> <span class="tok-fn">lookupModuleWin32</span>(self: *DebugInfo, address: <span class="tok-type">usize</span>) !*ModuleDebugInfo {</span>
<span class="line" id="L1695">        <span class="tok-kw">for</span> (self.modules.items) |*module| {</span>
<span class="line" id="L1696">            <span class="tok-kw">if</span> (address &gt;= module.base_address <span class="tok-kw">and</span> address &lt; module.base_address + module.size) {</span>
<span class="line" id="L1697">                <span class="tok-kw">if</span> (self.address_map.get(module.base_address)) |obj_di| {</span>
<span class="line" id="L1698">                    <span class="tok-kw">return</span> obj_di;</span>
<span class="line" id="L1699">                }</span>
<span class="line" id="L1700"></span>
<span class="line" id="L1701">                <span class="tok-kw">const</span> obj_di = <span class="tok-kw">try</span> self.allocator.create(ModuleDebugInfo);</span>
<span class="line" id="L1702">                <span class="tok-kw">errdefer</span> self.allocator.destroy(obj_di);</span>
<span class="line" id="L1703"></span>
<span class="line" id="L1704">                <span class="tok-kw">const</span> mapped_module = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(module.base_address))[<span class="tok-number">0</span>..module.size];</span>
<span class="line" id="L1705">                <span class="tok-kw">var</span> coff_obj = <span class="tok-kw">try</span> coff.Coff.init(mapped_module, <span class="tok-null">true</span>);</span>
<span class="line" id="L1706"></span>
<span class="line" id="L1707">                <span class="tok-comment">// The string table is not mapped into memory by the loader, so if a section name is in the</span>
</span>
<span class="line" id="L1708">                <span class="tok-comment">// string table then we have to map the full image file from disk. This can happen when</span>
</span>
<span class="line" id="L1709">                <span class="tok-comment">// a binary is produced with -gdwarf, since the section names are longer than 8 bytes.</span>
</span>
<span class="line" id="L1710">                <span class="tok-kw">if</span> (coff_obj.strtabRequired()) {</span>
<span class="line" id="L1711">                    <span class="tok-kw">var</span> name_buffer: [windows.PATH_MAX_WIDE + <span class="tok-number">4</span>:<span class="tok-number">0</span>]<span class="tok-type">u16</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1712">                    <span class="tok-comment">// openFileAbsoluteW requires the prefix to be present</span>
</span>
<span class="line" id="L1713">                    mem.copy(<span class="tok-type">u16</span>, name_buffer[<span class="tok-number">0</span>..<span class="tok-number">4</span>], &amp;[_]<span class="tok-type">u16</span>{ <span class="tok-str">'\\'</span>, <span class="tok-str">'?'</span>, <span class="tok-str">'?'</span>, <span class="tok-str">'\\'</span> });</span>
<span class="line" id="L1714"></span>
<span class="line" id="L1715">                    <span class="tok-kw">const</span> process_handle = windows.kernel32.GetCurrentProcess();</span>
<span class="line" id="L1716">                    <span class="tok-kw">const</span> len = windows.kernel32.K32GetModuleFileNameExW(</span>
<span class="line" id="L1717">                        process_handle,</span>
<span class="line" id="L1718">                        module.handle,</span>
<span class="line" id="L1719">                        <span class="tok-builtin">@ptrCast</span>(&amp;name_buffer[<span class="tok-number">4</span>]),</span>
<span class="line" id="L1720">                        windows.PATH_MAX_WIDE,</span>
<span class="line" id="L1721">                    );</span>
<span class="line" id="L1722"></span>
<span class="line" id="L1723">                    <span class="tok-kw">if</span> (len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1724">                    <span class="tok-kw">const</span> coff_file = fs.openFileAbsoluteW(name_buffer[<span class="tok-number">0</span> .. len + <span class="tok-number">4</span> :<span class="tok-number">0</span>], .{}) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1725">                        <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo,</span>
<span class="line" id="L1726">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L1727">                    };</span>
<span class="line" id="L1728">                    <span class="tok-kw">errdefer</span> coff_file.close();</span>
<span class="line" id="L1729"></span>
<span class="line" id="L1730">                    <span class="tok-kw">var</span> section_handle: windows.HANDLE = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1731">                    <span class="tok-kw">const</span> create_section_rc = windows.ntdll.NtCreateSection(</span>
<span class="line" id="L1732">                        &amp;section_handle,</span>
<span class="line" id="L1733">                        windows.STANDARD_RIGHTS_REQUIRED | windows.SECTION_QUERY | windows.SECTION_MAP_READ,</span>
<span class="line" id="L1734">                        <span class="tok-null">null</span>,</span>
<span class="line" id="L1735">                        <span class="tok-null">null</span>,</span>
<span class="line" id="L1736">                        windows.PAGE_READONLY,</span>
<span class="line" id="L1737">                        <span class="tok-comment">// The documentation states that if no AllocationAttribute is specified, then SEC_COMMIT is the default.</span>
</span>
<span class="line" id="L1738">                        <span class="tok-comment">// In practice, this isn't the case and specifying 0 will result in INVALID_PARAMETER_6.</span>
</span>
<span class="line" id="L1739">                        windows.SEC_COMMIT,</span>
<span class="line" id="L1740">                        coff_file.handle,</span>
<span class="line" id="L1741">                    );</span>
<span class="line" id="L1742">                    <span class="tok-kw">if</span> (create_section_rc != .SUCCESS) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1743">                    <span class="tok-kw">errdefer</span> windows.CloseHandle(section_handle);</span>
<span class="line" id="L1744"></span>
<span class="line" id="L1745">                    <span class="tok-kw">var</span> coff_len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1746">                    <span class="tok-kw">var</span> base_ptr: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1747">                    <span class="tok-kw">const</span> map_section_rc = windows.ntdll.NtMapViewOfSection(</span>
<span class="line" id="L1748">                        section_handle,</span>
<span class="line" id="L1749">                        process_handle,</span>
<span class="line" id="L1750">                        <span class="tok-builtin">@ptrCast</span>(&amp;base_ptr),</span>
<span class="line" id="L1751">                        <span class="tok-null">null</span>,</span>
<span class="line" id="L1752">                        <span class="tok-number">0</span>,</span>
<span class="line" id="L1753">                        <span class="tok-null">null</span>,</span>
<span class="line" id="L1754">                        &amp;coff_len,</span>
<span class="line" id="L1755">                        .ViewUnmap,</span>
<span class="line" id="L1756">                        <span class="tok-number">0</span>,</span>
<span class="line" id="L1757">                        windows.PAGE_READONLY,</span>
<span class="line" id="L1758">                    );</span>
<span class="line" id="L1759">                    <span class="tok-kw">if</span> (map_section_rc != .SUCCESS) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1760">                    <span class="tok-kw">errdefer</span> assert(windows.ntdll.NtUnmapViewOfSection(process_handle, <span class="tok-builtin">@ptrFromInt</span>(base_ptr)) == .SUCCESS);</span>
<span class="line" id="L1761"></span>
<span class="line" id="L1762">                    <span class="tok-kw">const</span> section_view = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(base_ptr))[<span class="tok-number">0</span>..coff_len];</span>
<span class="line" id="L1763">                    coff_obj = <span class="tok-kw">try</span> coff.Coff.init(section_view, <span class="tok-null">false</span>);</span>
<span class="line" id="L1764"></span>
<span class="line" id="L1765">                    module.mapped_file = .{</span>
<span class="line" id="L1766">                        .file = coff_file,</span>
<span class="line" id="L1767">                        .section_handle = section_handle,</span>
<span class="line" id="L1768">                        .section_view = section_view,</span>
<span class="line" id="L1769">                    };</span>
<span class="line" id="L1770">                }</span>
<span class="line" id="L1771">                <span class="tok-kw">errdefer</span> <span class="tok-kw">if</span> (module.mapped_file) |mapped_file| mapped_file.deinit();</span>
<span class="line" id="L1772"></span>
<span class="line" id="L1773">                obj_di.* = <span class="tok-kw">try</span> readCoffDebugInfo(self.allocator, &amp;coff_obj);</span>
<span class="line" id="L1774">                obj_di.base_address = module.base_address;</span>
<span class="line" id="L1775"></span>
<span class="line" id="L1776">                <span class="tok-kw">try</span> self.address_map.putNoClobber(module.base_address, obj_di);</span>
<span class="line" id="L1777">                <span class="tok-kw">return</span> obj_di;</span>
<span class="line" id="L1778">            }</span>
<span class="line" id="L1779">        }</span>
<span class="line" id="L1780"></span>
<span class="line" id="L1781">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1782">    }</span>
<span class="line" id="L1783"></span>
<span class="line" id="L1784">    <span class="tok-kw">fn</span> <span class="tok-fn">lookupModuleNameWin32</span>(self: *DebugInfo, address: <span class="tok-type">usize</span>) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1785">        <span class="tok-kw">for</span> (self.modules.items) |module| {</span>
<span class="line" id="L1786">            <span class="tok-kw">if</span> (address &gt;= module.base_address <span class="tok-kw">and</span> address &lt; module.base_address + module.size) {</span>
<span class="line" id="L1787">                <span class="tok-kw">return</span> module.name;</span>
<span class="line" id="L1788">            }</span>
<span class="line" id="L1789">        }</span>
<span class="line" id="L1790">        <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1791">    }</span>
<span class="line" id="L1792"></span>
<span class="line" id="L1793">    <span class="tok-kw">fn</span> <span class="tok-fn">lookupModuleNameDl</span>(self: *DebugInfo, address: <span class="tok-type">usize</span>) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1794">        _ = self;</span>
<span class="line" id="L1795"></span>
<span class="line" id="L1796">        <span class="tok-kw">var</span> ctx: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1797">            <span class="tok-comment">// Input</span>
</span>
<span class="line" id="L1798">            address: <span class="tok-type">usize</span>,</span>
<span class="line" id="L1799">            <span class="tok-comment">// Output</span>
</span>
<span class="line" id="L1800">            name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;&quot;</span>,</span>
<span class="line" id="L1801">        } = .{ .address = address };</span>
<span class="line" id="L1802">        <span class="tok-kw">const</span> CtxTy = <span class="tok-builtin">@TypeOf</span>(ctx);</span>
<span class="line" id="L1803"></span>
<span class="line" id="L1804">        <span class="tok-kw">if</span> (os.dl_iterate_phdr(&amp;ctx, <span class="tok-kw">error</span>{Found}, <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1805">            <span class="tok-kw">fn</span> <span class="tok-fn">callback</span>(info: *os.dl_phdr_info, size: <span class="tok-type">usize</span>, context: *CtxTy) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1806">                _ = size;</span>
<span class="line" id="L1807">                <span class="tok-kw">if</span> (context.address &lt; info.dlpi_addr) <span class="tok-kw">return</span>;</span>
<span class="line" id="L1808">                <span class="tok-kw">const</span> phdrs = info.dlpi_phdr[<span class="tok-number">0</span>..info.dlpi_phnum];</span>
<span class="line" id="L1809">                <span class="tok-kw">for</span> (phdrs) |*phdr| {</span>
<span class="line" id="L1810">                    <span class="tok-kw">if</span> (phdr.p_type != elf.PT_LOAD) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1811"></span>
<span class="line" id="L1812">                    <span class="tok-kw">const</span> seg_start = info.dlpi_addr +% phdr.p_vaddr;</span>
<span class="line" id="L1813">                    <span class="tok-kw">const</span> seg_end = seg_start + phdr.p_memsz;</span>
<span class="line" id="L1814">                    <span class="tok-kw">if</span> (context.address &gt;= seg_start <span class="tok-kw">and</span> context.address &lt; seg_end) {</span>
<span class="line" id="L1815">                        context.name = mem.sliceTo(info.dlpi_name, <span class="tok-number">0</span>) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;&quot;</span>;</span>
<span class="line" id="L1816">                        <span class="tok-kw">break</span>;</span>
<span class="line" id="L1817">                    }</span>
<span class="line" id="L1818">                } <span class="tok-kw">else</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L1819"></span>
<span class="line" id="L1820">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Found;</span>
<span class="line" id="L1821">            }</span>
<span class="line" id="L1822">        }.callback)) {</span>
<span class="line" id="L1823">            <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1824">        } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1825">            <span class="tok-kw">error</span>.Found =&gt; <span class="tok-kw">return</span> fs.path.basename(ctx.name),</span>
<span class="line" id="L1826">        }</span>
<span class="line" id="L1827"></span>
<span class="line" id="L1828">        <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1829">    }</span>
<span class="line" id="L1830"></span>
<span class="line" id="L1831">    <span class="tok-kw">fn</span> <span class="tok-fn">lookupModuleDl</span>(self: *DebugInfo, address: <span class="tok-type">usize</span>) !*ModuleDebugInfo {</span>
<span class="line" id="L1832">        <span class="tok-kw">var</span> ctx: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1833">            <span class="tok-comment">// Input</span>
</span>
<span class="line" id="L1834">            address: <span class="tok-type">usize</span>,</span>
<span class="line" id="L1835">            <span class="tok-comment">// Output</span>
</span>
<span class="line" id="L1836">            base_address: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L1837">            name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L1838">            build_id: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L1839">            gnu_eh_frame: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L1840">        } = .{ .address = address };</span>
<span class="line" id="L1841">        <span class="tok-kw">const</span> CtxTy = <span class="tok-builtin">@TypeOf</span>(ctx);</span>
<span class="line" id="L1842"></span>
<span class="line" id="L1843">        <span class="tok-kw">if</span> (os.dl_iterate_phdr(&amp;ctx, <span class="tok-kw">error</span>{Found}, <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1844">            <span class="tok-kw">fn</span> <span class="tok-fn">callback</span>(info: *os.dl_phdr_info, size: <span class="tok-type">usize</span>, context: *CtxTy) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1845">                _ = size;</span>
<span class="line" id="L1846">                <span class="tok-comment">// The base address is too high</span>
</span>
<span class="line" id="L1847">                <span class="tok-kw">if</span> (context.address &lt; info.dlpi_addr)</span>
<span class="line" id="L1848">                    <span class="tok-kw">return</span>;</span>
<span class="line" id="L1849"></span>
<span class="line" id="L1850">                <span class="tok-kw">const</span> phdrs = info.dlpi_phdr[<span class="tok-number">0</span>..info.dlpi_phnum];</span>
<span class="line" id="L1851">                <span class="tok-kw">for</span> (phdrs) |*phdr| {</span>
<span class="line" id="L1852">                    <span class="tok-kw">if</span> (phdr.p_type != elf.PT_LOAD) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1853"></span>
<span class="line" id="L1854">                    <span class="tok-comment">// Overflowing addition is used to handle the case of VSDOs having a p_vaddr = 0xffffffffff700000</span>
</span>
<span class="line" id="L1855">                    <span class="tok-kw">const</span> seg_start = info.dlpi_addr +% phdr.p_vaddr;</span>
<span class="line" id="L1856">                    <span class="tok-kw">const</span> seg_end = seg_start + phdr.p_memsz;</span>
<span class="line" id="L1857">                    <span class="tok-kw">if</span> (context.address &gt;= seg_start <span class="tok-kw">and</span> context.address &lt; seg_end) {</span>
<span class="line" id="L1858">                        <span class="tok-comment">// Android libc uses NULL instead of an empty string to mark the</span>
</span>
<span class="line" id="L1859">                        <span class="tok-comment">// main program</span>
</span>
<span class="line" id="L1860">                        context.name = mem.sliceTo(info.dlpi_name, <span class="tok-number">0</span>) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;&quot;</span>;</span>
<span class="line" id="L1861">                        context.base_address = info.dlpi_addr;</span>
<span class="line" id="L1862">                        <span class="tok-kw">break</span>;</span>
<span class="line" id="L1863">                    }</span>
<span class="line" id="L1864">                } <span class="tok-kw">else</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L1865"></span>
<span class="line" id="L1866">                <span class="tok-kw">for</span> (info.dlpi_phdr[<span class="tok-number">0</span>..info.dlpi_phnum]) |phdr| {</span>
<span class="line" id="L1867">                    <span class="tok-kw">switch</span> (phdr.p_type) {</span>
<span class="line" id="L1868">                        elf.PT_NOTE =&gt; {</span>
<span class="line" id="L1869">                            <span class="tok-comment">// Look for .note.gnu.build-id</span>
</span>
<span class="line" id="L1870">                            <span class="tok-kw">const</span> note_bytes = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(info.dlpi_addr + phdr.p_vaddr))[<span class="tok-number">0</span>..phdr.p_memsz];</span>
<span class="line" id="L1871">                            <span class="tok-kw">const</span> name_size = mem.readInt(<span class="tok-type">u32</span>, note_bytes[<span class="tok-number">0</span>..<span class="tok-number">4</span>], native_endian);</span>
<span class="line" id="L1872">                            <span class="tok-kw">if</span> (name_size != <span class="tok-number">4</span>) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1873">                            <span class="tok-kw">const</span> desc_size = mem.readInt(<span class="tok-type">u32</span>, note_bytes[<span class="tok-number">4</span>..<span class="tok-number">8</span>], native_endian);</span>
<span class="line" id="L1874">                            <span class="tok-kw">const</span> note_type = mem.readInt(<span class="tok-type">u32</span>, note_bytes[<span class="tok-number">8</span>..<span class="tok-number">12</span>], native_endian);</span>
<span class="line" id="L1875">                            <span class="tok-kw">if</span> (note_type != elf.NT_GNU_BUILD_ID) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1876">                            <span class="tok-kw">if</span> (!mem.eql(<span class="tok-type">u8</span>, <span class="tok-str">&quot;GNU\x00&quot;</span>, note_bytes[<span class="tok-number">12</span>..<span class="tok-number">16</span>])) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1877">                            context.build_id = note_bytes[<span class="tok-number">16</span>..][<span class="tok-number">0</span>..desc_size];</span>
<span class="line" id="L1878">                        },</span>
<span class="line" id="L1879">                        elf.PT_GNU_EH_FRAME =&gt; {</span>
<span class="line" id="L1880">                            context.gnu_eh_frame = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(info.dlpi_addr + phdr.p_vaddr))[<span class="tok-number">0</span>..phdr.p_memsz];</span>
<span class="line" id="L1881">                        },</span>
<span class="line" id="L1882">                        <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L1883">                    }</span>
<span class="line" id="L1884">                }</span>
<span class="line" id="L1885"></span>
<span class="line" id="L1886">                <span class="tok-comment">// Stop the iteration</span>
</span>
<span class="line" id="L1887">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Found;</span>
<span class="line" id="L1888">            }</span>
<span class="line" id="L1889">        }.callback)) {</span>
<span class="line" id="L1890">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1891">        } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1892">            <span class="tok-kw">error</span>.Found =&gt; {},</span>
<span class="line" id="L1893">        }</span>
<span class="line" id="L1894"></span>
<span class="line" id="L1895">        <span class="tok-kw">if</span> (self.address_map.get(ctx.base_address)) |obj_di| {</span>
<span class="line" id="L1896">            <span class="tok-kw">return</span> obj_di;</span>
<span class="line" id="L1897">        }</span>
<span class="line" id="L1898"></span>
<span class="line" id="L1899">        <span class="tok-kw">const</span> obj_di = <span class="tok-kw">try</span> self.allocator.create(ModuleDebugInfo);</span>
<span class="line" id="L1900">        <span class="tok-kw">errdefer</span> self.allocator.destroy(obj_di);</span>
<span class="line" id="L1901"></span>
<span class="line" id="L1902">        <span class="tok-kw">var</span> sections: DW.DwarfInfo.SectionArray = DW.DwarfInfo.null_section_array;</span>
<span class="line" id="L1903">        <span class="tok-kw">if</span> (ctx.gnu_eh_frame) |eh_frame_hdr| {</span>
<span class="line" id="L1904">            <span class="tok-comment">// This is a special case - pointer offsets inside .eh_frame_hdr</span>
</span>
<span class="line" id="L1905">            <span class="tok-comment">// are encoded relative to its base address, so we must use the</span>
</span>
<span class="line" id="L1906">            <span class="tok-comment">// version that is already memory mapped, and not the one that</span>
</span>
<span class="line" id="L1907">            <span class="tok-comment">// will be mapped separately from the ELF file.</span>
</span>
<span class="line" id="L1908">            sections[<span class="tok-builtin">@intFromEnum</span>(DW.DwarfSection.eh_frame_hdr)] = .{</span>
<span class="line" id="L1909">                .data = eh_frame_hdr,</span>
<span class="line" id="L1910">                .owned = <span class="tok-null">false</span>,</span>
<span class="line" id="L1911">            };</span>
<span class="line" id="L1912">        }</span>
<span class="line" id="L1913"></span>
<span class="line" id="L1914">        obj_di.* = <span class="tok-kw">try</span> readElfDebugInfo(self.allocator, <span class="tok-kw">if</span> (ctx.name.len &gt; <span class="tok-number">0</span>) ctx.name <span class="tok-kw">else</span> <span class="tok-null">null</span>, ctx.build_id, <span class="tok-null">null</span>, &amp;sections, <span class="tok-null">null</span>);</span>
<span class="line" id="L1915">        obj_di.base_address = ctx.base_address;</span>
<span class="line" id="L1916"></span>
<span class="line" id="L1917">        <span class="tok-comment">// Missing unwind info isn't treated as a failure, as the unwinder will fall back to FP-based unwinding</span>
</span>
<span class="line" id="L1918">        obj_di.dwarf.scanAllUnwindInfo(self.allocator, ctx.base_address) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L1919"></span>
<span class="line" id="L1920">        <span class="tok-kw">try</span> self.address_map.putNoClobber(ctx.base_address, obj_di);</span>
<span class="line" id="L1921"></span>
<span class="line" id="L1922">        <span class="tok-kw">return</span> obj_di;</span>
<span class="line" id="L1923">    }</span>
<span class="line" id="L1924"></span>
<span class="line" id="L1925">    <span class="tok-kw">fn</span> <span class="tok-fn">lookupModuleHaiku</span>(self: *DebugInfo, address: <span class="tok-type">usize</span>) !*ModuleDebugInfo {</span>
<span class="line" id="L1926">        _ = self;</span>
<span class="line" id="L1927">        _ = address;</span>
<span class="line" id="L1928">        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;TODO implement lookup module for Haiku&quot;</span>);</span>
<span class="line" id="L1929">    }</span>
<span class="line" id="L1930"></span>
<span class="line" id="L1931">    <span class="tok-kw">fn</span> <span class="tok-fn">lookupModuleWasm</span>(self: *DebugInfo, address: <span class="tok-type">usize</span>) !*ModuleDebugInfo {</span>
<span class="line" id="L1932">        _ = self;</span>
<span class="line" id="L1933">        _ = address;</span>
<span class="line" id="L1934">        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;TODO implement lookup module for Wasm&quot;</span>);</span>
<span class="line" id="L1935">    }</span>
<span class="line" id="L1936">};</span>
<span class="line" id="L1937"></span>
<span class="line" id="L1938"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ModuleDebugInfo = <span class="tok-kw">switch</span> (native_os) {</span>
<span class="line" id="L1939">    .macos, .ios, .watchos, .tvos =&gt; <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1940">        base_address: <span class="tok-type">usize</span>,</span>
<span class="line" id="L1941">        vmaddr_slide: <span class="tok-type">usize</span>,</span>
<span class="line" id="L1942">        mapped_memory: []<span class="tok-kw">align</span>(mem.page_size) <span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1943">        symbols: []<span class="tok-kw">const</span> MachoSymbol,</span>
<span class="line" id="L1944">        strings: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1945">        ofiles: OFileTable,</span>
<span class="line" id="L1946"></span>
<span class="line" id="L1947">        <span class="tok-comment">// Backed by the in-memory sections mapped by the loader</span>
</span>
<span class="line" id="L1948">        unwind_info: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L1949">        eh_frame: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L1950"></span>
<span class="line" id="L1951">        <span class="tok-kw">const</span> OFileTable = std.StringHashMap(OFileInfo);</span>
<span class="line" id="L1952">        <span class="tok-kw">const</span> OFileInfo = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1953">            di: DW.DwarfInfo,</span>
<span class="line" id="L1954">            addr_table: std.StringHashMap(<span class="tok-type">u64</span>),</span>
<span class="line" id="L1955">        };</span>
<span class="line" id="L1956"></span>
<span class="line" id="L1957">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L1958">            <span class="tok-kw">var</span> it = self.ofiles.iterator();</span>
<span class="line" id="L1959">            <span class="tok-kw">while</span> (it.next()) |entry| {</span>
<span class="line" id="L1960">                <span class="tok-kw">const</span> ofile = entry.value_ptr;</span>
<span class="line" id="L1961">                ofile.di.deinit(allocator);</span>
<span class="line" id="L1962">                ofile.addr_table.deinit();</span>
<span class="line" id="L1963">            }</span>
<span class="line" id="L1964">            self.ofiles.deinit();</span>
<span class="line" id="L1965">            allocator.free(self.symbols);</span>
<span class="line" id="L1966">            os.munmap(self.mapped_memory);</span>
<span class="line" id="L1967">        }</span>
<span class="line" id="L1968"></span>
<span class="line" id="L1969">        <span class="tok-kw">fn</span> <span class="tok-fn">loadOFile</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator, o_file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !*OFileInfo {</span>
<span class="line" id="L1970">            <span class="tok-kw">const</span> o_file = <span class="tok-kw">try</span> fs.cwd().openFile(o_file_path, .{ .intended_io_mode = .blocking });</span>
<span class="line" id="L1971">            <span class="tok-kw">const</span> mapped_mem = <span class="tok-kw">try</span> mapWholeFile(o_file);</span>
<span class="line" id="L1972"></span>
<span class="line" id="L1973">            <span class="tok-kw">const</span> hdr: *<span class="tok-kw">const</span> macho.mach_header_64 = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(mapped_mem.ptr));</span>
<span class="line" id="L1974">            <span class="tok-kw">if</span> (hdr.magic != std.macho.MH_MAGIC_64)</span>
<span class="line" id="L1975">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo;</span>
<span class="line" id="L1976"></span>
<span class="line" id="L1977">            <span class="tok-kw">var</span> segcmd: ?macho.LoadCommandIterator.LoadCommand = <span class="tok-null">null</span>;</span>
<span class="line" id="L1978">            <span class="tok-kw">var</span> symtabcmd: ?macho.symtab_command = <span class="tok-null">null</span>;</span>
<span class="line" id="L1979">            <span class="tok-kw">var</span> it = macho.LoadCommandIterator{</span>
<span class="line" id="L1980">                .ncmds = hdr.ncmds,</span>
<span class="line" id="L1981">                .buffer = mapped_mem[<span class="tok-builtin">@sizeOf</span>(macho.mach_header_64)..][<span class="tok-number">0</span>..hdr.sizeofcmds],</span>
<span class="line" id="L1982">            };</span>
<span class="line" id="L1983">            <span class="tok-kw">while</span> (it.next()) |cmd| <span class="tok-kw">switch</span> (cmd.cmd()) {</span>
<span class="line" id="L1984">                .SEGMENT_64 =&gt; segcmd = cmd,</span>
<span class="line" id="L1985">                .SYMTAB =&gt; symtabcmd = cmd.cast(macho.symtab_command).?,</span>
<span class="line" id="L1986">                <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L1987">            };</span>
<span class="line" id="L1988"></span>
<span class="line" id="L1989">            <span class="tok-kw">if</span> (segcmd == <span class="tok-null">null</span> <span class="tok-kw">or</span> symtabcmd == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1990"></span>
<span class="line" id="L1991">            <span class="tok-comment">// Parse symbols</span>
</span>
<span class="line" id="L1992">            <span class="tok-kw">const</span> strtab = <span class="tok-builtin">@as</span>(</span>
<span class="line" id="L1993">                [*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1994">                <span class="tok-builtin">@ptrCast</span>(&amp;mapped_mem[symtabcmd.?.stroff]),</span>
<span class="line" id="L1995">            )[<span class="tok-number">0</span> .. symtabcmd.?.strsize - <span class="tok-number">1</span> :<span class="tok-number">0</span>];</span>
<span class="line" id="L1996">            <span class="tok-kw">const</span> symtab = <span class="tok-builtin">@as</span>(</span>
<span class="line" id="L1997">                [*]<span class="tok-kw">const</span> macho.nlist_64,</span>
<span class="line" id="L1998">                <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;mapped_mem[symtabcmd.?.symoff])),</span>
<span class="line" id="L1999">            )[<span class="tok-number">0</span>..symtabcmd.?.nsyms];</span>
<span class="line" id="L2000"></span>
<span class="line" id="L2001">            <span class="tok-comment">// TODO handle tentative (common) symbols</span>
</span>
<span class="line" id="L2002">            <span class="tok-kw">var</span> addr_table = std.StringHashMap(<span class="tok-type">u64</span>).init(allocator);</span>
<span class="line" id="L2003">            <span class="tok-kw">try</span> addr_table.ensureTotalCapacity(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(symtab.len)));</span>
<span class="line" id="L2004">            <span class="tok-kw">for</span> (symtab) |sym| {</span>
<span class="line" id="L2005">                <span class="tok-kw">if</span> (sym.n_strx == <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L2006">                <span class="tok-kw">if</span> (sym.undf() <span class="tok-kw">or</span> sym.tentative() <span class="tok-kw">or</span> sym.abs()) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L2007">                <span class="tok-kw">const</span> sym_name = mem.sliceTo(strtab[sym.n_strx..], <span class="tok-number">0</span>);</span>
<span class="line" id="L2008">                <span class="tok-comment">// TODO is it possible to have a symbol collision?</span>
</span>
<span class="line" id="L2009">                addr_table.putAssumeCapacityNoClobber(sym_name, sym.n_value);</span>
<span class="line" id="L2010">            }</span>
<span class="line" id="L2011"></span>
<span class="line" id="L2012">            <span class="tok-kw">var</span> sections: DW.DwarfInfo.SectionArray = DW.DwarfInfo.null_section_array;</span>
<span class="line" id="L2013">            <span class="tok-kw">if</span> (self.eh_frame) |eh_frame| sections[<span class="tok-builtin">@intFromEnum</span>(DW.DwarfSection.eh_frame)] = .{</span>
<span class="line" id="L2014">                .data = eh_frame,</span>
<span class="line" id="L2015">                .owned = <span class="tok-null">false</span>,</span>
<span class="line" id="L2016">            };</span>
<span class="line" id="L2017"></span>
<span class="line" id="L2018">            <span class="tok-kw">for</span> (segcmd.?.getSections()) |sect| {</span>
<span class="line" id="L2019">                <span class="tok-kw">if</span> (!std.mem.eql(<span class="tok-type">u8</span>, <span class="tok-str">&quot;__DWARF&quot;</span>, sect.segName())) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L2020"></span>
<span class="line" id="L2021">                <span class="tok-kw">var</span> section_index: ?<span class="tok-type">usize</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L2022">                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(DW.DwarfSection).Enum.fields, <span class="tok-number">0</span>..) |section, i| {</span>
<span class="line" id="L2023">                    <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, <span class="tok-str">&quot;__&quot;</span> ++ section.name, sect.sectName())) section_index = i;</span>
<span class="line" id="L2024">                }</span>
<span class="line" id="L2025">                <span class="tok-kw">if</span> (section_index == <span class="tok-null">null</span>) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L2026"></span>
<span class="line" id="L2027">                <span class="tok-kw">const</span> section_bytes = <span class="tok-kw">try</span> chopSlice(mapped_mem, sect.offset, sect.size);</span>
<span class="line" id="L2028">                sections[section_index.?] = .{</span>
<span class="line" id="L2029">                    .data = section_bytes,</span>
<span class="line" id="L2030">                    .virtual_address = sect.addr,</span>
<span class="line" id="L2031">                    .owned = <span class="tok-null">false</span>,</span>
<span class="line" id="L2032">                };</span>
<span class="line" id="L2033">            }</span>
<span class="line" id="L2034"></span>
<span class="line" id="L2035">            <span class="tok-kw">const</span> missing_debug_info =</span>
<span class="line" id="L2036">                sections[<span class="tok-builtin">@intFromEnum</span>(DW.DwarfSection.debug_info)] == <span class="tok-null">null</span> <span class="tok-kw">or</span></span>
<span class="line" id="L2037">                sections[<span class="tok-builtin">@intFromEnum</span>(DW.DwarfSection.debug_abbrev)] == <span class="tok-null">null</span> <span class="tok-kw">or</span></span>
<span class="line" id="L2038">                sections[<span class="tok-builtin">@intFromEnum</span>(DW.DwarfSection.debug_str)] == <span class="tok-null">null</span> <span class="tok-kw">or</span></span>
<span class="line" id="L2039">                sections[<span class="tok-builtin">@intFromEnum</span>(DW.DwarfSection.debug_line)] == <span class="tok-null">null</span>;</span>
<span class="line" id="L2040">            <span class="tok-kw">if</span> (missing_debug_info) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L2041"></span>
<span class="line" id="L2042">            <span class="tok-kw">var</span> di = DW.DwarfInfo{</span>
<span class="line" id="L2043">                .endian = .little,</span>
<span class="line" id="L2044">                .sections = sections,</span>
<span class="line" id="L2045">                .is_macho = <span class="tok-null">true</span>,</span>
<span class="line" id="L2046">            };</span>
<span class="line" id="L2047"></span>
<span class="line" id="L2048">            <span class="tok-kw">try</span> DW.openDwarfDebugInfo(&amp;di, allocator);</span>
<span class="line" id="L2049">            <span class="tok-kw">var</span> info = OFileInfo{</span>
<span class="line" id="L2050">                .di = di,</span>
<span class="line" id="L2051">                .addr_table = addr_table,</span>
<span class="line" id="L2052">            };</span>
<span class="line" id="L2053"></span>
<span class="line" id="L2054">            <span class="tok-comment">// Add the debug info to the cache</span>
</span>
<span class="line" id="L2055">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.ofiles.getOrPut(o_file_path);</span>
<span class="line" id="L2056">            assert(!result.found_existing);</span>
<span class="line" id="L2057">            result.value_ptr.* = info;</span>
<span class="line" id="L2058"></span>
<span class="line" id="L2059">            <span class="tok-kw">return</span> result.value_ptr;</span>
<span class="line" id="L2060">        }</span>
<span class="line" id="L2061"></span>
<span class="line" id="L2062">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSymbolAtAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator, address: <span class="tok-type">usize</span>) !SymbolInfo {</span>
<span class="line" id="L2063">            <span class="tok-kw">nosuspend</span> {</span>
<span class="line" id="L2064">                <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.getOFileInfoForAddress(allocator, address);</span>
<span class="line" id="L2065">                <span class="tok-kw">if</span> (result.symbol == <span class="tok-null">null</span>) <span class="tok-kw">return</span> .{};</span>
<span class="line" id="L2066"></span>
<span class="line" id="L2067">                <span class="tok-comment">// Take the symbol name from the N_FUN STAB entry, we're going to</span>
</span>
<span class="line" id="L2068">                <span class="tok-comment">// use it if we fail to find the DWARF infos</span>
</span>
<span class="line" id="L2069">                <span class="tok-kw">const</span> stab_symbol = mem.sliceTo(self.strings[result.symbol.?.strx..], <span class="tok-number">0</span>);</span>
<span class="line" id="L2070">                <span class="tok-kw">if</span> (result.o_file_info == <span class="tok-null">null</span>) <span class="tok-kw">return</span> .{ .symbol_name = stab_symbol };</span>
<span class="line" id="L2071"></span>
<span class="line" id="L2072">                <span class="tok-comment">// Translate again the address, this time into an address inside the</span>
</span>
<span class="line" id="L2073">                <span class="tok-comment">// .o file</span>
</span>
<span class="line" id="L2074">                <span class="tok-kw">const</span> relocated_address_o = result.o_file_info.?.addr_table.get(stab_symbol) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> .{</span>
<span class="line" id="L2075">                    .symbol_name = <span class="tok-str">&quot;???&quot;</span>,</span>
<span class="line" id="L2076">                };</span>
<span class="line" id="L2077"></span>
<span class="line" id="L2078">                <span class="tok-kw">const</span> addr_off = result.relocated_address - result.symbol.?.addr;</span>
<span class="line" id="L2079">                <span class="tok-kw">const</span> o_file_di = &amp;result.o_file_info.?.di;</span>
<span class="line" id="L2080">                <span class="tok-kw">if</span> (o_file_di.findCompileUnit(relocated_address_o)) |compile_unit| {</span>
<span class="line" id="L2081">                    <span class="tok-kw">return</span> SymbolInfo{</span>
<span class="line" id="L2082">                        .symbol_name = o_file_di.getSymbolName(relocated_address_o) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;???&quot;</span>,</span>
<span class="line" id="L2083">                        .compile_unit_name = compile_unit.die.getAttrString(</span>
<span class="line" id="L2084">                            o_file_di,</span>
<span class="line" id="L2085">                            DW.AT.name,</span>
<span class="line" id="L2086">                            o_file_di.section(.debug_str),</span>
<span class="line" id="L2087">                            compile_unit.*,</span>
<span class="line" id="L2088">                        ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2089">                            <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; <span class="tok-str">&quot;???&quot;</span>,</span>
<span class="line" id="L2090">                        },</span>
<span class="line" id="L2091">                        .line_info = o_file_di.getLineNumberInfo(</span>
<span class="line" id="L2092">                            allocator,</span>
<span class="line" id="L2093">                            compile_unit.*,</span>
<span class="line" id="L2094">                            relocated_address_o + addr_off,</span>
<span class="line" id="L2095">                        ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2096">                            <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; <span class="tok-null">null</span>,</span>
<span class="line" id="L2097">                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L2098">                        },</span>
<span class="line" id="L2099">                    };</span>
<span class="line" id="L2100">                } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2101">                    <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; {</span>
<span class="line" id="L2102">                        <span class="tok-kw">return</span> SymbolInfo{ .symbol_name = stab_symbol };</span>
<span class="line" id="L2103">                    },</span>
<span class="line" id="L2104">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L2105">                }</span>
<span class="line" id="L2106">            }</span>
<span class="line" id="L2107">        }</span>
<span class="line" id="L2108"></span>
<span class="line" id="L2109">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOFileInfoForAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator, address: <span class="tok-type">usize</span>) !<span class="tok-kw">struct</span> {</span>
<span class="line" id="L2110">            relocated_address: <span class="tok-type">usize</span>,</span>
<span class="line" id="L2111">            symbol: ?*<span class="tok-kw">const</span> MachoSymbol = <span class="tok-null">null</span>,</span>
<span class="line" id="L2112">            o_file_info: ?*OFileInfo = <span class="tok-null">null</span>,</span>
<span class="line" id="L2113">        } {</span>
<span class="line" id="L2114">            <span class="tok-kw">nosuspend</span> {</span>
<span class="line" id="L2115">                <span class="tok-comment">// Translate the VA into an address into this object</span>
</span>
<span class="line" id="L2116">                <span class="tok-kw">const</span> relocated_address = address - self.vmaddr_slide;</span>
<span class="line" id="L2117"></span>
<span class="line" id="L2118">                <span class="tok-comment">// Find the .o file where this symbol is defined</span>
</span>
<span class="line" id="L2119">                <span class="tok-kw">const</span> symbol = machoSearchSymbols(self.symbols, relocated_address) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> .{</span>
<span class="line" id="L2120">                    .relocated_address = relocated_address,</span>
<span class="line" id="L2121">                };</span>
<span class="line" id="L2122"></span>
<span class="line" id="L2123">                <span class="tok-comment">// Check if its debug infos are already in the cache</span>
</span>
<span class="line" id="L2124">                <span class="tok-kw">const</span> o_file_path = mem.sliceTo(self.strings[symbol.ofile..], <span class="tok-number">0</span>);</span>
<span class="line" id="L2125">                <span class="tok-kw">var</span> o_file_info = self.ofiles.getPtr(o_file_path) <span class="tok-kw">orelse</span></span>
<span class="line" id="L2126">                    (self.loadOFile(allocator, o_file_path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2127">                    <span class="tok-kw">error</span>.FileNotFound,</span>
<span class="line" id="L2128">                    <span class="tok-kw">error</span>.MissingDebugInfo,</span>
<span class="line" id="L2129">                    <span class="tok-kw">error</span>.InvalidDebugInfo,</span>
<span class="line" id="L2130">                    =&gt; <span class="tok-kw">return</span> .{</span>
<span class="line" id="L2131">                        .relocated_address = relocated_address,</span>
<span class="line" id="L2132">                        .symbol = symbol,</span>
<span class="line" id="L2133">                    },</span>
<span class="line" id="L2134">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L2135">                });</span>
<span class="line" id="L2136"></span>
<span class="line" id="L2137">                <span class="tok-kw">return</span> .{</span>
<span class="line" id="L2138">                    .relocated_address = relocated_address,</span>
<span class="line" id="L2139">                    .symbol = symbol,</span>
<span class="line" id="L2140">                    .o_file_info = o_file_info,</span>
<span class="line" id="L2141">                };</span>
<span class="line" id="L2142">            }</span>
<span class="line" id="L2143">        }</span>
<span class="line" id="L2144"></span>
<span class="line" id="L2145">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getDwarfInfoForAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator, address: <span class="tok-type">usize</span>) !?*<span class="tok-kw">const</span> DW.DwarfInfo {</span>
<span class="line" id="L2146">            <span class="tok-kw">return</span> <span class="tok-kw">if</span> ((<span class="tok-kw">try</span> self.getOFileInfoForAddress(allocator, address)).o_file_info) |o_file_info| &amp;o_file_info.di <span class="tok-kw">else</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2147">        }</span>
<span class="line" id="L2148">    },</span>
<span class="line" id="L2149">    .uefi, .windows =&gt; <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2150">        base_address: <span class="tok-type">usize</span>,</span>
<span class="line" id="L2151">        pdb: ?pdb.Pdb = <span class="tok-null">null</span>,</span>
<span class="line" id="L2152">        dwarf: ?DW.DwarfInfo = <span class="tok-null">null</span>,</span>
<span class="line" id="L2153">        coff_image_base: <span class="tok-type">u64</span>,</span>
<span class="line" id="L2154"></span>
<span class="line" id="L2155">        <span class="tok-comment">/// Only used if pdb is non-null</span></span>
<span class="line" id="L2156">        coff_section_headers: []coff.SectionHeader,</span>
<span class="line" id="L2157"></span>
<span class="line" id="L2158">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L2159">            <span class="tok-kw">if</span> (self.dwarf) |*dwarf| {</span>
<span class="line" id="L2160">                dwarf.deinit(allocator);</span>
<span class="line" id="L2161">            }</span>
<span class="line" id="L2162"></span>
<span class="line" id="L2163">            <span class="tok-kw">if</span> (self.pdb) |*p| {</span>
<span class="line" id="L2164">                p.deinit();</span>
<span class="line" id="L2165">                allocator.free(self.coff_section_headers);</span>
<span class="line" id="L2166">            }</span>
<span class="line" id="L2167">        }</span>
<span class="line" id="L2168"></span>
<span class="line" id="L2169">        <span class="tok-kw">fn</span> <span class="tok-fn">getSymbolFromPdb</span>(self: *<span class="tok-builtin">@This</span>(), relocated_address: <span class="tok-type">usize</span>) !?SymbolInfo {</span>
<span class="line" id="L2170">            <span class="tok-kw">var</span> coff_section: *<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> coff.SectionHeader = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L2171">            <span class="tok-kw">const</span> mod_index = <span class="tok-kw">for</span> (self.pdb.?.sect_contribs) |sect_contrib| {</span>
<span class="line" id="L2172">                <span class="tok-kw">if</span> (sect_contrib.Section &gt; self.coff_section_headers.len) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L2173">                <span class="tok-comment">// Remember that SectionContribEntry.Section is 1-based.</span>
</span>
<span class="line" id="L2174">                coff_section = &amp;self.coff_section_headers[sect_contrib.Section - <span class="tok-number">1</span>];</span>
<span class="line" id="L2175"></span>
<span class="line" id="L2176">                <span class="tok-kw">const</span> vaddr_start = coff_section.virtual_address + sect_contrib.Offset;</span>
<span class="line" id="L2177">                <span class="tok-kw">const</span> vaddr_end = vaddr_start + sect_contrib.Size;</span>
<span class="line" id="L2178">                <span class="tok-kw">if</span> (relocated_address &gt;= vaddr_start <span class="tok-kw">and</span> relocated_address &lt; vaddr_end) {</span>
<span class="line" id="L2179">                    <span class="tok-kw">break</span> sect_contrib.ModuleIndex;</span>
<span class="line" id="L2180">                }</span>
<span class="line" id="L2181">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2182">                <span class="tok-comment">// we have no information to add to the address</span>
</span>
<span class="line" id="L2183">                <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2184">            };</span>
<span class="line" id="L2185"></span>
<span class="line" id="L2186">            <span class="tok-kw">const</span> module = (<span class="tok-kw">try</span> self.pdb.?.getModule(mod_index)) <span class="tok-kw">orelse</span></span>
<span class="line" id="L2187">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo;</span>
<span class="line" id="L2188">            <span class="tok-kw">const</span> obj_basename = fs.path.basename(module.obj_file_name);</span>
<span class="line" id="L2189"></span>
<span class="line" id="L2190">            <span class="tok-kw">const</span> symbol_name = self.pdb.?.getSymbolName(</span>
<span class="line" id="L2191">                module,</span>
<span class="line" id="L2192">                relocated_address - coff_section.virtual_address,</span>
<span class="line" id="L2193">            ) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;???&quot;</span>;</span>
<span class="line" id="L2194">            <span class="tok-kw">const</span> opt_line_info = <span class="tok-kw">try</span> self.pdb.?.getLineNumberInfo(</span>
<span class="line" id="L2195">                module,</span>
<span class="line" id="L2196">                relocated_address - coff_section.virtual_address,</span>
<span class="line" id="L2197">            );</span>
<span class="line" id="L2198"></span>
<span class="line" id="L2199">            <span class="tok-kw">return</span> SymbolInfo{</span>
<span class="line" id="L2200">                .symbol_name = symbol_name,</span>
<span class="line" id="L2201">                .compile_unit_name = obj_basename,</span>
<span class="line" id="L2202">                .line_info = opt_line_info,</span>
<span class="line" id="L2203">            };</span>
<span class="line" id="L2204">        }</span>
<span class="line" id="L2205"></span>
<span class="line" id="L2206">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSymbolAtAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator, address: <span class="tok-type">usize</span>) !SymbolInfo {</span>
<span class="line" id="L2207">            <span class="tok-comment">// Translate the VA into an address into this object</span>
</span>
<span class="line" id="L2208">            <span class="tok-kw">const</span> relocated_address = address - self.base_address;</span>
<span class="line" id="L2209"></span>
<span class="line" id="L2210">            <span class="tok-kw">if</span> (self.pdb != <span class="tok-null">null</span>) {</span>
<span class="line" id="L2211">                <span class="tok-kw">if</span> (<span class="tok-kw">try</span> self.getSymbolFromPdb(relocated_address)) |symbol| <span class="tok-kw">return</span> symbol;</span>
<span class="line" id="L2212">            }</span>
<span class="line" id="L2213"></span>
<span class="line" id="L2214">            <span class="tok-kw">if</span> (self.dwarf) |*dwarf| {</span>
<span class="line" id="L2215">                <span class="tok-kw">const</span> dwarf_address = relocated_address + self.coff_image_base;</span>
<span class="line" id="L2216">                <span class="tok-kw">return</span> getSymbolFromDwarf(allocator, dwarf_address, dwarf);</span>
<span class="line" id="L2217">            }</span>
<span class="line" id="L2218"></span>
<span class="line" id="L2219">            <span class="tok-kw">return</span> SymbolInfo{};</span>
<span class="line" id="L2220">        }</span>
<span class="line" id="L2221"></span>
<span class="line" id="L2222">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getDwarfInfoForAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator, address: <span class="tok-type">usize</span>) !?*<span class="tok-kw">const</span> DW.DwarfInfo {</span>
<span class="line" id="L2223">            _ = allocator;</span>
<span class="line" id="L2224">            _ = address;</span>
<span class="line" id="L2225"></span>
<span class="line" id="L2226">            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self.debug_data) {</span>
<span class="line" id="L2227">                .dwarf =&gt; |*dwarf| dwarf,</span>
<span class="line" id="L2228">                <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,</span>
<span class="line" id="L2229">            };</span>
<span class="line" id="L2230">        }</span>
<span class="line" id="L2231">    },</span>
<span class="line" id="L2232">    .linux, .netbsd, .freebsd, .dragonfly, .openbsd, .haiku, .solaris, .illumos =&gt; <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2233">        base_address: <span class="tok-type">usize</span>,</span>
<span class="line" id="L2234">        dwarf: DW.DwarfInfo,</span>
<span class="line" id="L2235">        mapped_memory: []<span class="tok-kw">align</span>(mem.page_size) <span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2236">        external_mapped_memory: ?[]<span class="tok-kw">align</span>(mem.page_size) <span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2237"></span>
<span class="line" id="L2238">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L2239">            self.dwarf.deinit(allocator);</span>
<span class="line" id="L2240">            os.munmap(self.mapped_memory);</span>
<span class="line" id="L2241">            <span class="tok-kw">if</span> (self.external_mapped_memory) |m| os.munmap(m);</span>
<span class="line" id="L2242">        }</span>
<span class="line" id="L2243"></span>
<span class="line" id="L2244">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSymbolAtAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator, address: <span class="tok-type">usize</span>) !SymbolInfo {</span>
<span class="line" id="L2245">            <span class="tok-comment">// Translate the VA into an address into this object</span>
</span>
<span class="line" id="L2246">            <span class="tok-kw">const</span> relocated_address = address - self.base_address;</span>
<span class="line" id="L2247">            <span class="tok-kw">return</span> getSymbolFromDwarf(allocator, relocated_address, &amp;self.dwarf);</span>
<span class="line" id="L2248">        }</span>
<span class="line" id="L2249"></span>
<span class="line" id="L2250">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getDwarfInfoForAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator, address: <span class="tok-type">usize</span>) !?*<span class="tok-kw">const</span> DW.DwarfInfo {</span>
<span class="line" id="L2251">            _ = allocator;</span>
<span class="line" id="L2252">            _ = address;</span>
<span class="line" id="L2253">            <span class="tok-kw">return</span> &amp;self.dwarf;</span>
<span class="line" id="L2254">        }</span>
<span class="line" id="L2255">    },</span>
<span class="line" id="L2256">    .wasi =&gt; <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2257">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L2258">            _ = self;</span>
<span class="line" id="L2259">            _ = allocator;</span>
<span class="line" id="L2260">        }</span>
<span class="line" id="L2261"></span>
<span class="line" id="L2262">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSymbolAtAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator, address: <span class="tok-type">usize</span>) !SymbolInfo {</span>
<span class="line" id="L2263">            _ = self;</span>
<span class="line" id="L2264">            _ = allocator;</span>
<span class="line" id="L2265">            _ = address;</span>
<span class="line" id="L2266">            <span class="tok-kw">return</span> SymbolInfo{};</span>
<span class="line" id="L2267">        }</span>
<span class="line" id="L2268"></span>
<span class="line" id="L2269">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getDwarfInfoForAddress</span>(self: *<span class="tok-builtin">@This</span>(), allocator: mem.Allocator, address: <span class="tok-type">usize</span>) !?*<span class="tok-kw">const</span> DW.DwarfInfo {</span>
<span class="line" id="L2270">            _ = self;</span>
<span class="line" id="L2271">            _ = allocator;</span>
<span class="line" id="L2272">            _ = address;</span>
<span class="line" id="L2273">            <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2274">        }</span>
<span class="line" id="L2275">    },</span>
<span class="line" id="L2276">    <span class="tok-kw">else</span> =&gt; DW.DwarfInfo,</span>
<span class="line" id="L2277">};</span>
<span class="line" id="L2278"></span>
<span class="line" id="L2279"><span class="tok-kw">fn</span> <span class="tok-fn">getSymbolFromDwarf</span>(allocator: mem.Allocator, address: <span class="tok-type">u64</span>, di: *DW.DwarfInfo) !SymbolInfo {</span>
<span class="line" id="L2280">    <span class="tok-kw">if</span> (<span class="tok-kw">nosuspend</span> di.findCompileUnit(address)) |compile_unit| {</span>
<span class="line" id="L2281">        <span class="tok-kw">return</span> SymbolInfo{</span>
<span class="line" id="L2282">            .symbol_name = <span class="tok-kw">nosuspend</span> di.getSymbolName(address) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;???&quot;</span>,</span>
<span class="line" id="L2283">            .compile_unit_name = compile_unit.die.getAttrString(di, DW.AT.name, di.section(.debug_str), compile_unit.*) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2284">                <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; <span class="tok-str">&quot;???&quot;</span>,</span>
<span class="line" id="L2285">            },</span>
<span class="line" id="L2286">            .line_info = <span class="tok-kw">nosuspend</span> di.getLineNumberInfo(allocator, compile_unit.*, address) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2287">                <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; <span class="tok-null">null</span>,</span>
<span class="line" id="L2288">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L2289">            },</span>
<span class="line" id="L2290">        };</span>
<span class="line" id="L2291">    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2292">        <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; {</span>
<span class="line" id="L2293">            <span class="tok-kw">return</span> SymbolInfo{};</span>
<span class="line" id="L2294">        },</span>
<span class="line" id="L2295">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L2296">    }</span>
<span class="line" id="L2297">}</span>
<span class="line" id="L2298"></span>
<span class="line" id="L2299"><span class="tok-comment">/// TODO multithreaded awareness</span></span>
<span class="line" id="L2300"><span class="tok-kw">var</span> debug_info_allocator: ?mem.Allocator = <span class="tok-null">null</span>;</span>
<span class="line" id="L2301"><span class="tok-kw">var</span> debug_info_arena_allocator: std.heap.ArenaAllocator = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L2302"><span class="tok-kw">fn</span> <span class="tok-fn">getDebugInfoAllocator</span>() mem.Allocator {</span>
<span class="line" id="L2303">    <span class="tok-kw">if</span> (debug_info_allocator) |a| <span class="tok-kw">return</span> a;</span>
<span class="line" id="L2304"></span>
<span class="line" id="L2305">    debug_info_arena_allocator = std.heap.ArenaAllocator.init(std.heap.page_allocator);</span>
<span class="line" id="L2306">    <span class="tok-kw">const</span> allocator = debug_info_arena_allocator.allocator();</span>
<span class="line" id="L2307">    debug_info_allocator = allocator;</span>
<span class="line" id="L2308">    <span class="tok-kw">return</span> allocator;</span>
<span class="line" id="L2309">}</span>
<span class="line" id="L2310"></span>
<span class="line" id="L2311"><span class="tok-comment">/// Whether or not the current target can print useful debug information when a segfault occurs.</span></span>
<span class="line" id="L2312"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> have_segfault_handling_support = <span class="tok-kw">switch</span> (native_os) {</span>
<span class="line" id="L2313">    .linux,</span>
<span class="line" id="L2314">    .macos,</span>
<span class="line" id="L2315">    .netbsd,</span>
<span class="line" id="L2316">    .solaris,</span>
<span class="line" id="L2317">    .illumos,</span>
<span class="line" id="L2318">    .windows,</span>
<span class="line" id="L2319">    =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L2320"></span>
<span class="line" id="L2321">    .freebsd, .openbsd =&gt; <span class="tok-builtin">@hasDecl</span>(os.system, <span class="tok-str">&quot;ucontext_t&quot;</span>),</span>
<span class="line" id="L2322">    <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L2323">};</span>
<span class="line" id="L2324"></span>
<span class="line" id="L2325"><span class="tok-kw">const</span> enable_segfault_handler = std.options.enable_segfault_handler;</span>
<span class="line" id="L2326"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> default_enable_segfault_handler = runtime_safety <span class="tok-kw">and</span> have_segfault_handling_support;</span>
<span class="line" id="L2327"></span>
<span class="line" id="L2328"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">maybeEnableSegfaultHandler</span>() <span class="tok-type">void</span> {</span>
<span class="line" id="L2329">    <span class="tok-kw">if</span> (enable_segfault_handler) {</span>
<span class="line" id="L2330">        std.debug.attachSegfaultHandler();</span>
<span class="line" id="L2331">    }</span>
<span class="line" id="L2332">}</span>
<span class="line" id="L2333"></span>
<span class="line" id="L2334"><span class="tok-kw">var</span> windows_segfault_handle: ?windows.HANDLE = <span class="tok-null">null</span>;</span>
<span class="line" id="L2335"></span>
<span class="line" id="L2336"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">updateSegfaultHandler</span>(act: ?*<span class="tok-kw">const</span> os.Sigaction) <span class="tok-kw">error</span>{OperationNotSupported}!<span class="tok-type">void</span> {</span>
<span class="line" id="L2337">    <span class="tok-kw">try</span> os.sigaction(os.SIG.SEGV, act, <span class="tok-null">null</span>);</span>
<span class="line" id="L2338">    <span class="tok-kw">try</span> os.sigaction(os.SIG.ILL, act, <span class="tok-null">null</span>);</span>
<span class="line" id="L2339">    <span class="tok-kw">try</span> os.sigaction(os.SIG.BUS, act, <span class="tok-null">null</span>);</span>
<span class="line" id="L2340">    <span class="tok-kw">try</span> os.sigaction(os.SIG.FPE, act, <span class="tok-null">null</span>);</span>
<span class="line" id="L2341">}</span>
<span class="line" id="L2342"></span>
<span class="line" id="L2343"><span class="tok-comment">/// Attaches a global SIGSEGV handler which calls `@panic(&quot;segmentation fault&quot;);`</span></span>
<span class="line" id="L2344"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">attachSegfaultHandler</span>() <span class="tok-type">void</span> {</span>
<span class="line" id="L2345">    <span class="tok-kw">if</span> (!have_segfault_handling_support) {</span>
<span class="line" id="L2346">        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;segfault handler not supported for this target&quot;</span>);</span>
<span class="line" id="L2347">    }</span>
<span class="line" id="L2348">    <span class="tok-kw">if</span> (native_os == .windows) {</span>
<span class="line" id="L2349">        windows_segfault_handle = windows.kernel32.AddVectoredExceptionHandler(<span class="tok-number">0</span>, handleSegfaultWindows);</span>
<span class="line" id="L2350">        <span class="tok-kw">return</span>;</span>
<span class="line" id="L2351">    }</span>
<span class="line" id="L2352">    <span class="tok-kw">var</span> act = os.Sigaction{</span>
<span class="line" id="L2353">        .handler = .{ .sigaction = handleSegfaultPosix },</span>
<span class="line" id="L2354">        .mask = os.empty_sigset,</span>
<span class="line" id="L2355">        .flags = (os.SA.SIGINFO | os.SA.RESTART | os.SA.RESETHAND),</span>
<span class="line" id="L2356">    };</span>
<span class="line" id="L2357"></span>
<span class="line" id="L2358">    updateSegfaultHandler(&amp;act) <span class="tok-kw">catch</span> {</span>
<span class="line" id="L2359">        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;unable to install segfault handler, maybe adjust have_segfault_handling_support in std/debug.zig&quot;</span>);</span>
<span class="line" id="L2360">    };</span>
<span class="line" id="L2361">}</span>
<span class="line" id="L2362"></span>
<span class="line" id="L2363"><span class="tok-kw">fn</span> <span class="tok-fn">resetSegfaultHandler</span>() <span class="tok-type">void</span> {</span>
<span class="line" id="L2364">    <span class="tok-kw">if</span> (native_os == .windows) {</span>
<span class="line" id="L2365">        <span class="tok-kw">if</span> (windows_segfault_handle) |handle| {</span>
<span class="line" id="L2366">            assert(windows.kernel32.RemoveVectoredExceptionHandler(handle) != <span class="tok-number">0</span>);</span>
<span class="line" id="L2367">            windows_segfault_handle = <span class="tok-null">null</span>;</span>
<span class="line" id="L2368">        }</span>
<span class="line" id="L2369">        <span class="tok-kw">return</span>;</span>
<span class="line" id="L2370">    }</span>
<span class="line" id="L2371">    <span class="tok-kw">var</span> act = os.Sigaction{</span>
<span class="line" id="L2372">        .handler = .{ .handler = os.SIG.DFL },</span>
<span class="line" id="L2373">        .mask = os.empty_sigset,</span>
<span class="line" id="L2374">        .flags = <span class="tok-number">0</span>,</span>
<span class="line" id="L2375">    };</span>
<span class="line" id="L2376">    <span class="tok-comment">// To avoid a double-panic, do nothing if an error happens here.</span>
</span>
<span class="line" id="L2377">    updateSegfaultHandler(&amp;act) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L2378">}</span>
<span class="line" id="L2379"></span>
<span class="line" id="L2380"><span class="tok-kw">fn</span> <span class="tok-fn">handleSegfaultPosix</span>(sig: <span class="tok-type">i32</span>, info: *<span class="tok-kw">const</span> os.siginfo_t, ctx_ptr: ?*<span class="tok-kw">const</span> <span class="tok-type">anyopaque</span>) <span class="tok-kw">callconv</span>(.C) <span class="tok-type">noreturn</span> {</span>
<span class="line" id="L2381">    <span class="tok-comment">// Reset to the default handler so that if a segfault happens in this handler it will crash</span>
</span>
<span class="line" id="L2382">    <span class="tok-comment">// the process. Also when this handler returns, the original instruction will be repeated</span>
</span>
<span class="line" id="L2383">    <span class="tok-comment">// and the resulting segfault will crash the process rather than continually dump stack traces.</span>
</span>
<span class="line" id="L2384">    resetSegfaultHandler();</span>
<span class="line" id="L2385"></span>
<span class="line" id="L2386">    <span class="tok-kw">const</span> addr = <span class="tok-kw">switch</span> (native_os) {</span>
<span class="line" id="L2387">        .linux =&gt; <span class="tok-builtin">@intFromPtr</span>(info.fields.sigfault.addr),</span>
<span class="line" id="L2388">        .freebsd, .macos =&gt; <span class="tok-builtin">@intFromPtr</span>(info.addr),</span>
<span class="line" id="L2389">        .netbsd =&gt; <span class="tok-builtin">@intFromPtr</span>(info.info.reason.fault.addr),</span>
<span class="line" id="L2390">        .openbsd =&gt; <span class="tok-builtin">@intFromPtr</span>(info.data.fault.addr),</span>
<span class="line" id="L2391">        .solaris, .illumos =&gt; <span class="tok-builtin">@intFromPtr</span>(info.reason.fault.addr),</span>
<span class="line" id="L2392">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L2393">    };</span>
<span class="line" id="L2394"></span>
<span class="line" id="L2395">    <span class="tok-kw">nosuspend</span> <span class="tok-kw">switch</span> (panic_stage) {</span>
<span class="line" id="L2396">        <span class="tok-number">0</span> =&gt; {</span>
<span class="line" id="L2397">            panic_stage = <span class="tok-number">1</span>;</span>
<span class="line" id="L2398">            _ = panicking.fetchAdd(<span class="tok-number">1</span>, .SeqCst);</span>
<span class="line" id="L2399"></span>
<span class="line" id="L2400">            {</span>
<span class="line" id="L2401">                panic_mutex.lock();</span>
<span class="line" id="L2402">                <span class="tok-kw">defer</span> panic_mutex.unlock();</span>
<span class="line" id="L2403"></span>
<span class="line" id="L2404">                dumpSegfaultInfoPosix(sig, addr, ctx_ptr);</span>
<span class="line" id="L2405">            }</span>
<span class="line" id="L2406"></span>
<span class="line" id="L2407">            waitForOtherThreadToFinishPanicking();</span>
<span class="line" id="L2408">        },</span>
<span class="line" id="L2409">        <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L2410">            <span class="tok-comment">// panic mutex already locked</span>
</span>
<span class="line" id="L2411">            dumpSegfaultInfoPosix(sig, addr, ctx_ptr);</span>
<span class="line" id="L2412">        },</span>
<span class="line" id="L2413">    };</span>
<span class="line" id="L2414"></span>
<span class="line" id="L2415">    <span class="tok-comment">// We cannot allow the signal handler to return because when it runs the original instruction</span>
</span>
<span class="line" id="L2416">    <span class="tok-comment">// again, the memory may be mapped and undefined behavior would occur rather than repeating</span>
</span>
<span class="line" id="L2417">    <span class="tok-comment">// the segfault. So we simply abort here.</span>
</span>
<span class="line" id="L2418">    os.abort();</span>
<span class="line" id="L2419">}</span>
<span class="line" id="L2420"></span>
<span class="line" id="L2421"><span class="tok-kw">fn</span> <span class="tok-fn">dumpSegfaultInfoPosix</span>(sig: <span class="tok-type">i32</span>, addr: <span class="tok-type">usize</span>, ctx_ptr: ?*<span class="tok-kw">const</span> <span class="tok-type">anyopaque</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L2422">    <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L2423">    _ = <span class="tok-kw">switch</span> (sig) {</span>
<span class="line" id="L2424">        os.SIG.SEGV =&gt; stderr.print(<span class="tok-str">&quot;Segmentation fault at address 0x{x}\n&quot;</span>, .{addr}),</span>
<span class="line" id="L2425">        os.SIG.ILL =&gt; stderr.print(<span class="tok-str">&quot;Illegal instruction at address 0x{x}\n&quot;</span>, .{addr}),</span>
<span class="line" id="L2426">        os.SIG.BUS =&gt; stderr.print(<span class="tok-str">&quot;Bus error at address 0x{x}\n&quot;</span>, .{addr}),</span>
<span class="line" id="L2427">        os.SIG.FPE =&gt; stderr.print(<span class="tok-str">&quot;Arithmetic exception at address 0x{x}\n&quot;</span>, .{addr}),</span>
<span class="line" id="L2428">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L2429">    } <span class="tok-kw">catch</span> os.abort();</span>
<span class="line" id="L2430"></span>
<span class="line" id="L2431">    <span class="tok-kw">switch</span> (native_arch) {</span>
<span class="line" id="L2432">        .x86,</span>
<span class="line" id="L2433">        .x86_64,</span>
<span class="line" id="L2434">        .arm,</span>
<span class="line" id="L2435">        .aarch64,</span>
<span class="line" id="L2436">        =&gt; {</span>
<span class="line" id="L2437">            <span class="tok-kw">const</span> ctx: *<span class="tok-kw">const</span> os.ucontext_t = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(ctx_ptr));</span>
<span class="line" id="L2438">            dumpStackTraceFromBase(ctx);</span>
<span class="line" id="L2439">        },</span>
<span class="line" id="L2440">        <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L2441">    }</span>
<span class="line" id="L2442">}</span>
<span class="line" id="L2443"></span>
<span class="line" id="L2444"><span class="tok-kw">fn</span> <span class="tok-fn">handleSegfaultWindows</span>(info: *windows.EXCEPTION_POINTERS) <span class="tok-kw">callconv</span>(windows.WINAPI) <span class="tok-type">c_long</span> {</span>
<span class="line" id="L2445">    <span class="tok-kw">switch</span> (info.ExceptionRecord.ExceptionCode) {</span>
<span class="line" id="L2446">        windows.EXCEPTION_DATATYPE_MISALIGNMENT =&gt; handleSegfaultWindowsExtra(info, <span class="tok-number">0</span>, <span class="tok-str">&quot;Unaligned Memory Access&quot;</span>),</span>
<span class="line" id="L2447">        windows.EXCEPTION_ACCESS_VIOLATION =&gt; handleSegfaultWindowsExtra(info, <span class="tok-number">1</span>, <span class="tok-null">null</span>),</span>
<span class="line" id="L2448">        windows.EXCEPTION_ILLEGAL_INSTRUCTION =&gt; handleSegfaultWindowsExtra(info, <span class="tok-number">2</span>, <span class="tok-null">null</span>),</span>
<span class="line" id="L2449">        windows.EXCEPTION_STACK_OVERFLOW =&gt; handleSegfaultWindowsExtra(info, <span class="tok-number">0</span>, <span class="tok-str">&quot;Stack Overflow&quot;</span>),</span>
<span class="line" id="L2450">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> windows.EXCEPTION_CONTINUE_SEARCH,</span>
<span class="line" id="L2451">    }</span>
<span class="line" id="L2452">}</span>
<span class="line" id="L2453"></span>
<span class="line" id="L2454"><span class="tok-kw">fn</span> <span class="tok-fn">handleSegfaultWindowsExtra</span>(</span>
<span class="line" id="L2455">    info: *windows.EXCEPTION_POINTERS,</span>
<span class="line" id="L2456">    msg: <span class="tok-type">u8</span>,</span>
<span class="line" id="L2457">    label: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2458">) <span class="tok-type">noreturn</span> {</span>
<span class="line" id="L2459">    <span class="tok-kw">const</span> exception_address = <span class="tok-builtin">@intFromPtr</span>(info.ExceptionRecord.ExceptionAddress);</span>
<span class="line" id="L2460">    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(windows, <span class="tok-str">&quot;CONTEXT&quot;</span>)) {</span>
<span class="line" id="L2461">        <span class="tok-kw">nosuspend</span> <span class="tok-kw">switch</span> (panic_stage) {</span>
<span class="line" id="L2462">            <span class="tok-number">0</span> =&gt; {</span>
<span class="line" id="L2463">                panic_stage = <span class="tok-number">1</span>;</span>
<span class="line" id="L2464">                _ = panicking.fetchAdd(<span class="tok-number">1</span>, .SeqCst);</span>
<span class="line" id="L2465"></span>
<span class="line" id="L2466">                {</span>
<span class="line" id="L2467">                    panic_mutex.lock();</span>
<span class="line" id="L2468">                    <span class="tok-kw">defer</span> panic_mutex.unlock();</span>
<span class="line" id="L2469"></span>
<span class="line" id="L2470">                    dumpSegfaultInfoWindows(info, msg, label);</span>
<span class="line" id="L2471">                }</span>
<span class="line" id="L2472"></span>
<span class="line" id="L2473">                waitForOtherThreadToFinishPanicking();</span>
<span class="line" id="L2474">            },</span>
<span class="line" id="L2475">            <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L2476">                <span class="tok-comment">// panic mutex already locked</span>
</span>
<span class="line" id="L2477">                dumpSegfaultInfoWindows(info, msg, label);</span>
<span class="line" id="L2478">            },</span>
<span class="line" id="L2479">        };</span>
<span class="line" id="L2480">        os.abort();</span>
<span class="line" id="L2481">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2482">        <span class="tok-kw">switch</span> (msg) {</span>
<span class="line" id="L2483">            <span class="tok-number">0</span> =&gt; panicImpl(<span class="tok-null">null</span>, exception_address, <span class="tok-str">&quot;{s}&quot;</span>, label.?),</span>
<span class="line" id="L2484">            <span class="tok-number">1</span> =&gt; {</span>
<span class="line" id="L2485">                <span class="tok-kw">const</span> format_item = <span class="tok-str">&quot;Segmentation fault at address 0x{x}&quot;</span>;</span>
<span class="line" id="L2486">                <span class="tok-kw">var</span> buf: [format_item.len + <span class="tok-number">64</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>; <span class="tok-comment">// 64 is arbitrary, but sufficiently large</span>
</span>
<span class="line" id="L2487">                <span class="tok-kw">const</span> to_print = std.fmt.bufPrint(buf[<span class="tok-number">0</span>..buf.len], format_item, .{info.ExceptionRecord.ExceptionInformation[<span class="tok-number">1</span>]}) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L2488">                panicImpl(<span class="tok-null">null</span>, exception_address, to_print);</span>
<span class="line" id="L2489">            },</span>
<span class="line" id="L2490">            <span class="tok-number">2</span> =&gt; panicImpl(<span class="tok-null">null</span>, exception_address, <span class="tok-str">&quot;Illegal Instruction&quot;</span>),</span>
<span class="line" id="L2491">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L2492">        }</span>
<span class="line" id="L2493">    }</span>
<span class="line" id="L2494">}</span>
<span class="line" id="L2495"></span>
<span class="line" id="L2496"><span class="tok-kw">fn</span> <span class="tok-fn">dumpSegfaultInfoWindows</span>(info: *windows.EXCEPTION_POINTERS, msg: <span class="tok-type">u8</span>, label: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L2497">    <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L2498">    _ = <span class="tok-kw">switch</span> (msg) {</span>
<span class="line" id="L2499">        <span class="tok-number">0</span> =&gt; stderr.print(<span class="tok-str">&quot;{s}\n&quot;</span>, .{label.?}),</span>
<span class="line" id="L2500">        <span class="tok-number">1</span> =&gt; stderr.print(<span class="tok-str">&quot;Segmentation fault at address 0x{x}\n&quot;</span>, .{info.ExceptionRecord.ExceptionInformation[<span class="tok-number">1</span>]}),</span>
<span class="line" id="L2501">        <span class="tok-number">2</span> =&gt; stderr.print(<span class="tok-str">&quot;Illegal instruction at address 0x{x}\n&quot;</span>, .{info.ContextRecord.getRegs().ip}),</span>
<span class="line" id="L2502">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L2503">    } <span class="tok-kw">catch</span> os.abort();</span>
<span class="line" id="L2504"></span>
<span class="line" id="L2505">    dumpStackTraceFromBase(info.ContextRecord);</span>
<span class="line" id="L2506">}</span>
<span class="line" id="L2507"></span>
<span class="line" id="L2508"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpStackPointerAddr</span>(prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L2509">    <span class="tok-kw">const</span> sp = <span class="tok-kw">asm</span> (<span class="tok-str">&quot;&quot;</span></span>
<span class="line" id="L2510">        : [argc] <span class="tok-str">&quot;={rsp}&quot;</span> (-&gt; <span class="tok-type">usize</span>),</span>
<span class="line" id="L2511">    );</span>
<span class="line" id="L2512">    std.debug.print(<span class="tok-str">&quot;{} sp = 0x{x}\n&quot;</span>, .{ prefix, sp });</span>
<span class="line" id="L2513">}</span>
<span class="line" id="L2514"></span>
<span class="line" id="L2515"><span class="tok-kw">test</span> <span class="tok-str">&quot;manage resources correctly&quot;</span> {</span>
<span class="line" id="L2516">    <span class="tok-kw">if</span> (builtin.os.tag == .wasi) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;</span>
<span class="line" id="L2517"></span>
<span class="line" id="L2518">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L2519">        <span class="tok-comment">// https://github.com/ziglang/zig/issues/13963</span>
</span>
<span class="line" id="L2520">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;</span>
<span class="line" id="L2521">    }</span>
<span class="line" id="L2522"></span>
<span class="line" id="L2523">    <span class="tok-kw">const</span> writer = std.io.null_writer;</span>
<span class="line" id="L2524">    <span class="tok-kw">var</span> di = <span class="tok-kw">try</span> openSelfDebugInfo(testing.allocator);</span>
<span class="line" id="L2525">    <span class="tok-kw">defer</span> di.deinit();</span>
<span class="line" id="L2526">    <span class="tok-kw">try</span> printSourceAtAddress(&amp;di, writer, showMyTrace(), io.tty.detectConfig(std.io.getStdErr()));</span>
<span class="line" id="L2527">}</span>
<span class="line" id="L2528"></span>
<span class="line" id="L2529"><span class="tok-kw">noinline</span> <span class="tok-kw">fn</span> <span class="tok-fn">showMyTrace</span>() <span class="tok-type">usize</span> {</span>
<span class="line" id="L2530">    <span class="tok-kw">return</span> <span class="tok-builtin">@returnAddress</span>();</span>
<span class="line" id="L2531">}</span>
<span class="line" id="L2532"></span>
<span class="line" id="L2533"><span class="tok-comment">/// This API helps you track where a value originated and where it was mutated,</span></span>
<span class="line" id="L2534"><span class="tok-comment">/// or any other points of interest.</span></span>
<span class="line" id="L2535"><span class="tok-comment">/// In debug mode, it adds a small size penalty (104 bytes on 64-bit architectures)</span></span>
<span class="line" id="L2536"><span class="tok-comment">/// to the aggregate that you add it to.</span></span>
<span class="line" id="L2537"><span class="tok-comment">/// In release mode, it is size 0 and all methods are no-ops.</span></span>
<span class="line" id="L2538"><span class="tok-comment">/// This is a pre-made type with default settings.</span></span>
<span class="line" id="L2539"><span class="tok-comment">/// For more advanced usage, see `ConfigurableTrace`.</span></span>
<span class="line" id="L2540"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Trace = ConfigurableTrace(<span class="tok-number">2</span>, <span class="tok-number">4</span>, builtin.mode == .Debug);</span>
<span class="line" id="L2541"></span>
<span class="line" id="L2542"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ConfigurableTrace</span>(<span class="tok-kw">comptime</span> size: <span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> stack_frame_count: <span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> is_enabled: <span class="tok-type">bool</span>) <span class="tok-type">type</span> {</span>
<span class="line" id="L2543">    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2544">        addrs: [actual_size][stack_frame_count]<span class="tok-type">usize</span> = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L2545">        notes: [actual_size][]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L2546">        index: Index = <span class="tok-number">0</span>,</span>
<span class="line" id="L2547"></span>
<span class="line" id="L2548">        <span class="tok-kw">const</span> actual_size = <span class="tok-kw">if</span> (enabled) size <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L2549">        <span class="tok-kw">const</span> Index = <span class="tok-kw">if</span> (enabled) <span class="tok-type">usize</span> <span class="tok-kw">else</span> <span class="tok-type">u0</span>;</span>
<span class="line" id="L2550"></span>
<span class="line" id="L2551">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> enabled = is_enabled;</span>
<span class="line" id="L2552"></span>
<span class="line" id="L2553">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> add = <span class="tok-kw">if</span> (enabled) addNoInline <span class="tok-kw">else</span> addNoOp;</span>
<span class="line" id="L2554"></span>
<span class="line" id="L2555">        <span class="tok-kw">pub</span> <span class="tok-kw">noinline</span> <span class="tok-kw">fn</span> <span class="tok-fn">addNoInline</span>(t: *<span class="tok-builtin">@This</span>(), note: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L2556">            <span class="tok-kw">comptime</span> assert(enabled);</span>
<span class="line" id="L2557">            <span class="tok-kw">return</span> addAddr(t, <span class="tok-builtin">@returnAddress</span>(), note);</span>
<span class="line" id="L2558">        }</span>
<span class="line" id="L2559"></span>
<span class="line" id="L2560">        <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">addNoOp</span>(t: *<span class="tok-builtin">@This</span>(), note: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L2561">            _ = t;</span>
<span class="line" id="L2562">            _ = note;</span>
<span class="line" id="L2563">            <span class="tok-kw">comptime</span> assert(!enabled);</span>
<span class="line" id="L2564">        }</span>
<span class="line" id="L2565"></span>
<span class="line" id="L2566">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addAddr</span>(t: *<span class="tok-builtin">@This</span>(), addr: <span class="tok-type">usize</span>, note: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L2567">            <span class="tok-kw">if</span> (!enabled) <span class="tok-kw">return</span>;</span>
<span class="line" id="L2568"></span>
<span class="line" id="L2569">            <span class="tok-kw">if</span> (t.index &lt; size) {</span>
<span class="line" id="L2570">                t.notes[t.index] = note;</span>
<span class="line" id="L2571">                t.addrs[t.index] = [<span class="tok-number">1</span>]<span class="tok-type">usize</span>{<span class="tok-number">0</span>} ** stack_frame_count;</span>
<span class="line" id="L2572">                <span class="tok-kw">var</span> stack_trace: std.builtin.StackTrace = .{</span>
<span class="line" id="L2573">                    .index = <span class="tok-number">0</span>,</span>
<span class="line" id="L2574">                    .instruction_addresses = &amp;t.addrs[t.index],</span>
<span class="line" id="L2575">                };</span>
<span class="line" id="L2576">                captureStackTrace(addr, &amp;stack_trace);</span>
<span class="line" id="L2577">            }</span>
<span class="line" id="L2578">            <span class="tok-comment">// Keep counting even if the end is reached so that the</span>
</span>
<span class="line" id="L2579">            <span class="tok-comment">// user can find out how much more size they need.</span>
</span>
<span class="line" id="L2580">            t.index += <span class="tok-number">1</span>;</span>
<span class="line" id="L2581">        }</span>
<span class="line" id="L2582"></span>
<span class="line" id="L2583">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dump</span>(t: <span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {</span>
<span class="line" id="L2584">            <span class="tok-kw">if</span> (!enabled) <span class="tok-kw">return</span>;</span>
<span class="line" id="L2585"></span>
<span class="line" id="L2586">            <span class="tok-kw">const</span> tty_config = io.tty.detectConfig(std.io.getStdErr());</span>
<span class="line" id="L2587">            <span class="tok-kw">const</span> stderr = io.getStdErr().writer();</span>
<span class="line" id="L2588">            <span class="tok-kw">const</span> end = <span class="tok-builtin">@min</span>(t.index, size);</span>
<span class="line" id="L2589">            <span class="tok-kw">const</span> debug_info = getSelfDebugInfo() <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L2590">                stderr.print(</span>
<span class="line" id="L2591">                    <span class="tok-str">&quot;Unable to dump stack trace: Unable to open debug info: {s}\n&quot;</span>,</span>
<span class="line" id="L2592">                    .{<span class="tok-builtin">@errorName</span>(err)},</span>
<span class="line" id="L2593">                ) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L2594">                <span class="tok-kw">return</span>;</span>
<span class="line" id="L2595">            };</span>
<span class="line" id="L2596">            <span class="tok-kw">for</span> (t.addrs[<span class="tok-number">0</span>..end], <span class="tok-number">0</span>..) |frames_array, i| {</span>
<span class="line" id="L2597">                stderr.print(<span class="tok-str">&quot;{s}:\n&quot;</span>, .{t.notes[i]}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L2598">                <span class="tok-kw">var</span> frames_array_mutable = frames_array;</span>
<span class="line" id="L2599">                <span class="tok-kw">const</span> frames = mem.sliceTo(frames_array_mutable[<span class="tok-number">0</span>..], <span class="tok-number">0</span>);</span>
<span class="line" id="L2600">                <span class="tok-kw">const</span> stack_trace: std.builtin.StackTrace = .{</span>
<span class="line" id="L2601">                    .index = frames.len,</span>
<span class="line" id="L2602">                    .instruction_addresses = frames,</span>
<span class="line" id="L2603">                };</span>
<span class="line" id="L2604">                writeStackTrace(stack_trace, stderr, getDebugInfoAllocator(), debug_info, tty_config) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L2605">            }</span>
<span class="line" id="L2606">            <span class="tok-kw">if</span> (t.index &gt; end) {</span>
<span class="line" id="L2607">                stderr.print(<span class="tok-str">&quot;{d} more traces not shown; consider increasing trace size\n&quot;</span>, .{</span>
<span class="line" id="L2608">                    t.index - end,</span>
<span class="line" id="L2609">                }) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L2610">            }</span>
<span class="line" id="L2611">        }</span>
<span class="line" id="L2612"></span>
<span class="line" id="L2613">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(</span>
<span class="line" id="L2614">            t: Trace,</span>
<span class="line" id="L2615">            <span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2616">            options: std.fmt.FormatOptions,</span>
<span class="line" id="L2617">            writer: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L2618">        ) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2619">            <span class="tok-kw">if</span> (fmt.len != <span class="tok-number">0</span>) std.fmt.invalidFmtError(fmt, t);</span>
<span class="line" id="L2620">            _ = options;</span>
<span class="line" id="L2621">            <span class="tok-kw">if</span> (enabled) {</span>
<span class="line" id="L2622">                <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;\n&quot;</span>);</span>
<span class="line" id="L2623">                t.dump();</span>
<span class="line" id="L2624">                <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;\n&quot;</span>);</span>
<span class="line" id="L2625">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2626">                <span class="tok-kw">return</span> writer.writeAll(<span class="tok-str">&quot;(value tracing disabled)&quot;</span>);</span>
<span class="line" id="L2627">            }</span>
<span class="line" id="L2628">        }</span>
<span class="line" id="L2629">    };</span>
<span class="line" id="L2630">}</span>
<span class="line" id="L2631"></span>
</code></pre></body>
</html>