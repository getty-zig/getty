<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>dwarf.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAPNJREFUeNpi/P//PwMlgOXHUjly9E0G4hwgZmQiQZMqEK8H4v9QzUEgQSaoADK+zhH9iAGL+C0gDoAaNg9mGLoLfgA1awK9hS9gzgJxA9RQBmQDrgMxJzRMGKE4HYj/Ial5A8QmQLwCJoBsgBYW2+TR1ChDaWt4LOBxKsi/VUh8XiD+gq4IVyzwQAMJBoKwacZlAB8Qf0bi96IZhtOAe1D6LpqaEiz6rmEzQAeIzwGxCJpieFqApo/vQKyJboAaEBsAsSEupwI1MwKjGBTVHOhegMX5UajYRqiBjMgYmj400cVh0XgTiKdC0zhJgJHS7AwQYABm9EAdCKrEfAAAAABJRU5ErkJggg=="/>
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);</span>
<span class="line" id="L2"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std.zig&quot;</span>);</span>
<span class="line" id="L3"><span class="tok-kw">const</span> debug = std.debug;</span>
<span class="line" id="L4"><span class="tok-kw">const</span> fs = std.fs;</span>
<span class="line" id="L5"><span class="tok-kw">const</span> io = std.io;</span>
<span class="line" id="L6"><span class="tok-kw">const</span> os = std.os;</span>
<span class="line" id="L7"><span class="tok-kw">const</span> mem = std.mem;</span>
<span class="line" id="L8"><span class="tok-kw">const</span> math = std.math;</span>
<span class="line" id="L9"><span class="tok-kw">const</span> leb = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;leb128.zig&quot;</span>);</span>
<span class="line" id="L10"><span class="tok-kw">const</span> assert = std.debug.assert;</span>
<span class="line" id="L11"></span>
<span class="line" id="L12"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> TAG = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;dwarf/TAG.zig&quot;</span>);</span>
<span class="line" id="L13"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> AT = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;dwarf/AT.zig&quot;</span>);</span>
<span class="line" id="L14"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> OP = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;dwarf/OP.zig&quot;</span>);</span>
<span class="line" id="L15"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> LANG = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;dwarf/LANG.zig&quot;</span>);</span>
<span class="line" id="L16"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FORM = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;dwarf/FORM.zig&quot;</span>);</span>
<span class="line" id="L17"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ATE = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;dwarf/ATE.zig&quot;</span>);</span>
<span class="line" id="L18"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> EH = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;dwarf/EH.zig&quot;</span>);</span>
<span class="line" id="L19"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> abi = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;dwarf/abi.zig&quot;</span>);</span>
<span class="line" id="L20"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> call_frame = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;dwarf/call_frame.zig&quot;</span>);</span>
<span class="line" id="L21"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> expressions = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;dwarf/expressions.zig&quot;</span>);</span>
<span class="line" id="L22"></span>
<span class="line" id="L23"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> LLE = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L24">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> end_of_list = <span class="tok-number">0x00</span>;</span>
<span class="line" id="L25">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> base_addressx = <span class="tok-number">0x01</span>;</span>
<span class="line" id="L26">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> startx_endx = <span class="tok-number">0x02</span>;</span>
<span class="line" id="L27">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> startx_length = <span class="tok-number">0x03</span>;</span>
<span class="line" id="L28">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> offset_pair = <span class="tok-number">0x04</span>;</span>
<span class="line" id="L29">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> default_location = <span class="tok-number">0x05</span>;</span>
<span class="line" id="L30">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> base_address = <span class="tok-number">0x06</span>;</span>
<span class="line" id="L31">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> start_end = <span class="tok-number">0x07</span>;</span>
<span class="line" id="L32">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> start_length = <span class="tok-number">0x08</span>;</span>
<span class="line" id="L33">};</span>
<span class="line" id="L34"></span>
<span class="line" id="L35"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CFA = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L36">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> advance_loc = <span class="tok-number">0x40</span>;</span>
<span class="line" id="L37">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> offset = <span class="tok-number">0x80</span>;</span>
<span class="line" id="L38">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> restore = <span class="tok-number">0xc0</span>;</span>
<span class="line" id="L39">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> nop = <span class="tok-number">0x00</span>;</span>
<span class="line" id="L40">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> set_loc = <span class="tok-number">0x01</span>;</span>
<span class="line" id="L41">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> advance_loc1 = <span class="tok-number">0x02</span>;</span>
<span class="line" id="L42">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> advance_loc2 = <span class="tok-number">0x03</span>;</span>
<span class="line" id="L43">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> advance_loc4 = <span class="tok-number">0x04</span>;</span>
<span class="line" id="L44">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> offset_extended = <span class="tok-number">0x05</span>;</span>
<span class="line" id="L45">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> restore_extended = <span class="tok-number">0x06</span>;</span>
<span class="line" id="L46">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> @&quot;undefined&quot; = <span class="tok-number">0x07</span>;</span>
<span class="line" id="L47">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> same_value = <span class="tok-number">0x08</span>;</span>
<span class="line" id="L48">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> register = <span class="tok-number">0x09</span>;</span>
<span class="line" id="L49">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> remember_state = <span class="tok-number">0x0a</span>;</span>
<span class="line" id="L50">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> restore_state = <span class="tok-number">0x0b</span>;</span>
<span class="line" id="L51">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> def_cfa = <span class="tok-number">0x0c</span>;</span>
<span class="line" id="L52">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> def_cfa_register = <span class="tok-number">0x0d</span>;</span>
<span class="line" id="L53">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> def_cfa_offset = <span class="tok-number">0x0e</span>;</span>
<span class="line" id="L54"></span>
<span class="line" id="L55">    <span class="tok-comment">// DWARF 3.</span>
</span>
<span class="line" id="L56">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> def_cfa_expression = <span class="tok-number">0x0f</span>;</span>
<span class="line" id="L57">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> expression = <span class="tok-number">0x10</span>;</span>
<span class="line" id="L58">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> offset_extended_sf = <span class="tok-number">0x11</span>;</span>
<span class="line" id="L59">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> def_cfa_sf = <span class="tok-number">0x12</span>;</span>
<span class="line" id="L60">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> def_cfa_offset_sf = <span class="tok-number">0x13</span>;</span>
<span class="line" id="L61">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> val_offset = <span class="tok-number">0x14</span>;</span>
<span class="line" id="L62">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> val_offset_sf = <span class="tok-number">0x15</span>;</span>
<span class="line" id="L63">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> val_expression = <span class="tok-number">0x16</span>;</span>
<span class="line" id="L64"></span>
<span class="line" id="L65">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> lo_user = <span class="tok-number">0x1c</span>;</span>
<span class="line" id="L66">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> hi_user = <span class="tok-number">0x3f</span>;</span>
<span class="line" id="L67"></span>
<span class="line" id="L68">    <span class="tok-comment">// SGI/MIPS specific.</span>
</span>
<span class="line" id="L69">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> MIPS_advance_loc8 = <span class="tok-number">0x1d</span>;</span>
<span class="line" id="L70"></span>
<span class="line" id="L71">    <span class="tok-comment">// GNU extensions.</span>
</span>
<span class="line" id="L72">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> GNU_window_save = <span class="tok-number">0x2d</span>;</span>
<span class="line" id="L73">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> GNU_args_size = <span class="tok-number">0x2e</span>;</span>
<span class="line" id="L74">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> GNU_negative_offset_extended = <span class="tok-number">0x2f</span>;</span>
<span class="line" id="L75">};</span>
<span class="line" id="L76"></span>
<span class="line" id="L77"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CHILDREN = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L78">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> no = <span class="tok-number">0x00</span>;</span>
<span class="line" id="L79">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> yes = <span class="tok-number">0x01</span>;</span>
<span class="line" id="L80">};</span>
<span class="line" id="L81"></span>
<span class="line" id="L82"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> LNS = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L83">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> extended_op = <span class="tok-number">0x00</span>;</span>
<span class="line" id="L84">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> copy = <span class="tok-number">0x01</span>;</span>
<span class="line" id="L85">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> advance_pc = <span class="tok-number">0x02</span>;</span>
<span class="line" id="L86">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> advance_line = <span class="tok-number">0x03</span>;</span>
<span class="line" id="L87">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> set_file = <span class="tok-number">0x04</span>;</span>
<span class="line" id="L88">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> set_column = <span class="tok-number">0x05</span>;</span>
<span class="line" id="L89">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> negate_stmt = <span class="tok-number">0x06</span>;</span>
<span class="line" id="L90">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> set_basic_block = <span class="tok-number">0x07</span>;</span>
<span class="line" id="L91">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> const_add_pc = <span class="tok-number">0x08</span>;</span>
<span class="line" id="L92">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> fixed_advance_pc = <span class="tok-number">0x09</span>;</span>
<span class="line" id="L93">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> set_prologue_end = <span class="tok-number">0x0a</span>;</span>
<span class="line" id="L94">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> set_epilogue_begin = <span class="tok-number">0x0b</span>;</span>
<span class="line" id="L95">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> set_isa = <span class="tok-number">0x0c</span>;</span>
<span class="line" id="L96">};</span>
<span class="line" id="L97"></span>
<span class="line" id="L98"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> LNE = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L99">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> end_sequence = <span class="tok-number">0x01</span>;</span>
<span class="line" id="L100">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> set_address = <span class="tok-number">0x02</span>;</span>
<span class="line" id="L101">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> define_file = <span class="tok-number">0x03</span>;</span>
<span class="line" id="L102">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> set_discriminator = <span class="tok-number">0x04</span>;</span>
<span class="line" id="L103">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> lo_user = <span class="tok-number">0x80</span>;</span>
<span class="line" id="L104">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> hi_user = <span class="tok-number">0xff</span>;</span>
<span class="line" id="L105">};</span>
<span class="line" id="L106"></span>
<span class="line" id="L107"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> UT = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L108">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> compile = <span class="tok-number">0x01</span>;</span>
<span class="line" id="L109">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> @&quot;type&quot; = <span class="tok-number">0x02</span>;</span>
<span class="line" id="L110">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> partial = <span class="tok-number">0x03</span>;</span>
<span class="line" id="L111">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> skeleton = <span class="tok-number">0x04</span>;</span>
<span class="line" id="L112">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> split_compile = <span class="tok-number">0x05</span>;</span>
<span class="line" id="L113">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> split_type = <span class="tok-number">0x06</span>;</span>
<span class="line" id="L114"></span>
<span class="line" id="L115">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> lo_user = <span class="tok-number">0x80</span>;</span>
<span class="line" id="L116">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> hi_user = <span class="tok-number">0xff</span>;</span>
<span class="line" id="L117">};</span>
<span class="line" id="L118"></span>
<span class="line" id="L119"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> LNCT = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L120">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> path = <span class="tok-number">0x1</span>;</span>
<span class="line" id="L121">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> directory_index = <span class="tok-number">0x2</span>;</span>
<span class="line" id="L122">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> timestamp = <span class="tok-number">0x3</span>;</span>
<span class="line" id="L123">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> size = <span class="tok-number">0x4</span>;</span>
<span class="line" id="L124">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> MD5 = <span class="tok-number">0x5</span>;</span>
<span class="line" id="L125"></span>
<span class="line" id="L126">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> lo_user = <span class="tok-number">0x2000</span>;</span>
<span class="line" id="L127">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> hi_user = <span class="tok-number">0x3fff</span>;</span>
<span class="line" id="L128">};</span>
<span class="line" id="L129"></span>
<span class="line" id="L130"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> RLE = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L131">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> end_of_list = <span class="tok-number">0x00</span>;</span>
<span class="line" id="L132">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> base_addressx = <span class="tok-number">0x01</span>;</span>
<span class="line" id="L133">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> startx_endx = <span class="tok-number">0x02</span>;</span>
<span class="line" id="L134">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> startx_length = <span class="tok-number">0x03</span>;</span>
<span class="line" id="L135">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> offset_pair = <span class="tok-number">0x04</span>;</span>
<span class="line" id="L136">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> base_address = <span class="tok-number">0x05</span>;</span>
<span class="line" id="L137">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> start_end = <span class="tok-number">0x06</span>;</span>
<span class="line" id="L138">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> start_length = <span class="tok-number">0x07</span>;</span>
<span class="line" id="L139">};</span>
<span class="line" id="L140"></span>
<span class="line" id="L141"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CC = <span class="tok-kw">enum</span>(<span class="tok-type">u8</span>) {</span>
<span class="line" id="L142">    normal = <span class="tok-number">0x1</span>,</span>
<span class="line" id="L143">    program = <span class="tok-number">0x2</span>,</span>
<span class="line" id="L144">    nocall = <span class="tok-number">0x3</span>,</span>
<span class="line" id="L145"></span>
<span class="line" id="L146">    pass_by_reference = <span class="tok-number">0x4</span>,</span>
<span class="line" id="L147">    pass_by_value = <span class="tok-number">0x5</span>,</span>
<span class="line" id="L148"></span>
<span class="line" id="L149">    GNU_renesas_sh = <span class="tok-number">0x40</span>,</span>
<span class="line" id="L150">    GNU_borland_fastcall_i386 = <span class="tok-number">0x41</span>,</span>
<span class="line" id="L151"></span>
<span class="line" id="L152">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> lo_user = <span class="tok-number">0x40</span>;</span>
<span class="line" id="L153">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> hi_user = <span class="tok-number">0xff</span>;</span>
<span class="line" id="L154">};</span>
<span class="line" id="L155"></span>
<span class="line" id="L156"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Format = <span class="tok-kw">enum</span> { @&quot;32&quot;, @&quot;64&quot; };</span>
<span class="line" id="L157"></span>
<span class="line" id="L158"><span class="tok-kw">const</span> PcRange = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L159">    start: <span class="tok-type">u64</span>,</span>
<span class="line" id="L160">    end: <span class="tok-type">u64</span>,</span>
<span class="line" id="L161">};</span>
<span class="line" id="L162"></span>
<span class="line" id="L163"><span class="tok-kw">const</span> Func = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L164">    pc_range: ?PcRange,</span>
<span class="line" id="L165">    name: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L166">};</span>
<span class="line" id="L167"></span>
<span class="line" id="L168"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CompileUnit = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L169">    version: <span class="tok-type">u16</span>,</span>
<span class="line" id="L170">    is_64: <span class="tok-type">bool</span>,</span>
<span class="line" id="L171">    die: *Die,</span>
<span class="line" id="L172">    pc_range: ?PcRange,</span>
<span class="line" id="L173"></span>
<span class="line" id="L174">    str_offsets_base: <span class="tok-type">usize</span>,</span>
<span class="line" id="L175">    addr_base: <span class="tok-type">usize</span>,</span>
<span class="line" id="L176">    rnglists_base: <span class="tok-type">usize</span>,</span>
<span class="line" id="L177">    loclists_base: <span class="tok-type">usize</span>,</span>
<span class="line" id="L178">    frame_base: ?*<span class="tok-kw">const</span> FormValue,</span>
<span class="line" id="L179">};</span>
<span class="line" id="L180"></span>
<span class="line" id="L181"><span class="tok-kw">const</span> AbbrevTable = std.ArrayList(AbbrevTableEntry);</span>
<span class="line" id="L182"></span>
<span class="line" id="L183"><span class="tok-kw">const</span> AbbrevTableHeader = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L184">    <span class="tok-comment">// offset from .debug_abbrev</span>
</span>
<span class="line" id="L185">    offset: <span class="tok-type">u64</span>,</span>
<span class="line" id="L186">    table: AbbrevTable,</span>
<span class="line" id="L187"></span>
<span class="line" id="L188">    <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(header: *AbbrevTableHeader) <span class="tok-type">void</span> {</span>
<span class="line" id="L189">        <span class="tok-kw">for</span> (header.table.items) |*entry| {</span>
<span class="line" id="L190">            entry.deinit();</span>
<span class="line" id="L191">        }</span>
<span class="line" id="L192">        header.table.deinit();</span>
<span class="line" id="L193">    }</span>
<span class="line" id="L194">};</span>
<span class="line" id="L195"></span>
<span class="line" id="L196"><span class="tok-kw">const</span> AbbrevTableEntry = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L197">    has_children: <span class="tok-type">bool</span>,</span>
<span class="line" id="L198">    abbrev_code: <span class="tok-type">u64</span>,</span>
<span class="line" id="L199">    tag_id: <span class="tok-type">u64</span>,</span>
<span class="line" id="L200">    attrs: std.ArrayList(AbbrevAttr),</span>
<span class="line" id="L201"></span>
<span class="line" id="L202">    <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(entry: *AbbrevTableEntry) <span class="tok-type">void</span> {</span>
<span class="line" id="L203">        entry.attrs.deinit();</span>
<span class="line" id="L204">    }</span>
<span class="line" id="L205">};</span>
<span class="line" id="L206"></span>
<span class="line" id="L207"><span class="tok-kw">const</span> AbbrevAttr = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L208">    attr_id: <span class="tok-type">u64</span>,</span>
<span class="line" id="L209">    form_id: <span class="tok-type">u64</span>,</span>
<span class="line" id="L210">    <span class="tok-comment">/// Only valid if form_id is .implicit_const</span></span>
<span class="line" id="L211">    payload: <span class="tok-type">i64</span>,</span>
<span class="line" id="L212">};</span>
<span class="line" id="L213"></span>
<span class="line" id="L214"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FormValue = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L215">    Address: <span class="tok-type">u64</span>,</span>
<span class="line" id="L216">    AddrOffset: <span class="tok-type">usize</span>,</span>
<span class="line" id="L217">    Block: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L218">    Const: Constant,</span>
<span class="line" id="L219">    ExprLoc: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L220">    Flag: <span class="tok-type">bool</span>,</span>
<span class="line" id="L221">    SecOffset: <span class="tok-type">u64</span>,</span>
<span class="line" id="L222">    Ref: <span class="tok-type">u64</span>,</span>
<span class="line" id="L223">    RefAddr: <span class="tok-type">u64</span>,</span>
<span class="line" id="L224">    String: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L225">    StrPtr: <span class="tok-type">u64</span>,</span>
<span class="line" id="L226">    StrOffset: <span class="tok-type">usize</span>,</span>
<span class="line" id="L227">    LineStrPtr: <span class="tok-type">u64</span>,</span>
<span class="line" id="L228">    LocListOffset: <span class="tok-type">u64</span>,</span>
<span class="line" id="L229">    RangeListOffset: <span class="tok-type">u64</span>,</span>
<span class="line" id="L230">    data16: [<span class="tok-number">16</span>]<span class="tok-type">u8</span>,</span>
<span class="line" id="L231"></span>
<span class="line" id="L232">    <span class="tok-kw">fn</span> <span class="tok-fn">getString</span>(fv: FormValue, di: DwarfInfo) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L233">        <span class="tok-kw">switch</span> (fv) {</span>
<span class="line" id="L234">            .String =&gt; |s| <span class="tok-kw">return</span> s,</span>
<span class="line" id="L235">            .StrPtr =&gt; |off| <span class="tok-kw">return</span> di.getString(off),</span>
<span class="line" id="L236">            .LineStrPtr =&gt; |off| <span class="tok-kw">return</span> di.getLineString(off),</span>
<span class="line" id="L237">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> badDwarf(),</span>
<span class="line" id="L238">        }</span>
<span class="line" id="L239">    }</span>
<span class="line" id="L240"></span>
<span class="line" id="L241">    <span class="tok-kw">fn</span> <span class="tok-fn">getUInt</span>(fv: FormValue, <span class="tok-kw">comptime</span> U: <span class="tok-type">type</span>) !U {</span>
<span class="line" id="L242">        <span class="tok-kw">switch</span> (fv) {</span>
<span class="line" id="L243">            .Const =&gt; |c| {</span>
<span class="line" id="L244">                <span class="tok-kw">const</span> int = <span class="tok-kw">try</span> c.asUnsignedLe();</span>
<span class="line" id="L245">                <span class="tok-kw">return</span> math.cast(U, int) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L246">            },</span>
<span class="line" id="L247">            .SecOffset =&gt; |x| <span class="tok-kw">return</span> math.cast(U, x) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf(),</span>
<span class="line" id="L248">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> badDwarf(),</span>
<span class="line" id="L249">        }</span>
<span class="line" id="L250">    }</span>
<span class="line" id="L251"></span>
<span class="line" id="L252">    <span class="tok-kw">fn</span> <span class="tok-fn">getData16</span>(fv: FormValue) ![<span class="tok-number">16</span>]<span class="tok-type">u8</span> {</span>
<span class="line" id="L253">        <span class="tok-kw">switch</span> (fv) {</span>
<span class="line" id="L254">            .data16 =&gt; |d| <span class="tok-kw">return</span> d,</span>
<span class="line" id="L255">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> badDwarf(),</span>
<span class="line" id="L256">        }</span>
<span class="line" id="L257">    }</span>
<span class="line" id="L258">};</span>
<span class="line" id="L259"></span>
<span class="line" id="L260"><span class="tok-kw">const</span> Constant = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L261">    payload: <span class="tok-type">u64</span>,</span>
<span class="line" id="L262">    signed: <span class="tok-type">bool</span>,</span>
<span class="line" id="L263"></span>
<span class="line" id="L264">    <span class="tok-kw">fn</span> <span class="tok-fn">asUnsignedLe</span>(self: Constant) !<span class="tok-type">u64</span> {</span>
<span class="line" id="L265">        <span class="tok-kw">if</span> (self.signed) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L266">        <span class="tok-kw">return</span> self.payload;</span>
<span class="line" id="L267">    }</span>
<span class="line" id="L268">};</span>
<span class="line" id="L269"></span>
<span class="line" id="L270"><span class="tok-kw">const</span> Die = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L271">    <span class="tok-comment">// Arena for Die's Attr's and FormValue's.</span>
</span>
<span class="line" id="L272">    arena: std.heap.ArenaAllocator,</span>
<span class="line" id="L273">    tag_id: <span class="tok-type">u64</span>,</span>
<span class="line" id="L274">    has_children: <span class="tok-type">bool</span>,</span>
<span class="line" id="L275">    attrs: std.ArrayListUnmanaged(Attr) = .{},</span>
<span class="line" id="L276"></span>
<span class="line" id="L277">    <span class="tok-kw">const</span> Attr = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L278">        id: <span class="tok-type">u64</span>,</span>
<span class="line" id="L279">        value: FormValue,</span>
<span class="line" id="L280">    };</span>
<span class="line" id="L281"></span>
<span class="line" id="L282">    <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *Die, allocator: mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L283">        self.arena.deinit();</span>
<span class="line" id="L284">        self.attrs.deinit(allocator);</span>
<span class="line" id="L285">    }</span>
<span class="line" id="L286"></span>
<span class="line" id="L287">    <span class="tok-kw">fn</span> <span class="tok-fn">getAttr</span>(self: *<span class="tok-kw">const</span> Die, id: <span class="tok-type">u64</span>) ?*<span class="tok-kw">const</span> FormValue {</span>
<span class="line" id="L288">        <span class="tok-kw">for</span> (self.attrs.items) |*attr| {</span>
<span class="line" id="L289">            <span class="tok-kw">if</span> (attr.id == id) <span class="tok-kw">return</span> &amp;attr.value;</span>
<span class="line" id="L290">        }</span>
<span class="line" id="L291">        <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L292">    }</span>
<span class="line" id="L293"></span>
<span class="line" id="L294">    <span class="tok-kw">fn</span> <span class="tok-fn">getAttrAddr</span>(</span>
<span class="line" id="L295">        self: *<span class="tok-kw">const</span> Die,</span>
<span class="line" id="L296">        di: *<span class="tok-kw">const</span> DwarfInfo,</span>
<span class="line" id="L297">        id: <span class="tok-type">u64</span>,</span>
<span class="line" id="L298">        compile_unit: CompileUnit,</span>
<span class="line" id="L299">    ) <span class="tok-kw">error</span>{ InvalidDebugInfo, MissingDebugInfo }!<span class="tok-type">u64</span> {</span>
<span class="line" id="L300">        <span class="tok-kw">const</span> form_value = self.getAttr(id) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L301">        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (form_value.*) {</span>
<span class="line" id="L302">            FormValue.Address =&gt; |value| value,</span>
<span class="line" id="L303">            FormValue.AddrOffset =&gt; |index| di.readDebugAddr(compile_unit, index),</span>
<span class="line" id="L304">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">error</span>.InvalidDebugInfo,</span>
<span class="line" id="L305">        };</span>
<span class="line" id="L306">    }</span>
<span class="line" id="L307"></span>
<span class="line" id="L308">    <span class="tok-kw">fn</span> <span class="tok-fn">getAttrSecOffset</span>(self: *<span class="tok-kw">const</span> Die, id: <span class="tok-type">u64</span>) !<span class="tok-type">u64</span> {</span>
<span class="line" id="L309">        <span class="tok-kw">const</span> form_value = self.getAttr(id) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L310">        <span class="tok-kw">return</span> form_value.getUInt(<span class="tok-type">u64</span>);</span>
<span class="line" id="L311">    }</span>
<span class="line" id="L312"></span>
<span class="line" id="L313">    <span class="tok-kw">fn</span> <span class="tok-fn">getAttrUnsignedLe</span>(self: *<span class="tok-kw">const</span> Die, id: <span class="tok-type">u64</span>) !<span class="tok-type">u64</span> {</span>
<span class="line" id="L314">        <span class="tok-kw">const</span> form_value = self.getAttr(id) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L315">        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (form_value.*) {</span>
<span class="line" id="L316">            FormValue.Const =&gt; |value| value.asUnsignedLe(),</span>
<span class="line" id="L317">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">error</span>.InvalidDebugInfo,</span>
<span class="line" id="L318">        };</span>
<span class="line" id="L319">    }</span>
<span class="line" id="L320"></span>
<span class="line" id="L321">    <span class="tok-kw">fn</span> <span class="tok-fn">getAttrRef</span>(self: *<span class="tok-kw">const</span> Die, id: <span class="tok-type">u64</span>) !<span class="tok-type">u64</span> {</span>
<span class="line" id="L322">        <span class="tok-kw">const</span> form_value = self.getAttr(id) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L323">        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (form_value.*) {</span>
<span class="line" id="L324">            FormValue.Ref =&gt; |value| value,</span>
<span class="line" id="L325">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">error</span>.InvalidDebugInfo,</span>
<span class="line" id="L326">        };</span>
<span class="line" id="L327">    }</span>
<span class="line" id="L328"></span>
<span class="line" id="L329">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAttrString</span>(</span>
<span class="line" id="L330">        self: *<span class="tok-kw">const</span> Die,</span>
<span class="line" id="L331">        di: *DwarfInfo,</span>
<span class="line" id="L332">        id: <span class="tok-type">u64</span>,</span>
<span class="line" id="L333">        opt_str: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L334">        compile_unit: CompileUnit,</span>
<span class="line" id="L335">    ) <span class="tok-kw">error</span>{ InvalidDebugInfo, MissingDebugInfo }![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L336">        <span class="tok-kw">const</span> form_value = self.getAttr(id) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L337">        <span class="tok-kw">switch</span> (form_value.*) {</span>
<span class="line" id="L338">            FormValue.String =&gt; |value| <span class="tok-kw">return</span> value,</span>
<span class="line" id="L339">            FormValue.StrPtr =&gt; |offset| <span class="tok-kw">return</span> di.getString(offset),</span>
<span class="line" id="L340">            FormValue.StrOffset =&gt; |index| {</span>
<span class="line" id="L341">                <span class="tok-kw">const</span> debug_str_offsets = di.section(.debug_str_offsets) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L342">                <span class="tok-kw">if</span> (compile_unit.str_offsets_base == <span class="tok-number">0</span>) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L343">                <span class="tok-kw">if</span> (compile_unit.is_64) {</span>
<span class="line" id="L344">                    <span class="tok-kw">const</span> byte_offset = compile_unit.str_offsets_base + <span class="tok-number">8</span> * index;</span>
<span class="line" id="L345">                    <span class="tok-kw">if</span> (byte_offset + <span class="tok-number">8</span> &gt; debug_str_offsets.len) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L346">                    <span class="tok-kw">const</span> offset = mem.readInt(<span class="tok-type">u64</span>, debug_str_offsets[byte_offset..][<span class="tok-number">0</span>..<span class="tok-number">8</span>], di.endian);</span>
<span class="line" id="L347">                    <span class="tok-kw">return</span> getStringGeneric(opt_str, offset);</span>
<span class="line" id="L348">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L349">                    <span class="tok-kw">const</span> byte_offset = compile_unit.str_offsets_base + <span class="tok-number">4</span> * index;</span>
<span class="line" id="L350">                    <span class="tok-kw">if</span> (byte_offset + <span class="tok-number">4</span> &gt; debug_str_offsets.len) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L351">                    <span class="tok-kw">const</span> offset = mem.readInt(<span class="tok-type">u32</span>, debug_str_offsets[byte_offset..][<span class="tok-number">0</span>..<span class="tok-number">4</span>], di.endian);</span>
<span class="line" id="L352">                    <span class="tok-kw">return</span> getStringGeneric(opt_str, offset);</span>
<span class="line" id="L353">                }</span>
<span class="line" id="L354">            },</span>
<span class="line" id="L355">            FormValue.LineStrPtr =&gt; |offset| <span class="tok-kw">return</span> di.getLineString(offset),</span>
<span class="line" id="L356">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> badDwarf(),</span>
<span class="line" id="L357">        }</span>
<span class="line" id="L358">    }</span>
<span class="line" id="L359">};</span>
<span class="line" id="L360"></span>
<span class="line" id="L361"><span class="tok-kw">const</span> FileEntry = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L362">    path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L363">    dir_index: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L364">    mtime: <span class="tok-type">u64</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L365">    size: <span class="tok-type">u64</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L366">    md5: [<span class="tok-number">16</span>]<span class="tok-type">u8</span> = [<span class="tok-number">1</span>]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** <span class="tok-number">16</span>,</span>
<span class="line" id="L367">};</span>
<span class="line" id="L368"></span>
<span class="line" id="L369"><span class="tok-kw">const</span> LineNumberProgram = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L370">    address: <span class="tok-type">u64</span>,</span>
<span class="line" id="L371">    file: <span class="tok-type">usize</span>,</span>
<span class="line" id="L372">    line: <span class="tok-type">i64</span>,</span>
<span class="line" id="L373">    column: <span class="tok-type">u64</span>,</span>
<span class="line" id="L374">    version: <span class="tok-type">u16</span>,</span>
<span class="line" id="L375">    is_stmt: <span class="tok-type">bool</span>,</span>
<span class="line" id="L376">    basic_block: <span class="tok-type">bool</span>,</span>
<span class="line" id="L377">    end_sequence: <span class="tok-type">bool</span>,</span>
<span class="line" id="L378"></span>
<span class="line" id="L379">    default_is_stmt: <span class="tok-type">bool</span>,</span>
<span class="line" id="L380">    target_address: <span class="tok-type">u64</span>,</span>
<span class="line" id="L381">    include_dirs: []<span class="tok-kw">const</span> FileEntry,</span>
<span class="line" id="L382"></span>
<span class="line" id="L383">    prev_valid: <span class="tok-type">bool</span>,</span>
<span class="line" id="L384">    prev_address: <span class="tok-type">u64</span>,</span>
<span class="line" id="L385">    prev_file: <span class="tok-type">usize</span>,</span>
<span class="line" id="L386">    prev_line: <span class="tok-type">i64</span>,</span>
<span class="line" id="L387">    prev_column: <span class="tok-type">u64</span>,</span>
<span class="line" id="L388">    prev_is_stmt: <span class="tok-type">bool</span>,</span>
<span class="line" id="L389">    prev_basic_block: <span class="tok-type">bool</span>,</span>
<span class="line" id="L390">    prev_end_sequence: <span class="tok-type">bool</span>,</span>
<span class="line" id="L391"></span>
<span class="line" id="L392">    <span class="tok-comment">// Reset the state machine following the DWARF specification</span>
</span>
<span class="line" id="L393">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *LineNumberProgram) <span class="tok-type">void</span> {</span>
<span class="line" id="L394">        self.address = <span class="tok-number">0</span>;</span>
<span class="line" id="L395">        self.file = <span class="tok-number">1</span>;</span>
<span class="line" id="L396">        self.line = <span class="tok-number">1</span>;</span>
<span class="line" id="L397">        self.column = <span class="tok-number">0</span>;</span>
<span class="line" id="L398">        self.is_stmt = self.default_is_stmt;</span>
<span class="line" id="L399">        self.basic_block = <span class="tok-null">false</span>;</span>
<span class="line" id="L400">        self.end_sequence = <span class="tok-null">false</span>;</span>
<span class="line" id="L401">        <span class="tok-comment">// Invalidate all the remaining fields</span>
</span>
<span class="line" id="L402">        self.prev_valid = <span class="tok-null">false</span>;</span>
<span class="line" id="L403">        self.prev_address = <span class="tok-number">0</span>;</span>
<span class="line" id="L404">        self.prev_file = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L405">        self.prev_line = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L406">        self.prev_column = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L407">        self.prev_is_stmt = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L408">        self.prev_basic_block = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L409">        self.prev_end_sequence = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L410">    }</span>
<span class="line" id="L411"></span>
<span class="line" id="L412">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(</span>
<span class="line" id="L413">        is_stmt: <span class="tok-type">bool</span>,</span>
<span class="line" id="L414">        include_dirs: []<span class="tok-kw">const</span> FileEntry,</span>
<span class="line" id="L415">        target_address: <span class="tok-type">u64</span>,</span>
<span class="line" id="L416">        version: <span class="tok-type">u16</span>,</span>
<span class="line" id="L417">    ) LineNumberProgram {</span>
<span class="line" id="L418">        <span class="tok-kw">return</span> LineNumberProgram{</span>
<span class="line" id="L419">            .address = <span class="tok-number">0</span>,</span>
<span class="line" id="L420">            .file = <span class="tok-number">1</span>,</span>
<span class="line" id="L421">            .line = <span class="tok-number">1</span>,</span>
<span class="line" id="L422">            .column = <span class="tok-number">0</span>,</span>
<span class="line" id="L423">            .version = version,</span>
<span class="line" id="L424">            .is_stmt = is_stmt,</span>
<span class="line" id="L425">            .basic_block = <span class="tok-null">false</span>,</span>
<span class="line" id="L426">            .end_sequence = <span class="tok-null">false</span>,</span>
<span class="line" id="L427">            .include_dirs = include_dirs,</span>
<span class="line" id="L428">            .default_is_stmt = is_stmt,</span>
<span class="line" id="L429">            .target_address = target_address,</span>
<span class="line" id="L430">            .prev_valid = <span class="tok-null">false</span>,</span>
<span class="line" id="L431">            .prev_address = <span class="tok-number">0</span>,</span>
<span class="line" id="L432">            .prev_file = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L433">            .prev_line = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L434">            .prev_column = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L435">            .prev_is_stmt = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L436">            .prev_basic_block = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L437">            .prev_end_sequence = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L438">        };</span>
<span class="line" id="L439">    }</span>
<span class="line" id="L440"></span>
<span class="line" id="L441">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkLineMatch</span>(</span>
<span class="line" id="L442">        self: *LineNumberProgram,</span>
<span class="line" id="L443">        allocator: mem.Allocator,</span>
<span class="line" id="L444">        file_entries: []<span class="tok-kw">const</span> FileEntry,</span>
<span class="line" id="L445">    ) !?debug.LineInfo {</span>
<span class="line" id="L446">        <span class="tok-kw">if</span> (self.prev_valid <span class="tok-kw">and</span></span>
<span class="line" id="L447">            self.target_address &gt;= self.prev_address <span class="tok-kw">and</span></span>
<span class="line" id="L448">            self.target_address &lt; self.address)</span>
<span class="line" id="L449">        {</span>
<span class="line" id="L450">            <span class="tok-kw">const</span> file_index = <span class="tok-kw">if</span> (self.version &gt;= <span class="tok-number">5</span>) self.prev_file <span class="tok-kw">else</span> i: {</span>
<span class="line" id="L451">                <span class="tok-kw">if</span> (self.prev_file == <span class="tok-number">0</span>) <span class="tok-kw">return</span> missingDwarf();</span>
<span class="line" id="L452">                <span class="tok-kw">break</span> :i self.prev_file - <span class="tok-number">1</span>;</span>
<span class="line" id="L453">            };</span>
<span class="line" id="L454"></span>
<span class="line" id="L455">            <span class="tok-kw">if</span> (file_index &gt;= file_entries.len) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L456">            <span class="tok-kw">const</span> file_entry = &amp;file_entries[file_index];</span>
<span class="line" id="L457"></span>
<span class="line" id="L458">            <span class="tok-kw">if</span> (file_entry.dir_index &gt;= self.include_dirs.len) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L459">            <span class="tok-kw">const</span> dir_name = self.include_dirs[file_entry.dir_index].path;</span>
<span class="line" id="L460"></span>
<span class="line" id="L461">            <span class="tok-kw">const</span> file_name = <span class="tok-kw">try</span> fs.path.join(allocator, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{</span>
<span class="line" id="L462">                dir_name, file_entry.path,</span>
<span class="line" id="L463">            });</span>
<span class="line" id="L464"></span>
<span class="line" id="L465">            <span class="tok-kw">return</span> debug.LineInfo{</span>
<span class="line" id="L466">                .line = <span class="tok-kw">if</span> (self.prev_line &gt;= <span class="tok-number">0</span>) <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@intCast</span>(self.prev_line)) <span class="tok-kw">else</span> <span class="tok-number">0</span>,</span>
<span class="line" id="L467">                .column = self.prev_column,</span>
<span class="line" id="L468">                .file_name = file_name,</span>
<span class="line" id="L469">            };</span>
<span class="line" id="L470">        }</span>
<span class="line" id="L471"></span>
<span class="line" id="L472">        self.prev_valid = <span class="tok-null">true</span>;</span>
<span class="line" id="L473">        self.prev_address = self.address;</span>
<span class="line" id="L474">        self.prev_file = self.file;</span>
<span class="line" id="L475">        self.prev_line = self.line;</span>
<span class="line" id="L476">        self.prev_column = self.column;</span>
<span class="line" id="L477">        self.prev_is_stmt = self.is_stmt;</span>
<span class="line" id="L478">        self.prev_basic_block = self.basic_block;</span>
<span class="line" id="L479">        self.prev_end_sequence = self.end_sequence;</span>
<span class="line" id="L480">        <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L481">    }</span>
<span class="line" id="L482">};</span>
<span class="line" id="L483"></span>
<span class="line" id="L484"><span class="tok-kw">fn</span> <span class="tok-fn">readUnitLength</span>(in_stream: <span class="tok-kw">anytype</span>, endian: std.builtin.Endian, is_64: *<span class="tok-type">bool</span>) !<span class="tok-type">u64</span> {</span>
<span class="line" id="L485">    <span class="tok-kw">const</span> first_32_bits = <span class="tok-kw">try</span> in_stream.readInt(<span class="tok-type">u32</span>, endian);</span>
<span class="line" id="L486">    is_64.* = (first_32_bits == <span class="tok-number">0xffffffff</span>);</span>
<span class="line" id="L487">    <span class="tok-kw">if</span> (is_64.*) {</span>
<span class="line" id="L488">        <span class="tok-kw">return</span> in_stream.readInt(<span class="tok-type">u64</span>, endian);</span>
<span class="line" id="L489">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L490">        <span class="tok-kw">if</span> (first_32_bits &gt;= <span class="tok-number">0xfffffff0</span>) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L491">        <span class="tok-comment">// TODO this cast should not be needed</span>
</span>
<span class="line" id="L492">        <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, first_32_bits);</span>
<span class="line" id="L493">    }</span>
<span class="line" id="L494">}</span>
<span class="line" id="L495"></span>
<span class="line" id="L496"><span class="tok-comment">// TODO the nosuspends here are workarounds</span>
</span>
<span class="line" id="L497"><span class="tok-kw">fn</span> <span class="tok-fn">readAllocBytes</span>(allocator: mem.Allocator, in_stream: <span class="tok-kw">anytype</span>, size: <span class="tok-type">usize</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L498">    <span class="tok-kw">const</span> buf = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, size);</span>
<span class="line" id="L499">    <span class="tok-kw">errdefer</span> allocator.free(buf);</span>
<span class="line" id="L500">    <span class="tok-kw">if</span> ((<span class="tok-kw">try</span> <span class="tok-kw">nosuspend</span> in_stream.read(buf)) &lt; size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EndOfFile;</span>
<span class="line" id="L501">    <span class="tok-kw">return</span> buf;</span>
<span class="line" id="L502">}</span>
<span class="line" id="L503"></span>
<span class="line" id="L504"><span class="tok-comment">// TODO the nosuspends here are workarounds</span>
</span>
<span class="line" id="L505"><span class="tok-kw">fn</span> <span class="tok-fn">readAddress</span>(in_stream: <span class="tok-kw">anytype</span>, endian: std.builtin.Endian, is_64: <span class="tok-type">bool</span>) !<span class="tok-type">u64</span> {</span>
<span class="line" id="L506">    <span class="tok-kw">return</span> <span class="tok-kw">nosuspend</span> <span class="tok-kw">if</span> (is_64)</span>
<span class="line" id="L507">        <span class="tok-kw">try</span> in_stream.readInt(<span class="tok-type">u64</span>, endian)</span>
<span class="line" id="L508">    <span class="tok-kw">else</span></span>
<span class="line" id="L509">        <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-kw">try</span> in_stream.readInt(<span class="tok-type">u32</span>, endian));</span>
<span class="line" id="L510">}</span>
<span class="line" id="L511"></span>
<span class="line" id="L512"><span class="tok-kw">fn</span> <span class="tok-fn">parseFormValueBlockLen</span>(allocator: mem.Allocator, in_stream: <span class="tok-kw">anytype</span>, size: <span class="tok-type">usize</span>) !FormValue {</span>
<span class="line" id="L513">    <span class="tok-kw">const</span> buf = <span class="tok-kw">try</span> readAllocBytes(allocator, in_stream, size);</span>
<span class="line" id="L514">    <span class="tok-kw">return</span> FormValue{ .Block = buf };</span>
<span class="line" id="L515">}</span>
<span class="line" id="L516"></span>
<span class="line" id="L517"><span class="tok-comment">// TODO the nosuspends here are workarounds</span>
</span>
<span class="line" id="L518"><span class="tok-kw">fn</span> <span class="tok-fn">parseFormValueBlock</span>(allocator: mem.Allocator, in_stream: <span class="tok-kw">anytype</span>, endian: std.builtin.Endian, size: <span class="tok-type">usize</span>) !FormValue {</span>
<span class="line" id="L519">    <span class="tok-kw">const</span> block_len = <span class="tok-kw">try</span> <span class="tok-kw">nosuspend</span> in_stream.readVarInt(<span class="tok-type">usize</span>, endian, size);</span>
<span class="line" id="L520">    <span class="tok-kw">return</span> parseFormValueBlockLen(allocator, in_stream, block_len);</span>
<span class="line" id="L521">}</span>
<span class="line" id="L522"></span>
<span class="line" id="L523"><span class="tok-kw">fn</span> <span class="tok-fn">parseFormValueConstant</span>(in_stream: <span class="tok-kw">anytype</span>, signed: <span class="tok-type">bool</span>, endian: std.builtin.Endian, <span class="tok-kw">comptime</span> size: <span class="tok-type">i32</span>) !FormValue {</span>
<span class="line" id="L524">    <span class="tok-comment">// TODO: Please forgive me, I've worked around zig not properly spilling some intermediate values here.</span>
</span>
<span class="line" id="L525">    <span class="tok-comment">// `nosuspend` should be removed from all the function calls once it is fixed.</span>
</span>
<span class="line" id="L526">    <span class="tok-kw">return</span> FormValue{</span>
<span class="line" id="L527">        .Const = Constant{</span>
<span class="line" id="L528">            .signed = signed,</span>
<span class="line" id="L529">            .payload = <span class="tok-kw">switch</span> (size) {</span>
<span class="line" id="L530">                <span class="tok-number">1</span> =&gt; <span class="tok-kw">try</span> <span class="tok-kw">nosuspend</span> in_stream.readInt(<span class="tok-type">u8</span>, endian),</span>
<span class="line" id="L531">                <span class="tok-number">2</span> =&gt; <span class="tok-kw">try</span> <span class="tok-kw">nosuspend</span> in_stream.readInt(<span class="tok-type">u16</span>, endian),</span>
<span class="line" id="L532">                <span class="tok-number">4</span> =&gt; <span class="tok-kw">try</span> <span class="tok-kw">nosuspend</span> in_stream.readInt(<span class="tok-type">u32</span>, endian),</span>
<span class="line" id="L533">                <span class="tok-number">8</span> =&gt; <span class="tok-kw">try</span> <span class="tok-kw">nosuspend</span> in_stream.readInt(<span class="tok-type">u64</span>, endian),</span>
<span class="line" id="L534">                -<span class="tok-number">1</span> =&gt; blk: {</span>
<span class="line" id="L535">                    <span class="tok-kw">if</span> (signed) {</span>
<span class="line" id="L536">                        <span class="tok-kw">const</span> x = <span class="tok-kw">try</span> <span class="tok-kw">nosuspend</span> leb.readILEB128(<span class="tok-type">i64</span>, in_stream);</span>
<span class="line" id="L537">                        <span class="tok-kw">break</span> :blk <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@bitCast</span>(x));</span>
<span class="line" id="L538">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L539">                        <span class="tok-kw">const</span> x = <span class="tok-kw">try</span> <span class="tok-kw">nosuspend</span> leb.readULEB128(<span class="tok-type">u64</span>, in_stream);</span>
<span class="line" id="L540">                        <span class="tok-kw">break</span> :blk x;</span>
<span class="line" id="L541">                    }</span>
<span class="line" id="L542">                },</span>
<span class="line" id="L543">                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Invalid size&quot;</span>),</span>
<span class="line" id="L544">            },</span>
<span class="line" id="L545">        },</span>
<span class="line" id="L546">    };</span>
<span class="line" id="L547">}</span>
<span class="line" id="L548"></span>
<span class="line" id="L549"><span class="tok-comment">// TODO the nosuspends here are workarounds</span>
</span>
<span class="line" id="L550"><span class="tok-kw">fn</span> <span class="tok-fn">parseFormValueRef</span>(in_stream: <span class="tok-kw">anytype</span>, endian: std.builtin.Endian, size: <span class="tok-type">i32</span>) !FormValue {</span>
<span class="line" id="L551">    <span class="tok-kw">return</span> FormValue{</span>
<span class="line" id="L552">        .Ref = <span class="tok-kw">switch</span> (size) {</span>
<span class="line" id="L553">            <span class="tok-number">1</span> =&gt; <span class="tok-kw">try</span> <span class="tok-kw">nosuspend</span> in_stream.readInt(<span class="tok-type">u8</span>, endian),</span>
<span class="line" id="L554">            <span class="tok-number">2</span> =&gt; <span class="tok-kw">try</span> <span class="tok-kw">nosuspend</span> in_stream.readInt(<span class="tok-type">u16</span>, endian),</span>
<span class="line" id="L555">            <span class="tok-number">4</span> =&gt; <span class="tok-kw">try</span> <span class="tok-kw">nosuspend</span> in_stream.readInt(<span class="tok-type">u32</span>, endian),</span>
<span class="line" id="L556">            <span class="tok-number">8</span> =&gt; <span class="tok-kw">try</span> <span class="tok-kw">nosuspend</span> in_stream.readInt(<span class="tok-type">u64</span>, endian),</span>
<span class="line" id="L557">            -<span class="tok-number">1</span> =&gt; <span class="tok-kw">try</span> <span class="tok-kw">nosuspend</span> leb.readULEB128(<span class="tok-type">u64</span>, in_stream),</span>
<span class="line" id="L558">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L559">        },</span>
<span class="line" id="L560">    };</span>
<span class="line" id="L561">}</span>
<span class="line" id="L562"></span>
<span class="line" id="L563"><span class="tok-comment">// TODO the nosuspends here are workarounds</span>
</span>
<span class="line" id="L564"><span class="tok-kw">fn</span> <span class="tok-fn">parseFormValue</span>(allocator: mem.Allocator, in_stream: <span class="tok-kw">anytype</span>, form_id: <span class="tok-type">u64</span>, endian: std.builtin.Endian, is_64: <span class="tok-type">bool</span>) <span class="tok-type">anyerror</span>!FormValue {</span>
<span class="line" id="L565">    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (form_id) {</span>
<span class="line" id="L566">        FORM.addr =&gt; FormValue{ .Address = <span class="tok-kw">try</span> readAddress(in_stream, endian, <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) == <span class="tok-number">8</span>) },</span>
<span class="line" id="L567">        FORM.addrx1 =&gt; <span class="tok-kw">return</span> FormValue{ .AddrOffset = <span class="tok-kw">try</span> in_stream.readInt(<span class="tok-type">u8</span>, endian) },</span>
<span class="line" id="L568">        FORM.addrx2 =&gt; <span class="tok-kw">return</span> FormValue{ .AddrOffset = <span class="tok-kw">try</span> in_stream.readInt(<span class="tok-type">u16</span>, endian) },</span>
<span class="line" id="L569">        FORM.addrx3 =&gt; <span class="tok-kw">return</span> FormValue{ .AddrOffset = <span class="tok-kw">try</span> in_stream.readInt(<span class="tok-type">u24</span>, endian) },</span>
<span class="line" id="L570">        FORM.addrx4 =&gt; <span class="tok-kw">return</span> FormValue{ .AddrOffset = <span class="tok-kw">try</span> in_stream.readInt(<span class="tok-type">u32</span>, endian) },</span>
<span class="line" id="L571">        FORM.addrx =&gt; <span class="tok-kw">return</span> FormValue{ .AddrOffset = <span class="tok-kw">try</span> <span class="tok-kw">nosuspend</span> leb.readULEB128(<span class="tok-type">usize</span>, in_stream) },</span>
<span class="line" id="L572"></span>
<span class="line" id="L573">        FORM.block1 =&gt; parseFormValueBlock(allocator, in_stream, endian, <span class="tok-number">1</span>),</span>
<span class="line" id="L574">        FORM.block2 =&gt; parseFormValueBlock(allocator, in_stream, endian, <span class="tok-number">2</span>),</span>
<span class="line" id="L575">        FORM.block4 =&gt; parseFormValueBlock(allocator, in_stream, endian, <span class="tok-number">4</span>),</span>
<span class="line" id="L576">        FORM.block =&gt; {</span>
<span class="line" id="L577">            <span class="tok-kw">const</span> block_len = <span class="tok-kw">try</span> <span class="tok-kw">nosuspend</span> leb.readULEB128(<span class="tok-type">usize</span>, in_stream);</span>
<span class="line" id="L578">            <span class="tok-kw">return</span> parseFormValueBlockLen(allocator, in_stream, block_len);</span>
<span class="line" id="L579">        },</span>
<span class="line" id="L580">        FORM.data1 =&gt; parseFormValueConstant(in_stream, <span class="tok-null">false</span>, endian, <span class="tok-number">1</span>),</span>
<span class="line" id="L581">        FORM.data2 =&gt; parseFormValueConstant(in_stream, <span class="tok-null">false</span>, endian, <span class="tok-number">2</span>),</span>
<span class="line" id="L582">        FORM.data4 =&gt; parseFormValueConstant(in_stream, <span class="tok-null">false</span>, endian, <span class="tok-number">4</span>),</span>
<span class="line" id="L583">        FORM.data8 =&gt; parseFormValueConstant(in_stream, <span class="tok-null">false</span>, endian, <span class="tok-number">8</span>),</span>
<span class="line" id="L584">        FORM.data16 =&gt; {</span>
<span class="line" id="L585">            <span class="tok-kw">var</span> buf: [<span class="tok-number">16</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L586">            <span class="tok-kw">if</span> ((<span class="tok-kw">try</span> <span class="tok-kw">nosuspend</span> in_stream.readAll(&amp;buf)) &lt; <span class="tok-number">16</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EndOfFile;</span>
<span class="line" id="L587">            <span class="tok-kw">return</span> FormValue{ .data16 = buf };</span>
<span class="line" id="L588">        },</span>
<span class="line" id="L589">        FORM.udata, FORM.sdata =&gt; {</span>
<span class="line" id="L590">            <span class="tok-kw">const</span> signed = form_id == FORM.sdata;</span>
<span class="line" id="L591">            <span class="tok-kw">return</span> parseFormValueConstant(in_stream, signed, endian, -<span class="tok-number">1</span>);</span>
<span class="line" id="L592">        },</span>
<span class="line" id="L593">        FORM.exprloc =&gt; {</span>
<span class="line" id="L594">            <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> <span class="tok-kw">nosuspend</span> leb.readULEB128(<span class="tok-type">usize</span>, in_stream);</span>
<span class="line" id="L595">            <span class="tok-kw">const</span> buf = <span class="tok-kw">try</span> readAllocBytes(allocator, in_stream, size);</span>
<span class="line" id="L596">            <span class="tok-kw">return</span> FormValue{ .ExprLoc = buf };</span>
<span class="line" id="L597">        },</span>
<span class="line" id="L598">        FORM.flag =&gt; FormValue{ .Flag = (<span class="tok-kw">try</span> <span class="tok-kw">nosuspend</span> in_stream.readByte()) != <span class="tok-number">0</span> },</span>
<span class="line" id="L599">        FORM.flag_present =&gt; FormValue{ .Flag = <span class="tok-null">true</span> },</span>
<span class="line" id="L600">        FORM.sec_offset =&gt; FormValue{ .SecOffset = <span class="tok-kw">try</span> readAddress(in_stream, endian, is_64) },</span>
<span class="line" id="L601"></span>
<span class="line" id="L602">        FORM.ref1 =&gt; parseFormValueRef(in_stream, endian, <span class="tok-number">1</span>),</span>
<span class="line" id="L603">        FORM.ref2 =&gt; parseFormValueRef(in_stream, endian, <span class="tok-number">2</span>),</span>
<span class="line" id="L604">        FORM.ref4 =&gt; parseFormValueRef(in_stream, endian, <span class="tok-number">4</span>),</span>
<span class="line" id="L605">        FORM.ref8 =&gt; parseFormValueRef(in_stream, endian, <span class="tok-number">8</span>),</span>
<span class="line" id="L606">        FORM.ref_udata =&gt; parseFormValueRef(in_stream, endian, -<span class="tok-number">1</span>),</span>
<span class="line" id="L607"></span>
<span class="line" id="L608">        FORM.ref_addr =&gt; FormValue{ .RefAddr = <span class="tok-kw">try</span> readAddress(in_stream, endian, is_64) },</span>
<span class="line" id="L609">        FORM.ref_sig8 =&gt; FormValue{ .Ref = <span class="tok-kw">try</span> <span class="tok-kw">nosuspend</span> in_stream.readInt(<span class="tok-type">u64</span>, endian) },</span>
<span class="line" id="L610"></span>
<span class="line" id="L611">        FORM.string =&gt; FormValue{ .String = <span class="tok-kw">try</span> in_stream.readUntilDelimiterAlloc(allocator, <span class="tok-number">0</span>, math.maxInt(<span class="tok-type">usize</span>)) },</span>
<span class="line" id="L612">        FORM.strp =&gt; FormValue{ .StrPtr = <span class="tok-kw">try</span> readAddress(in_stream, endian, is_64) },</span>
<span class="line" id="L613">        FORM.strx1 =&gt; <span class="tok-kw">return</span> FormValue{ .StrOffset = <span class="tok-kw">try</span> in_stream.readInt(<span class="tok-type">u8</span>, endian) },</span>
<span class="line" id="L614">        FORM.strx2 =&gt; <span class="tok-kw">return</span> FormValue{ .StrOffset = <span class="tok-kw">try</span> in_stream.readInt(<span class="tok-type">u16</span>, endian) },</span>
<span class="line" id="L615">        FORM.strx3 =&gt; <span class="tok-kw">return</span> FormValue{ .StrOffset = <span class="tok-kw">try</span> in_stream.readInt(<span class="tok-type">u24</span>, endian) },</span>
<span class="line" id="L616">        FORM.strx4 =&gt; <span class="tok-kw">return</span> FormValue{ .StrOffset = <span class="tok-kw">try</span> in_stream.readInt(<span class="tok-type">u32</span>, endian) },</span>
<span class="line" id="L617">        FORM.strx =&gt; <span class="tok-kw">return</span> FormValue{ .StrOffset = <span class="tok-kw">try</span> <span class="tok-kw">nosuspend</span> leb.readULEB128(<span class="tok-type">usize</span>, in_stream) },</span>
<span class="line" id="L618">        FORM.line_strp =&gt; FormValue{ .LineStrPtr = <span class="tok-kw">try</span> readAddress(in_stream, endian, is_64) },</span>
<span class="line" id="L619">        FORM.indirect =&gt; {</span>
<span class="line" id="L620">            <span class="tok-kw">const</span> child_form_id = <span class="tok-kw">try</span> <span class="tok-kw">nosuspend</span> leb.readULEB128(<span class="tok-type">u64</span>, in_stream);</span>
<span class="line" id="L621">            <span class="tok-kw">if</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L622">                <span class="tok-kw">return</span> parseFormValue(allocator, in_stream, child_form_id, endian, is_64);</span>
<span class="line" id="L623">            }</span>
<span class="line" id="L624">            <span class="tok-kw">const</span> F = <span class="tok-builtin">@TypeOf</span>(<span class="tok-kw">async</span> parseFormValue(allocator, in_stream, child_form_id, endian, is_64));</span>
<span class="line" id="L625">            <span class="tok-kw">var</span> frame = <span class="tok-kw">try</span> allocator.create(F);</span>
<span class="line" id="L626">            <span class="tok-kw">defer</span> allocator.destroy(frame);</span>
<span class="line" id="L627">            <span class="tok-kw">return</span> <span class="tok-kw">await</span> <span class="tok-builtin">@asyncCall</span>(frame, {}, parseFormValue, .{ allocator, in_stream, child_form_id, endian, is_64 });</span>
<span class="line" id="L628">        },</span>
<span class="line" id="L629">        FORM.implicit_const =&gt; FormValue{ .Const = Constant{ .signed = <span class="tok-null">true</span>, .payload = <span class="tok-null">undefined</span> } },</span>
<span class="line" id="L630">        FORM.loclistx =&gt; <span class="tok-kw">return</span> FormValue{ .LocListOffset = <span class="tok-kw">try</span> <span class="tok-kw">nosuspend</span> leb.readULEB128(<span class="tok-type">u64</span>, in_stream) },</span>
<span class="line" id="L631">        FORM.rnglistx =&gt; <span class="tok-kw">return</span> FormValue{ .RangeListOffset = <span class="tok-kw">try</span> <span class="tok-kw">nosuspend</span> leb.readULEB128(<span class="tok-type">u64</span>, in_stream) },</span>
<span class="line" id="L632">        <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L633">            <span class="tok-comment">//std.debug.print(&quot;unrecognized form id: {x}\n&quot;, .{form_id});</span>
</span>
<span class="line" id="L634">            <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L635">        },</span>
<span class="line" id="L636">    };</span>
<span class="line" id="L637">}</span>
<span class="line" id="L638"></span>
<span class="line" id="L639"><span class="tok-kw">fn</span> <span class="tok-fn">getAbbrevTableEntry</span>(abbrev_table: *<span class="tok-kw">const</span> AbbrevTable, abbrev_code: <span class="tok-type">u64</span>) ?*<span class="tok-kw">const</span> AbbrevTableEntry {</span>
<span class="line" id="L640">    <span class="tok-kw">for</span> (abbrev_table.items) |*table_entry| {</span>
<span class="line" id="L641">        <span class="tok-kw">if</span> (table_entry.abbrev_code == abbrev_code) <span class="tok-kw">return</span> table_entry;</span>
<span class="line" id="L642">    }</span>
<span class="line" id="L643">    <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L644">}</span>
<span class="line" id="L645"></span>
<span class="line" id="L646"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DwarfSection = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L647">    debug_info,</span>
<span class="line" id="L648">    debug_abbrev,</span>
<span class="line" id="L649">    debug_str,</span>
<span class="line" id="L650">    debug_str_offsets,</span>
<span class="line" id="L651">    debug_line,</span>
<span class="line" id="L652">    debug_line_str,</span>
<span class="line" id="L653">    debug_ranges,</span>
<span class="line" id="L654">    debug_loclists,</span>
<span class="line" id="L655">    debug_rnglists,</span>
<span class="line" id="L656">    debug_addr,</span>
<span class="line" id="L657">    debug_names,</span>
<span class="line" id="L658">    debug_frame,</span>
<span class="line" id="L659">    eh_frame,</span>
<span class="line" id="L660">    eh_frame_hdr,</span>
<span class="line" id="L661">};</span>
<span class="line" id="L662"></span>
<span class="line" id="L663"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DwarfInfo = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L664">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Section = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L665">        data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L666">        <span class="tok-comment">// Module-relative virtual address.</span>
</span>
<span class="line" id="L667">        <span class="tok-comment">// Only set if the section data was loaded from disk.</span>
</span>
<span class="line" id="L668">        virtual_address: ?<span class="tok-type">usize</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L669">        <span class="tok-comment">// If `data` is owned by this DwarfInfo.</span>
</span>
<span class="line" id="L670">        owned: <span class="tok-type">bool</span>,</span>
<span class="line" id="L671"></span>
<span class="line" id="L672">        <span class="tok-comment">// For sections that are not memory mapped by the loader, this is an offset</span>
</span>
<span class="line" id="L673">        <span class="tok-comment">// from `data.ptr` to where the section would have been mapped. Otherwise,</span>
</span>
<span class="line" id="L674">        <span class="tok-comment">// `data` is directly backed by the section and the offset is zero.</span>
</span>
<span class="line" id="L675">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">virtualOffset</span>(self: Section, base_address: <span class="tok-type">usize</span>) <span class="tok-type">i64</span> {</span>
<span class="line" id="L676">            <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.virtual_address) |va|</span>
<span class="line" id="L677">                <span class="tok-builtin">@as</span>(<span class="tok-type">i64</span>, <span class="tok-builtin">@intCast</span>(base_address + va)) -</span>
<span class="line" id="L678">                    <span class="tok-builtin">@as</span>(<span class="tok-type">i64</span>, <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@intFromPtr</span>(self.data.ptr)))</span>
<span class="line" id="L679">            <span class="tok-kw">else</span></span>
<span class="line" id="L680">                <span class="tok-number">0</span>;</span>
<span class="line" id="L681">        }</span>
<span class="line" id="L682">    };</span>
<span class="line" id="L683"></span>
<span class="line" id="L684">    <span class="tok-kw">const</span> num_sections = std.enums.directEnumArrayLen(DwarfSection, <span class="tok-number">0</span>);</span>
<span class="line" id="L685">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> SectionArray = [num_sections]?Section;</span>
<span class="line" id="L686">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> null_section_array = [_]?Section{<span class="tok-null">null</span>} ** num_sections;</span>
<span class="line" id="L687"></span>
<span class="line" id="L688">    endian: std.builtin.Endian,</span>
<span class="line" id="L689">    sections: SectionArray = null_section_array,</span>
<span class="line" id="L690">    is_macho: <span class="tok-type">bool</span>,</span>
<span class="line" id="L691"></span>
<span class="line" id="L692">    <span class="tok-comment">// Filled later by the initializer</span>
</span>
<span class="line" id="L693">    abbrev_table_list: std.ArrayListUnmanaged(AbbrevTableHeader) = .{},</span>
<span class="line" id="L694">    compile_unit_list: std.ArrayListUnmanaged(CompileUnit) = .{},</span>
<span class="line" id="L695">    func_list: std.ArrayListUnmanaged(Func) = .{},</span>
<span class="line" id="L696"></span>
<span class="line" id="L697">    eh_frame_hdr: ?ExceptionFrameHeader = <span class="tok-null">null</span>,</span>
<span class="line" id="L698">    <span class="tok-comment">// These lookup tables are only used if `eh_frame_hdr` is null</span>
</span>
<span class="line" id="L699">    cie_map: std.AutoArrayHashMapUnmanaged(<span class="tok-type">u64</span>, CommonInformationEntry) = .{},</span>
<span class="line" id="L700">    <span class="tok-comment">// Sorted by start_pc</span>
</span>
<span class="line" id="L701">    fde_list: std.ArrayListUnmanaged(FrameDescriptionEntry) = .{},</span>
<span class="line" id="L702"></span>
<span class="line" id="L703">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">section</span>(di: DwarfInfo, dwarf_section: DwarfSection) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L704">        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (di.sections[<span class="tok-builtin">@intFromEnum</span>(dwarf_section)]) |s| s.data <span class="tok-kw">else</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L705">    }</span>
<span class="line" id="L706"></span>
<span class="line" id="L707">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sectionVirtualOffset</span>(di: DwarfInfo, dwarf_section: DwarfSection, base_address: <span class="tok-type">usize</span>) ?<span class="tok-type">i64</span> {</span>
<span class="line" id="L708">        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (di.sections[<span class="tok-builtin">@intFromEnum</span>(dwarf_section)]) |s| s.virtualOffset(base_address) <span class="tok-kw">else</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L709">    }</span>
<span class="line" id="L710"></span>
<span class="line" id="L711">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(di: *DwarfInfo, allocator: mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L712">        <span class="tok-kw">for</span> (di.sections) |opt_section| {</span>
<span class="line" id="L713">            <span class="tok-kw">if</span> (opt_section) |s| <span class="tok-kw">if</span> (s.owned) allocator.free(s.data);</span>
<span class="line" id="L714">        }</span>
<span class="line" id="L715">        <span class="tok-kw">for</span> (di.abbrev_table_list.items) |*abbrev| {</span>
<span class="line" id="L716">            abbrev.deinit();</span>
<span class="line" id="L717">        }</span>
<span class="line" id="L718">        di.abbrev_table_list.deinit(allocator);</span>
<span class="line" id="L719">        <span class="tok-kw">for</span> (di.compile_unit_list.items) |*cu| {</span>
<span class="line" id="L720">            cu.die.deinit(allocator);</span>
<span class="line" id="L721">            allocator.destroy(cu.die);</span>
<span class="line" id="L722">        }</span>
<span class="line" id="L723">        di.compile_unit_list.deinit(allocator);</span>
<span class="line" id="L724">        di.func_list.deinit(allocator);</span>
<span class="line" id="L725">        di.cie_map.deinit(allocator);</span>
<span class="line" id="L726">        di.fde_list.deinit(allocator);</span>
<span class="line" id="L727">    }</span>
<span class="line" id="L728"></span>
<span class="line" id="L729">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSymbolName</span>(di: *DwarfInfo, address: <span class="tok-type">u64</span>) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L730">        <span class="tok-kw">for</span> (di.func_list.items) |*func| {</span>
<span class="line" id="L731">            <span class="tok-kw">if</span> (func.pc_range) |range| {</span>
<span class="line" id="L732">                <span class="tok-kw">if</span> (address &gt;= range.start <span class="tok-kw">and</span> address &lt; range.end) {</span>
<span class="line" id="L733">                    <span class="tok-kw">return</span> func.name;</span>
<span class="line" id="L734">                }</span>
<span class="line" id="L735">            }</span>
<span class="line" id="L736">        }</span>
<span class="line" id="L737"></span>
<span class="line" id="L738">        <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L739">    }</span>
<span class="line" id="L740"></span>
<span class="line" id="L741">    <span class="tok-kw">fn</span> <span class="tok-fn">scanAllFunctions</span>(di: *DwarfInfo, allocator: mem.Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L742">        <span class="tok-kw">var</span> stream = io.fixedBufferStream(di.section(.debug_info).?);</span>
<span class="line" id="L743">        <span class="tok-kw">const</span> in = stream.reader();</span>
<span class="line" id="L744">        <span class="tok-kw">const</span> seekable = stream.seekableStream();</span>
<span class="line" id="L745">        <span class="tok-kw">var</span> this_unit_offset: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L746"></span>
<span class="line" id="L747">        <span class="tok-kw">var</span> tmp_arena = std.heap.ArenaAllocator.init(allocator);</span>
<span class="line" id="L748">        <span class="tok-kw">defer</span> tmp_arena.deinit();</span>
<span class="line" id="L749">        <span class="tok-kw">const</span> arena = tmp_arena.allocator();</span>
<span class="line" id="L750"></span>
<span class="line" id="L751">        <span class="tok-kw">while</span> (this_unit_offset &lt; <span class="tok-kw">try</span> seekable.getEndPos()) {</span>
<span class="line" id="L752">            <span class="tok-kw">try</span> seekable.seekTo(this_unit_offset);</span>
<span class="line" id="L753"></span>
<span class="line" id="L754">            <span class="tok-kw">var</span> is_64: <span class="tok-type">bool</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L755">            <span class="tok-kw">const</span> unit_length = <span class="tok-kw">try</span> readUnitLength(in, di.endian, &amp;is_64);</span>
<span class="line" id="L756">            <span class="tok-kw">if</span> (unit_length == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;</span>
<span class="line" id="L757">            <span class="tok-kw">const</span> next_offset = unit_length + (<span class="tok-kw">if</span> (is_64) <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">12</span>) <span class="tok-kw">else</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">4</span>));</span>
<span class="line" id="L758"></span>
<span class="line" id="L759">            <span class="tok-kw">const</span> version = <span class="tok-kw">try</span> in.readInt(<span class="tok-type">u16</span>, di.endian);</span>
<span class="line" id="L760">            <span class="tok-kw">if</span> (version &lt; <span class="tok-number">2</span> <span class="tok-kw">or</span> version &gt; <span class="tok-number">5</span>) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L761"></span>
<span class="line" id="L762">            <span class="tok-kw">var</span> address_size: <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L763">            <span class="tok-kw">var</span> debug_abbrev_offset: <span class="tok-type">u64</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L764">            <span class="tok-kw">if</span> (version &gt;= <span class="tok-number">5</span>) {</span>
<span class="line" id="L765">                <span class="tok-kw">const</span> unit_type = <span class="tok-kw">try</span> in.readInt(<span class="tok-type">u8</span>, di.endian);</span>
<span class="line" id="L766">                <span class="tok-kw">if</span> (unit_type != UT.compile) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L767">                address_size = <span class="tok-kw">try</span> in.readByte();</span>
<span class="line" id="L768">                debug_abbrev_offset = <span class="tok-kw">if</span> (is_64)</span>
<span class="line" id="L769">                    <span class="tok-kw">try</span> in.readInt(<span class="tok-type">u64</span>, di.endian)</span>
<span class="line" id="L770">                <span class="tok-kw">else</span></span>
<span class="line" id="L771">                    <span class="tok-kw">try</span> in.readInt(<span class="tok-type">u32</span>, di.endian);</span>
<span class="line" id="L772">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L773">                debug_abbrev_offset = <span class="tok-kw">if</span> (is_64)</span>
<span class="line" id="L774">                    <span class="tok-kw">try</span> in.readInt(<span class="tok-type">u64</span>, di.endian)</span>
<span class="line" id="L775">                <span class="tok-kw">else</span></span>
<span class="line" id="L776">                    <span class="tok-kw">try</span> in.readInt(<span class="tok-type">u32</span>, di.endian);</span>
<span class="line" id="L777">                address_size = <span class="tok-kw">try</span> in.readByte();</span>
<span class="line" id="L778">            }</span>
<span class="line" id="L779">            <span class="tok-kw">if</span> (address_size != <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L780"></span>
<span class="line" id="L781">            <span class="tok-kw">const</span> compile_unit_pos = <span class="tok-kw">try</span> seekable.getPos();</span>
<span class="line" id="L782">            <span class="tok-kw">const</span> abbrev_table = <span class="tok-kw">try</span> di.getAbbrevTable(allocator, debug_abbrev_offset);</span>
<span class="line" id="L783"></span>
<span class="line" id="L784">            <span class="tok-kw">try</span> seekable.seekTo(compile_unit_pos);</span>
<span class="line" id="L785"></span>
<span class="line" id="L786">            <span class="tok-kw">const</span> next_unit_pos = this_unit_offset + next_offset;</span>
<span class="line" id="L787"></span>
<span class="line" id="L788">            <span class="tok-kw">var</span> compile_unit: CompileUnit = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L789"></span>
<span class="line" id="L790">            <span class="tok-kw">while</span> ((<span class="tok-kw">try</span> seekable.getPos()) &lt; next_unit_pos) {</span>
<span class="line" id="L791">                <span class="tok-kw">var</span> die_obj = (<span class="tok-kw">try</span> di.parseDie(arena, in, abbrev_table, is_64)) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L792">                <span class="tok-kw">const</span> after_die_offset = <span class="tok-kw">try</span> seekable.getPos();</span>
<span class="line" id="L793"></span>
<span class="line" id="L794">                <span class="tok-kw">switch</span> (die_obj.tag_id) {</span>
<span class="line" id="L795">                    TAG.compile_unit =&gt; {</span>
<span class="line" id="L796">                        compile_unit = .{</span>
<span class="line" id="L797">                            .version = version,</span>
<span class="line" id="L798">                            .is_64 = is_64,</span>
<span class="line" id="L799">                            .die = &amp;die_obj,</span>
<span class="line" id="L800">                            .pc_range = <span class="tok-null">null</span>,</span>
<span class="line" id="L801"></span>
<span class="line" id="L802">                            .str_offsets_base = <span class="tok-kw">if</span> (die_obj.getAttr(AT.str_offsets_base)) |fv| <span class="tok-kw">try</span> fv.getUInt(<span class="tok-type">usize</span>) <span class="tok-kw">else</span> <span class="tok-number">0</span>,</span>
<span class="line" id="L803">                            .addr_base = <span class="tok-kw">if</span> (die_obj.getAttr(AT.addr_base)) |fv| <span class="tok-kw">try</span> fv.getUInt(<span class="tok-type">usize</span>) <span class="tok-kw">else</span> <span class="tok-number">0</span>,</span>
<span class="line" id="L804">                            .rnglists_base = <span class="tok-kw">if</span> (die_obj.getAttr(AT.rnglists_base)) |fv| <span class="tok-kw">try</span> fv.getUInt(<span class="tok-type">usize</span>) <span class="tok-kw">else</span> <span class="tok-number">0</span>,</span>
<span class="line" id="L805">                            .loclists_base = <span class="tok-kw">if</span> (die_obj.getAttr(AT.loclists_base)) |fv| <span class="tok-kw">try</span> fv.getUInt(<span class="tok-type">usize</span>) <span class="tok-kw">else</span> <span class="tok-number">0</span>,</span>
<span class="line" id="L806">                            .frame_base = die_obj.getAttr(AT.frame_base),</span>
<span class="line" id="L807">                        };</span>
<span class="line" id="L808">                    },</span>
<span class="line" id="L809">                    TAG.subprogram, TAG.inlined_subroutine, TAG.subroutine, TAG.entry_point =&gt; {</span>
<span class="line" id="L810">                        <span class="tok-kw">const</span> fn_name = x: {</span>
<span class="line" id="L811">                            <span class="tok-kw">var</span> depth: <span class="tok-type">i32</span> = <span class="tok-number">3</span>;</span>
<span class="line" id="L812">                            <span class="tok-kw">var</span> this_die_obj = die_obj;</span>
<span class="line" id="L813">                            <span class="tok-comment">// Prevent endless loops</span>
</span>
<span class="line" id="L814">                            <span class="tok-kw">while</span> (depth &gt; <span class="tok-number">0</span>) : (depth -= <span class="tok-number">1</span>) {</span>
<span class="line" id="L815">                                <span class="tok-kw">if</span> (this_die_obj.getAttr(AT.name)) |_| {</span>
<span class="line" id="L816">                                    <span class="tok-kw">break</span> :x <span class="tok-kw">try</span> this_die_obj.getAttrString(di, AT.name, di.section(.debug_str), compile_unit);</span>
<span class="line" id="L817">                                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (this_die_obj.getAttr(AT.abstract_origin)) |_| {</span>
<span class="line" id="L818">                                    <span class="tok-comment">// Follow the DIE it points to and repeat</span>
</span>
<span class="line" id="L819">                                    <span class="tok-kw">const</span> ref_offset = <span class="tok-kw">try</span> this_die_obj.getAttrRef(AT.abstract_origin);</span>
<span class="line" id="L820">                                    <span class="tok-kw">if</span> (ref_offset &gt; next_offset) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L821">                                    <span class="tok-kw">try</span> seekable.seekTo(this_unit_offset + ref_offset);</span>
<span class="line" id="L822">                                    this_die_obj = (<span class="tok-kw">try</span> di.parseDie(</span>
<span class="line" id="L823">                                        arena,</span>
<span class="line" id="L824">                                        in,</span>
<span class="line" id="L825">                                        abbrev_table,</span>
<span class="line" id="L826">                                        is_64,</span>
<span class="line" id="L827">                                    )) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L828">                                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (this_die_obj.getAttr(AT.specification)) |_| {</span>
<span class="line" id="L829">                                    <span class="tok-comment">// Follow the DIE it points to and repeat</span>
</span>
<span class="line" id="L830">                                    <span class="tok-kw">const</span> ref_offset = <span class="tok-kw">try</span> this_die_obj.getAttrRef(AT.specification);</span>
<span class="line" id="L831">                                    <span class="tok-kw">if</span> (ref_offset &gt; next_offset) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L832">                                    <span class="tok-kw">try</span> seekable.seekTo(this_unit_offset + ref_offset);</span>
<span class="line" id="L833">                                    this_die_obj = (<span class="tok-kw">try</span> di.parseDie(</span>
<span class="line" id="L834">                                        arena,</span>
<span class="line" id="L835">                                        in,</span>
<span class="line" id="L836">                                        abbrev_table,</span>
<span class="line" id="L837">                                        is_64,</span>
<span class="line" id="L838">                                    )) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L839">                                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L840">                                    <span class="tok-kw">break</span> :x <span class="tok-null">null</span>;</span>
<span class="line" id="L841">                                }</span>
<span class="line" id="L842">                            }</span>
<span class="line" id="L843"></span>
<span class="line" id="L844">                            <span class="tok-kw">break</span> :x <span class="tok-null">null</span>;</span>
<span class="line" id="L845">                        };</span>
<span class="line" id="L846"></span>
<span class="line" id="L847">                        <span class="tok-kw">var</span> range_added = <span class="tok-kw">if</span> (die_obj.getAttrAddr(di, AT.low_pc, compile_unit)) |low_pc| blk: {</span>
<span class="line" id="L848">                            <span class="tok-kw">if</span> (die_obj.getAttr(AT.high_pc)) |high_pc_value| {</span>
<span class="line" id="L849">                                <span class="tok-kw">const</span> pc_end = <span class="tok-kw">switch</span> (high_pc_value.*) {</span>
<span class="line" id="L850">                                    FormValue.Address =&gt; |value| value,</span>
<span class="line" id="L851">                                    FormValue.Const =&gt; |value| b: {</span>
<span class="line" id="L852">                                        <span class="tok-kw">const</span> offset = <span class="tok-kw">try</span> value.asUnsignedLe();</span>
<span class="line" id="L853">                                        <span class="tok-kw">break</span> :b (low_pc + offset);</span>
<span class="line" id="L854">                                    },</span>
<span class="line" id="L855">                                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> badDwarf(),</span>
<span class="line" id="L856">                                };</span>
<span class="line" id="L857"></span>
<span class="line" id="L858">                                <span class="tok-kw">try</span> di.func_list.append(allocator, Func{</span>
<span class="line" id="L859">                                    .name = fn_name,</span>
<span class="line" id="L860">                                    .pc_range = .{</span>
<span class="line" id="L861">                                        .start = low_pc,</span>
<span class="line" id="L862">                                        .end = pc_end,</span>
<span class="line" id="L863">                                    },</span>
<span class="line" id="L864">                                });</span>
<span class="line" id="L865"></span>
<span class="line" id="L866">                                <span class="tok-kw">break</span> :blk <span class="tok-null">true</span>;</span>
<span class="line" id="L867">                            }</span>
<span class="line" id="L868"></span>
<span class="line" id="L869">                            <span class="tok-kw">break</span> :blk <span class="tok-null">false</span>;</span>
<span class="line" id="L870">                        } <span class="tok-kw">else</span> |err| blk: {</span>
<span class="line" id="L871">                            <span class="tok-kw">if</span> (err != <span class="tok-kw">error</span>.MissingDebugInfo) <span class="tok-kw">return</span> err;</span>
<span class="line" id="L872">                            <span class="tok-kw">break</span> :blk <span class="tok-null">false</span>;</span>
<span class="line" id="L873">                        };</span>
<span class="line" id="L874"></span>
<span class="line" id="L875">                        <span class="tok-kw">if</span> (die_obj.getAttr(AT.ranges)) |ranges_value| blk: {</span>
<span class="line" id="L876">                            <span class="tok-kw">var</span> iter = DebugRangeIterator.init(ranges_value, di, &amp;compile_unit) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L877">                                <span class="tok-kw">if</span> (err != <span class="tok-kw">error</span>.MissingDebugInfo) <span class="tok-kw">return</span> err;</span>
<span class="line" id="L878">                                <span class="tok-kw">break</span> :blk;</span>
<span class="line" id="L879">                            };</span>
<span class="line" id="L880"></span>
<span class="line" id="L881">                            <span class="tok-kw">while</span> (<span class="tok-kw">try</span> iter.next()) |range| {</span>
<span class="line" id="L882">                                range_added = <span class="tok-null">true</span>;</span>
<span class="line" id="L883">                                <span class="tok-kw">try</span> di.func_list.append(allocator, Func{</span>
<span class="line" id="L884">                                    .name = fn_name,</span>
<span class="line" id="L885">                                    .pc_range = .{</span>
<span class="line" id="L886">                                        .start = range.start_addr,</span>
<span class="line" id="L887">                                        .end = range.end_addr,</span>
<span class="line" id="L888">                                    },</span>
<span class="line" id="L889">                                });</span>
<span class="line" id="L890">                            }</span>
<span class="line" id="L891">                        }</span>
<span class="line" id="L892"></span>
<span class="line" id="L893">                        <span class="tok-kw">if</span> (fn_name != <span class="tok-null">null</span> <span class="tok-kw">and</span> !range_added) {</span>
<span class="line" id="L894">                            <span class="tok-kw">try</span> di.func_list.append(allocator, Func{</span>
<span class="line" id="L895">                                .name = fn_name,</span>
<span class="line" id="L896">                                .pc_range = <span class="tok-null">null</span>,</span>
<span class="line" id="L897">                            });</span>
<span class="line" id="L898">                        }</span>
<span class="line" id="L899">                    },</span>
<span class="line" id="L900">                    <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L901">                }</span>
<span class="line" id="L902"></span>
<span class="line" id="L903">                <span class="tok-kw">try</span> seekable.seekTo(after_die_offset);</span>
<span class="line" id="L904">            }</span>
<span class="line" id="L905"></span>
<span class="line" id="L906">            this_unit_offset += next_offset;</span>
<span class="line" id="L907">        }</span>
<span class="line" id="L908">    }</span>
<span class="line" id="L909"></span>
<span class="line" id="L910">    <span class="tok-kw">fn</span> <span class="tok-fn">scanAllCompileUnits</span>(di: *DwarfInfo, allocator: mem.Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L911">        <span class="tok-kw">var</span> stream = io.fixedBufferStream(di.section(.debug_info).?);</span>
<span class="line" id="L912">        <span class="tok-kw">const</span> in = stream.reader();</span>
<span class="line" id="L913">        <span class="tok-kw">const</span> seekable = stream.seekableStream();</span>
<span class="line" id="L914">        <span class="tok-kw">var</span> this_unit_offset: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L915"></span>
<span class="line" id="L916">        <span class="tok-kw">while</span> (this_unit_offset &lt; <span class="tok-kw">try</span> seekable.getEndPos()) {</span>
<span class="line" id="L917">            <span class="tok-kw">try</span> seekable.seekTo(this_unit_offset);</span>
<span class="line" id="L918"></span>
<span class="line" id="L919">            <span class="tok-kw">var</span> is_64: <span class="tok-type">bool</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L920">            <span class="tok-kw">const</span> unit_length = <span class="tok-kw">try</span> readUnitLength(in, di.endian, &amp;is_64);</span>
<span class="line" id="L921">            <span class="tok-kw">if</span> (unit_length == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;</span>
<span class="line" id="L922">            <span class="tok-kw">const</span> next_offset = unit_length + (<span class="tok-kw">if</span> (is_64) <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">12</span>) <span class="tok-kw">else</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">4</span>));</span>
<span class="line" id="L923"></span>
<span class="line" id="L924">            <span class="tok-kw">const</span> version = <span class="tok-kw">try</span> in.readInt(<span class="tok-type">u16</span>, di.endian);</span>
<span class="line" id="L925">            <span class="tok-kw">if</span> (version &lt; <span class="tok-number">2</span> <span class="tok-kw">or</span> version &gt; <span class="tok-number">5</span>) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L926"></span>
<span class="line" id="L927">            <span class="tok-kw">var</span> address_size: <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L928">            <span class="tok-kw">var</span> debug_abbrev_offset: <span class="tok-type">u64</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L929">            <span class="tok-kw">if</span> (version &gt;= <span class="tok-number">5</span>) {</span>
<span class="line" id="L930">                <span class="tok-kw">const</span> unit_type = <span class="tok-kw">try</span> in.readInt(<span class="tok-type">u8</span>, di.endian);</span>
<span class="line" id="L931">                <span class="tok-kw">if</span> (unit_type != UT.compile) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L932">                address_size = <span class="tok-kw">try</span> in.readByte();</span>
<span class="line" id="L933">                debug_abbrev_offset = <span class="tok-kw">if</span> (is_64)</span>
<span class="line" id="L934">                    <span class="tok-kw">try</span> in.readInt(<span class="tok-type">u64</span>, di.endian)</span>
<span class="line" id="L935">                <span class="tok-kw">else</span></span>
<span class="line" id="L936">                    <span class="tok-kw">try</span> in.readInt(<span class="tok-type">u32</span>, di.endian);</span>
<span class="line" id="L937">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L938">                debug_abbrev_offset = <span class="tok-kw">if</span> (is_64)</span>
<span class="line" id="L939">                    <span class="tok-kw">try</span> in.readInt(<span class="tok-type">u64</span>, di.endian)</span>
<span class="line" id="L940">                <span class="tok-kw">else</span></span>
<span class="line" id="L941">                    <span class="tok-kw">try</span> in.readInt(<span class="tok-type">u32</span>, di.endian);</span>
<span class="line" id="L942">                address_size = <span class="tok-kw">try</span> in.readByte();</span>
<span class="line" id="L943">            }</span>
<span class="line" id="L944">            <span class="tok-kw">if</span> (address_size != <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L945"></span>
<span class="line" id="L946">            <span class="tok-kw">const</span> compile_unit_pos = <span class="tok-kw">try</span> seekable.getPos();</span>
<span class="line" id="L947">            <span class="tok-kw">const</span> abbrev_table = <span class="tok-kw">try</span> di.getAbbrevTable(allocator, debug_abbrev_offset);</span>
<span class="line" id="L948"></span>
<span class="line" id="L949">            <span class="tok-kw">try</span> seekable.seekTo(compile_unit_pos);</span>
<span class="line" id="L950"></span>
<span class="line" id="L951">            <span class="tok-kw">const</span> compile_unit_die = <span class="tok-kw">try</span> allocator.create(Die);</span>
<span class="line" id="L952">            <span class="tok-kw">errdefer</span> allocator.destroy(compile_unit_die);</span>
<span class="line" id="L953">            compile_unit_die.* = (<span class="tok-kw">try</span> di.parseDie(allocator, in, abbrev_table, is_64)) <span class="tok-kw">orelse</span></span>
<span class="line" id="L954">                <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L955"></span>
<span class="line" id="L956">            <span class="tok-kw">if</span> (compile_unit_die.tag_id != TAG.compile_unit) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L957"></span>
<span class="line" id="L958">            <span class="tok-kw">var</span> compile_unit: CompileUnit = .{</span>
<span class="line" id="L959">                .version = version,</span>
<span class="line" id="L960">                .is_64 = is_64,</span>
<span class="line" id="L961">                .pc_range = <span class="tok-null">null</span>,</span>
<span class="line" id="L962">                .die = compile_unit_die,</span>
<span class="line" id="L963">                .str_offsets_base = <span class="tok-kw">if</span> (compile_unit_die.getAttr(AT.str_offsets_base)) |fv| <span class="tok-kw">try</span> fv.getUInt(<span class="tok-type">usize</span>) <span class="tok-kw">else</span> <span class="tok-number">0</span>,</span>
<span class="line" id="L964">                .addr_base = <span class="tok-kw">if</span> (compile_unit_die.getAttr(AT.addr_base)) |fv| <span class="tok-kw">try</span> fv.getUInt(<span class="tok-type">usize</span>) <span class="tok-kw">else</span> <span class="tok-number">0</span>,</span>
<span class="line" id="L965">                .rnglists_base = <span class="tok-kw">if</span> (compile_unit_die.getAttr(AT.rnglists_base)) |fv| <span class="tok-kw">try</span> fv.getUInt(<span class="tok-type">usize</span>) <span class="tok-kw">else</span> <span class="tok-number">0</span>,</span>
<span class="line" id="L966">                .loclists_base = <span class="tok-kw">if</span> (compile_unit_die.getAttr(AT.loclists_base)) |fv| <span class="tok-kw">try</span> fv.getUInt(<span class="tok-type">usize</span>) <span class="tok-kw">else</span> <span class="tok-number">0</span>,</span>
<span class="line" id="L967">                .frame_base = compile_unit_die.getAttr(AT.frame_base),</span>
<span class="line" id="L968">            };</span>
<span class="line" id="L969"></span>
<span class="line" id="L970">            compile_unit.pc_range = x: {</span>
<span class="line" id="L971">                <span class="tok-kw">if</span> (compile_unit_die.getAttrAddr(di, AT.low_pc, compile_unit)) |low_pc| {</span>
<span class="line" id="L972">                    <span class="tok-kw">if</span> (compile_unit_die.getAttr(AT.high_pc)) |high_pc_value| {</span>
<span class="line" id="L973">                        <span class="tok-kw">const</span> pc_end = <span class="tok-kw">switch</span> (high_pc_value.*) {</span>
<span class="line" id="L974">                            FormValue.Address =&gt; |value| value,</span>
<span class="line" id="L975">                            FormValue.Const =&gt; |value| b: {</span>
<span class="line" id="L976">                                <span class="tok-kw">const</span> offset = <span class="tok-kw">try</span> value.asUnsignedLe();</span>
<span class="line" id="L977">                                <span class="tok-kw">break</span> :b (low_pc + offset);</span>
<span class="line" id="L978">                            },</span>
<span class="line" id="L979">                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> badDwarf(),</span>
<span class="line" id="L980">                        };</span>
<span class="line" id="L981">                        <span class="tok-kw">break</span> :x PcRange{</span>
<span class="line" id="L982">                            .start = low_pc,</span>
<span class="line" id="L983">                            .end = pc_end,</span>
<span class="line" id="L984">                        };</span>
<span class="line" id="L985">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L986">                        <span class="tok-kw">break</span> :x <span class="tok-null">null</span>;</span>
<span class="line" id="L987">                    }</span>
<span class="line" id="L988">                } <span class="tok-kw">else</span> |err| {</span>
<span class="line" id="L989">                    <span class="tok-kw">if</span> (err != <span class="tok-kw">error</span>.MissingDebugInfo) <span class="tok-kw">return</span> err;</span>
<span class="line" id="L990">                    <span class="tok-kw">break</span> :x <span class="tok-null">null</span>;</span>
<span class="line" id="L991">                }</span>
<span class="line" id="L992">            };</span>
<span class="line" id="L993"></span>
<span class="line" id="L994">            <span class="tok-kw">try</span> di.compile_unit_list.append(allocator, compile_unit);</span>
<span class="line" id="L995"></span>
<span class="line" id="L996">            this_unit_offset += next_offset;</span>
<span class="line" id="L997">        }</span>
<span class="line" id="L998">    }</span>
<span class="line" id="L999"></span>
<span class="line" id="L1000">    <span class="tok-kw">const</span> DebugRangeIterator = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1001">        base_address: <span class="tok-type">u64</span>,</span>
<span class="line" id="L1002">        section_type: DwarfSection,</span>
<span class="line" id="L1003">        di: *<span class="tok-kw">const</span> DwarfInfo,</span>
<span class="line" id="L1004">        compile_unit: *<span class="tok-kw">const</span> CompileUnit,</span>
<span class="line" id="L1005">        stream: io.FixedBufferStream([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>),</span>
<span class="line" id="L1006"></span>
<span class="line" id="L1007">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(ranges_value: *<span class="tok-kw">const</span> FormValue, di: *<span class="tok-kw">const</span> DwarfInfo, compile_unit: *<span class="tok-kw">const</span> CompileUnit) !<span class="tok-builtin">@This</span>() {</span>
<span class="line" id="L1008">            <span class="tok-kw">const</span> section_type = <span class="tok-kw">if</span> (compile_unit.version &gt;= <span class="tok-number">5</span>) DwarfSection.debug_rnglists <span class="tok-kw">else</span> DwarfSection.debug_ranges;</span>
<span class="line" id="L1009">            <span class="tok-kw">const</span> debug_ranges = di.section(section_type) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L1010"></span>
<span class="line" id="L1011">            <span class="tok-kw">const</span> ranges_offset = <span class="tok-kw">switch</span> (ranges_value.*) {</span>
<span class="line" id="L1012">                .SecOffset =&gt; |off| off,</span>
<span class="line" id="L1013">                .Const =&gt; |c| <span class="tok-kw">try</span> c.asUnsignedLe(),</span>
<span class="line" id="L1014">                .RangeListOffset =&gt; |idx| off: {</span>
<span class="line" id="L1015">                    <span class="tok-kw">if</span> (compile_unit.is_64) {</span>
<span class="line" id="L1016">                        <span class="tok-kw">const</span> offset_loc = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(compile_unit.rnglists_base + <span class="tok-number">8</span> * idx));</span>
<span class="line" id="L1017">                        <span class="tok-kw">if</span> (offset_loc + <span class="tok-number">8</span> &gt; debug_ranges.len) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1018">                        <span class="tok-kw">const</span> offset = mem.readInt(<span class="tok-type">u64</span>, debug_ranges[offset_loc..][<span class="tok-number">0</span>..<span class="tok-number">8</span>], di.endian);</span>
<span class="line" id="L1019">                        <span class="tok-kw">break</span> :off compile_unit.rnglists_base + offset;</span>
<span class="line" id="L1020">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1021">                        <span class="tok-kw">const</span> offset_loc = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(compile_unit.rnglists_base + <span class="tok-number">4</span> * idx));</span>
<span class="line" id="L1022">                        <span class="tok-kw">if</span> (offset_loc + <span class="tok-number">4</span> &gt; debug_ranges.len) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1023">                        <span class="tok-kw">const</span> offset = mem.readInt(<span class="tok-type">u32</span>, debug_ranges[offset_loc..][<span class="tok-number">0</span>..<span class="tok-number">4</span>], di.endian);</span>
<span class="line" id="L1024">                        <span class="tok-kw">break</span> :off compile_unit.rnglists_base + offset;</span>
<span class="line" id="L1025">                    }</span>
<span class="line" id="L1026">                },</span>
<span class="line" id="L1027">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> badDwarf(),</span>
<span class="line" id="L1028">            };</span>
<span class="line" id="L1029"></span>
<span class="line" id="L1030">            <span class="tok-kw">var</span> stream = io.fixedBufferStream(debug_ranges);</span>
<span class="line" id="L1031">            <span class="tok-kw">try</span> stream.seekTo(ranges_offset);</span>
<span class="line" id="L1032"></span>
<span class="line" id="L1033">            <span class="tok-comment">// All the addresses in the list are relative to the value</span>
</span>
<span class="line" id="L1034">            <span class="tok-comment">// specified by DW_AT.low_pc or to some other value encoded</span>
</span>
<span class="line" id="L1035">            <span class="tok-comment">// in the list itself.</span>
</span>
<span class="line" id="L1036">            <span class="tok-comment">// If no starting value is specified use zero.</span>
</span>
<span class="line" id="L1037">            <span class="tok-kw">var</span> base_address = compile_unit.die.getAttrAddr(di, AT.low_pc, compile_unit.*) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1038">                <span class="tok-kw">error</span>.MissingDebugInfo =&gt; <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">0</span>), <span class="tok-comment">// TODO https://github.com/ziglang/zig/issues/11135</span>
</span>
<span class="line" id="L1039">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L1040">            };</span>
<span class="line" id="L1041"></span>
<span class="line" id="L1042">            <span class="tok-kw">return</span> .{</span>
<span class="line" id="L1043">                .base_address = base_address,</span>
<span class="line" id="L1044">                .section_type = section_type,</span>
<span class="line" id="L1045">                .di = di,</span>
<span class="line" id="L1046">                .compile_unit = compile_unit,</span>
<span class="line" id="L1047">                .stream = stream,</span>
<span class="line" id="L1048">            };</span>
<span class="line" id="L1049">        }</span>
<span class="line" id="L1050"></span>
<span class="line" id="L1051">        <span class="tok-comment">// Returns the next range in the list, or null if the end was reached.</span>
</span>
<span class="line" id="L1052">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<span class="tok-builtin">@This</span>()) !?<span class="tok-kw">struct</span> { start_addr: <span class="tok-type">u64</span>, end_addr: <span class="tok-type">u64</span> } {</span>
<span class="line" id="L1053">            <span class="tok-kw">const</span> in = self.stream.reader();</span>
<span class="line" id="L1054">            <span class="tok-kw">switch</span> (self.section_type) {</span>
<span class="line" id="L1055">                .debug_rnglists =&gt; {</span>
<span class="line" id="L1056">                    <span class="tok-kw">const</span> kind = <span class="tok-kw">try</span> in.readByte();</span>
<span class="line" id="L1057">                    <span class="tok-kw">switch</span> (kind) {</span>
<span class="line" id="L1058">                        RLE.end_of_list =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,</span>
<span class="line" id="L1059">                        RLE.base_addressx =&gt; {</span>
<span class="line" id="L1060">                            <span class="tok-kw">const</span> index = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">usize</span>, in);</span>
<span class="line" id="L1061">                            self.base_address = <span class="tok-kw">try</span> self.di.readDebugAddr(self.compile_unit.*, index);</span>
<span class="line" id="L1062">                            <span class="tok-kw">return</span> <span class="tok-kw">try</span> self.next();</span>
<span class="line" id="L1063">                        },</span>
<span class="line" id="L1064">                        RLE.startx_endx =&gt; {</span>
<span class="line" id="L1065">                            <span class="tok-kw">const</span> start_index = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">usize</span>, in);</span>
<span class="line" id="L1066">                            <span class="tok-kw">const</span> start_addr = <span class="tok-kw">try</span> self.di.readDebugAddr(self.compile_unit.*, start_index);</span>
<span class="line" id="L1067"></span>
<span class="line" id="L1068">                            <span class="tok-kw">const</span> end_index = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">usize</span>, in);</span>
<span class="line" id="L1069">                            <span class="tok-kw">const</span> end_addr = <span class="tok-kw">try</span> self.di.readDebugAddr(self.compile_unit.*, end_index);</span>
<span class="line" id="L1070"></span>
<span class="line" id="L1071">                            <span class="tok-kw">return</span> .{</span>
<span class="line" id="L1072">                                .start_addr = start_addr,</span>
<span class="line" id="L1073">                                .end_addr = end_addr,</span>
<span class="line" id="L1074">                            };</span>
<span class="line" id="L1075">                        },</span>
<span class="line" id="L1076">                        RLE.startx_length =&gt; {</span>
<span class="line" id="L1077">                            <span class="tok-kw">const</span> start_index = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">usize</span>, in);</span>
<span class="line" id="L1078">                            <span class="tok-kw">const</span> start_addr = <span class="tok-kw">try</span> self.di.readDebugAddr(self.compile_unit.*, start_index);</span>
<span class="line" id="L1079"></span>
<span class="line" id="L1080">                            <span class="tok-kw">const</span> len = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">usize</span>, in);</span>
<span class="line" id="L1081">                            <span class="tok-kw">const</span> end_addr = start_addr + len;</span>
<span class="line" id="L1082"></span>
<span class="line" id="L1083">                            <span class="tok-kw">return</span> .{</span>
<span class="line" id="L1084">                                .start_addr = start_addr,</span>
<span class="line" id="L1085">                                .end_addr = end_addr,</span>
<span class="line" id="L1086">                            };</span>
<span class="line" id="L1087">                        },</span>
<span class="line" id="L1088">                        RLE.offset_pair =&gt; {</span>
<span class="line" id="L1089">                            <span class="tok-kw">const</span> start_addr = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">usize</span>, in);</span>
<span class="line" id="L1090">                            <span class="tok-kw">const</span> end_addr = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">usize</span>, in);</span>
<span class="line" id="L1091"></span>
<span class="line" id="L1092">                            <span class="tok-comment">// This is the only kind that uses the base address</span>
</span>
<span class="line" id="L1093">                            <span class="tok-kw">return</span> .{</span>
<span class="line" id="L1094">                                .start_addr = self.base_address + start_addr,</span>
<span class="line" id="L1095">                                .end_addr = self.base_address + end_addr,</span>
<span class="line" id="L1096">                            };</span>
<span class="line" id="L1097">                        },</span>
<span class="line" id="L1098">                        RLE.base_address =&gt; {</span>
<span class="line" id="L1099">                            self.base_address = <span class="tok-kw">try</span> in.readInt(<span class="tok-type">usize</span>, self.di.endian);</span>
<span class="line" id="L1100">                            <span class="tok-kw">return</span> <span class="tok-kw">try</span> self.next();</span>
<span class="line" id="L1101">                        },</span>
<span class="line" id="L1102">                        RLE.start_end =&gt; {</span>
<span class="line" id="L1103">                            <span class="tok-kw">const</span> start_addr = <span class="tok-kw">try</span> in.readInt(<span class="tok-type">usize</span>, self.di.endian);</span>
<span class="line" id="L1104">                            <span class="tok-kw">const</span> end_addr = <span class="tok-kw">try</span> in.readInt(<span class="tok-type">usize</span>, self.di.endian);</span>
<span class="line" id="L1105"></span>
<span class="line" id="L1106">                            <span class="tok-kw">return</span> .{</span>
<span class="line" id="L1107">                                .start_addr = start_addr,</span>
<span class="line" id="L1108">                                .end_addr = end_addr,</span>
<span class="line" id="L1109">                            };</span>
<span class="line" id="L1110">                        },</span>
<span class="line" id="L1111">                        RLE.start_length =&gt; {</span>
<span class="line" id="L1112">                            <span class="tok-kw">const</span> start_addr = <span class="tok-kw">try</span> in.readInt(<span class="tok-type">usize</span>, self.di.endian);</span>
<span class="line" id="L1113">                            <span class="tok-kw">const</span> len = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">usize</span>, in);</span>
<span class="line" id="L1114">                            <span class="tok-kw">const</span> end_addr = start_addr + len;</span>
<span class="line" id="L1115"></span>
<span class="line" id="L1116">                            <span class="tok-kw">return</span> .{</span>
<span class="line" id="L1117">                                .start_addr = start_addr,</span>
<span class="line" id="L1118">                                .end_addr = end_addr,</span>
<span class="line" id="L1119">                            };</span>
<span class="line" id="L1120">                        },</span>
<span class="line" id="L1121">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> badDwarf(),</span>
<span class="line" id="L1122">                    }</span>
<span class="line" id="L1123">                },</span>
<span class="line" id="L1124">                .debug_ranges =&gt; {</span>
<span class="line" id="L1125">                    <span class="tok-kw">const</span> start_addr = <span class="tok-kw">try</span> in.readInt(<span class="tok-type">usize</span>, self.di.endian);</span>
<span class="line" id="L1126">                    <span class="tok-kw">const</span> end_addr = <span class="tok-kw">try</span> in.readInt(<span class="tok-type">usize</span>, self.di.endian);</span>
<span class="line" id="L1127">                    <span class="tok-kw">if</span> (start_addr == <span class="tok-number">0</span> <span class="tok-kw">and</span> end_addr == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1128"></span>
<span class="line" id="L1129">                    <span class="tok-comment">// This entry selects a new value for the base address</span>
</span>
<span class="line" id="L1130">                    <span class="tok-kw">if</span> (start_addr == math.maxInt(<span class="tok-type">usize</span>)) {</span>
<span class="line" id="L1131">                        self.base_address = end_addr;</span>
<span class="line" id="L1132">                        <span class="tok-kw">return</span> <span class="tok-kw">try</span> self.next();</span>
<span class="line" id="L1133">                    }</span>
<span class="line" id="L1134"></span>
<span class="line" id="L1135">                    <span class="tok-kw">return</span> .{</span>
<span class="line" id="L1136">                        .start_addr = self.base_address + start_addr,</span>
<span class="line" id="L1137">                        .end_addr = self.base_address + end_addr,</span>
<span class="line" id="L1138">                    };</span>
<span class="line" id="L1139">                },</span>
<span class="line" id="L1140">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1141">            }</span>
<span class="line" id="L1142">        }</span>
<span class="line" id="L1143">    };</span>
<span class="line" id="L1144"></span>
<span class="line" id="L1145">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">findCompileUnit</span>(di: *<span class="tok-kw">const</span> DwarfInfo, target_address: <span class="tok-type">u64</span>) !*<span class="tok-kw">const</span> CompileUnit {</span>
<span class="line" id="L1146">        <span class="tok-kw">for</span> (di.compile_unit_list.items) |*compile_unit| {</span>
<span class="line" id="L1147">            <span class="tok-kw">if</span> (compile_unit.pc_range) |range| {</span>
<span class="line" id="L1148">                <span class="tok-kw">if</span> (target_address &gt;= range.start <span class="tok-kw">and</span> target_address &lt; range.end) <span class="tok-kw">return</span> compile_unit;</span>
<span class="line" id="L1149">            }</span>
<span class="line" id="L1150"></span>
<span class="line" id="L1151">            <span class="tok-kw">const</span> ranges_value = compile_unit.die.getAttr(AT.ranges) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1152">            <span class="tok-kw">var</span> iter = DebugRangeIterator.init(ranges_value, di, compile_unit) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1153">            <span class="tok-kw">while</span> (<span class="tok-kw">try</span> iter.next()) |range| {</span>
<span class="line" id="L1154">                <span class="tok-kw">if</span> (target_address &gt;= range.start_addr <span class="tok-kw">and</span> target_address &lt; range.end_addr) <span class="tok-kw">return</span> compile_unit;</span>
<span class="line" id="L1155">            }</span>
<span class="line" id="L1156">        }</span>
<span class="line" id="L1157"></span>
<span class="line" id="L1158">        <span class="tok-kw">return</span> missingDwarf();</span>
<span class="line" id="L1159">    }</span>
<span class="line" id="L1160"></span>
<span class="line" id="L1161">    <span class="tok-comment">/// Gets an already existing AbbrevTable given the abbrev_offset, or if not found,</span></span>
<span class="line" id="L1162">    <span class="tok-comment">/// seeks in the stream and parses it.</span></span>
<span class="line" id="L1163">    <span class="tok-kw">fn</span> <span class="tok-fn">getAbbrevTable</span>(di: *DwarfInfo, allocator: mem.Allocator, abbrev_offset: <span class="tok-type">u64</span>) !*<span class="tok-kw">const</span> AbbrevTable {</span>
<span class="line" id="L1164">        <span class="tok-kw">for</span> (di.abbrev_table_list.items) |*header| {</span>
<span class="line" id="L1165">            <span class="tok-kw">if</span> (header.offset == abbrev_offset) {</span>
<span class="line" id="L1166">                <span class="tok-kw">return</span> &amp;header.table;</span>
<span class="line" id="L1167">            }</span>
<span class="line" id="L1168">        }</span>
<span class="line" id="L1169">        <span class="tok-kw">try</span> di.abbrev_table_list.append(allocator, AbbrevTableHeader{</span>
<span class="line" id="L1170">            .offset = abbrev_offset,</span>
<span class="line" id="L1171">            .table = <span class="tok-kw">try</span> di.parseAbbrevTable(allocator, abbrev_offset),</span>
<span class="line" id="L1172">        });</span>
<span class="line" id="L1173">        <span class="tok-kw">return</span> &amp;di.abbrev_table_list.items[di.abbrev_table_list.items.len - <span class="tok-number">1</span>].table;</span>
<span class="line" id="L1174">    }</span>
<span class="line" id="L1175"></span>
<span class="line" id="L1176">    <span class="tok-kw">fn</span> <span class="tok-fn">parseAbbrevTable</span>(di: *DwarfInfo, allocator: mem.Allocator, offset: <span class="tok-type">u64</span>) !AbbrevTable {</span>
<span class="line" id="L1177">        <span class="tok-kw">var</span> stream = io.fixedBufferStream(di.section(.debug_abbrev).?);</span>
<span class="line" id="L1178">        <span class="tok-kw">const</span> in = stream.reader();</span>
<span class="line" id="L1179">        <span class="tok-kw">const</span> seekable = stream.seekableStream();</span>
<span class="line" id="L1180"></span>
<span class="line" id="L1181">        <span class="tok-kw">try</span> seekable.seekTo(offset);</span>
<span class="line" id="L1182">        <span class="tok-kw">var</span> result = AbbrevTable.init(allocator);</span>
<span class="line" id="L1183">        <span class="tok-kw">errdefer</span> {</span>
<span class="line" id="L1184">            <span class="tok-kw">for</span> (result.items) |*entry| {</span>
<span class="line" id="L1185">                entry.attrs.deinit();</span>
<span class="line" id="L1186">            }</span>
<span class="line" id="L1187">            result.deinit();</span>
<span class="line" id="L1188">        }</span>
<span class="line" id="L1189"></span>
<span class="line" id="L1190">        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L1191">            <span class="tok-kw">const</span> abbrev_code = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">u64</span>, in);</span>
<span class="line" id="L1192">            <span class="tok-kw">if</span> (abbrev_code == <span class="tok-number">0</span>) <span class="tok-kw">return</span> result;</span>
<span class="line" id="L1193">            <span class="tok-kw">try</span> result.append(AbbrevTableEntry{</span>
<span class="line" id="L1194">                .abbrev_code = abbrev_code,</span>
<span class="line" id="L1195">                .tag_id = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">u64</span>, in),</span>
<span class="line" id="L1196">                .has_children = (<span class="tok-kw">try</span> in.readByte()) == CHILDREN.yes,</span>
<span class="line" id="L1197">                .attrs = std.ArrayList(AbbrevAttr).init(allocator),</span>
<span class="line" id="L1198">            });</span>
<span class="line" id="L1199">            <span class="tok-kw">const</span> attrs = &amp;result.items[result.items.len - <span class="tok-number">1</span>].attrs;</span>
<span class="line" id="L1200"></span>
<span class="line" id="L1201">            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L1202">                <span class="tok-kw">const</span> attr_id = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">u64</span>, in);</span>
<span class="line" id="L1203">                <span class="tok-kw">const</span> form_id = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">u64</span>, in);</span>
<span class="line" id="L1204">                <span class="tok-kw">if</span> (attr_id == <span class="tok-number">0</span> <span class="tok-kw">and</span> form_id == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;</span>
<span class="line" id="L1205">                <span class="tok-comment">// DW_FORM_implicit_const stores its value immediately after the attribute pair :(</span>
</span>
<span class="line" id="L1206">                <span class="tok-kw">const</span> payload = <span class="tok-kw">if</span> (form_id == FORM.implicit_const) <span class="tok-kw">try</span> leb.readILEB128(<span class="tok-type">i64</span>, in) <span class="tok-kw">else</span> <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1207">                <span class="tok-kw">try</span> attrs.append(AbbrevAttr{</span>
<span class="line" id="L1208">                    .attr_id = attr_id,</span>
<span class="line" id="L1209">                    .form_id = form_id,</span>
<span class="line" id="L1210">                    .payload = payload,</span>
<span class="line" id="L1211">                });</span>
<span class="line" id="L1212">            }</span>
<span class="line" id="L1213">        }</span>
<span class="line" id="L1214">    }</span>
<span class="line" id="L1215"></span>
<span class="line" id="L1216">    <span class="tok-kw">fn</span> <span class="tok-fn">parseDie</span>(</span>
<span class="line" id="L1217">        di: *DwarfInfo,</span>
<span class="line" id="L1218">        allocator: mem.Allocator,</span>
<span class="line" id="L1219">        in_stream: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L1220">        abbrev_table: *<span class="tok-kw">const</span> AbbrevTable,</span>
<span class="line" id="L1221">        is_64: <span class="tok-type">bool</span>,</span>
<span class="line" id="L1222">    ) !?Die {</span>
<span class="line" id="L1223">        <span class="tok-kw">const</span> abbrev_code = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">u64</span>, in_stream);</span>
<span class="line" id="L1224">        <span class="tok-kw">if</span> (abbrev_code == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1225">        <span class="tok-kw">const</span> table_entry = getAbbrevTableEntry(abbrev_table, abbrev_code) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1226"></span>
<span class="line" id="L1227">        <span class="tok-kw">var</span> result = Die{</span>
<span class="line" id="L1228">            <span class="tok-comment">// Lives as long as the Die.</span>
</span>
<span class="line" id="L1229">            .arena = std.heap.ArenaAllocator.init(allocator),</span>
<span class="line" id="L1230">            .tag_id = table_entry.tag_id,</span>
<span class="line" id="L1231">            .has_children = table_entry.has_children,</span>
<span class="line" id="L1232">        };</span>
<span class="line" id="L1233">        <span class="tok-kw">try</span> result.attrs.resize(allocator, table_entry.attrs.items.len);</span>
<span class="line" id="L1234">        <span class="tok-kw">for</span> (table_entry.attrs.items, <span class="tok-number">0</span>..) |attr, i| {</span>
<span class="line" id="L1235">            result.attrs.items[i] = Die.Attr{</span>
<span class="line" id="L1236">                .id = attr.attr_id,</span>
<span class="line" id="L1237">                .value = <span class="tok-kw">try</span> parseFormValue(</span>
<span class="line" id="L1238">                    result.arena.allocator(),</span>
<span class="line" id="L1239">                    in_stream,</span>
<span class="line" id="L1240">                    attr.form_id,</span>
<span class="line" id="L1241">                    di.endian,</span>
<span class="line" id="L1242">                    is_64,</span>
<span class="line" id="L1243">                ),</span>
<span class="line" id="L1244">            };</span>
<span class="line" id="L1245">            <span class="tok-kw">if</span> (attr.form_id == FORM.implicit_const) {</span>
<span class="line" id="L1246">                result.attrs.items[i].value.Const.payload = <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@bitCast</span>(attr.payload));</span>
<span class="line" id="L1247">            }</span>
<span class="line" id="L1248">        }</span>
<span class="line" id="L1249">        <span class="tok-kw">return</span> result;</span>
<span class="line" id="L1250">    }</span>
<span class="line" id="L1251"></span>
<span class="line" id="L1252">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLineNumberInfo</span>(</span>
<span class="line" id="L1253">        di: *DwarfInfo,</span>
<span class="line" id="L1254">        allocator: mem.Allocator,</span>
<span class="line" id="L1255">        compile_unit: CompileUnit,</span>
<span class="line" id="L1256">        target_address: <span class="tok-type">u64</span>,</span>
<span class="line" id="L1257">    ) !debug.LineInfo {</span>
<span class="line" id="L1258">        <span class="tok-kw">var</span> stream = io.fixedBufferStream(di.section(.debug_line).?);</span>
<span class="line" id="L1259">        <span class="tok-kw">const</span> in = stream.reader();</span>
<span class="line" id="L1260">        <span class="tok-kw">const</span> seekable = stream.seekableStream();</span>
<span class="line" id="L1261"></span>
<span class="line" id="L1262">        <span class="tok-kw">const</span> compile_unit_cwd = <span class="tok-kw">try</span> compile_unit.die.getAttrString(di, AT.comp_dir, di.section(.debug_line_str), compile_unit);</span>
<span class="line" id="L1263">        <span class="tok-kw">const</span> line_info_offset = <span class="tok-kw">try</span> compile_unit.die.getAttrSecOffset(AT.stmt_list);</span>
<span class="line" id="L1264"></span>
<span class="line" id="L1265">        <span class="tok-kw">try</span> seekable.seekTo(line_info_offset);</span>
<span class="line" id="L1266"></span>
<span class="line" id="L1267">        <span class="tok-kw">var</span> is_64: <span class="tok-type">bool</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1268">        <span class="tok-kw">const</span> unit_length = <span class="tok-kw">try</span> readUnitLength(in, di.endian, &amp;is_64);</span>
<span class="line" id="L1269">        <span class="tok-kw">if</span> (unit_length == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1270">            <span class="tok-kw">return</span> missingDwarf();</span>
<span class="line" id="L1271">        }</span>
<span class="line" id="L1272">        <span class="tok-kw">const</span> next_offset = unit_length + (<span class="tok-kw">if</span> (is_64) <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">12</span>) <span class="tok-kw">else</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">4</span>));</span>
<span class="line" id="L1273"></span>
<span class="line" id="L1274">        <span class="tok-kw">const</span> version = <span class="tok-kw">try</span> in.readInt(<span class="tok-type">u16</span>, di.endian);</span>
<span class="line" id="L1275">        <span class="tok-kw">if</span> (version &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1276"></span>
<span class="line" id="L1277">        <span class="tok-kw">var</span> addr_size: <span class="tok-type">u8</span> = <span class="tok-kw">if</span> (is_64) <span class="tok-number">8</span> <span class="tok-kw">else</span> <span class="tok-number">4</span>;</span>
<span class="line" id="L1278">        <span class="tok-kw">var</span> seg_size: <span class="tok-type">u8</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1279">        <span class="tok-kw">if</span> (version &gt;= <span class="tok-number">5</span>) {</span>
<span class="line" id="L1280">            addr_size = <span class="tok-kw">try</span> in.readByte();</span>
<span class="line" id="L1281">            seg_size = <span class="tok-kw">try</span> in.readByte();</span>
<span class="line" id="L1282">        }</span>
<span class="line" id="L1283"></span>
<span class="line" id="L1284">        <span class="tok-kw">const</span> prologue_length = <span class="tok-kw">if</span> (is_64) <span class="tok-kw">try</span> in.readInt(<span class="tok-type">u64</span>, di.endian) <span class="tok-kw">else</span> <span class="tok-kw">try</span> in.readInt(<span class="tok-type">u32</span>, di.endian);</span>
<span class="line" id="L1285">        <span class="tok-kw">const</span> prog_start_offset = (<span class="tok-kw">try</span> seekable.getPos()) + prologue_length;</span>
<span class="line" id="L1286"></span>
<span class="line" id="L1287">        <span class="tok-kw">const</span> minimum_instruction_length = <span class="tok-kw">try</span> in.readByte();</span>
<span class="line" id="L1288">        <span class="tok-kw">if</span> (minimum_instruction_length == <span class="tok-number">0</span>) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1289"></span>
<span class="line" id="L1290">        <span class="tok-kw">if</span> (version &gt;= <span class="tok-number">4</span>) {</span>
<span class="line" id="L1291">            <span class="tok-comment">// maximum_operations_per_instruction</span>
</span>
<span class="line" id="L1292">            _ = <span class="tok-kw">try</span> in.readByte();</span>
<span class="line" id="L1293">        }</span>
<span class="line" id="L1294"></span>
<span class="line" id="L1295">        <span class="tok-kw">const</span> default_is_stmt = (<span class="tok-kw">try</span> in.readByte()) != <span class="tok-number">0</span>;</span>
<span class="line" id="L1296">        <span class="tok-kw">const</span> line_base = <span class="tok-kw">try</span> in.readByteSigned();</span>
<span class="line" id="L1297"></span>
<span class="line" id="L1298">        <span class="tok-kw">const</span> line_range = <span class="tok-kw">try</span> in.readByte();</span>
<span class="line" id="L1299">        <span class="tok-kw">if</span> (line_range == <span class="tok-number">0</span>) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1300"></span>
<span class="line" id="L1301">        <span class="tok-kw">const</span> opcode_base = <span class="tok-kw">try</span> in.readByte();</span>
<span class="line" id="L1302"></span>
<span class="line" id="L1303">        <span class="tok-kw">const</span> standard_opcode_lengths = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, opcode_base - <span class="tok-number">1</span>);</span>
<span class="line" id="L1304">        <span class="tok-kw">defer</span> allocator.free(standard_opcode_lengths);</span>
<span class="line" id="L1305"></span>
<span class="line" id="L1306">        {</span>
<span class="line" id="L1307">            <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1308">            <span class="tok-kw">while</span> (i &lt; opcode_base - <span class="tok-number">1</span>) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L1309">                standard_opcode_lengths[i] = <span class="tok-kw">try</span> in.readByte();</span>
<span class="line" id="L1310">            }</span>
<span class="line" id="L1311">        }</span>
<span class="line" id="L1312"></span>
<span class="line" id="L1313">        <span class="tok-kw">var</span> tmp_arena = std.heap.ArenaAllocator.init(allocator);</span>
<span class="line" id="L1314">        <span class="tok-kw">defer</span> tmp_arena.deinit();</span>
<span class="line" id="L1315">        <span class="tok-kw">const</span> arena = tmp_arena.allocator();</span>
<span class="line" id="L1316"></span>
<span class="line" id="L1317">        <span class="tok-kw">var</span> include_directories = std.ArrayList(FileEntry).init(arena);</span>
<span class="line" id="L1318">        <span class="tok-kw">var</span> file_entries = std.ArrayList(FileEntry).init(arena);</span>
<span class="line" id="L1319"></span>
<span class="line" id="L1320">        <span class="tok-kw">if</span> (version &lt; <span class="tok-number">5</span>) {</span>
<span class="line" id="L1321">            <span class="tok-kw">try</span> include_directories.append(.{ .path = compile_unit_cwd });</span>
<span class="line" id="L1322"></span>
<span class="line" id="L1323">            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L1324">                <span class="tok-kw">const</span> dir = <span class="tok-kw">try</span> in.readUntilDelimiterAlloc(arena, <span class="tok-number">0</span>, math.maxInt(<span class="tok-type">usize</span>));</span>
<span class="line" id="L1325">                <span class="tok-kw">if</span> (dir.len == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;</span>
<span class="line" id="L1326">                <span class="tok-kw">try</span> include_directories.append(.{ .path = dir });</span>
<span class="line" id="L1327">            }</span>
<span class="line" id="L1328"></span>
<span class="line" id="L1329">            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L1330">                <span class="tok-kw">const</span> file_name = <span class="tok-kw">try</span> in.readUntilDelimiterAlloc(arena, <span class="tok-number">0</span>, math.maxInt(<span class="tok-type">usize</span>));</span>
<span class="line" id="L1331">                <span class="tok-kw">if</span> (file_name.len == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;</span>
<span class="line" id="L1332">                <span class="tok-kw">const</span> dir_index = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">u32</span>, in);</span>
<span class="line" id="L1333">                <span class="tok-kw">const</span> mtime = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">u64</span>, in);</span>
<span class="line" id="L1334">                <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">u64</span>, in);</span>
<span class="line" id="L1335">                <span class="tok-kw">try</span> file_entries.append(FileEntry{</span>
<span class="line" id="L1336">                    .path = file_name,</span>
<span class="line" id="L1337">                    .dir_index = dir_index,</span>
<span class="line" id="L1338">                    .mtime = mtime,</span>
<span class="line" id="L1339">                    .size = size,</span>
<span class="line" id="L1340">                });</span>
<span class="line" id="L1341">            }</span>
<span class="line" id="L1342">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1343">            <span class="tok-kw">const</span> FileEntFmt = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1344">                content_type_code: <span class="tok-type">u8</span>,</span>
<span class="line" id="L1345">                form_code: <span class="tok-type">u16</span>,</span>
<span class="line" id="L1346">            };</span>
<span class="line" id="L1347">            {</span>
<span class="line" id="L1348">                <span class="tok-kw">var</span> dir_ent_fmt_buf: [<span class="tok-number">10</span>]FileEntFmt = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1349">                <span class="tok-kw">const</span> directory_entry_format_count = <span class="tok-kw">try</span> in.readByte();</span>
<span class="line" id="L1350">                <span class="tok-kw">if</span> (directory_entry_format_count &gt; dir_ent_fmt_buf.len) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1351">                <span class="tok-kw">for</span> (dir_ent_fmt_buf[<span class="tok-number">0</span>..directory_entry_format_count]) |*ent_fmt| {</span>
<span class="line" id="L1352">                    ent_fmt.* = .{</span>
<span class="line" id="L1353">                        .content_type_code = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">u8</span>, in),</span>
<span class="line" id="L1354">                        .form_code = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">u16</span>, in),</span>
<span class="line" id="L1355">                    };</span>
<span class="line" id="L1356">                }</span>
<span class="line" id="L1357"></span>
<span class="line" id="L1358">                <span class="tok-kw">const</span> directories_count = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">usize</span>, in);</span>
<span class="line" id="L1359">                <span class="tok-kw">try</span> include_directories.ensureUnusedCapacity(directories_count);</span>
<span class="line" id="L1360">                {</span>
<span class="line" id="L1361">                    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1362">                    <span class="tok-kw">while</span> (i &lt; directories_count) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L1363">                        <span class="tok-kw">var</span> e: FileEntry = .{ .path = &amp;.{} };</span>
<span class="line" id="L1364">                        <span class="tok-kw">for</span> (dir_ent_fmt_buf[<span class="tok-number">0</span>..directory_entry_format_count]) |ent_fmt| {</span>
<span class="line" id="L1365">                            <span class="tok-kw">const</span> form_value = <span class="tok-kw">try</span> parseFormValue(</span>
<span class="line" id="L1366">                                arena,</span>
<span class="line" id="L1367">                                in,</span>
<span class="line" id="L1368">                                ent_fmt.form_code,</span>
<span class="line" id="L1369">                                di.endian,</span>
<span class="line" id="L1370">                                is_64,</span>
<span class="line" id="L1371">                            );</span>
<span class="line" id="L1372">                            <span class="tok-kw">switch</span> (ent_fmt.content_type_code) {</span>
<span class="line" id="L1373">                                LNCT.path =&gt; e.path = <span class="tok-kw">try</span> form_value.getString(di.*),</span>
<span class="line" id="L1374">                                LNCT.directory_index =&gt; e.dir_index = <span class="tok-kw">try</span> form_value.getUInt(<span class="tok-type">u32</span>),</span>
<span class="line" id="L1375">                                LNCT.timestamp =&gt; e.mtime = <span class="tok-kw">try</span> form_value.getUInt(<span class="tok-type">u64</span>),</span>
<span class="line" id="L1376">                                LNCT.size =&gt; e.size = <span class="tok-kw">try</span> form_value.getUInt(<span class="tok-type">u64</span>),</span>
<span class="line" id="L1377">                                LNCT.MD5 =&gt; e.md5 = <span class="tok-kw">try</span> form_value.getData16(),</span>
<span class="line" id="L1378">                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L1379">                            }</span>
<span class="line" id="L1380">                        }</span>
<span class="line" id="L1381">                        include_directories.appendAssumeCapacity(e);</span>
<span class="line" id="L1382">                    }</span>
<span class="line" id="L1383">                }</span>
<span class="line" id="L1384">            }</span>
<span class="line" id="L1385"></span>
<span class="line" id="L1386">            <span class="tok-kw">var</span> file_ent_fmt_buf: [<span class="tok-number">10</span>]FileEntFmt = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1387">            <span class="tok-kw">const</span> file_name_entry_format_count = <span class="tok-kw">try</span> in.readByte();</span>
<span class="line" id="L1388">            <span class="tok-kw">if</span> (file_name_entry_format_count &gt; file_ent_fmt_buf.len) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1389">            <span class="tok-kw">for</span> (file_ent_fmt_buf[<span class="tok-number">0</span>..file_name_entry_format_count]) |*ent_fmt| {</span>
<span class="line" id="L1390">                ent_fmt.* = .{</span>
<span class="line" id="L1391">                    .content_type_code = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">u8</span>, in),</span>
<span class="line" id="L1392">                    .form_code = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">u16</span>, in),</span>
<span class="line" id="L1393">                };</span>
<span class="line" id="L1394">            }</span>
<span class="line" id="L1395"></span>
<span class="line" id="L1396">            <span class="tok-kw">const</span> file_names_count = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">usize</span>, in);</span>
<span class="line" id="L1397">            <span class="tok-kw">try</span> file_entries.ensureUnusedCapacity(file_names_count);</span>
<span class="line" id="L1398">            {</span>
<span class="line" id="L1399">                <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1400">                <span class="tok-kw">while</span> (i &lt; file_names_count) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L1401">                    <span class="tok-kw">var</span> e: FileEntry = .{ .path = &amp;.{} };</span>
<span class="line" id="L1402">                    <span class="tok-kw">for</span> (file_ent_fmt_buf[<span class="tok-number">0</span>..file_name_entry_format_count]) |ent_fmt| {</span>
<span class="line" id="L1403">                        <span class="tok-kw">const</span> form_value = <span class="tok-kw">try</span> parseFormValue(</span>
<span class="line" id="L1404">                            arena,</span>
<span class="line" id="L1405">                            in,</span>
<span class="line" id="L1406">                            ent_fmt.form_code,</span>
<span class="line" id="L1407">                            di.endian,</span>
<span class="line" id="L1408">                            is_64,</span>
<span class="line" id="L1409">                        );</span>
<span class="line" id="L1410">                        <span class="tok-kw">switch</span> (ent_fmt.content_type_code) {</span>
<span class="line" id="L1411">                            LNCT.path =&gt; e.path = <span class="tok-kw">try</span> form_value.getString(di.*),</span>
<span class="line" id="L1412">                            LNCT.directory_index =&gt; e.dir_index = <span class="tok-kw">try</span> form_value.getUInt(<span class="tok-type">u32</span>),</span>
<span class="line" id="L1413">                            LNCT.timestamp =&gt; e.mtime = <span class="tok-kw">try</span> form_value.getUInt(<span class="tok-type">u64</span>),</span>
<span class="line" id="L1414">                            LNCT.size =&gt; e.size = <span class="tok-kw">try</span> form_value.getUInt(<span class="tok-type">u64</span>),</span>
<span class="line" id="L1415">                            LNCT.MD5 =&gt; e.md5 = <span class="tok-kw">try</span> form_value.getData16(),</span>
<span class="line" id="L1416">                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L1417">                        }</span>
<span class="line" id="L1418">                    }</span>
<span class="line" id="L1419">                    file_entries.appendAssumeCapacity(e);</span>
<span class="line" id="L1420">                }</span>
<span class="line" id="L1421">            }</span>
<span class="line" id="L1422">        }</span>
<span class="line" id="L1423"></span>
<span class="line" id="L1424">        <span class="tok-kw">var</span> prog = LineNumberProgram.init(</span>
<span class="line" id="L1425">            default_is_stmt,</span>
<span class="line" id="L1426">            include_directories.items,</span>
<span class="line" id="L1427">            target_address,</span>
<span class="line" id="L1428">            version,</span>
<span class="line" id="L1429">        );</span>
<span class="line" id="L1430"></span>
<span class="line" id="L1431">        <span class="tok-kw">try</span> seekable.seekTo(prog_start_offset);</span>
<span class="line" id="L1432"></span>
<span class="line" id="L1433">        <span class="tok-kw">const</span> next_unit_pos = line_info_offset + next_offset;</span>
<span class="line" id="L1434"></span>
<span class="line" id="L1435">        <span class="tok-kw">while</span> ((<span class="tok-kw">try</span> seekable.getPos()) &lt; next_unit_pos) {</span>
<span class="line" id="L1436">            <span class="tok-kw">const</span> opcode = <span class="tok-kw">try</span> in.readByte();</span>
<span class="line" id="L1437"></span>
<span class="line" id="L1438">            <span class="tok-kw">if</span> (opcode == LNS.extended_op) {</span>
<span class="line" id="L1439">                <span class="tok-kw">const</span> op_size = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">u64</span>, in);</span>
<span class="line" id="L1440">                <span class="tok-kw">if</span> (op_size &lt; <span class="tok-number">1</span>) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1441">                <span class="tok-kw">var</span> sub_op = <span class="tok-kw">try</span> in.readByte();</span>
<span class="line" id="L1442">                <span class="tok-kw">switch</span> (sub_op) {</span>
<span class="line" id="L1443">                    LNE.end_sequence =&gt; {</span>
<span class="line" id="L1444">                        prog.end_sequence = <span class="tok-null">true</span>;</span>
<span class="line" id="L1445">                        <span class="tok-kw">if</span> (<span class="tok-kw">try</span> prog.checkLineMatch(allocator, file_entries.items)) |info| <span class="tok-kw">return</span> info;</span>
<span class="line" id="L1446">                        prog.reset();</span>
<span class="line" id="L1447">                    },</span>
<span class="line" id="L1448">                    LNE.set_address =&gt; {</span>
<span class="line" id="L1449">                        <span class="tok-kw">const</span> addr = <span class="tok-kw">try</span> in.readInt(<span class="tok-type">usize</span>, di.endian);</span>
<span class="line" id="L1450">                        prog.address = addr;</span>
<span class="line" id="L1451">                    },</span>
<span class="line" id="L1452">                    LNE.define_file =&gt; {</span>
<span class="line" id="L1453">                        <span class="tok-kw">const</span> path = <span class="tok-kw">try</span> in.readUntilDelimiterAlloc(arena, <span class="tok-number">0</span>, math.maxInt(<span class="tok-type">usize</span>));</span>
<span class="line" id="L1454">                        <span class="tok-kw">const</span> dir_index = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">u32</span>, in);</span>
<span class="line" id="L1455">                        <span class="tok-kw">const</span> mtime = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">u64</span>, in);</span>
<span class="line" id="L1456">                        <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">u64</span>, in);</span>
<span class="line" id="L1457">                        <span class="tok-kw">try</span> file_entries.append(FileEntry{</span>
<span class="line" id="L1458">                            .path = path,</span>
<span class="line" id="L1459">                            .dir_index = dir_index,</span>
<span class="line" id="L1460">                            .mtime = mtime,</span>
<span class="line" id="L1461">                            .size = size,</span>
<span class="line" id="L1462">                        });</span>
<span class="line" id="L1463">                    },</span>
<span class="line" id="L1464">                    <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L1465">                        <span class="tok-kw">const</span> fwd_amt = math.cast(<span class="tok-type">isize</span>, op_size - <span class="tok-number">1</span>) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1466">                        <span class="tok-kw">try</span> seekable.seekBy(fwd_amt);</span>
<span class="line" id="L1467">                    },</span>
<span class="line" id="L1468">                }</span>
<span class="line" id="L1469">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (opcode &gt;= opcode_base) {</span>
<span class="line" id="L1470">                <span class="tok-comment">// special opcodes</span>
</span>
<span class="line" id="L1471">                <span class="tok-kw">const</span> adjusted_opcode = opcode - opcode_base;</span>
<span class="line" id="L1472">                <span class="tok-kw">const</span> inc_addr = minimum_instruction_length * (adjusted_opcode / line_range);</span>
<span class="line" id="L1473">                <span class="tok-kw">const</span> inc_line = <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, line_base) + <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, adjusted_opcode % line_range);</span>
<span class="line" id="L1474">                prog.line += inc_line;</span>
<span class="line" id="L1475">                prog.address += inc_addr;</span>
<span class="line" id="L1476">                <span class="tok-kw">if</span> (<span class="tok-kw">try</span> prog.checkLineMatch(allocator, file_entries.items)) |info| <span class="tok-kw">return</span> info;</span>
<span class="line" id="L1477">                prog.basic_block = <span class="tok-null">false</span>;</span>
<span class="line" id="L1478">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1479">                <span class="tok-kw">switch</span> (opcode) {</span>
<span class="line" id="L1480">                    LNS.copy =&gt; {</span>
<span class="line" id="L1481">                        <span class="tok-kw">if</span> (<span class="tok-kw">try</span> prog.checkLineMatch(allocator, file_entries.items)) |info| <span class="tok-kw">return</span> info;</span>
<span class="line" id="L1482">                        prog.basic_block = <span class="tok-null">false</span>;</span>
<span class="line" id="L1483">                    },</span>
<span class="line" id="L1484">                    LNS.advance_pc =&gt; {</span>
<span class="line" id="L1485">                        <span class="tok-kw">const</span> arg = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">usize</span>, in);</span>
<span class="line" id="L1486">                        prog.address += arg * minimum_instruction_length;</span>
<span class="line" id="L1487">                    },</span>
<span class="line" id="L1488">                    LNS.advance_line =&gt; {</span>
<span class="line" id="L1489">                        <span class="tok-kw">const</span> arg = <span class="tok-kw">try</span> leb.readILEB128(<span class="tok-type">i64</span>, in);</span>
<span class="line" id="L1490">                        prog.line += arg;</span>
<span class="line" id="L1491">                    },</span>
<span class="line" id="L1492">                    LNS.set_file =&gt; {</span>
<span class="line" id="L1493">                        <span class="tok-kw">const</span> arg = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">usize</span>, in);</span>
<span class="line" id="L1494">                        prog.file = arg;</span>
<span class="line" id="L1495">                    },</span>
<span class="line" id="L1496">                    LNS.set_column =&gt; {</span>
<span class="line" id="L1497">                        <span class="tok-kw">const</span> arg = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">u64</span>, in);</span>
<span class="line" id="L1498">                        prog.column = arg;</span>
<span class="line" id="L1499">                    },</span>
<span class="line" id="L1500">                    LNS.negate_stmt =&gt; {</span>
<span class="line" id="L1501">                        prog.is_stmt = !prog.is_stmt;</span>
<span class="line" id="L1502">                    },</span>
<span class="line" id="L1503">                    LNS.set_basic_block =&gt; {</span>
<span class="line" id="L1504">                        prog.basic_block = <span class="tok-null">true</span>;</span>
<span class="line" id="L1505">                    },</span>
<span class="line" id="L1506">                    LNS.const_add_pc =&gt; {</span>
<span class="line" id="L1507">                        <span class="tok-kw">const</span> inc_addr = minimum_instruction_length * ((<span class="tok-number">255</span> - opcode_base) / line_range);</span>
<span class="line" id="L1508">                        prog.address += inc_addr;</span>
<span class="line" id="L1509">                    },</span>
<span class="line" id="L1510">                    LNS.fixed_advance_pc =&gt; {</span>
<span class="line" id="L1511">                        <span class="tok-kw">const</span> arg = <span class="tok-kw">try</span> in.readInt(<span class="tok-type">u16</span>, di.endian);</span>
<span class="line" id="L1512">                        prog.address += arg;</span>
<span class="line" id="L1513">                    },</span>
<span class="line" id="L1514">                    LNS.set_prologue_end =&gt; {},</span>
<span class="line" id="L1515">                    <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L1516">                        <span class="tok-kw">if</span> (opcode - <span class="tok-number">1</span> &gt;= standard_opcode_lengths.len) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1517">                        <span class="tok-kw">const</span> len_bytes = standard_opcode_lengths[opcode - <span class="tok-number">1</span>];</span>
<span class="line" id="L1518">                        <span class="tok-kw">try</span> seekable.seekBy(len_bytes);</span>
<span class="line" id="L1519">                    },</span>
<span class="line" id="L1520">                }</span>
<span class="line" id="L1521">            }</span>
<span class="line" id="L1522">        }</span>
<span class="line" id="L1523"></span>
<span class="line" id="L1524">        <span class="tok-kw">return</span> missingDwarf();</span>
<span class="line" id="L1525">    }</span>
<span class="line" id="L1526"></span>
<span class="line" id="L1527">    <span class="tok-kw">fn</span> <span class="tok-fn">getString</span>(di: DwarfInfo, offset: <span class="tok-type">u64</span>) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1528">        <span class="tok-kw">return</span> getStringGeneric(di.section(.debug_str), offset);</span>
<span class="line" id="L1529">    }</span>
<span class="line" id="L1530"></span>
<span class="line" id="L1531">    <span class="tok-kw">fn</span> <span class="tok-fn">getLineString</span>(di: DwarfInfo, offset: <span class="tok-type">u64</span>) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1532">        <span class="tok-kw">return</span> getStringGeneric(di.section(.debug_line_str), offset);</span>
<span class="line" id="L1533">    }</span>
<span class="line" id="L1534"></span>
<span class="line" id="L1535">    <span class="tok-kw">fn</span> <span class="tok-fn">readDebugAddr</span>(di: DwarfInfo, compile_unit: CompileUnit, index: <span class="tok-type">u64</span>) !<span class="tok-type">u64</span> {</span>
<span class="line" id="L1536">        <span class="tok-kw">const</span> debug_addr = di.section(.debug_addr) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1537"></span>
<span class="line" id="L1538">        <span class="tok-comment">// addr_base points to the first item after the header, however we</span>
</span>
<span class="line" id="L1539">        <span class="tok-comment">// need to read the header to know the size of each item. Empirically,</span>
</span>
<span class="line" id="L1540">        <span class="tok-comment">// it may disagree with is_64 on the compile unit.</span>
</span>
<span class="line" id="L1541">        <span class="tok-comment">// The header is 8 or 12 bytes depending on is_64.</span>
</span>
<span class="line" id="L1542">        <span class="tok-kw">if</span> (compile_unit.addr_base &lt; <span class="tok-number">8</span>) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1543"></span>
<span class="line" id="L1544">        <span class="tok-kw">const</span> version = mem.readInt(<span class="tok-type">u16</span>, debug_addr[compile_unit.addr_base - <span class="tok-number">4</span> ..][<span class="tok-number">0</span>..<span class="tok-number">2</span>], di.endian);</span>
<span class="line" id="L1545">        <span class="tok-kw">if</span> (version != <span class="tok-number">5</span>) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1546"></span>
<span class="line" id="L1547">        <span class="tok-kw">const</span> addr_size = debug_addr[compile_unit.addr_base - <span class="tok-number">2</span>];</span>
<span class="line" id="L1548">        <span class="tok-kw">const</span> seg_size = debug_addr[compile_unit.addr_base - <span class="tok-number">1</span>];</span>
<span class="line" id="L1549"></span>
<span class="line" id="L1550">        <span class="tok-kw">const</span> byte_offset = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(compile_unit.addr_base + (addr_size + seg_size) * index));</span>
<span class="line" id="L1551">        <span class="tok-kw">if</span> (byte_offset + addr_size &gt; debug_addr.len) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1552">        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (addr_size) {</span>
<span class="line" id="L1553">            <span class="tok-number">1</span> =&gt; debug_addr[byte_offset],</span>
<span class="line" id="L1554">            <span class="tok-number">2</span> =&gt; mem.readInt(<span class="tok-type">u16</span>, debug_addr[byte_offset..][<span class="tok-number">0</span>..<span class="tok-number">2</span>], di.endian),</span>
<span class="line" id="L1555">            <span class="tok-number">4</span> =&gt; mem.readInt(<span class="tok-type">u32</span>, debug_addr[byte_offset..][<span class="tok-number">0</span>..<span class="tok-number">4</span>], di.endian),</span>
<span class="line" id="L1556">            <span class="tok-number">8</span> =&gt; mem.readInt(<span class="tok-type">u64</span>, debug_addr[byte_offset..][<span class="tok-number">0</span>..<span class="tok-number">8</span>], di.endian),</span>
<span class="line" id="L1557">            <span class="tok-kw">else</span> =&gt; badDwarf(),</span>
<span class="line" id="L1558">        };</span>
<span class="line" id="L1559">    }</span>
<span class="line" id="L1560"></span>
<span class="line" id="L1561">    <span class="tok-comment">/// If .eh_frame_hdr is present, then only the header needs to be parsed.</span></span>
<span class="line" id="L1562">    <span class="tok-comment">///</span></span>
<span class="line" id="L1563">    <span class="tok-comment">/// Otherwise, .eh_frame and .debug_frame are scanned and a sorted list</span></span>
<span class="line" id="L1564">    <span class="tok-comment">/// of FDEs is built for binary searching during unwinding.</span></span>
<span class="line" id="L1565">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">scanAllUnwindInfo</span>(di: *DwarfInfo, allocator: mem.Allocator, base_address: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1566">        <span class="tok-kw">if</span> (di.section(.eh_frame_hdr)) |eh_frame_hdr| blk: {</span>
<span class="line" id="L1567">            <span class="tok-kw">var</span> stream = io.fixedBufferStream(eh_frame_hdr);</span>
<span class="line" id="L1568">            <span class="tok-kw">const</span> reader = stream.reader();</span>
<span class="line" id="L1569"></span>
<span class="line" id="L1570">            <span class="tok-kw">const</span> version = <span class="tok-kw">try</span> reader.readByte();</span>
<span class="line" id="L1571">            <span class="tok-kw">if</span> (version != <span class="tok-number">1</span>) <span class="tok-kw">break</span> :blk;</span>
<span class="line" id="L1572"></span>
<span class="line" id="L1573">            <span class="tok-kw">const</span> eh_frame_ptr_enc = <span class="tok-kw">try</span> reader.readByte();</span>
<span class="line" id="L1574">            <span class="tok-kw">if</span> (eh_frame_ptr_enc == EH.PE.omit) <span class="tok-kw">break</span> :blk;</span>
<span class="line" id="L1575">            <span class="tok-kw">const</span> fde_count_enc = <span class="tok-kw">try</span> reader.readByte();</span>
<span class="line" id="L1576">            <span class="tok-kw">if</span> (fde_count_enc == EH.PE.omit) <span class="tok-kw">break</span> :blk;</span>
<span class="line" id="L1577">            <span class="tok-kw">const</span> table_enc = <span class="tok-kw">try</span> reader.readByte();</span>
<span class="line" id="L1578">            <span class="tok-kw">if</span> (table_enc == EH.PE.omit) <span class="tok-kw">break</span> :blk;</span>
<span class="line" id="L1579"></span>
<span class="line" id="L1580">            <span class="tok-kw">const</span> eh_frame_ptr = std.math.cast(<span class="tok-type">usize</span>, <span class="tok-kw">try</span> readEhPointer(reader, eh_frame_ptr_enc, <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>), .{</span>
<span class="line" id="L1581">                .pc_rel_base = <span class="tok-builtin">@intFromPtr</span>(&amp;eh_frame_hdr[stream.pos]),</span>
<span class="line" id="L1582">                .follow_indirect = <span class="tok-null">true</span>,</span>
<span class="line" id="L1583">            }, builtin.cpu.arch.endian()) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf()) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1584"></span>
<span class="line" id="L1585">            <span class="tok-kw">const</span> fde_count = std.math.cast(<span class="tok-type">usize</span>, <span class="tok-kw">try</span> readEhPointer(reader, fde_count_enc, <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>), .{</span>
<span class="line" id="L1586">                .pc_rel_base = <span class="tok-builtin">@intFromPtr</span>(&amp;eh_frame_hdr[stream.pos]),</span>
<span class="line" id="L1587">                .follow_indirect = <span class="tok-null">true</span>,</span>
<span class="line" id="L1588">            }, builtin.cpu.arch.endian()) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf()) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1589"></span>
<span class="line" id="L1590">            <span class="tok-kw">const</span> entry_size = <span class="tok-kw">try</span> ExceptionFrameHeader.entrySize(table_enc);</span>
<span class="line" id="L1591">            <span class="tok-kw">const</span> entries_len = fde_count * entry_size;</span>
<span class="line" id="L1592">            <span class="tok-kw">if</span> (entries_len &gt; eh_frame_hdr.len - stream.pos) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1593"></span>
<span class="line" id="L1594">            di.eh_frame_hdr = .{</span>
<span class="line" id="L1595">                .eh_frame_ptr = eh_frame_ptr,</span>
<span class="line" id="L1596">                .table_enc = table_enc,</span>
<span class="line" id="L1597">                .fde_count = fde_count,</span>
<span class="line" id="L1598">                .entries = eh_frame_hdr[stream.pos..][<span class="tok-number">0</span>..entries_len],</span>
<span class="line" id="L1599">            };</span>
<span class="line" id="L1600"></span>
<span class="line" id="L1601">            <span class="tok-comment">// No need to scan .eh_frame, we have a binary search table already</span>
</span>
<span class="line" id="L1602">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L1603">        }</span>
<span class="line" id="L1604"></span>
<span class="line" id="L1605">        <span class="tok-kw">const</span> frame_sections = [<span class="tok-number">2</span>]DwarfSection{ .eh_frame, .debug_frame };</span>
<span class="line" id="L1606">        <span class="tok-kw">for</span> (frame_sections) |frame_section| {</span>
<span class="line" id="L1607">            <span class="tok-kw">if</span> (di.section(frame_section)) |section_data| {</span>
<span class="line" id="L1608">                <span class="tok-kw">var</span> stream = io.fixedBufferStream(section_data);</span>
<span class="line" id="L1609">                <span class="tok-kw">while</span> (stream.pos &lt; stream.buffer.len) {</span>
<span class="line" id="L1610">                    <span class="tok-kw">const</span> entry_header = <span class="tok-kw">try</span> EntryHeader.read(&amp;stream, frame_section, di.endian);</span>
<span class="line" id="L1611">                    <span class="tok-kw">switch</span> (entry_header.<span class="tok-type">type</span>) {</span>
<span class="line" id="L1612">                        .cie =&gt; {</span>
<span class="line" id="L1613">                            <span class="tok-kw">const</span> cie = <span class="tok-kw">try</span> CommonInformationEntry.parse(</span>
<span class="line" id="L1614">                                entry_header.entry_bytes,</span>
<span class="line" id="L1615">                                di.sectionVirtualOffset(frame_section, base_address).?,</span>
<span class="line" id="L1616">                                <span class="tok-null">true</span>,</span>
<span class="line" id="L1617">                                entry_header.is_64,</span>
<span class="line" id="L1618">                                frame_section,</span>
<span class="line" id="L1619">                                entry_header.length_offset,</span>
<span class="line" id="L1620">                                <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>),</span>
<span class="line" id="L1621">                                di.endian,</span>
<span class="line" id="L1622">                            );</span>
<span class="line" id="L1623">                            <span class="tok-kw">try</span> di.cie_map.put(allocator, entry_header.length_offset, cie);</span>
<span class="line" id="L1624">                        },</span>
<span class="line" id="L1625">                        .fde =&gt; |cie_offset| {</span>
<span class="line" id="L1626">                            <span class="tok-kw">const</span> cie = di.cie_map.get(cie_offset) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1627">                            <span class="tok-kw">const</span> fde = <span class="tok-kw">try</span> FrameDescriptionEntry.parse(</span>
<span class="line" id="L1628">                                entry_header.entry_bytes,</span>
<span class="line" id="L1629">                                di.sectionVirtualOffset(frame_section, base_address).?,</span>
<span class="line" id="L1630">                                <span class="tok-null">true</span>,</span>
<span class="line" id="L1631">                                cie,</span>
<span class="line" id="L1632">                                <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>),</span>
<span class="line" id="L1633">                                di.endian,</span>
<span class="line" id="L1634">                            );</span>
<span class="line" id="L1635">                            <span class="tok-kw">try</span> di.fde_list.append(allocator, fde);</span>
<span class="line" id="L1636">                        },</span>
<span class="line" id="L1637">                        .terminator =&gt; <span class="tok-kw">break</span>,</span>
<span class="line" id="L1638">                    }</span>
<span class="line" id="L1639">                }</span>
<span class="line" id="L1640"></span>
<span class="line" id="L1641">                std.mem.sortUnstable(FrameDescriptionEntry, di.fde_list.items, {}, <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1642">                    <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(ctx: <span class="tok-type">void</span>, a: FrameDescriptionEntry, b: FrameDescriptionEntry) <span class="tok-type">bool</span> {</span>
<span class="line" id="L1643">                        _ = ctx;</span>
<span class="line" id="L1644">                        <span class="tok-kw">return</span> a.pc_begin &lt; b.pc_begin;</span>
<span class="line" id="L1645">                    }</span>
<span class="line" id="L1646">                }.lessThan);</span>
<span class="line" id="L1647">            }</span>
<span class="line" id="L1648">        }</span>
<span class="line" id="L1649">    }</span>
<span class="line" id="L1650"></span>
<span class="line" id="L1651">    <span class="tok-comment">/// Unwind a stack frame using DWARF unwinding info, updating the register context.</span></span>
<span class="line" id="L1652">    <span class="tok-comment">///</span></span>
<span class="line" id="L1653">    <span class="tok-comment">/// If `.eh_frame_hdr` is available, it will be used to binary search for the FDE.</span></span>
<span class="line" id="L1654">    <span class="tok-comment">/// Otherwise, a linear scan of `.eh_frame` and `.debug_frame` is done to find the FDE.</span></span>
<span class="line" id="L1655">    <span class="tok-comment">///</span></span>
<span class="line" id="L1656">    <span class="tok-comment">/// `explicit_fde_offset` is for cases where the FDE offset is known, such as when __unwind_info</span></span>
<span class="line" id="L1657">    <span class="tok-comment">/// defers unwinding to DWARF. This is an offset into the `.eh_frame` section.</span></span>
<span class="line" id="L1658">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unwindFrame</span>(di: *<span class="tok-kw">const</span> DwarfInfo, context: *UnwindContext, explicit_fde_offset: ?<span class="tok-type">usize</span>) !<span class="tok-type">usize</span> {</span>
<span class="line" id="L1659">        <span class="tok-kw">if</span> (!<span class="tok-kw">comptime</span> abi.supportsUnwinding(builtin.target)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedCpuArchitecture;</span>
<span class="line" id="L1660">        <span class="tok-kw">if</span> (context.pc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L1661"></span>
<span class="line" id="L1662">        <span class="tok-comment">// Find the FDE and CIE</span>
</span>
<span class="line" id="L1663">        <span class="tok-kw">var</span> cie: CommonInformationEntry = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1664">        <span class="tok-kw">var</span> fde: FrameDescriptionEntry = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1665"></span>
<span class="line" id="L1666">        <span class="tok-kw">if</span> (explicit_fde_offset) |fde_offset| {</span>
<span class="line" id="L1667">            <span class="tok-kw">const</span> dwarf_section: DwarfSection = .eh_frame;</span>
<span class="line" id="L1668">            <span class="tok-kw">const</span> frame_section = di.section(dwarf_section) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingFDE;</span>
<span class="line" id="L1669">            <span class="tok-kw">if</span> (fde_offset &gt;= frame_section.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingFDE;</span>
<span class="line" id="L1670"></span>
<span class="line" id="L1671">            <span class="tok-kw">var</span> stream = io.fixedBufferStream(frame_section);</span>
<span class="line" id="L1672">            <span class="tok-kw">try</span> stream.seekTo(fde_offset);</span>
<span class="line" id="L1673"></span>
<span class="line" id="L1674">            <span class="tok-kw">const</span> fde_entry_header = <span class="tok-kw">try</span> EntryHeader.read(&amp;stream, dwarf_section, di.endian);</span>
<span class="line" id="L1675">            <span class="tok-kw">if</span> (fde_entry_header.<span class="tok-type">type</span> != .fde) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingFDE;</span>
<span class="line" id="L1676"></span>
<span class="line" id="L1677">            <span class="tok-kw">const</span> cie_offset = fde_entry_header.<span class="tok-type">type</span>.fde;</span>
<span class="line" id="L1678">            <span class="tok-kw">try</span> stream.seekTo(cie_offset);</span>
<span class="line" id="L1679"></span>
<span class="line" id="L1680">            <span class="tok-kw">const</span> cie_entry_header = <span class="tok-kw">try</span> EntryHeader.read(&amp;stream, dwarf_section, builtin.cpu.arch.endian());</span>
<span class="line" id="L1681">            <span class="tok-kw">if</span> (cie_entry_header.<span class="tok-type">type</span> != .cie) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1682"></span>
<span class="line" id="L1683">            cie = <span class="tok-kw">try</span> CommonInformationEntry.parse(</span>
<span class="line" id="L1684">                cie_entry_header.entry_bytes,</span>
<span class="line" id="L1685">                <span class="tok-number">0</span>,</span>
<span class="line" id="L1686">                <span class="tok-null">true</span>,</span>
<span class="line" id="L1687">                cie_entry_header.is_64,</span>
<span class="line" id="L1688">                dwarf_section,</span>
<span class="line" id="L1689">                cie_entry_header.length_offset,</span>
<span class="line" id="L1690">                <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>),</span>
<span class="line" id="L1691">                builtin.cpu.arch.endian(),</span>
<span class="line" id="L1692">            );</span>
<span class="line" id="L1693"></span>
<span class="line" id="L1694">            fde = <span class="tok-kw">try</span> FrameDescriptionEntry.parse(</span>
<span class="line" id="L1695">                fde_entry_header.entry_bytes,</span>
<span class="line" id="L1696">                <span class="tok-number">0</span>,</span>
<span class="line" id="L1697">                <span class="tok-null">true</span>,</span>
<span class="line" id="L1698">                cie,</span>
<span class="line" id="L1699">                <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>),</span>
<span class="line" id="L1700">                builtin.cpu.arch.endian(),</span>
<span class="line" id="L1701">            );</span>
<span class="line" id="L1702">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (di.eh_frame_hdr) |header| {</span>
<span class="line" id="L1703">            <span class="tok-kw">const</span> eh_frame_len = <span class="tok-kw">if</span> (di.section(.eh_frame)) |eh_frame| eh_frame.len <span class="tok-kw">else</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1704">            <span class="tok-kw">try</span> header.findEntry(</span>
<span class="line" id="L1705">                context.isValidMemory,</span>
<span class="line" id="L1706">                eh_frame_len,</span>
<span class="line" id="L1707">                <span class="tok-builtin">@intFromPtr</span>(di.section(.eh_frame_hdr).?.ptr),</span>
<span class="line" id="L1708">                context.pc,</span>
<span class="line" id="L1709">                &amp;cie,</span>
<span class="line" id="L1710">                &amp;fde,</span>
<span class="line" id="L1711">            );</span>
<span class="line" id="L1712">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1713">            <span class="tok-kw">const</span> index = std.sort.binarySearch(FrameDescriptionEntry, context.pc, di.fde_list.items, {}, <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1714">                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">compareFn</span>(_: <span class="tok-type">void</span>, pc: <span class="tok-type">usize</span>, mid_item: FrameDescriptionEntry) std.math.Order {</span>
<span class="line" id="L1715">                    <span class="tok-kw">if</span> (pc &lt; mid_item.pc_begin) <span class="tok-kw">return</span> .lt;</span>
<span class="line" id="L1716"></span>
<span class="line" id="L1717">                    <span class="tok-kw">const</span> range_end = mid_item.pc_begin + mid_item.pc_range;</span>
<span class="line" id="L1718">                    <span class="tok-kw">if</span> (pc &lt; range_end) <span class="tok-kw">return</span> .eq;</span>
<span class="line" id="L1719"></span>
<span class="line" id="L1720">                    <span class="tok-kw">return</span> .gt;</span>
<span class="line" id="L1721">                }</span>
<span class="line" id="L1722">            }.compareFn);</span>
<span class="line" id="L1723"></span>
<span class="line" id="L1724">            fde = <span class="tok-kw">if</span> (index) |i| di.fde_list.items[i] <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingFDE;</span>
<span class="line" id="L1725">            cie = di.cie_map.get(fde.cie_length_offset) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingCIE;</span>
<span class="line" id="L1726">        }</span>
<span class="line" id="L1727"></span>
<span class="line" id="L1728">        <span class="tok-kw">var</span> expression_context = .{</span>
<span class="line" id="L1729">            .is_64 = cie.is_64,</span>
<span class="line" id="L1730">            .isValidMemory = context.isValidMemory,</span>
<span class="line" id="L1731">            .compile_unit = di.findCompileUnit(fde.pc_begin) <span class="tok-kw">catch</span> <span class="tok-null">null</span>,</span>
<span class="line" id="L1732">            .thread_context = context.thread_context,</span>
<span class="line" id="L1733">            .reg_context = context.reg_context,</span>
<span class="line" id="L1734">            .cfa = context.cfa,</span>
<span class="line" id="L1735">        };</span>
<span class="line" id="L1736"></span>
<span class="line" id="L1737">        context.vm.reset();</span>
<span class="line" id="L1738">        context.reg_context.eh_frame = cie.version != <span class="tok-number">4</span>;</span>
<span class="line" id="L1739">        context.reg_context.is_macho = di.is_macho;</span>
<span class="line" id="L1740"></span>
<span class="line" id="L1741">        <span class="tok-kw">const</span> row = <span class="tok-kw">try</span> context.vm.runToNative(context.allocator, context.pc, cie, fde);</span>
<span class="line" id="L1742">        context.cfa = <span class="tok-kw">switch</span> (row.cfa.rule) {</span>
<span class="line" id="L1743">            .val_offset =&gt; |offset| blk: {</span>
<span class="line" id="L1744">                <span class="tok-kw">const</span> register = row.cfa.register <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFARule;</span>
<span class="line" id="L1745">                <span class="tok-kw">const</span> value = mem.readIntSliceNative(<span class="tok-type">usize</span>, <span class="tok-kw">try</span> abi.regBytes(context.thread_context, register, context.reg_context));</span>
<span class="line" id="L1746">                <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> call_frame.applyOffset(value, offset);</span>
<span class="line" id="L1747">            },</span>
<span class="line" id="L1748">            .expression =&gt; |expression| blk: {</span>
<span class="line" id="L1749">                context.stack_machine.reset();</span>
<span class="line" id="L1750">                <span class="tok-kw">const</span> value = <span class="tok-kw">try</span> context.stack_machine.run(</span>
<span class="line" id="L1751">                    expression,</span>
<span class="line" id="L1752">                    context.allocator,</span>
<span class="line" id="L1753">                    expression_context,</span>
<span class="line" id="L1754">                    context.cfa,</span>
<span class="line" id="L1755">                );</span>
<span class="line" id="L1756"></span>
<span class="line" id="L1757">                <span class="tok-kw">if</span> (value) |v| {</span>
<span class="line" id="L1758">                    <span class="tok-kw">if</span> (v != .generic) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpressionValue;</span>
<span class="line" id="L1759">                    <span class="tok-kw">break</span> :blk v.generic;</span>
<span class="line" id="L1760">                } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoExpressionValue;</span>
<span class="line" id="L1761">            },</span>
<span class="line" id="L1762">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFARule,</span>
<span class="line" id="L1763">        };</span>
<span class="line" id="L1764"></span>
<span class="line" id="L1765">        <span class="tok-kw">if</span> (!context.isValidMemory(context.cfa.?)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFA;</span>
<span class="line" id="L1766">        expression_context.cfa = context.cfa;</span>
<span class="line" id="L1767"></span>
<span class="line" id="L1768">        <span class="tok-comment">// Buffering the modifications is done because copying the thread context is not portable,</span>
</span>
<span class="line" id="L1769">        <span class="tok-comment">// some implementations (ie. darwin) use internal pointers to the mcontext.</span>
</span>
<span class="line" id="L1770">        <span class="tok-kw">var</span> arena = std.heap.ArenaAllocator.init(context.allocator);</span>
<span class="line" id="L1771">        <span class="tok-kw">defer</span> arena.deinit();</span>
<span class="line" id="L1772">        <span class="tok-kw">const</span> update_allocator = arena.allocator();</span>
<span class="line" id="L1773"></span>
<span class="line" id="L1774">        <span class="tok-kw">const</span> RegisterUpdate = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1775">            <span class="tok-comment">// Backed by thread_context</span>
</span>
<span class="line" id="L1776">            dest: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L1777">            <span class="tok-comment">// Backed by arena</span>
</span>
<span class="line" id="L1778">            src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1779">            prev: ?*<span class="tok-builtin">@This</span>(),</span>
<span class="line" id="L1780">        };</span>
<span class="line" id="L1781"></span>
<span class="line" id="L1782">        <span class="tok-kw">var</span> update_tail: ?*RegisterUpdate = <span class="tok-null">null</span>;</span>
<span class="line" id="L1783">        <span class="tok-kw">var</span> has_return_address = <span class="tok-null">true</span>;</span>
<span class="line" id="L1784">        <span class="tok-kw">for</span> (context.vm.rowColumns(row)) |column| {</span>
<span class="line" id="L1785">            <span class="tok-kw">if</span> (column.register) |register| {</span>
<span class="line" id="L1786">                <span class="tok-kw">if</span> (register == cie.return_address_register) {</span>
<span class="line" id="L1787">                    has_return_address = column.rule != .<span class="tok-null">undefined</span>;</span>
<span class="line" id="L1788">                }</span>
<span class="line" id="L1789"></span>
<span class="line" id="L1790">                <span class="tok-kw">const</span> dest = <span class="tok-kw">try</span> abi.regBytes(context.thread_context, register, context.reg_context);</span>
<span class="line" id="L1791">                <span class="tok-kw">const</span> src = <span class="tok-kw">try</span> update_allocator.alloc(<span class="tok-type">u8</span>, dest.len);</span>
<span class="line" id="L1792"></span>
<span class="line" id="L1793">                <span class="tok-kw">const</span> prev = update_tail;</span>
<span class="line" id="L1794">                update_tail = <span class="tok-kw">try</span> update_allocator.create(RegisterUpdate);</span>
<span class="line" id="L1795">                update_tail.?.* = .{</span>
<span class="line" id="L1796">                    .dest = dest,</span>
<span class="line" id="L1797">                    .src = src,</span>
<span class="line" id="L1798">                    .prev = prev,</span>
<span class="line" id="L1799">                };</span>
<span class="line" id="L1800"></span>
<span class="line" id="L1801">                <span class="tok-kw">try</span> column.resolveValue(</span>
<span class="line" id="L1802">                    context,</span>
<span class="line" id="L1803">                    expression_context,</span>
<span class="line" id="L1804">                    src,</span>
<span class="line" id="L1805">                );</span>
<span class="line" id="L1806">            }</span>
<span class="line" id="L1807">        }</span>
<span class="line" id="L1808"></span>
<span class="line" id="L1809">        <span class="tok-comment">// On all implemented architectures, the CFA is defined as being the previous frame's SP</span>
</span>
<span class="line" id="L1810">        (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, abi.spRegNum(context.reg_context), context.reg_context)).* = context.cfa.?;</span>
<span class="line" id="L1811"></span>
<span class="line" id="L1812">        <span class="tok-kw">while</span> (update_tail) |tail| {</span>
<span class="line" id="L1813">            <span class="tok-builtin">@memcpy</span>(tail.dest, tail.src);</span>
<span class="line" id="L1814">            update_tail = tail.prev;</span>
<span class="line" id="L1815">        }</span>
<span class="line" id="L1816"></span>
<span class="line" id="L1817">        <span class="tok-kw">if</span> (has_return_address) {</span>
<span class="line" id="L1818">            context.pc = abi.stripInstructionPtrAuthCode(mem.readIntSliceNative(<span class="tok-type">usize</span>, <span class="tok-kw">try</span> abi.regBytes(</span>
<span class="line" id="L1819">                context.thread_context,</span>
<span class="line" id="L1820">                cie.return_address_register,</span>
<span class="line" id="L1821">                context.reg_context,</span>
<span class="line" id="L1822">            )));</span>
<span class="line" id="L1823">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1824">            context.pc = <span class="tok-number">0</span>;</span>
<span class="line" id="L1825">        }</span>
<span class="line" id="L1826"></span>
<span class="line" id="L1827">        (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, abi.ipRegNum(), context.reg_context)).* = context.pc;</span>
<span class="line" id="L1828"></span>
<span class="line" id="L1829">        <span class="tok-comment">// The call instruction will have pushed the address of the instruction that follows the call as the return address.</span>
</span>
<span class="line" id="L1830">        <span class="tok-comment">// This next instruction may be past the end of the function if the caller was `noreturn` (ie. the last instruction in</span>
</span>
<span class="line" id="L1831">        <span class="tok-comment">// the function was the call). If we were to look up an FDE entry using the return address directly, it could end up</span>
</span>
<span class="line" id="L1832">        <span class="tok-comment">// either not finding an FDE at all, or using the next FDE in the program, producing incorrect results. To prevent this,</span>
</span>
<span class="line" id="L1833">        <span class="tok-comment">// we subtract one so that the next lookup is guaranteed to land inside the</span>
</span>
<span class="line" id="L1834">        <span class="tok-comment">//</span>
</span>
<span class="line" id="L1835">        <span class="tok-comment">// The exception to this rule is signal frames, where we return execution would be returned to the instruction</span>
</span>
<span class="line" id="L1836">        <span class="tok-comment">// that triggered the handler.</span>
</span>
<span class="line" id="L1837">        <span class="tok-kw">const</span> return_address = context.pc;</span>
<span class="line" id="L1838">        <span class="tok-kw">if</span> (context.pc &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> !cie.isSignalFrame()) context.pc -= <span class="tok-number">1</span>;</span>
<span class="line" id="L1839"></span>
<span class="line" id="L1840">        <span class="tok-kw">return</span> return_address;</span>
<span class="line" id="L1841">    }</span>
<span class="line" id="L1842">};</span>
<span class="line" id="L1843"></span>
<span class="line" id="L1844"><span class="tok-comment">/// Returns the DWARF register number for an x86_64 register number found in compact unwind info</span></span>
<span class="line" id="L1845"><span class="tok-kw">fn</span> <span class="tok-fn">compactUnwindToDwarfRegNumber</span>(unwind_reg_number: <span class="tok-type">u3</span>) !<span class="tok-type">u8</span> {</span>
<span class="line" id="L1846">    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (unwind_reg_number) {</span>
<span class="line" id="L1847">        <span class="tok-number">1</span> =&gt; <span class="tok-number">3</span>, <span class="tok-comment">// RBX</span>
</span>
<span class="line" id="L1848">        <span class="tok-number">2</span> =&gt; <span class="tok-number">12</span>, <span class="tok-comment">// R12</span>
</span>
<span class="line" id="L1849">        <span class="tok-number">3</span> =&gt; <span class="tok-number">13</span>, <span class="tok-comment">// R13</span>
</span>
<span class="line" id="L1850">        <span class="tok-number">4</span> =&gt; <span class="tok-number">14</span>, <span class="tok-comment">// R14</span>
</span>
<span class="line" id="L1851">        <span class="tok-number">5</span> =&gt; <span class="tok-number">15</span>, <span class="tok-comment">// R15</span>
</span>
<span class="line" id="L1852">        <span class="tok-number">6</span> =&gt; <span class="tok-number">6</span>, <span class="tok-comment">// RBP</span>
</span>
<span class="line" id="L1853">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">error</span>.InvalidUnwindRegisterNumber,</span>
<span class="line" id="L1854">    };</span>
<span class="line" id="L1855">}</span>
<span class="line" id="L1856"></span>
<span class="line" id="L1857"><span class="tok-kw">const</span> macho = std.macho;</span>
<span class="line" id="L1858"></span>
<span class="line" id="L1859"><span class="tok-comment">/// Unwind a frame using MachO compact unwind info (from __unwind_info).</span></span>
<span class="line" id="L1860"><span class="tok-comment">/// If the compact encoding can't encode a way to unwind a frame, it will</span></span>
<span class="line" id="L1861"><span class="tok-comment">/// defer unwinding to DWARF, in which case `.eh_frame` will be used if available.</span></span>
<span class="line" id="L1862"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unwindFrameMachO</span>(context: *UnwindContext, unwind_info: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, eh_frame: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, module_base_address: <span class="tok-type">usize</span>) !<span class="tok-type">usize</span> {</span>
<span class="line" id="L1863">    <span class="tok-kw">const</span> header = mem.bytesAsValue(</span>
<span class="line" id="L1864">        macho.unwind_info_section_header,</span>
<span class="line" id="L1865">        unwind_info[<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(macho.unwind_info_section_header)],</span>
<span class="line" id="L1866">    );</span>
<span class="line" id="L1867">    <span class="tok-kw">const</span> indices = mem.bytesAsSlice(</span>
<span class="line" id="L1868">        macho.unwind_info_section_header_index_entry,</span>
<span class="line" id="L1869">        unwind_info[header.indexSectionOffset..][<span class="tok-number">0</span> .. header.indexCount * <span class="tok-builtin">@sizeOf</span>(macho.unwind_info_section_header_index_entry)],</span>
<span class="line" id="L1870">    );</span>
<span class="line" id="L1871">    <span class="tok-kw">if</span> (indices.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingUnwindInfo;</span>
<span class="line" id="L1872"></span>
<span class="line" id="L1873">    <span class="tok-kw">const</span> mapped_pc = context.pc - module_base_address;</span>
<span class="line" id="L1874">    <span class="tok-kw">const</span> second_level_index = blk: {</span>
<span class="line" id="L1875">        <span class="tok-kw">var</span> left: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1876">        <span class="tok-kw">var</span> len: <span class="tok-type">usize</span> = indices.len;</span>
<span class="line" id="L1877"></span>
<span class="line" id="L1878">        <span class="tok-kw">while</span> (len &gt; <span class="tok-number">1</span>) {</span>
<span class="line" id="L1879">            <span class="tok-kw">const</span> mid = left + len / <span class="tok-number">2</span>;</span>
<span class="line" id="L1880">            <span class="tok-kw">const</span> offset = indices[mid].functionOffset;</span>
<span class="line" id="L1881">            <span class="tok-kw">if</span> (mapped_pc &lt; offset) {</span>
<span class="line" id="L1882">                len /= <span class="tok-number">2</span>;</span>
<span class="line" id="L1883">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1884">                left = mid;</span>
<span class="line" id="L1885">                <span class="tok-kw">if</span> (mapped_pc == offset) <span class="tok-kw">break</span>;</span>
<span class="line" id="L1886">                len -= len / <span class="tok-number">2</span>;</span>
<span class="line" id="L1887">            }</span>
<span class="line" id="L1888">        }</span>
<span class="line" id="L1889"></span>
<span class="line" id="L1890">        <span class="tok-comment">// Last index is a sentinel containing the highest address as its functionOffset</span>
</span>
<span class="line" id="L1891">        <span class="tok-kw">if</span> (indices[left].secondLevelPagesSectionOffset == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingUnwindInfo;</span>
<span class="line" id="L1892">        <span class="tok-kw">break</span> :blk &amp;indices[left];</span>
<span class="line" id="L1893">    };</span>
<span class="line" id="L1894"></span>
<span class="line" id="L1895">    <span class="tok-kw">const</span> common_encodings = mem.bytesAsSlice(</span>
<span class="line" id="L1896">        macho.compact_unwind_encoding_t,</span>
<span class="line" id="L1897">        unwind_info[header.commonEncodingsArraySectionOffset..][<span class="tok-number">0</span> .. header.commonEncodingsArrayCount * <span class="tok-builtin">@sizeOf</span>(macho.compact_unwind_encoding_t)],</span>
<span class="line" id="L1898">    );</span>
<span class="line" id="L1899"></span>
<span class="line" id="L1900">    <span class="tok-kw">const</span> start_offset = second_level_index.secondLevelPagesSectionOffset;</span>
<span class="line" id="L1901">    <span class="tok-kw">const</span> kind = mem.bytesAsValue(</span>
<span class="line" id="L1902">        macho.UNWIND_SECOND_LEVEL,</span>
<span class="line" id="L1903">        unwind_info[start_offset..][<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(macho.UNWIND_SECOND_LEVEL)],</span>
<span class="line" id="L1904">    );</span>
<span class="line" id="L1905"></span>
<span class="line" id="L1906">    <span class="tok-kw">const</span> entry: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1907">        function_offset: <span class="tok-type">usize</span>,</span>
<span class="line" id="L1908">        raw_encoding: <span class="tok-type">u32</span>,</span>
<span class="line" id="L1909">    } = <span class="tok-kw">switch</span> (kind.*) {</span>
<span class="line" id="L1910">        .REGULAR =&gt; blk: {</span>
<span class="line" id="L1911">            <span class="tok-kw">const</span> page_header = mem.bytesAsValue(</span>
<span class="line" id="L1912">                macho.unwind_info_regular_second_level_page_header,</span>
<span class="line" id="L1913">                unwind_info[start_offset..][<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(macho.unwind_info_regular_second_level_page_header)],</span>
<span class="line" id="L1914">            );</span>
<span class="line" id="L1915"></span>
<span class="line" id="L1916">            <span class="tok-kw">const</span> entries = mem.bytesAsSlice(</span>
<span class="line" id="L1917">                macho.unwind_info_regular_second_level_entry,</span>
<span class="line" id="L1918">                unwind_info[start_offset + page_header.entryPageOffset ..][<span class="tok-number">0</span> .. page_header.entryCount * <span class="tok-builtin">@sizeOf</span>(macho.unwind_info_regular_second_level_entry)],</span>
<span class="line" id="L1919">            );</span>
<span class="line" id="L1920">            <span class="tok-kw">if</span> (entries.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;</span>
<span class="line" id="L1921"></span>
<span class="line" id="L1922">            <span class="tok-kw">var</span> left: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1923">            <span class="tok-kw">var</span> len: <span class="tok-type">usize</span> = entries.len;</span>
<span class="line" id="L1924">            <span class="tok-kw">while</span> (len &gt; <span class="tok-number">1</span>) {</span>
<span class="line" id="L1925">                <span class="tok-kw">const</span> mid = left + len / <span class="tok-number">2</span>;</span>
<span class="line" id="L1926">                <span class="tok-kw">const</span> offset = entries[mid].functionOffset;</span>
<span class="line" id="L1927">                <span class="tok-kw">if</span> (mapped_pc &lt; offset) {</span>
<span class="line" id="L1928">                    len /= <span class="tok-number">2</span>;</span>
<span class="line" id="L1929">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1930">                    left = mid;</span>
<span class="line" id="L1931">                    <span class="tok-kw">if</span> (mapped_pc == offset) <span class="tok-kw">break</span>;</span>
<span class="line" id="L1932">                    len -= len / <span class="tok-number">2</span>;</span>
<span class="line" id="L1933">                }</span>
<span class="line" id="L1934">            }</span>
<span class="line" id="L1935"></span>
<span class="line" id="L1936">            <span class="tok-kw">break</span> :blk .{</span>
<span class="line" id="L1937">                .function_offset = entries[left].functionOffset,</span>
<span class="line" id="L1938">                .raw_encoding = entries[left].encoding,</span>
<span class="line" id="L1939">            };</span>
<span class="line" id="L1940">        },</span>
<span class="line" id="L1941">        .COMPRESSED =&gt; blk: {</span>
<span class="line" id="L1942">            <span class="tok-kw">const</span> page_header = mem.bytesAsValue(</span>
<span class="line" id="L1943">                macho.unwind_info_compressed_second_level_page_header,</span>
<span class="line" id="L1944">                unwind_info[start_offset..][<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(macho.unwind_info_compressed_second_level_page_header)],</span>
<span class="line" id="L1945">            );</span>
<span class="line" id="L1946"></span>
<span class="line" id="L1947">            <span class="tok-kw">const</span> entries = mem.bytesAsSlice(</span>
<span class="line" id="L1948">                macho.UnwindInfoCompressedEntry,</span>
<span class="line" id="L1949">                unwind_info[start_offset + page_header.entryPageOffset ..][<span class="tok-number">0</span> .. page_header.entryCount * <span class="tok-builtin">@sizeOf</span>(macho.UnwindInfoCompressedEntry)],</span>
<span class="line" id="L1950">            );</span>
<span class="line" id="L1951">            <span class="tok-kw">if</span> (entries.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;</span>
<span class="line" id="L1952"></span>
<span class="line" id="L1953">            <span class="tok-kw">var</span> left: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1954">            <span class="tok-kw">var</span> len: <span class="tok-type">usize</span> = entries.len;</span>
<span class="line" id="L1955">            <span class="tok-kw">while</span> (len &gt; <span class="tok-number">1</span>) {</span>
<span class="line" id="L1956">                <span class="tok-kw">const</span> mid = left + len / <span class="tok-number">2</span>;</span>
<span class="line" id="L1957">                <span class="tok-kw">const</span> offset = second_level_index.functionOffset + entries[mid].funcOffset;</span>
<span class="line" id="L1958">                <span class="tok-kw">if</span> (mapped_pc &lt; offset) {</span>
<span class="line" id="L1959">                    len /= <span class="tok-number">2</span>;</span>
<span class="line" id="L1960">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1961">                    left = mid;</span>
<span class="line" id="L1962">                    <span class="tok-kw">if</span> (mapped_pc == offset) <span class="tok-kw">break</span>;</span>
<span class="line" id="L1963">                    len -= len / <span class="tok-number">2</span>;</span>
<span class="line" id="L1964">                }</span>
<span class="line" id="L1965">            }</span>
<span class="line" id="L1966"></span>
<span class="line" id="L1967">            <span class="tok-kw">const</span> entry = entries[left];</span>
<span class="line" id="L1968">            <span class="tok-kw">const</span> function_offset = second_level_index.functionOffset + entry.funcOffset;</span>
<span class="line" id="L1969">            <span class="tok-kw">if</span> (entry.encodingIndex &lt; header.commonEncodingsArrayCount) {</span>
<span class="line" id="L1970">                <span class="tok-kw">if</span> (entry.encodingIndex &gt;= common_encodings.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;</span>
<span class="line" id="L1971">                <span class="tok-kw">break</span> :blk .{</span>
<span class="line" id="L1972">                    .function_offset = function_offset,</span>
<span class="line" id="L1973">                    .raw_encoding = common_encodings[entry.encodingIndex],</span>
<span class="line" id="L1974">                };</span>
<span class="line" id="L1975">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1976">                <span class="tok-kw">const</span> local_index = <span class="tok-kw">try</span> std.math.sub(</span>
<span class="line" id="L1977">                    <span class="tok-type">u8</span>,</span>
<span class="line" id="L1978">                    entry.encodingIndex,</span>
<span class="line" id="L1979">                    std.math.cast(<span class="tok-type">u8</span>, header.commonEncodingsArrayCount) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo,</span>
<span class="line" id="L1980">                );</span>
<span class="line" id="L1981">                <span class="tok-kw">const</span> local_encodings = mem.bytesAsSlice(</span>
<span class="line" id="L1982">                    macho.compact_unwind_encoding_t,</span>
<span class="line" id="L1983">                    unwind_info[start_offset + page_header.encodingsPageOffset ..][<span class="tok-number">0</span> .. page_header.encodingsCount * <span class="tok-builtin">@sizeOf</span>(macho.compact_unwind_encoding_t)],</span>
<span class="line" id="L1984">                );</span>
<span class="line" id="L1985">                <span class="tok-kw">if</span> (local_index &gt;= local_encodings.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;</span>
<span class="line" id="L1986">                <span class="tok-kw">break</span> :blk .{</span>
<span class="line" id="L1987">                    .function_offset = function_offset,</span>
<span class="line" id="L1988">                    .raw_encoding = local_encodings[local_index],</span>
<span class="line" id="L1989">                };</span>
<span class="line" id="L1990">            }</span>
<span class="line" id="L1991">        },</span>
<span class="line" id="L1992">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo,</span>
<span class="line" id="L1993">    };</span>
<span class="line" id="L1994"></span>
<span class="line" id="L1995">    <span class="tok-kw">if</span> (entry.raw_encoding == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoUnwindInfo;</span>
<span class="line" id="L1996">    <span class="tok-kw">const</span> reg_context = abi.RegisterContext{</span>
<span class="line" id="L1997">        .eh_frame = <span class="tok-null">false</span>,</span>
<span class="line" id="L1998">        .is_macho = <span class="tok-null">true</span>,</span>
<span class="line" id="L1999">    };</span>
<span class="line" id="L2000"></span>
<span class="line" id="L2001">    <span class="tok-kw">const</span> encoding: macho.CompactUnwindEncoding = <span class="tok-builtin">@bitCast</span>(entry.raw_encoding);</span>
<span class="line" id="L2002">    <span class="tok-kw">const</span> new_ip = <span class="tok-kw">switch</span> (builtin.cpu.arch) {</span>
<span class="line" id="L2003">        .x86_64 =&gt; <span class="tok-kw">switch</span> (encoding.mode.x86_64) {</span>
<span class="line" id="L2004">            .OLD =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedUnwindEncoding,</span>
<span class="line" id="L2005">            .RBP_FRAME =&gt; blk: {</span>
<span class="line" id="L2006">                <span class="tok-kw">const</span> regs: [<span class="tok-number">5</span>]<span class="tok-type">u3</span> = .{</span>
<span class="line" id="L2007">                    encoding.value.x86_64.frame.reg0,</span>
<span class="line" id="L2008">                    encoding.value.x86_64.frame.reg1,</span>
<span class="line" id="L2009">                    encoding.value.x86_64.frame.reg2,</span>
<span class="line" id="L2010">                    encoding.value.x86_64.frame.reg3,</span>
<span class="line" id="L2011">                    encoding.value.x86_64.frame.reg4,</span>
<span class="line" id="L2012">                };</span>
<span class="line" id="L2013"></span>
<span class="line" id="L2014">                <span class="tok-kw">const</span> frame_offset = encoding.value.x86_64.frame.frame_offset * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);</span>
<span class="line" id="L2015">                <span class="tok-kw">var</span> max_reg: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2016">                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (regs, <span class="tok-number">0</span>..) |reg, i| {</span>
<span class="line" id="L2017">                    <span class="tok-kw">if</span> (reg &gt; <span class="tok-number">0</span>) max_reg = i;</span>
<span class="line" id="L2018">                }</span>
<span class="line" id="L2019"></span>
<span class="line" id="L2020">                <span class="tok-kw">const</span> fp = (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, abi.fpRegNum(reg_context), reg_context)).*;</span>
<span class="line" id="L2021">                <span class="tok-kw">const</span> new_sp = fp + <span class="tok-number">2</span> * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);</span>
<span class="line" id="L2022"></span>
<span class="line" id="L2023">                <span class="tok-comment">// Verify the stack range we're about to read register values from</span>
</span>
<span class="line" id="L2024">                <span class="tok-kw">if</span> (!context.isValidMemory(new_sp) <span class="tok-kw">or</span> !context.isValidMemory(fp - frame_offset + max_reg * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>))) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;</span>
<span class="line" id="L2025"></span>
<span class="line" id="L2026">                <span class="tok-kw">const</span> ip_ptr = fp + <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);</span>
<span class="line" id="L2027">                <span class="tok-kw">const</span> new_ip = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(ip_ptr)).*;</span>
<span class="line" id="L2028">                <span class="tok-kw">const</span> new_fp = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(fp)).*;</span>
<span class="line" id="L2029"></span>
<span class="line" id="L2030">                (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, abi.fpRegNum(reg_context), reg_context)).* = new_fp;</span>
<span class="line" id="L2031">                (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, abi.spRegNum(reg_context), reg_context)).* = new_sp;</span>
<span class="line" id="L2032">                (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, abi.ipRegNum(), reg_context)).* = new_ip;</span>
<span class="line" id="L2033"></span>
<span class="line" id="L2034">                <span class="tok-kw">for</span> (regs, <span class="tok-number">0</span>..) |reg, i| {</span>
<span class="line" id="L2035">                    <span class="tok-kw">if</span> (reg == <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L2036">                    <span class="tok-kw">const</span> addr = fp - frame_offset + i * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);</span>
<span class="line" id="L2037">                    <span class="tok-kw">const</span> reg_number = <span class="tok-kw">try</span> compactUnwindToDwarfRegNumber(reg);</span>
<span class="line" id="L2038">                    (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, reg_number, reg_context)).* = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(addr)).*;</span>
<span class="line" id="L2039">                }</span>
<span class="line" id="L2040"></span>
<span class="line" id="L2041">                <span class="tok-kw">break</span> :blk new_ip;</span>
<span class="line" id="L2042">            },</span>
<span class="line" id="L2043">            .STACK_IMMD,</span>
<span class="line" id="L2044">            .STACK_IND,</span>
<span class="line" id="L2045">            =&gt; blk: {</span>
<span class="line" id="L2046">                <span class="tok-kw">const</span> sp = (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, abi.spRegNum(reg_context), reg_context)).*;</span>
<span class="line" id="L2047">                <span class="tok-kw">const</span> stack_size = <span class="tok-kw">if</span> (encoding.mode.x86_64 == .STACK_IMMD)</span>
<span class="line" id="L2048">                    <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, encoding.value.x86_64.frameless.stack.direct.stack_size) * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)</span>
<span class="line" id="L2049">                <span class="tok-kw">else</span> stack_size: {</span>
<span class="line" id="L2050">                    <span class="tok-comment">// In .STACK_IND, the stack size is inferred from the subq instruction at the beginning of the function.</span>
</span>
<span class="line" id="L2051">                    <span class="tok-kw">const</span> sub_offset_addr =</span>
<span class="line" id="L2052">                        module_base_address +</span>
<span class="line" id="L2053">                        entry.function_offset +</span>
<span class="line" id="L2054">                        encoding.value.x86_64.frameless.stack.indirect.sub_offset;</span>
<span class="line" id="L2055">                    <span class="tok-kw">if</span> (!context.isValidMemory(sub_offset_addr)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;</span>
<span class="line" id="L2056"></span>
<span class="line" id="L2057">                    <span class="tok-comment">// `sub_offset_addr` points to the offset of the literal within the instruction</span>
</span>
<span class="line" id="L2058">                    <span class="tok-kw">const</span> sub_operand = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> <span class="tok-type">u32</span>, <span class="tok-builtin">@ptrFromInt</span>(sub_offset_addr)).*;</span>
<span class="line" id="L2059">                    <span class="tok-kw">break</span> :stack_size sub_operand + <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) * <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, encoding.value.x86_64.frameless.stack.indirect.stack_adjust);</span>
<span class="line" id="L2060">                };</span>
<span class="line" id="L2061"></span>
<span class="line" id="L2062">                <span class="tok-comment">// Decode the Lehmer-coded sequence of registers.</span>
</span>
<span class="line" id="L2063">                <span class="tok-comment">// For a description of the encoding see lib/libc/include/any-macos.13-any/mach-o/compact_unwind_encoding.h</span>
</span>
<span class="line" id="L2064"></span>
<span class="line" id="L2065">                <span class="tok-comment">// Decode the variable-based permutation number into its digits. Each digit represents</span>
</span>
<span class="line" id="L2066">                <span class="tok-comment">// an index into the list of register numbers that weren't yet used in the sequence at</span>
</span>
<span class="line" id="L2067">                <span class="tok-comment">// the time the digit was added.</span>
</span>
<span class="line" id="L2068">                <span class="tok-kw">const</span> reg_count = encoding.value.x86_64.frameless.stack_reg_count;</span>
<span class="line" id="L2069">                <span class="tok-kw">const</span> ip_ptr = <span class="tok-kw">if</span> (reg_count &gt; <span class="tok-number">0</span>) reg_blk: {</span>
<span class="line" id="L2070">                    <span class="tok-kw">var</span> digits: [<span class="tok-number">6</span>]<span class="tok-type">u3</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L2071">                    <span class="tok-kw">var</span> accumulator: <span class="tok-type">usize</span> = encoding.value.x86_64.frameless.stack_reg_permutation;</span>
<span class="line" id="L2072">                    <span class="tok-kw">var</span> base: <span class="tok-type">usize</span> = <span class="tok-number">2</span>;</span>
<span class="line" id="L2073">                    <span class="tok-kw">for</span> (<span class="tok-number">0</span>..reg_count) |i| {</span>
<span class="line" id="L2074">                        <span class="tok-kw">const</span> div = accumulator / base;</span>
<span class="line" id="L2075">                        digits[digits.len - <span class="tok-number">1</span> - i] = <span class="tok-builtin">@intCast</span>(accumulator - base * div);</span>
<span class="line" id="L2076">                        accumulator = div;</span>
<span class="line" id="L2077">                        base += <span class="tok-number">1</span>;</span>
<span class="line" id="L2078">                    }</span>
<span class="line" id="L2079"></span>
<span class="line" id="L2080">                    <span class="tok-kw">const</span> reg_numbers = [_]<span class="tok-type">u3</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span> };</span>
<span class="line" id="L2081">                    <span class="tok-kw">var</span> registers: [reg_numbers.len]<span class="tok-type">u3</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L2082">                    <span class="tok-kw">var</span> used_indices = [_]<span class="tok-type">bool</span>{<span class="tok-null">false</span>} ** reg_numbers.len;</span>
<span class="line" id="L2083">                    <span class="tok-kw">for</span> (digits[digits.len - reg_count ..], <span class="tok-number">0</span>..) |target_unused_index, i| {</span>
<span class="line" id="L2084">                        <span class="tok-kw">var</span> unused_count: <span class="tok-type">u8</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2085">                        <span class="tok-kw">const</span> unused_index = <span class="tok-kw">for</span> (used_indices, <span class="tok-number">0</span>..) |used, index| {</span>
<span class="line" id="L2086">                            <span class="tok-kw">if</span> (!used) {</span>
<span class="line" id="L2087">                                <span class="tok-kw">if</span> (target_unused_index == unused_count) <span class="tok-kw">break</span> index;</span>
<span class="line" id="L2088">                                unused_count += <span class="tok-number">1</span>;</span>
<span class="line" id="L2089">                            }</span>
<span class="line" id="L2090">                        } <span class="tok-kw">else</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L2091"></span>
<span class="line" id="L2092">                        registers[i] = reg_numbers[unused_index];</span>
<span class="line" id="L2093">                        used_indices[unused_index] = <span class="tok-null">true</span>;</span>
<span class="line" id="L2094">                    }</span>
<span class="line" id="L2095"></span>
<span class="line" id="L2096">                    <span class="tok-kw">var</span> reg_addr = sp + stack_size - <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) * <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, reg_count + <span class="tok-number">1</span>);</span>
<span class="line" id="L2097">                    <span class="tok-kw">if</span> (!context.isValidMemory(reg_addr)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;</span>
<span class="line" id="L2098">                    <span class="tok-kw">for</span> (<span class="tok-number">0</span>..reg_count) |i| {</span>
<span class="line" id="L2099">                        <span class="tok-kw">const</span> reg_number = <span class="tok-kw">try</span> compactUnwindToDwarfRegNumber(registers[i]);</span>
<span class="line" id="L2100">                        (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, reg_number, reg_context)).* = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(reg_addr)).*;</span>
<span class="line" id="L2101">                        reg_addr += <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);</span>
<span class="line" id="L2102">                    }</span>
<span class="line" id="L2103"></span>
<span class="line" id="L2104">                    <span class="tok-kw">break</span> :reg_blk reg_addr;</span>
<span class="line" id="L2105">                } <span class="tok-kw">else</span> sp + stack_size - <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);</span>
<span class="line" id="L2106"></span>
<span class="line" id="L2107">                <span class="tok-kw">const</span> new_ip = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(ip_ptr)).*;</span>
<span class="line" id="L2108">                <span class="tok-kw">const</span> new_sp = ip_ptr + <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);</span>
<span class="line" id="L2109">                <span class="tok-kw">if</span> (!context.isValidMemory(new_sp)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;</span>
<span class="line" id="L2110"></span>
<span class="line" id="L2111">                (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, abi.spRegNum(reg_context), reg_context)).* = new_sp;</span>
<span class="line" id="L2112">                (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, abi.ipRegNum(), reg_context)).* = new_ip;</span>
<span class="line" id="L2113"></span>
<span class="line" id="L2114">                <span class="tok-kw">break</span> :blk new_ip;</span>
<span class="line" id="L2115">            },</span>
<span class="line" id="L2116">            .DWARF =&gt; {</span>
<span class="line" id="L2117">                <span class="tok-kw">return</span> unwindFrameMachODwarf(context, eh_frame <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingEhFrame, <span class="tok-builtin">@intCast</span>(encoding.value.x86_64.dwarf));</span>
<span class="line" id="L2118">            },</span>
<span class="line" id="L2119">        },</span>
<span class="line" id="L2120">        .aarch64 =&gt; <span class="tok-kw">switch</span> (encoding.mode.arm64) {</span>
<span class="line" id="L2121">            .OLD =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedUnwindEncoding,</span>
<span class="line" id="L2122">            .FRAMELESS =&gt; blk: {</span>
<span class="line" id="L2123">                <span class="tok-kw">const</span> sp = (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, abi.spRegNum(reg_context), reg_context)).*;</span>
<span class="line" id="L2124">                <span class="tok-kw">const</span> new_sp = sp + encoding.value.arm64.frameless.stack_size * <span class="tok-number">16</span>;</span>
<span class="line" id="L2125">                <span class="tok-kw">const</span> new_ip = (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, <span class="tok-number">30</span>, reg_context)).*;</span>
<span class="line" id="L2126">                <span class="tok-kw">if</span> (!context.isValidMemory(new_sp)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;</span>
<span class="line" id="L2127">                (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, abi.spRegNum(reg_context), reg_context)).* = new_sp;</span>
<span class="line" id="L2128">                <span class="tok-kw">break</span> :blk new_ip;</span>
<span class="line" id="L2129">            },</span>
<span class="line" id="L2130">            .DWARF =&gt; {</span>
<span class="line" id="L2131">                <span class="tok-kw">return</span> unwindFrameMachODwarf(context, eh_frame <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingEhFrame, <span class="tok-builtin">@intCast</span>(encoding.value.arm64.dwarf));</span>
<span class="line" id="L2132">            },</span>
<span class="line" id="L2133">            .FRAME =&gt; blk: {</span>
<span class="line" id="L2134">                <span class="tok-kw">const</span> fp = (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, abi.fpRegNum(reg_context), reg_context)).*;</span>
<span class="line" id="L2135">                <span class="tok-kw">const</span> new_sp = fp + <span class="tok-number">16</span>;</span>
<span class="line" id="L2136">                <span class="tok-kw">const</span> ip_ptr = fp + <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);</span>
<span class="line" id="L2137"></span>
<span class="line" id="L2138">                <span class="tok-kw">const</span> num_restored_pairs: <span class="tok-type">usize</span> =</span>
<span class="line" id="L2139">                    <span class="tok-builtin">@popCount</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u5</span>, <span class="tok-builtin">@bitCast</span>(encoding.value.arm64.frame.x_reg_pairs))) +</span>
<span class="line" id="L2140">                    <span class="tok-builtin">@popCount</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u4</span>, <span class="tok-builtin">@bitCast</span>(encoding.value.arm64.frame.d_reg_pairs)));</span>
<span class="line" id="L2141">                <span class="tok-kw">const</span> min_reg_addr = fp - num_restored_pairs * <span class="tok-number">2</span> * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);</span>
<span class="line" id="L2142"></span>
<span class="line" id="L2143">                <span class="tok-kw">if</span> (!context.isValidMemory(new_sp) <span class="tok-kw">or</span> !context.isValidMemory(min_reg_addr)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;</span>
<span class="line" id="L2144"></span>
<span class="line" id="L2145">                <span class="tok-kw">var</span> reg_addr = fp - <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);</span>
<span class="line" id="L2146">                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(encoding.value.arm64.frame.x_reg_pairs)).Struct.fields, <span class="tok-number">0</span>..) |field, i| {</span>
<span class="line" id="L2147">                    <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(encoding.value.arm64.frame.x_reg_pairs, field.name) != <span class="tok-number">0</span>) {</span>
<span class="line" id="L2148">                        (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, <span class="tok-number">19</span> + i, reg_context)).* = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(reg_addr)).*;</span>
<span class="line" id="L2149">                        reg_addr += <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);</span>
<span class="line" id="L2150">                        (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, <span class="tok-number">20</span> + i, reg_context)).* = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(reg_addr)).*;</span>
<span class="line" id="L2151">                        reg_addr += <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);</span>
<span class="line" id="L2152">                    }</span>
<span class="line" id="L2153">                }</span>
<span class="line" id="L2154"></span>
<span class="line" id="L2155">                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(encoding.value.arm64.frame.d_reg_pairs)).Struct.fields, <span class="tok-number">0</span>..) |field, i| {</span>
<span class="line" id="L2156">                    <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(encoding.value.arm64.frame.d_reg_pairs, field.name) != <span class="tok-number">0</span>) {</span>
<span class="line" id="L2157">                        <span class="tok-comment">// Only the lower half of the 128-bit V registers are restored during unwinding</span>
</span>
<span class="line" id="L2158">                        <span class="tok-builtin">@memcpy</span>(</span>
<span class="line" id="L2159">                            <span class="tok-kw">try</span> abi.regBytes(context.thread_context, <span class="tok-number">64</span> + <span class="tok-number">8</span> + i, context.reg_context),</span>
<span class="line" id="L2160">                            mem.asBytes(<span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(reg_addr))),</span>
<span class="line" id="L2161">                        );</span>
<span class="line" id="L2162">                        reg_addr += <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);</span>
<span class="line" id="L2163">                        <span class="tok-builtin">@memcpy</span>(</span>
<span class="line" id="L2164">                            <span class="tok-kw">try</span> abi.regBytes(context.thread_context, <span class="tok-number">64</span> + <span class="tok-number">9</span> + i, context.reg_context),</span>
<span class="line" id="L2165">                            mem.asBytes(<span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(reg_addr))),</span>
<span class="line" id="L2166">                        );</span>
<span class="line" id="L2167">                        reg_addr += <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);</span>
<span class="line" id="L2168">                    }</span>
<span class="line" id="L2169">                }</span>
<span class="line" id="L2170"></span>
<span class="line" id="L2171">                <span class="tok-kw">const</span> new_ip = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(ip_ptr)).*;</span>
<span class="line" id="L2172">                <span class="tok-kw">const</span> new_fp = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(fp)).*;</span>
<span class="line" id="L2173"></span>
<span class="line" id="L2174">                (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, abi.fpRegNum(reg_context), reg_context)).* = new_fp;</span>
<span class="line" id="L2175">                (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, abi.ipRegNum(), reg_context)).* = new_ip;</span>
<span class="line" id="L2176"></span>
<span class="line" id="L2177">                <span class="tok-kw">break</span> :blk new_ip;</span>
<span class="line" id="L2178">            },</span>
<span class="line" id="L2179">        },</span>
<span class="line" id="L2180">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedArch,</span>
<span class="line" id="L2181">    };</span>
<span class="line" id="L2182"></span>
<span class="line" id="L2183">    context.pc = abi.stripInstructionPtrAuthCode(new_ip);</span>
<span class="line" id="L2184">    <span class="tok-kw">if</span> (context.pc &gt; <span class="tok-number">0</span>) context.pc -= <span class="tok-number">1</span>;</span>
<span class="line" id="L2185">    <span class="tok-kw">return</span> new_ip;</span>
<span class="line" id="L2186">}</span>
<span class="line" id="L2187"></span>
<span class="line" id="L2188"><span class="tok-kw">fn</span> <span class="tok-fn">unwindFrameMachODwarf</span>(context: *UnwindContext, eh_frame: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, fde_offset: <span class="tok-type">usize</span>) !<span class="tok-type">usize</span> {</span>
<span class="line" id="L2189">    <span class="tok-kw">var</span> di = DwarfInfo{</span>
<span class="line" id="L2190">        .endian = builtin.cpu.arch.endian(),</span>
<span class="line" id="L2191">        .is_macho = <span class="tok-null">true</span>,</span>
<span class="line" id="L2192">    };</span>
<span class="line" id="L2193">    <span class="tok-kw">defer</span> di.deinit(context.allocator);</span>
<span class="line" id="L2194"></span>
<span class="line" id="L2195">    di.sections[<span class="tok-builtin">@intFromEnum</span>(DwarfSection.eh_frame)] = .{</span>
<span class="line" id="L2196">        .data = eh_frame,</span>
<span class="line" id="L2197">        .owned = <span class="tok-null">false</span>,</span>
<span class="line" id="L2198">    };</span>
<span class="line" id="L2199"></span>
<span class="line" id="L2200">    <span class="tok-kw">return</span> di.unwindFrame(context, fde_offset);</span>
<span class="line" id="L2201">}</span>
<span class="line" id="L2202"></span>
<span class="line" id="L2203"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> UnwindContext = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2204">    allocator: mem.Allocator,</span>
<span class="line" id="L2205">    cfa: ?<span class="tok-type">usize</span>,</span>
<span class="line" id="L2206">    pc: <span class="tok-type">usize</span>,</span>
<span class="line" id="L2207">    thread_context: *debug.ThreadContext,</span>
<span class="line" id="L2208">    reg_context: abi.RegisterContext,</span>
<span class="line" id="L2209">    isValidMemory: *<span class="tok-kw">const</span> <span class="tok-kw">fn</span> (address: <span class="tok-type">usize</span>) <span class="tok-type">bool</span>,</span>
<span class="line" id="L2210">    vm: call_frame.VirtualMachine = .{},</span>
<span class="line" id="L2211">    stack_machine: expressions.StackMachine(.{ .call_frame_context = <span class="tok-null">true</span> }) = .{},</span>
<span class="line" id="L2212"></span>
<span class="line" id="L2213">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: mem.Allocator, thread_context: *<span class="tok-kw">const</span> debug.ThreadContext, isValidMemory: *<span class="tok-kw">const</span> <span class="tok-kw">fn</span> (address: <span class="tok-type">usize</span>) <span class="tok-type">bool</span>) !UnwindContext {</span>
<span class="line" id="L2214">        <span class="tok-kw">const</span> pc = abi.stripInstructionPtrAuthCode((<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, thread_context, abi.ipRegNum(), <span class="tok-null">null</span>)).*);</span>
<span class="line" id="L2215"></span>
<span class="line" id="L2216">        <span class="tok-kw">const</span> context_copy = <span class="tok-kw">try</span> allocator.create(debug.ThreadContext);</span>
<span class="line" id="L2217">        debug.copyContext(thread_context, context_copy);</span>
<span class="line" id="L2218"></span>
<span class="line" id="L2219">        <span class="tok-kw">return</span> .{</span>
<span class="line" id="L2220">            .allocator = allocator,</span>
<span class="line" id="L2221">            .cfa = <span class="tok-null">null</span>,</span>
<span class="line" id="L2222">            .pc = pc,</span>
<span class="line" id="L2223">            .thread_context = context_copy,</span>
<span class="line" id="L2224">            .reg_context = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L2225">            .isValidMemory = isValidMemory,</span>
<span class="line" id="L2226">        };</span>
<span class="line" id="L2227">    }</span>
<span class="line" id="L2228"></span>
<span class="line" id="L2229">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *UnwindContext) <span class="tok-type">void</span> {</span>
<span class="line" id="L2230">        self.vm.deinit(self.allocator);</span>
<span class="line" id="L2231">        self.stack_machine.deinit(self.allocator);</span>
<span class="line" id="L2232">        self.allocator.destroy(self.thread_context);</span>
<span class="line" id="L2233">    }</span>
<span class="line" id="L2234"></span>
<span class="line" id="L2235">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getFp</span>(self: *<span class="tok-kw">const</span> UnwindContext) !<span class="tok-type">usize</span> {</span>
<span class="line" id="L2236">        <span class="tok-kw">return</span> (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, self.thread_context, abi.fpRegNum(self.reg_context), self.reg_context)).*;</span>
<span class="line" id="L2237">    }</span>
<span class="line" id="L2238">};</span>
<span class="line" id="L2239"></span>
<span class="line" id="L2240"><span class="tok-comment">/// Initialize DWARF info. The caller has the responsibility to initialize most</span></span>
<span class="line" id="L2241"><span class="tok-comment">/// the DwarfInfo fields before calling. `binary_mem` is the raw bytes of the</span></span>
<span class="line" id="L2242"><span class="tok-comment">/// main binary file (not the secondary debug info file).</span></span>
<span class="line" id="L2243"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDwarfDebugInfo</span>(di: *DwarfInfo, allocator: mem.Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2244">    <span class="tok-kw">try</span> di.scanAllFunctions(allocator);</span>
<span class="line" id="L2245">    <span class="tok-kw">try</span> di.scanAllCompileUnits(allocator);</span>
<span class="line" id="L2246">}</span>
<span class="line" id="L2247"></span>
<span class="line" id="L2248"><span class="tok-comment">/// This function is to make it handy to comment out the return and make it</span></span>
<span class="line" id="L2249"><span class="tok-comment">/// into a crash when working on this file.</span></span>
<span class="line" id="L2250"><span class="tok-kw">fn</span> <span class="tok-fn">badDwarf</span>() <span class="tok-kw">error</span>{InvalidDebugInfo} {</span>
<span class="line" id="L2251">    <span class="tok-comment">//std.os.abort(); // can be handy to uncomment when working on this file</span>
</span>
<span class="line" id="L2252">    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo;</span>
<span class="line" id="L2253">}</span>
<span class="line" id="L2254"></span>
<span class="line" id="L2255"><span class="tok-kw">fn</span> <span class="tok-fn">missingDwarf</span>() <span class="tok-kw">error</span>{MissingDebugInfo} {</span>
<span class="line" id="L2256">    <span class="tok-comment">//std.os.abort(); // can be handy to uncomment when working on this file</span>
</span>
<span class="line" id="L2257">    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L2258">}</span>
<span class="line" id="L2259"></span>
<span class="line" id="L2260"><span class="tok-kw">fn</span> <span class="tok-fn">getStringGeneric</span>(opt_str: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, offset: <span class="tok-type">u64</span>) ![:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L2261">    <span class="tok-kw">const</span> str = opt_str <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2262">    <span class="tok-kw">if</span> (offset &gt; str.len) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2263">    <span class="tok-kw">const</span> casted_offset = math.cast(<span class="tok-type">usize</span>, offset) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2264">    <span class="tok-comment">// Valid strings always have a terminating zero byte</span>
</span>
<span class="line" id="L2265">    <span class="tok-kw">const</span> last = mem.indexOfScalarPos(<span class="tok-type">u8</span>, str, casted_offset, <span class="tok-number">0</span>) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2266">    <span class="tok-kw">return</span> str[casted_offset..last :<span class="tok-number">0</span>];</span>
<span class="line" id="L2267">}</span>
<span class="line" id="L2268"></span>
<span class="line" id="L2269"><span class="tok-kw">const</span> EhPointerContext = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2270">    <span class="tok-comment">// The address of the pointer field itself</span>
</span>
<span class="line" id="L2271">    pc_rel_base: <span class="tok-type">u64</span>,</span>
<span class="line" id="L2272"></span>
<span class="line" id="L2273">    <span class="tok-comment">// Whether or not to follow indirect pointers. This should only be</span>
</span>
<span class="line" id="L2274">    <span class="tok-comment">// used when decoding pointers at runtime using the current process's</span>
</span>
<span class="line" id="L2275">    <span class="tok-comment">// debug info</span>
</span>
<span class="line" id="L2276">    follow_indirect: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2277"></span>
<span class="line" id="L2278">    <span class="tok-comment">// These relative addressing modes are only used in specific cases, and</span>
</span>
<span class="line" id="L2279">    <span class="tok-comment">// might not be available / required in all parsing contexts</span>
</span>
<span class="line" id="L2280">    data_rel_base: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L2281">    text_rel_base: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L2282">    function_rel_base: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L2283">};</span>
<span class="line" id="L2284"></span>
<span class="line" id="L2285"><span class="tok-kw">fn</span> <span class="tok-fn">readEhPointer</span>(reader: <span class="tok-kw">anytype</span>, enc: <span class="tok-type">u8</span>, addr_size_bytes: <span class="tok-type">u8</span>, ctx: EhPointerContext, endian: std.builtin.Endian) !?<span class="tok-type">u64</span> {</span>
<span class="line" id="L2286">    <span class="tok-kw">if</span> (enc == EH.PE.omit) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2287"></span>
<span class="line" id="L2288">    <span class="tok-kw">const</span> value: <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L2289">        signed: <span class="tok-type">i64</span>,</span>
<span class="line" id="L2290">        unsigned: <span class="tok-type">u64</span>,</span>
<span class="line" id="L2291">    } = <span class="tok-kw">switch</span> (enc &amp; EH.PE.type_mask) {</span>
<span class="line" id="L2292">        EH.PE.absptr =&gt; .{</span>
<span class="line" id="L2293">            .unsigned = <span class="tok-kw">switch</span> (addr_size_bytes) {</span>
<span class="line" id="L2294">                <span class="tok-number">2</span> =&gt; <span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u16</span>, endian),</span>
<span class="line" id="L2295">                <span class="tok-number">4</span> =&gt; <span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u32</span>, endian),</span>
<span class="line" id="L2296">                <span class="tok-number">8</span> =&gt; <span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u64</span>, endian),</span>
<span class="line" id="L2297">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidAddrSize,</span>
<span class="line" id="L2298">            },</span>
<span class="line" id="L2299">        },</span>
<span class="line" id="L2300">        EH.PE.uleb128 =&gt; .{ .unsigned = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">u64</span>, reader) },</span>
<span class="line" id="L2301">        EH.PE.udata2 =&gt; .{ .unsigned = <span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u16</span>, endian) },</span>
<span class="line" id="L2302">        EH.PE.udata4 =&gt; .{ .unsigned = <span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u32</span>, endian) },</span>
<span class="line" id="L2303">        EH.PE.udata8 =&gt; .{ .unsigned = <span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u64</span>, endian) },</span>
<span class="line" id="L2304">        EH.PE.sleb128 =&gt; .{ .signed = <span class="tok-kw">try</span> leb.readILEB128(<span class="tok-type">i64</span>, reader) },</span>
<span class="line" id="L2305">        EH.PE.sdata2 =&gt; .{ .signed = <span class="tok-kw">try</span> reader.readInt(<span class="tok-type">i16</span>, endian) },</span>
<span class="line" id="L2306">        EH.PE.sdata4 =&gt; .{ .signed = <span class="tok-kw">try</span> reader.readInt(<span class="tok-type">i32</span>, endian) },</span>
<span class="line" id="L2307">        EH.PE.sdata8 =&gt; .{ .signed = <span class="tok-kw">try</span> reader.readInt(<span class="tok-type">i64</span>, endian) },</span>
<span class="line" id="L2308">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> badDwarf(),</span>
<span class="line" id="L2309">    };</span>
<span class="line" id="L2310"></span>
<span class="line" id="L2311">    <span class="tok-kw">var</span> base = <span class="tok-kw">switch</span> (enc &amp; EH.PE.rel_mask) {</span>
<span class="line" id="L2312">        EH.PE.pcrel =&gt; ctx.pc_rel_base,</span>
<span class="line" id="L2313">        EH.PE.textrel =&gt; ctx.text_rel_base <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PointerBaseNotSpecified,</span>
<span class="line" id="L2314">        EH.PE.datarel =&gt; ctx.data_rel_base <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PointerBaseNotSpecified,</span>
<span class="line" id="L2315">        EH.PE.funcrel =&gt; ctx.function_rel_base <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PointerBaseNotSpecified,</span>
<span class="line" id="L2316">        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,</span>
<span class="line" id="L2317">    };</span>
<span class="line" id="L2318"></span>
<span class="line" id="L2319">    <span class="tok-kw">const</span> ptr: <span class="tok-type">u64</span> = <span class="tok-kw">if</span> (base) |b| <span class="tok-kw">switch</span> (value) {</span>
<span class="line" id="L2320">        .signed =&gt; |s| <span class="tok-builtin">@intCast</span>(<span class="tok-kw">try</span> math.add(<span class="tok-type">i64</span>, s, <span class="tok-builtin">@as</span>(<span class="tok-type">i64</span>, <span class="tok-builtin">@intCast</span>(b)))),</span>
<span class="line" id="L2321">        <span class="tok-comment">// absptr can actually contain signed values in some cases (aarch64 MachO)</span>
</span>
<span class="line" id="L2322">        .unsigned =&gt; |u| u +% b,</span>
<span class="line" id="L2323">    } <span class="tok-kw">else</span> <span class="tok-kw">switch</span> (value) {</span>
<span class="line" id="L2324">        .signed =&gt; |s| <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@intCast</span>(s)),</span>
<span class="line" id="L2325">        .unsigned =&gt; |u| u,</span>
<span class="line" id="L2326">    };</span>
<span class="line" id="L2327"></span>
<span class="line" id="L2328">    <span class="tok-kw">if</span> ((enc &amp; EH.PE.indirect) &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> ctx.follow_indirect) {</span>
<span class="line" id="L2329">        <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) != addr_size_bytes) {</span>
<span class="line" id="L2330">            <span class="tok-comment">// See the documentation for `follow_indirect`</span>
</span>
<span class="line" id="L2331">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NonNativeIndirection;</span>
<span class="line" id="L2332">        }</span>
<span class="line" id="L2333"></span>
<span class="line" id="L2334">        <span class="tok-kw">const</span> native_ptr = math.cast(<span class="tok-type">usize</span>, ptr) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PointerOverflow;</span>
<span class="line" id="L2335">        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (addr_size_bytes) {</span>
<span class="line" id="L2336">            <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span> =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(native_ptr)).*,</span>
<span class="line" id="L2337">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedAddrSize,</span>
<span class="line" id="L2338">        };</span>
<span class="line" id="L2339">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2340">        <span class="tok-kw">return</span> ptr;</span>
<span class="line" id="L2341">    }</span>
<span class="line" id="L2342">}</span>
<span class="line" id="L2343"></span>
<span class="line" id="L2344"><span class="tok-comment">/// This represents the decoded .eh_frame_hdr header</span></span>
<span class="line" id="L2345"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ExceptionFrameHeader = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2346">    eh_frame_ptr: <span class="tok-type">usize</span>,</span>
<span class="line" id="L2347">    table_enc: <span class="tok-type">u8</span>,</span>
<span class="line" id="L2348">    fde_count: <span class="tok-type">usize</span>,</span>
<span class="line" id="L2349">    entries: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2350"></span>
<span class="line" id="L2351">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">entrySize</span>(table_enc: <span class="tok-type">u8</span>) !<span class="tok-type">u8</span> {</span>
<span class="line" id="L2352">        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (table_enc &amp; EH.PE.type_mask) {</span>
<span class="line" id="L2353">            EH.PE.udata2,</span>
<span class="line" id="L2354">            EH.PE.sdata2,</span>
<span class="line" id="L2355">            =&gt; <span class="tok-number">4</span>,</span>
<span class="line" id="L2356">            EH.PE.udata4,</span>
<span class="line" id="L2357">            EH.PE.sdata4,</span>
<span class="line" id="L2358">            =&gt; <span class="tok-number">8</span>,</span>
<span class="line" id="L2359">            EH.PE.udata8,</span>
<span class="line" id="L2360">            EH.PE.sdata8,</span>
<span class="line" id="L2361">            =&gt; <span class="tok-number">16</span>,</span>
<span class="line" id="L2362">            <span class="tok-comment">// This is a binary search table, so all entries must be the same length</span>
</span>
<span class="line" id="L2363">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> badDwarf(),</span>
<span class="line" id="L2364">        };</span>
<span class="line" id="L2365">    }</span>
<span class="line" id="L2366"></span>
<span class="line" id="L2367">    <span class="tok-kw">fn</span> <span class="tok-fn">isValidPtr</span>(</span>
<span class="line" id="L2368">        self: ExceptionFrameHeader,</span>
<span class="line" id="L2369">        ptr: <span class="tok-type">usize</span>,</span>
<span class="line" id="L2370">        isValidMemory: *<span class="tok-kw">const</span> <span class="tok-kw">fn</span> (address: <span class="tok-type">usize</span>) <span class="tok-type">bool</span>,</span>
<span class="line" id="L2371">        eh_frame_len: ?<span class="tok-type">usize</span>,</span>
<span class="line" id="L2372">    ) <span class="tok-type">bool</span> {</span>
<span class="line" id="L2373">        <span class="tok-kw">if</span> (eh_frame_len) |len| {</span>
<span class="line" id="L2374">            <span class="tok-kw">return</span> ptr &gt;= self.eh_frame_ptr <span class="tok-kw">and</span> ptr &lt; self.eh_frame_ptr + len;</span>
<span class="line" id="L2375">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2376">            <span class="tok-kw">return</span> isValidMemory(ptr);</span>
<span class="line" id="L2377">        }</span>
<span class="line" id="L2378">    }</span>
<span class="line" id="L2379"></span>
<span class="line" id="L2380">    <span class="tok-comment">/// Find an entry by binary searching the eh_frame_hdr section.</span></span>
<span class="line" id="L2381">    <span class="tok-comment">///</span></span>
<span class="line" id="L2382">    <span class="tok-comment">/// Since the length of the eh_frame section (`eh_frame_len`) may not be known by the caller,</span></span>
<span class="line" id="L2383">    <span class="tok-comment">/// `isValidMemory` will be called before accessing any memory referenced by</span></span>
<span class="line" id="L2384">    <span class="tok-comment">/// the header entries. If `eh_frame_len` is provided, then these checks can be skipped.</span></span>
<span class="line" id="L2385">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">findEntry</span>(</span>
<span class="line" id="L2386">        self: ExceptionFrameHeader,</span>
<span class="line" id="L2387">        isValidMemory: *<span class="tok-kw">const</span> <span class="tok-kw">fn</span> (address: <span class="tok-type">usize</span>) <span class="tok-type">bool</span>,</span>
<span class="line" id="L2388">        eh_frame_len: ?<span class="tok-type">usize</span>,</span>
<span class="line" id="L2389">        eh_frame_hdr_ptr: <span class="tok-type">usize</span>,</span>
<span class="line" id="L2390">        pc: <span class="tok-type">usize</span>,</span>
<span class="line" id="L2391">        cie: *CommonInformationEntry,</span>
<span class="line" id="L2392">        fde: *FrameDescriptionEntry,</span>
<span class="line" id="L2393">    ) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2394">        <span class="tok-kw">const</span> entry_size = <span class="tok-kw">try</span> entrySize(self.table_enc);</span>
<span class="line" id="L2395"></span>
<span class="line" id="L2396">        <span class="tok-kw">var</span> left: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2397">        <span class="tok-kw">var</span> len: <span class="tok-type">usize</span> = self.fde_count;</span>
<span class="line" id="L2398"></span>
<span class="line" id="L2399">        <span class="tok-kw">var</span> stream = io.fixedBufferStream(self.entries);</span>
<span class="line" id="L2400">        <span class="tok-kw">const</span> reader = stream.reader();</span>
<span class="line" id="L2401"></span>
<span class="line" id="L2402">        <span class="tok-kw">while</span> (len &gt; <span class="tok-number">1</span>) {</span>
<span class="line" id="L2403">            <span class="tok-kw">const</span> mid = left + len / <span class="tok-number">2</span>;</span>
<span class="line" id="L2404"></span>
<span class="line" id="L2405">            <span class="tok-kw">try</span> stream.seekTo(mid * entry_size);</span>
<span class="line" id="L2406">            <span class="tok-kw">const</span> pc_begin = <span class="tok-kw">try</span> readEhPointer(reader, self.table_enc, <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>), .{</span>
<span class="line" id="L2407">                .pc_rel_base = <span class="tok-builtin">@intFromPtr</span>(&amp;self.entries[stream.pos]),</span>
<span class="line" id="L2408">                .follow_indirect = <span class="tok-null">true</span>,</span>
<span class="line" id="L2409">                .data_rel_base = eh_frame_hdr_ptr,</span>
<span class="line" id="L2410">            }, builtin.cpu.arch.endian()) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2411"></span>
<span class="line" id="L2412">            <span class="tok-kw">if</span> (pc &lt; pc_begin) {</span>
<span class="line" id="L2413">                len /= <span class="tok-number">2</span>;</span>
<span class="line" id="L2414">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2415">                left = mid;</span>
<span class="line" id="L2416">                <span class="tok-kw">if</span> (pc == pc_begin) <span class="tok-kw">break</span>;</span>
<span class="line" id="L2417">                len -= len / <span class="tok-number">2</span>;</span>
<span class="line" id="L2418">            }</span>
<span class="line" id="L2419">        }</span>
<span class="line" id="L2420"></span>
<span class="line" id="L2421">        <span class="tok-kw">if</span> (len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2422">        <span class="tok-kw">try</span> stream.seekTo(left * entry_size);</span>
<span class="line" id="L2423"></span>
<span class="line" id="L2424">        <span class="tok-comment">// Read past the pc_begin field of the entry</span>
</span>
<span class="line" id="L2425">        _ = <span class="tok-kw">try</span> readEhPointer(reader, self.table_enc, <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>), .{</span>
<span class="line" id="L2426">            .pc_rel_base = <span class="tok-builtin">@intFromPtr</span>(&amp;self.entries[stream.pos]),</span>
<span class="line" id="L2427">            .follow_indirect = <span class="tok-null">true</span>,</span>
<span class="line" id="L2428">            .data_rel_base = eh_frame_hdr_ptr,</span>
<span class="line" id="L2429">        }, builtin.cpu.arch.endian()) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2430"></span>
<span class="line" id="L2431">        <span class="tok-kw">const</span> fde_ptr = math.cast(<span class="tok-type">usize</span>, <span class="tok-kw">try</span> readEhPointer(reader, self.table_enc, <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>), .{</span>
<span class="line" id="L2432">            .pc_rel_base = <span class="tok-builtin">@intFromPtr</span>(&amp;self.entries[stream.pos]),</span>
<span class="line" id="L2433">            .follow_indirect = <span class="tok-null">true</span>,</span>
<span class="line" id="L2434">            .data_rel_base = eh_frame_hdr_ptr,</span>
<span class="line" id="L2435">        }, builtin.cpu.arch.endian()) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf()) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2436"></span>
<span class="line" id="L2437">        <span class="tok-comment">// Verify the length fields of the FDE header are readable</span>
</span>
<span class="line" id="L2438">        <span class="tok-kw">if</span> (!self.isValidPtr(fde_ptr, isValidMemory, eh_frame_len) <span class="tok-kw">or</span> fde_ptr &lt; self.eh_frame_ptr) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2439"></span>
<span class="line" id="L2440">        <span class="tok-kw">var</span> fde_entry_header_len: <span class="tok-type">usize</span> = <span class="tok-number">4</span>;</span>
<span class="line" id="L2441">        <span class="tok-kw">if</span> (!self.isValidPtr(fde_ptr + <span class="tok-number">3</span>, isValidMemory, eh_frame_len)) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2442">        <span class="tok-kw">if</span> (self.isValidPtr(fde_ptr + <span class="tok-number">11</span>, isValidMemory, eh_frame_len)) fde_entry_header_len = <span class="tok-number">12</span>;</span>
<span class="line" id="L2443"></span>
<span class="line" id="L2444">        <span class="tok-comment">// Even if eh_frame_len is not specified, all ranges accssed are checked by isValidPtr</span>
</span>
<span class="line" id="L2445">        <span class="tok-kw">const</span> eh_frame = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(self.eh_frame_ptr))[<span class="tok-number">0</span> .. eh_frame_len <span class="tok-kw">orelse</span> math.maxInt(<span class="tok-type">u32</span>)];</span>
<span class="line" id="L2446"></span>
<span class="line" id="L2447">        <span class="tok-kw">const</span> fde_offset = fde_ptr - self.eh_frame_ptr;</span>
<span class="line" id="L2448">        <span class="tok-kw">var</span> eh_frame_stream = io.fixedBufferStream(eh_frame);</span>
<span class="line" id="L2449">        <span class="tok-kw">try</span> eh_frame_stream.seekTo(fde_offset);</span>
<span class="line" id="L2450"></span>
<span class="line" id="L2451">        <span class="tok-kw">const</span> fde_entry_header = <span class="tok-kw">try</span> EntryHeader.read(&amp;eh_frame_stream, .eh_frame, builtin.cpu.arch.endian());</span>
<span class="line" id="L2452">        <span class="tok-kw">if</span> (!self.isValidPtr(<span class="tok-builtin">@intFromPtr</span>(&amp;fde_entry_header.entry_bytes[fde_entry_header.entry_bytes.len - <span class="tok-number">1</span>]), isValidMemory, eh_frame_len)) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2453">        <span class="tok-kw">if</span> (fde_entry_header.<span class="tok-type">type</span> != .fde) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2454"></span>
<span class="line" id="L2455">        <span class="tok-comment">// CIEs always come before FDEs (the offset is a subtraction), so we can assume this memory is readable</span>
</span>
<span class="line" id="L2456">        <span class="tok-kw">const</span> cie_offset = fde_entry_header.<span class="tok-type">type</span>.fde;</span>
<span class="line" id="L2457">        <span class="tok-kw">try</span> eh_frame_stream.seekTo(cie_offset);</span>
<span class="line" id="L2458">        <span class="tok-kw">const</span> cie_entry_header = <span class="tok-kw">try</span> EntryHeader.read(&amp;eh_frame_stream, .eh_frame, builtin.cpu.arch.endian());</span>
<span class="line" id="L2459">        <span class="tok-kw">if</span> (!self.isValidPtr(<span class="tok-builtin">@intFromPtr</span>(&amp;cie_entry_header.entry_bytes[cie_entry_header.entry_bytes.len - <span class="tok-number">1</span>]), isValidMemory, eh_frame_len)) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2460">        <span class="tok-kw">if</span> (cie_entry_header.<span class="tok-type">type</span> != .cie) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2461"></span>
<span class="line" id="L2462">        cie.* = <span class="tok-kw">try</span> CommonInformationEntry.parse(</span>
<span class="line" id="L2463">            cie_entry_header.entry_bytes,</span>
<span class="line" id="L2464">            <span class="tok-number">0</span>,</span>
<span class="line" id="L2465">            <span class="tok-null">true</span>,</span>
<span class="line" id="L2466">            cie_entry_header.is_64,</span>
<span class="line" id="L2467">            .eh_frame,</span>
<span class="line" id="L2468">            cie_entry_header.length_offset,</span>
<span class="line" id="L2469">            <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>),</span>
<span class="line" id="L2470">            builtin.cpu.arch.endian(),</span>
<span class="line" id="L2471">        );</span>
<span class="line" id="L2472"></span>
<span class="line" id="L2473">        fde.* = <span class="tok-kw">try</span> FrameDescriptionEntry.parse(</span>
<span class="line" id="L2474">            fde_entry_header.entry_bytes,</span>
<span class="line" id="L2475">            <span class="tok-number">0</span>,</span>
<span class="line" id="L2476">            <span class="tok-null">true</span>,</span>
<span class="line" id="L2477">            cie.*,</span>
<span class="line" id="L2478">            <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>),</span>
<span class="line" id="L2479">            builtin.cpu.arch.endian(),</span>
<span class="line" id="L2480">        );</span>
<span class="line" id="L2481">    }</span>
<span class="line" id="L2482">};</span>
<span class="line" id="L2483"></span>
<span class="line" id="L2484"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> EntryHeader = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2485">    <span class="tok-comment">/// Offset of the length field in the backing buffer</span></span>
<span class="line" id="L2486">    length_offset: <span class="tok-type">usize</span>,</span>
<span class="line" id="L2487">    is_64: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2488">    <span class="tok-type">type</span>: <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L2489">        cie,</span>
<span class="line" id="L2490">        <span class="tok-comment">/// Value is the offset of the corresponding CIE</span></span>
<span class="line" id="L2491">        fde: <span class="tok-type">u64</span>,</span>
<span class="line" id="L2492">        terminator: <span class="tok-type">void</span>,</span>
<span class="line" id="L2493">    },</span>
<span class="line" id="L2494">    <span class="tok-comment">/// The entry's contents, not including the ID field</span></span>
<span class="line" id="L2495">    entry_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2496"></span>
<span class="line" id="L2497">    <span class="tok-comment">/// Reads a header for either an FDE or a CIE, then advances the stream to the position after the trailing structure.</span></span>
<span class="line" id="L2498">    <span class="tok-comment">/// `stream` must be a stream backed by either the .eh_frame or .debug_frame sections.</span></span>
<span class="line" id="L2499">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">read</span>(stream: *std.io.FixedBufferStream([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>), dwarf_section: DwarfSection, endian: std.builtin.Endian) !EntryHeader {</span>
<span class="line" id="L2500">        assert(dwarf_section == .eh_frame <span class="tok-kw">or</span> dwarf_section == .debug_frame);</span>
<span class="line" id="L2501"></span>
<span class="line" id="L2502">        <span class="tok-kw">const</span> reader = stream.reader();</span>
<span class="line" id="L2503">        <span class="tok-kw">const</span> length_offset = stream.pos;</span>
<span class="line" id="L2504"></span>
<span class="line" id="L2505">        <span class="tok-kw">var</span> is_64: <span class="tok-type">bool</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L2506">        <span class="tok-kw">const</span> length = math.cast(<span class="tok-type">usize</span>, <span class="tok-kw">try</span> readUnitLength(reader, endian, &amp;is_64)) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2507">        <span class="tok-kw">if</span> (length == <span class="tok-number">0</span>) <span class="tok-kw">return</span> .{</span>
<span class="line" id="L2508">            .length_offset = length_offset,</span>
<span class="line" id="L2509">            .is_64 = is_64,</span>
<span class="line" id="L2510">            .<span class="tok-type">type</span> = .{ .terminator = {} },</span>
<span class="line" id="L2511">            .entry_bytes = &amp;.{},</span>
<span class="line" id="L2512">        };</span>
<span class="line" id="L2513"></span>
<span class="line" id="L2514">        <span class="tok-kw">const</span> id_len = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-kw">if</span> (is_64) <span class="tok-number">8</span> <span class="tok-kw">else</span> <span class="tok-number">4</span>);</span>
<span class="line" id="L2515">        <span class="tok-kw">const</span> id = <span class="tok-kw">if</span> (is_64) <span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u64</span>, endian) <span class="tok-kw">else</span> <span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u32</span>, endian);</span>
<span class="line" id="L2516">        <span class="tok-kw">const</span> entry_bytes = stream.buffer[stream.pos..][<span class="tok-number">0</span> .. length - id_len];</span>
<span class="line" id="L2517">        <span class="tok-kw">const</span> cie_id: <span class="tok-type">u64</span> = <span class="tok-kw">switch</span> (dwarf_section) {</span>
<span class="line" id="L2518">            .eh_frame =&gt; CommonInformationEntry.eh_id,</span>
<span class="line" id="L2519">            .debug_frame =&gt; <span class="tok-kw">if</span> (is_64) CommonInformationEntry.dwarf64_id <span class="tok-kw">else</span> CommonInformationEntry.dwarf32_id,</span>
<span class="line" id="L2520">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L2521">        };</span>
<span class="line" id="L2522"></span>
<span class="line" id="L2523">        <span class="tok-kw">const</span> result = EntryHeader{</span>
<span class="line" id="L2524">            .length_offset = length_offset,</span>
<span class="line" id="L2525">            .is_64 = is_64,</span>
<span class="line" id="L2526">            .<span class="tok-type">type</span> = <span class="tok-kw">if</span> (id == cie_id) .{ .cie = {} } <span class="tok-kw">else</span> .{</span>
<span class="line" id="L2527">                .fde = <span class="tok-kw">switch</span> (dwarf_section) {</span>
<span class="line" id="L2528">                    .eh_frame =&gt; <span class="tok-kw">try</span> std.math.sub(<span class="tok-type">u64</span>, stream.pos - id_len, id),</span>
<span class="line" id="L2529">                    .debug_frame =&gt; id,</span>
<span class="line" id="L2530">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L2531">                },</span>
<span class="line" id="L2532">            },</span>
<span class="line" id="L2533">            .entry_bytes = entry_bytes,</span>
<span class="line" id="L2534">        };</span>
<span class="line" id="L2535"></span>
<span class="line" id="L2536">        stream.pos += entry_bytes.len;</span>
<span class="line" id="L2537">        <span class="tok-kw">return</span> result;</span>
<span class="line" id="L2538">    }</span>
<span class="line" id="L2539"></span>
<span class="line" id="L2540">    <span class="tok-comment">/// The length of the entry including the ID field, but not the length field itself</span></span>
<span class="line" id="L2541">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">entryLength</span>(self: EntryHeader) <span class="tok-type">usize</span> {</span>
<span class="line" id="L2542">        <span class="tok-kw">return</span> self.entry_bytes.len + <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-kw">if</span> (self.is_64) <span class="tok-number">8</span> <span class="tok-kw">else</span> <span class="tok-number">4</span>);</span>
<span class="line" id="L2543">    }</span>
<span class="line" id="L2544">};</span>
<span class="line" id="L2545"></span>
<span class="line" id="L2546"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CommonInformationEntry = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2547">    <span class="tok-comment">// Used in .eh_frame</span>
</span>
<span class="line" id="L2548">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> eh_id = <span class="tok-number">0</span>;</span>
<span class="line" id="L2549"></span>
<span class="line" id="L2550">    <span class="tok-comment">// Used in .debug_frame (DWARF32)</span>
</span>
<span class="line" id="L2551">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> dwarf32_id = math.maxInt(<span class="tok-type">u32</span>);</span>
<span class="line" id="L2552"></span>
<span class="line" id="L2553">    <span class="tok-comment">// Used in .debug_frame (DWARF64)</span>
</span>
<span class="line" id="L2554">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> dwarf64_id = math.maxInt(<span class="tok-type">u64</span>);</span>
<span class="line" id="L2555"></span>
<span class="line" id="L2556">    <span class="tok-comment">// Offset of the length field of this entry in the eh_frame section.</span>
</span>
<span class="line" id="L2557">    <span class="tok-comment">// This is the key that FDEs use to reference CIEs.</span>
</span>
<span class="line" id="L2558">    length_offset: <span class="tok-type">u64</span>,</span>
<span class="line" id="L2559">    version: <span class="tok-type">u8</span>,</span>
<span class="line" id="L2560">    address_size: <span class="tok-type">u8</span>,</span>
<span class="line" id="L2561">    is_64: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2562"></span>
<span class="line" id="L2563">    <span class="tok-comment">// Only present in version 4</span>
</span>
<span class="line" id="L2564">    segment_selector_size: ?<span class="tok-type">u8</span>,</span>
<span class="line" id="L2565"></span>
<span class="line" id="L2566">    code_alignment_factor: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2567">    data_alignment_factor: <span class="tok-type">i32</span>,</span>
<span class="line" id="L2568">    return_address_register: <span class="tok-type">u8</span>,</span>
<span class="line" id="L2569"></span>
<span class="line" id="L2570">    aug_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2571">    aug_data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2572">    lsda_pointer_enc: <span class="tok-type">u8</span>,</span>
<span class="line" id="L2573">    personality_enc: ?<span class="tok-type">u8</span>,</span>
<span class="line" id="L2574">    personality_routine_pointer: ?<span class="tok-type">u64</span>,</span>
<span class="line" id="L2575">    fde_pointer_enc: <span class="tok-type">u8</span>,</span>
<span class="line" id="L2576">    initial_instructions: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2577"></span>
<span class="line" id="L2578">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isSignalFrame</span>(self: CommonInformationEntry) <span class="tok-type">bool</span> {</span>
<span class="line" id="L2579">        <span class="tok-kw">for</span> (self.aug_str) |c| <span class="tok-kw">if</span> (c == <span class="tok-str">'S'</span>) <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L2580">        <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L2581">    }</span>
<span class="line" id="L2582"></span>
<span class="line" id="L2583">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addressesSignedWithBKey</span>(self: CommonInformationEntry) <span class="tok-type">bool</span> {</span>
<span class="line" id="L2584">        <span class="tok-kw">for</span> (self.aug_str) |c| <span class="tok-kw">if</span> (c == <span class="tok-str">'B'</span>) <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L2585">        <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L2586">    }</span>
<span class="line" id="L2587"></span>
<span class="line" id="L2588">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mteTaggedFrame</span>(self: CommonInformationEntry) <span class="tok-type">bool</span> {</span>
<span class="line" id="L2589">        <span class="tok-kw">for</span> (self.aug_str) |c| <span class="tok-kw">if</span> (c == <span class="tok-str">'G'</span>) <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L2590">        <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L2591">    }</span>
<span class="line" id="L2592"></span>
<span class="line" id="L2593">    <span class="tok-comment">/// This function expects to read the CIE starting with the version field.</span></span>
<span class="line" id="L2594">    <span class="tok-comment">/// The returned struct references memory backed by cie_bytes.</span></span>
<span class="line" id="L2595">    <span class="tok-comment">///</span></span>
<span class="line" id="L2596">    <span class="tok-comment">/// See the FrameDescriptionEntry.parse documentation for the description</span></span>
<span class="line" id="L2597">    <span class="tok-comment">/// of `pc_rel_offset` and `is_runtime`.</span></span>
<span class="line" id="L2598">    <span class="tok-comment">///</span></span>
<span class="line" id="L2599">    <span class="tok-comment">/// `length_offset` specifies the offset of this CIE's length field in the</span></span>
<span class="line" id="L2600">    <span class="tok-comment">/// .eh_frame / .debug_frame section.</span></span>
<span class="line" id="L2601">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parse</span>(</span>
<span class="line" id="L2602">        cie_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2603">        pc_rel_offset: <span class="tok-type">i64</span>,</span>
<span class="line" id="L2604">        is_runtime: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2605">        is_64: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2606">        dwarf_section: DwarfSection,</span>
<span class="line" id="L2607">        length_offset: <span class="tok-type">u64</span>,</span>
<span class="line" id="L2608">        addr_size_bytes: <span class="tok-type">u8</span>,</span>
<span class="line" id="L2609">        endian: std.builtin.Endian,</span>
<span class="line" id="L2610">    ) !CommonInformationEntry {</span>
<span class="line" id="L2611">        <span class="tok-kw">if</span> (addr_size_bytes &gt; <span class="tok-number">8</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedAddrSize;</span>
<span class="line" id="L2612"></span>
<span class="line" id="L2613">        <span class="tok-kw">var</span> stream = io.fixedBufferStream(cie_bytes);</span>
<span class="line" id="L2614">        <span class="tok-kw">const</span> reader = stream.reader();</span>
<span class="line" id="L2615"></span>
<span class="line" id="L2616">        <span class="tok-kw">const</span> version = <span class="tok-kw">try</span> reader.readByte();</span>
<span class="line" id="L2617">        <span class="tok-kw">switch</span> (dwarf_section) {</span>
<span class="line" id="L2618">            .eh_frame =&gt; <span class="tok-kw">if</span> (version != <span class="tok-number">1</span> <span class="tok-kw">and</span> version != <span class="tok-number">3</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedDwarfVersion,</span>
<span class="line" id="L2619">            .debug_frame =&gt; <span class="tok-kw">if</span> (version != <span class="tok-number">4</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedDwarfVersion,</span>
<span class="line" id="L2620">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedDwarfSection,</span>
<span class="line" id="L2621">        }</span>
<span class="line" id="L2622"></span>
<span class="line" id="L2623">        <span class="tok-kw">var</span> has_eh_data = <span class="tok-null">false</span>;</span>
<span class="line" id="L2624">        <span class="tok-kw">var</span> has_aug_data = <span class="tok-null">false</span>;</span>
<span class="line" id="L2625"></span>
<span class="line" id="L2626">        <span class="tok-kw">var</span> aug_str_len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2627">        <span class="tok-kw">var</span> aug_str_start = stream.pos;</span>
<span class="line" id="L2628">        <span class="tok-kw">var</span> aug_byte = <span class="tok-kw">try</span> reader.readByte();</span>
<span class="line" id="L2629">        <span class="tok-kw">while</span> (aug_byte != <span class="tok-number">0</span>) : (aug_byte = <span class="tok-kw">try</span> reader.readByte()) {</span>
<span class="line" id="L2630">            <span class="tok-kw">switch</span> (aug_byte) {</span>
<span class="line" id="L2631">                <span class="tok-str">'z'</span> =&gt; {</span>
<span class="line" id="L2632">                    <span class="tok-kw">if</span> (aug_str_len != <span class="tok-number">0</span>) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2633">                    has_aug_data = <span class="tok-null">true</span>;</span>
<span class="line" id="L2634">                },</span>
<span class="line" id="L2635">                <span class="tok-str">'e'</span> =&gt; {</span>
<span class="line" id="L2636">                    <span class="tok-kw">if</span> (has_aug_data <span class="tok-kw">or</span> aug_str_len != <span class="tok-number">0</span>) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2637">                    <span class="tok-kw">if</span> (<span class="tok-kw">try</span> reader.readByte() != <span class="tok-str">'h'</span>) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2638">                    has_eh_data = <span class="tok-null">true</span>;</span>
<span class="line" id="L2639">                },</span>
<span class="line" id="L2640">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">if</span> (has_eh_data) <span class="tok-kw">return</span> badDwarf(),</span>
<span class="line" id="L2641">            }</span>
<span class="line" id="L2642"></span>
<span class="line" id="L2643">            aug_str_len += <span class="tok-number">1</span>;</span>
<span class="line" id="L2644">        }</span>
<span class="line" id="L2645"></span>
<span class="line" id="L2646">        <span class="tok-kw">if</span> (has_eh_data) {</span>
<span class="line" id="L2647">            <span class="tok-comment">// legacy data created by older versions of gcc - unsupported here</span>
</span>
<span class="line" id="L2648">            <span class="tok-kw">for</span> (<span class="tok-number">0</span>..addr_size_bytes) |_| _ = <span class="tok-kw">try</span> reader.readByte();</span>
<span class="line" id="L2649">        }</span>
<span class="line" id="L2650"></span>
<span class="line" id="L2651">        <span class="tok-kw">const</span> address_size = <span class="tok-kw">if</span> (version == <span class="tok-number">4</span>) <span class="tok-kw">try</span> reader.readByte() <span class="tok-kw">else</span> addr_size_bytes;</span>
<span class="line" id="L2652">        <span class="tok-kw">const</span> segment_selector_size = <span class="tok-kw">if</span> (version == <span class="tok-number">4</span>) <span class="tok-kw">try</span> reader.readByte() <span class="tok-kw">else</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2653"></span>
<span class="line" id="L2654">        <span class="tok-kw">const</span> code_alignment_factor = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">u32</span>, reader);</span>
<span class="line" id="L2655">        <span class="tok-kw">const</span> data_alignment_factor = <span class="tok-kw">try</span> leb.readILEB128(<span class="tok-type">i32</span>, reader);</span>
<span class="line" id="L2656">        <span class="tok-kw">const</span> return_address_register = <span class="tok-kw">if</span> (version == <span class="tok-number">1</span>) <span class="tok-kw">try</span> reader.readByte() <span class="tok-kw">else</span> <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">u8</span>, reader);</span>
<span class="line" id="L2657"></span>
<span class="line" id="L2658">        <span class="tok-kw">var</span> lsda_pointer_enc: <span class="tok-type">u8</span> = EH.PE.omit;</span>
<span class="line" id="L2659">        <span class="tok-kw">var</span> personality_enc: ?<span class="tok-type">u8</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L2660">        <span class="tok-kw">var</span> personality_routine_pointer: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L2661">        <span class="tok-kw">var</span> fde_pointer_enc: <span class="tok-type">u8</span> = EH.PE.absptr;</span>
<span class="line" id="L2662"></span>
<span class="line" id="L2663">        <span class="tok-kw">var</span> aug_data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;[_]<span class="tok-type">u8</span>{};</span>
<span class="line" id="L2664">        <span class="tok-kw">const</span> aug_str = <span class="tok-kw">if</span> (has_aug_data) blk: {</span>
<span class="line" id="L2665">            <span class="tok-kw">const</span> aug_data_len = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">usize</span>, reader);</span>
<span class="line" id="L2666">            <span class="tok-kw">const</span> aug_data_start = stream.pos;</span>
<span class="line" id="L2667">            aug_data = cie_bytes[aug_data_start..][<span class="tok-number">0</span>..aug_data_len];</span>
<span class="line" id="L2668"></span>
<span class="line" id="L2669">            <span class="tok-kw">const</span> aug_str = cie_bytes[aug_str_start..][<span class="tok-number">0</span>..aug_str_len];</span>
<span class="line" id="L2670">            <span class="tok-kw">for</span> (aug_str[<span class="tok-number">1</span>..]) |byte| {</span>
<span class="line" id="L2671">                <span class="tok-kw">switch</span> (byte) {</span>
<span class="line" id="L2672">                    <span class="tok-str">'L'</span> =&gt; {</span>
<span class="line" id="L2673">                        lsda_pointer_enc = <span class="tok-kw">try</span> reader.readByte();</span>
<span class="line" id="L2674">                    },</span>
<span class="line" id="L2675">                    <span class="tok-str">'P'</span> =&gt; {</span>
<span class="line" id="L2676">                        personality_enc = <span class="tok-kw">try</span> reader.readByte();</span>
<span class="line" id="L2677">                        personality_routine_pointer = <span class="tok-kw">try</span> readEhPointer(</span>
<span class="line" id="L2678">                            reader,</span>
<span class="line" id="L2679">                            personality_enc.?,</span>
<span class="line" id="L2680">                            addr_size_bytes,</span>
<span class="line" id="L2681">                            .{</span>
<span class="line" id="L2682">                                .pc_rel_base = <span class="tok-kw">try</span> pcRelBase(<span class="tok-builtin">@intFromPtr</span>(&amp;cie_bytes[stream.pos]), pc_rel_offset),</span>
<span class="line" id="L2683">                                .follow_indirect = is_runtime,</span>
<span class="line" id="L2684">                            },</span>
<span class="line" id="L2685">                            endian,</span>
<span class="line" id="L2686">                        );</span>
<span class="line" id="L2687">                    },</span>
<span class="line" id="L2688">                    <span class="tok-str">'R'</span> =&gt; {</span>
<span class="line" id="L2689">                        fde_pointer_enc = <span class="tok-kw">try</span> reader.readByte();</span>
<span class="line" id="L2690">                    },</span>
<span class="line" id="L2691">                    <span class="tok-str">'S'</span>, <span class="tok-str">'B'</span>, <span class="tok-str">'G'</span> =&gt; {},</span>
<span class="line" id="L2692">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> badDwarf(),</span>
<span class="line" id="L2693">                }</span>
<span class="line" id="L2694">            }</span>
<span class="line" id="L2695"></span>
<span class="line" id="L2696">            <span class="tok-comment">// aug_data_len can include padding so the CIE ends on an address boundary</span>
</span>
<span class="line" id="L2697">            <span class="tok-kw">try</span> stream.seekTo(aug_data_start + aug_data_len);</span>
<span class="line" id="L2698">            <span class="tok-kw">break</span> :blk aug_str;</span>
<span class="line" id="L2699">        } <span class="tok-kw">else</span> &amp;[_]<span class="tok-type">u8</span>{};</span>
<span class="line" id="L2700"></span>
<span class="line" id="L2701">        <span class="tok-kw">const</span> initial_instructions = cie_bytes[stream.pos..];</span>
<span class="line" id="L2702">        <span class="tok-kw">return</span> .{</span>
<span class="line" id="L2703">            .length_offset = length_offset,</span>
<span class="line" id="L2704">            .version = version,</span>
<span class="line" id="L2705">            .address_size = address_size,</span>
<span class="line" id="L2706">            .is_64 = is_64,</span>
<span class="line" id="L2707">            .segment_selector_size = segment_selector_size,</span>
<span class="line" id="L2708">            .code_alignment_factor = code_alignment_factor,</span>
<span class="line" id="L2709">            .data_alignment_factor = data_alignment_factor,</span>
<span class="line" id="L2710">            .return_address_register = return_address_register,</span>
<span class="line" id="L2711">            .aug_str = aug_str,</span>
<span class="line" id="L2712">            .aug_data = aug_data,</span>
<span class="line" id="L2713">            .lsda_pointer_enc = lsda_pointer_enc,</span>
<span class="line" id="L2714">            .personality_enc = personality_enc,</span>
<span class="line" id="L2715">            .personality_routine_pointer = personality_routine_pointer,</span>
<span class="line" id="L2716">            .fde_pointer_enc = fde_pointer_enc,</span>
<span class="line" id="L2717">            .initial_instructions = initial_instructions,</span>
<span class="line" id="L2718">        };</span>
<span class="line" id="L2719">    }</span>
<span class="line" id="L2720">};</span>
<span class="line" id="L2721"></span>
<span class="line" id="L2722"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FrameDescriptionEntry = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2723">    <span class="tok-comment">// Offset into eh_frame where the CIE for this FDE is stored</span>
</span>
<span class="line" id="L2724">    cie_length_offset: <span class="tok-type">u64</span>,</span>
<span class="line" id="L2725"></span>
<span class="line" id="L2726">    pc_begin: <span class="tok-type">u64</span>,</span>
<span class="line" id="L2727">    pc_range: <span class="tok-type">u64</span>,</span>
<span class="line" id="L2728">    lsda_pointer: ?<span class="tok-type">u64</span>,</span>
<span class="line" id="L2729">    aug_data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2730">    instructions: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2731"></span>
<span class="line" id="L2732">    <span class="tok-comment">/// This function expects to read the FDE starting at the PC Begin field.</span></span>
<span class="line" id="L2733">    <span class="tok-comment">/// The returned struct references memory backed by `fde_bytes`.</span></span>
<span class="line" id="L2734">    <span class="tok-comment">///</span></span>
<span class="line" id="L2735">    <span class="tok-comment">/// `pc_rel_offset` specifies an offset to be applied to pc_rel_base values</span></span>
<span class="line" id="L2736">    <span class="tok-comment">/// used when decoding pointers. This should be set to zero if fde_bytes is</span></span>
<span class="line" id="L2737">    <span class="tok-comment">/// backed by the memory of a .eh_frame / .debug_frame section in the running executable.</span></span>
<span class="line" id="L2738">    <span class="tok-comment">/// Otherwise, it should be the relative offset to translate addresses from</span></span>
<span class="line" id="L2739">    <span class="tok-comment">/// where the section is currently stored in memory, to where it *would* be</span></span>
<span class="line" id="L2740">    <span class="tok-comment">/// stored at runtime: section base addr - backing data base ptr.</span></span>
<span class="line" id="L2741">    <span class="tok-comment">///</span></span>
<span class="line" id="L2742">    <span class="tok-comment">/// Similarly, `is_runtime` specifies this function is being called on a runtime</span></span>
<span class="line" id="L2743">    <span class="tok-comment">/// section, and so indirect pointers can be followed.</span></span>
<span class="line" id="L2744">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parse</span>(</span>
<span class="line" id="L2745">        fde_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2746">        pc_rel_offset: <span class="tok-type">i64</span>,</span>
<span class="line" id="L2747">        is_runtime: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2748">        cie: CommonInformationEntry,</span>
<span class="line" id="L2749">        addr_size_bytes: <span class="tok-type">u8</span>,</span>
<span class="line" id="L2750">        endian: std.builtin.Endian,</span>
<span class="line" id="L2751">    ) !FrameDescriptionEntry {</span>
<span class="line" id="L2752">        <span class="tok-kw">if</span> (addr_size_bytes &gt; <span class="tok-number">8</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidAddrSize;</span>
<span class="line" id="L2753"></span>
<span class="line" id="L2754">        <span class="tok-kw">var</span> stream = io.fixedBufferStream(fde_bytes);</span>
<span class="line" id="L2755">        <span class="tok-kw">const</span> reader = stream.reader();</span>
<span class="line" id="L2756"></span>
<span class="line" id="L2757">        <span class="tok-kw">const</span> pc_begin = <span class="tok-kw">try</span> readEhPointer(</span>
<span class="line" id="L2758">            reader,</span>
<span class="line" id="L2759">            cie.fde_pointer_enc,</span>
<span class="line" id="L2760">            addr_size_bytes,</span>
<span class="line" id="L2761">            .{</span>
<span class="line" id="L2762">                .pc_rel_base = <span class="tok-kw">try</span> pcRelBase(<span class="tok-builtin">@intFromPtr</span>(&amp;fde_bytes[stream.pos]), pc_rel_offset),</span>
<span class="line" id="L2763">                .follow_indirect = is_runtime,</span>
<span class="line" id="L2764">            },</span>
<span class="line" id="L2765">            endian,</span>
<span class="line" id="L2766">        ) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2767"></span>
<span class="line" id="L2768">        <span class="tok-kw">const</span> pc_range = <span class="tok-kw">try</span> readEhPointer(</span>
<span class="line" id="L2769">            reader,</span>
<span class="line" id="L2770">            cie.fde_pointer_enc,</span>
<span class="line" id="L2771">            addr_size_bytes,</span>
<span class="line" id="L2772">            .{</span>
<span class="line" id="L2773">                .pc_rel_base = <span class="tok-number">0</span>,</span>
<span class="line" id="L2774">                .follow_indirect = <span class="tok-null">false</span>,</span>
<span class="line" id="L2775">            },</span>
<span class="line" id="L2776">            endian,</span>
<span class="line" id="L2777">        ) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2778"></span>
<span class="line" id="L2779">        <span class="tok-kw">var</span> aug_data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;[_]<span class="tok-type">u8</span>{};</span>
<span class="line" id="L2780">        <span class="tok-kw">const</span> lsda_pointer = <span class="tok-kw">if</span> (cie.aug_str.len &gt; <span class="tok-number">0</span>) blk: {</span>
<span class="line" id="L2781">            <span class="tok-kw">const</span> aug_data_len = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">usize</span>, reader);</span>
<span class="line" id="L2782">            <span class="tok-kw">const</span> aug_data_start = stream.pos;</span>
<span class="line" id="L2783">            aug_data = fde_bytes[aug_data_start..][<span class="tok-number">0</span>..aug_data_len];</span>
<span class="line" id="L2784"></span>
<span class="line" id="L2785">            <span class="tok-kw">const</span> lsda_pointer = <span class="tok-kw">if</span> (cie.lsda_pointer_enc != EH.PE.omit)</span>
<span class="line" id="L2786">                <span class="tok-kw">try</span> readEhPointer(</span>
<span class="line" id="L2787">                    reader,</span>
<span class="line" id="L2788">                    cie.lsda_pointer_enc,</span>
<span class="line" id="L2789">                    addr_size_bytes,</span>
<span class="line" id="L2790">                    .{</span>
<span class="line" id="L2791">                        .pc_rel_base = <span class="tok-kw">try</span> pcRelBase(<span class="tok-builtin">@intFromPtr</span>(&amp;fde_bytes[stream.pos]), pc_rel_offset),</span>
<span class="line" id="L2792">                        .follow_indirect = is_runtime,</span>
<span class="line" id="L2793">                    },</span>
<span class="line" id="L2794">                    endian,</span>
<span class="line" id="L2795">                )</span>
<span class="line" id="L2796">            <span class="tok-kw">else</span></span>
<span class="line" id="L2797">                <span class="tok-null">null</span>;</span>
<span class="line" id="L2798"></span>
<span class="line" id="L2799">            <span class="tok-kw">try</span> stream.seekTo(aug_data_start + aug_data_len);</span>
<span class="line" id="L2800">            <span class="tok-kw">break</span> :blk lsda_pointer;</span>
<span class="line" id="L2801">        } <span class="tok-kw">else</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2802"></span>
<span class="line" id="L2803">        <span class="tok-kw">const</span> instructions = fde_bytes[stream.pos..];</span>
<span class="line" id="L2804">        <span class="tok-kw">return</span> .{</span>
<span class="line" id="L2805">            .cie_length_offset = cie.length_offset,</span>
<span class="line" id="L2806">            .pc_begin = pc_begin,</span>
<span class="line" id="L2807">            .pc_range = pc_range,</span>
<span class="line" id="L2808">            .lsda_pointer = lsda_pointer,</span>
<span class="line" id="L2809">            .aug_data = aug_data,</span>
<span class="line" id="L2810">            .instructions = instructions,</span>
<span class="line" id="L2811">        };</span>
<span class="line" id="L2812">    }</span>
<span class="line" id="L2813">};</span>
<span class="line" id="L2814"></span>
<span class="line" id="L2815"><span class="tok-kw">fn</span> <span class="tok-fn">pcRelBase</span>(field_ptr: <span class="tok-type">usize</span>, pc_rel_offset: <span class="tok-type">i64</span>) !<span class="tok-type">usize</span> {</span>
<span class="line" id="L2816">    <span class="tok-kw">if</span> (pc_rel_offset &lt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L2817">        <span class="tok-kw">return</span> math.sub(<span class="tok-type">usize</span>, field_ptr, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(-pc_rel_offset)));</span>
<span class="line" id="L2818">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2819">        <span class="tok-kw">return</span> math.add(<span class="tok-type">usize</span>, field_ptr, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(pc_rel_offset)));</span>
<span class="line" id="L2820">    }</span>
<span class="line" id="L2821">}</span>
<span class="line" id="L2822"></span>
<span class="line" id="L2823"><span class="tok-kw">test</span> {</span>
<span class="line" id="L2824">    std.testing.refAllDecls(<span class="tok-builtin">@This</span>());</span>
<span class="line" id="L2825">}</span>
<span class="line" id="L2826"></span>
</code></pre></body>
</html>