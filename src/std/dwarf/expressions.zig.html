<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>dwarf/expressions.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAPNJREFUeNpi/P//PwMlgOXHUjly9E0G4hwgZmQiQZMqEK8H4v9QzUEgQSaoADK+zhH9iAGL+C0gDoAaNg9mGLoLfgA1awK9hS9gzgJxA9RQBmQDrgMxJzRMGKE4HYj/Ial5A8QmQLwCJoBsgBYW2+TR1ChDaWt4LOBxKsi/VUh8XiD+gq4IVyzwQAMJBoKwacZlAB8Qf0bi96IZhtOAe1D6LpqaEiz6rmEzQAeIzwGxCJpieFqApo/vQKyJboAaEBsAsSEupwI1MwKjGBTVHOhegMX5UajYRqiBjMgYmj400cVh0XgTiKdC0zhJgJHS7AwQYABm9EAdCKrEfAAAAABJRU5ErkJggg=="/>
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);</span>
<span class="line" id="L2"><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);</span>
<span class="line" id="L3"><span class="tok-kw">const</span> OP = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;OP.zig&quot;</span>);</span>
<span class="line" id="L4"><span class="tok-kw">const</span> leb = std.leb;</span>
<span class="line" id="L5"><span class="tok-kw">const</span> dwarf = std.dwarf;</span>
<span class="line" id="L6"><span class="tok-kw">const</span> abi = dwarf.abi;</span>
<span class="line" id="L7"><span class="tok-kw">const</span> mem = std.mem;</span>
<span class="line" id="L8"><span class="tok-kw">const</span> assert = std.debug.assert;</span>
<span class="line" id="L9"></span>
<span class="line" id="L10"><span class="tok-comment">/// Expressions can be evaluated in different contexts, each requiring its own set of inputs.</span></span>
<span class="line" id="L11"><span class="tok-comment">/// Callers should specify all the fields relevant to their context. If a field is required</span></span>
<span class="line" id="L12"><span class="tok-comment">/// by the expression and it isn't in the context, error.IncompleteExpressionContext is returned.</span></span>
<span class="line" id="L13"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ExpressionContext = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L14">    <span class="tok-comment">/// This expression is from a DWARF64 section</span></span>
<span class="line" id="L15">    is_64: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L16"></span>
<span class="line" id="L17">    <span class="tok-comment">/// If specified, any addresses will pass through this function before being acccessed</span></span>
<span class="line" id="L18">    isValidMemory: ?*<span class="tok-kw">const</span> <span class="tok-kw">fn</span> (address: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L19"></span>
<span class="line" id="L20">    <span class="tok-comment">/// The compilation unit this expression relates to, if any</span></span>
<span class="line" id="L21">    compile_unit: ?*<span class="tok-kw">const</span> dwarf.CompileUnit = <span class="tok-null">null</span>,</span>
<span class="line" id="L22"></span>
<span class="line" id="L23">    <span class="tok-comment">/// When evaluating a user-presented expression, this is the address of the object being evaluated</span></span>
<span class="line" id="L24">    object_address: ?*<span class="tok-kw">const</span> <span class="tok-type">anyopaque</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L25"></span>
<span class="line" id="L26">    <span class="tok-comment">/// .debug_addr section</span></span>
<span class="line" id="L27">    debug_addr: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L28"></span>
<span class="line" id="L29">    <span class="tok-comment">/// Thread context</span></span>
<span class="line" id="L30">    thread_context: ?*std.debug.ThreadContext = <span class="tok-null">null</span>,</span>
<span class="line" id="L31">    reg_context: ?abi.RegisterContext = <span class="tok-null">null</span>,</span>
<span class="line" id="L32"></span>
<span class="line" id="L33">    <span class="tok-comment">/// Call frame address, if in a CFI context</span></span>
<span class="line" id="L34">    cfa: ?<span class="tok-type">usize</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L35"></span>
<span class="line" id="L36">    <span class="tok-comment">/// This expression is a sub-expression from an OP.entry_value instruction</span></span>
<span class="line" id="L37">    entry_value_context: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L38">};</span>
<span class="line" id="L39"></span>
<span class="line" id="L40"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ExpressionOptions = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L41">    <span class="tok-comment">/// The address size of the target architecture</span></span>
<span class="line" id="L42">    addr_size: <span class="tok-type">u8</span> = <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>),</span>
<span class="line" id="L43"></span>
<span class="line" id="L44">    <span class="tok-comment">/// Endianess of the target architecture</span></span>
<span class="line" id="L45">    endian: std.builtin.Endian = builtin.target.cpu.arch.endian(),</span>
<span class="line" id="L46"></span>
<span class="line" id="L47">    <span class="tok-comment">/// Restrict the stack machine to a subset of opcodes used in call frame instructions</span></span>
<span class="line" id="L48">    call_frame_context: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L49">};</span>
<span class="line" id="L50"></span>
<span class="line" id="L51"><span class="tok-comment">// Explcitly defined to support executing sub-expressions</span>
</span>
<span class="line" id="L52"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ExpressionError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L53">    UnimplementedExpressionCall,</span>
<span class="line" id="L54">    UnimplementedOpcode,</span>
<span class="line" id="L55">    UnimplementedUserOpcode,</span>
<span class="line" id="L56">    UnimplementedTypedComparison,</span>
<span class="line" id="L57">    UnimplementedTypeConversion,</span>
<span class="line" id="L58"></span>
<span class="line" id="L59">    UnknownExpressionOpcode,</span>
<span class="line" id="L60"></span>
<span class="line" id="L61">    IncompleteExpressionContext,</span>
<span class="line" id="L62"></span>
<span class="line" id="L63">    InvalidCFAOpcode,</span>
<span class="line" id="L64">    InvalidExpression,</span>
<span class="line" id="L65">    InvalidFrameBase,</span>
<span class="line" id="L66">    InvalidIntegralTypeSize,</span>
<span class="line" id="L67">    InvalidRegister,</span>
<span class="line" id="L68">    InvalidSubExpression,</span>
<span class="line" id="L69">    InvalidTypeLength,</span>
<span class="line" id="L70"></span>
<span class="line" id="L71">    TruncatedIntegralType,</span>
<span class="line" id="L72">} || abi.AbiError || <span class="tok-kw">error</span>{ EndOfStream, Overflow, OutOfMemory, DivisionByZero };</span>
<span class="line" id="L73"></span>
<span class="line" id="L74"><span class="tok-comment">/// A stack machine that can decode and run DWARF expressions.</span></span>
<span class="line" id="L75"><span class="tok-comment">/// Expressions can be decoded for non-native address size and endianness,</span></span>
<span class="line" id="L76"><span class="tok-comment">/// but can only be executed if the current target matches the configuration.</span></span>
<span class="line" id="L77"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">StackMachine</span>(<span class="tok-kw">comptime</span> options: ExpressionOptions) <span class="tok-type">type</span> {</span>
<span class="line" id="L78">    <span class="tok-kw">const</span> addr_type = <span class="tok-kw">switch</span> (options.addr_size) {</span>
<span class="line" id="L79">        <span class="tok-number">2</span> =&gt; <span class="tok-type">u16</span>,</span>
<span class="line" id="L80">        <span class="tok-number">4</span> =&gt; <span class="tok-type">u32</span>,</span>
<span class="line" id="L81">        <span class="tok-number">8</span> =&gt; <span class="tok-type">u64</span>,</span>
<span class="line" id="L82">        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unsupported address size of &quot;</span> ++ options.addr_size),</span>
<span class="line" id="L83">    };</span>
<span class="line" id="L84"></span>
<span class="line" id="L85">    <span class="tok-kw">const</span> addr_type_signed = <span class="tok-kw">switch</span> (options.addr_size) {</span>
<span class="line" id="L86">        <span class="tok-number">2</span> =&gt; <span class="tok-type">i16</span>,</span>
<span class="line" id="L87">        <span class="tok-number">4</span> =&gt; <span class="tok-type">i32</span>,</span>
<span class="line" id="L88">        <span class="tok-number">8</span> =&gt; <span class="tok-type">i64</span>,</span>
<span class="line" id="L89">        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unsupported address size of &quot;</span> ++ options.addr_size),</span>
<span class="line" id="L90">    };</span>
<span class="line" id="L91"></span>
<span class="line" id="L92">    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L93">        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L94"></span>
<span class="line" id="L95">        <span class="tok-kw">const</span> Operand = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L96">            generic: addr_type,</span>
<span class="line" id="L97">            register: <span class="tok-type">u8</span>,</span>
<span class="line" id="L98">            type_size: <span class="tok-type">u8</span>,</span>
<span class="line" id="L99">            branch_offset: <span class="tok-type">i16</span>,</span>
<span class="line" id="L100">            base_register: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L101">                base_register: <span class="tok-type">u8</span>,</span>
<span class="line" id="L102">                offset: <span class="tok-type">i64</span>,</span>
<span class="line" id="L103">            },</span>
<span class="line" id="L104">            composite_location: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L105">                size: <span class="tok-type">u64</span>,</span>
<span class="line" id="L106">                offset: <span class="tok-type">i64</span>,</span>
<span class="line" id="L107">            },</span>
<span class="line" id="L108">            block: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L109">            register_type: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L110">                register: <span class="tok-type">u8</span>,</span>
<span class="line" id="L111">                type_offset: addr_type,</span>
<span class="line" id="L112">            },</span>
<span class="line" id="L113">            const_type: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L114">                type_offset: addr_type,</span>
<span class="line" id="L115">                value_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L116">            },</span>
<span class="line" id="L117">            deref_type: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L118">                size: <span class="tok-type">u8</span>,</span>
<span class="line" id="L119">                type_offset: addr_type,</span>
<span class="line" id="L120">            },</span>
<span class="line" id="L121">        };</span>
<span class="line" id="L122"></span>
<span class="line" id="L123">        <span class="tok-kw">const</span> Value = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L124">            generic: addr_type,</span>
<span class="line" id="L125"></span>
<span class="line" id="L126">            <span class="tok-comment">// Typed value with a maximum size of a register</span>
</span>
<span class="line" id="L127">            regval_type: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L128">                <span class="tok-comment">// Offset of DW_TAG_base_type DIE</span>
</span>
<span class="line" id="L129">                type_offset: addr_type,</span>
<span class="line" id="L130">                type_size: <span class="tok-type">u8</span>,</span>
<span class="line" id="L131">                value: addr_type,</span>
<span class="line" id="L132">            },</span>
<span class="line" id="L133"></span>
<span class="line" id="L134">            <span class="tok-comment">// Typed value specified directly in the instruction stream</span>
</span>
<span class="line" id="L135">            const_type: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L136">                <span class="tok-comment">// Offset of DW_TAG_base_type DIE</span>
</span>
<span class="line" id="L137">                type_offset: addr_type,</span>
<span class="line" id="L138">                <span class="tok-comment">// Backed by the instruction stream</span>
</span>
<span class="line" id="L139">                value_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L140">            },</span>
<span class="line" id="L141"></span>
<span class="line" id="L142">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">asIntegral</span>(self: Value) !addr_type {</span>
<span class="line" id="L143">                <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self) {</span>
<span class="line" id="L144">                    .generic =&gt; |v| v,</span>
<span class="line" id="L145"></span>
<span class="line" id="L146">                    <span class="tok-comment">// TODO: For these two prongs, look up the type and assert it's integral?</span>
</span>
<span class="line" id="L147">                    .regval_type =&gt; |regval_type| regval_type.value,</span>
<span class="line" id="L148">                    .const_type =&gt; |const_type| {</span>
<span class="line" id="L149">                        <span class="tok-kw">const</span> value: <span class="tok-type">u64</span> = <span class="tok-kw">switch</span> (const_type.value_bytes.len) {</span>
<span class="line" id="L150">                            <span class="tok-number">1</span> =&gt; mem.readIntSliceNative(<span class="tok-type">u8</span>, const_type.value_bytes),</span>
<span class="line" id="L151">                            <span class="tok-number">2</span> =&gt; mem.readIntSliceNative(<span class="tok-type">u16</span>, const_type.value_bytes),</span>
<span class="line" id="L152">                            <span class="tok-number">4</span> =&gt; mem.readIntSliceNative(<span class="tok-type">u32</span>, const_type.value_bytes),</span>
<span class="line" id="L153">                            <span class="tok-number">8</span> =&gt; mem.readIntSliceNative(<span class="tok-type">u64</span>, const_type.value_bytes),</span>
<span class="line" id="L154">                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidIntegralTypeSize,</span>
<span class="line" id="L155">                        };</span>
<span class="line" id="L156"></span>
<span class="line" id="L157">                        <span class="tok-kw">return</span> std.math.cast(addr_type, value) <span class="tok-kw">orelse</span> <span class="tok-kw">error</span>.TruncatedIntegralType;</span>
<span class="line" id="L158">                    },</span>
<span class="line" id="L159">                };</span>
<span class="line" id="L160">            }</span>
<span class="line" id="L161">        };</span>
<span class="line" id="L162"></span>
<span class="line" id="L163">        stack: std.ArrayListUnmanaged(Value) = .{},</span>
<span class="line" id="L164"></span>
<span class="line" id="L165">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *Self) <span class="tok-type">void</span> {</span>
<span class="line" id="L166">            self.stack.clearRetainingCapacity();</span>
<span class="line" id="L167">        }</span>
<span class="line" id="L168"></span>
<span class="line" id="L169">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *Self, allocator: std.mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L170">            self.stack.deinit(allocator);</span>
<span class="line" id="L171">        }</span>
<span class="line" id="L172"></span>
<span class="line" id="L173">        <span class="tok-kw">fn</span> <span class="tok-fn">generic</span>(value: <span class="tok-kw">anytype</span>) Operand {</span>
<span class="line" id="L174">            <span class="tok-kw">const</span> int_info = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(value)).Int;</span>
<span class="line" id="L175">            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<span class="tok-builtin">@TypeOf</span>(value)) &gt; options.addr_size) {</span>
<span class="line" id="L176">                <span class="tok-kw">return</span> .{ .generic = <span class="tok-kw">switch</span> (int_info.signedness) {</span>
<span class="line" id="L177">                    .signed =&gt; <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(addr_type_signed, <span class="tok-builtin">@truncate</span>(value))),</span>
<span class="line" id="L178">                    .unsigned =&gt; <span class="tok-builtin">@truncate</span>(value),</span>
<span class="line" id="L179">                } };</span>
<span class="line" id="L180">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L181">                <span class="tok-kw">return</span> .{ .generic = <span class="tok-kw">switch</span> (int_info.signedness) {</span>
<span class="line" id="L182">                    .signed =&gt; <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(addr_type_signed, <span class="tok-builtin">@intCast</span>(value))),</span>
<span class="line" id="L183">                    .unsigned =&gt; <span class="tok-builtin">@intCast</span>(value),</span>
<span class="line" id="L184">                } };</span>
<span class="line" id="L185">            }</span>
<span class="line" id="L186">        }</span>
<span class="line" id="L187"></span>
<span class="line" id="L188">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readOperand</span>(stream: *std.io.FixedBufferStream([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>), opcode: <span class="tok-type">u8</span>, context: ExpressionContext) !?Operand {</span>
<span class="line" id="L189">            <span class="tok-kw">const</span> reader = stream.reader();</span>
<span class="line" id="L190">            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (opcode) {</span>
<span class="line" id="L191">                OP.addr =&gt; generic(<span class="tok-kw">try</span> reader.readInt(addr_type, options.endian)),</span>
<span class="line" id="L192">                OP.call_ref =&gt; <span class="tok-kw">if</span> (context.is_64)</span>
<span class="line" id="L193">                    generic(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u64</span>, options.endian))</span>
<span class="line" id="L194">                <span class="tok-kw">else</span></span>
<span class="line" id="L195">                    generic(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u32</span>, options.endian)),</span>
<span class="line" id="L196">                OP.const1u,</span>
<span class="line" id="L197">                OP.pick,</span>
<span class="line" id="L198">                =&gt; generic(<span class="tok-kw">try</span> reader.readByte()),</span>
<span class="line" id="L199">                OP.deref_size,</span>
<span class="line" id="L200">                OP.xderef_size,</span>
<span class="line" id="L201">                =&gt; .{ .type_size = <span class="tok-kw">try</span> reader.readByte() },</span>
<span class="line" id="L202">                OP.const1s =&gt; generic(<span class="tok-kw">try</span> reader.readByteSigned()),</span>
<span class="line" id="L203">                OP.const2u,</span>
<span class="line" id="L204">                OP.call2,</span>
<span class="line" id="L205">                =&gt; generic(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u16</span>, options.endian)),</span>
<span class="line" id="L206">                OP.call4 =&gt; generic(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u32</span>, options.endian)),</span>
<span class="line" id="L207">                OP.const2s =&gt; generic(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">i16</span>, options.endian)),</span>
<span class="line" id="L208">                OP.bra,</span>
<span class="line" id="L209">                OP.skip,</span>
<span class="line" id="L210">                =&gt; .{ .branch_offset = <span class="tok-kw">try</span> reader.readInt(<span class="tok-type">i16</span>, options.endian) },</span>
<span class="line" id="L211">                OP.const4u =&gt; generic(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u32</span>, options.endian)),</span>
<span class="line" id="L212">                OP.const4s =&gt; generic(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">i32</span>, options.endian)),</span>
<span class="line" id="L213">                OP.const8u =&gt; generic(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u64</span>, options.endian)),</span>
<span class="line" id="L214">                OP.const8s =&gt; generic(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">i64</span>, options.endian)),</span>
<span class="line" id="L215">                OP.constu,</span>
<span class="line" id="L216">                OP.plus_uconst,</span>
<span class="line" id="L217">                OP.addrx,</span>
<span class="line" id="L218">                OP.constx,</span>
<span class="line" id="L219">                OP.convert,</span>
<span class="line" id="L220">                OP.reinterpret,</span>
<span class="line" id="L221">                =&gt; generic(<span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">u64</span>, reader)),</span>
<span class="line" id="L222">                OP.consts,</span>
<span class="line" id="L223">                OP.fbreg,</span>
<span class="line" id="L224">                =&gt; generic(<span class="tok-kw">try</span> leb.readILEB128(<span class="tok-type">i64</span>, reader)),</span>
<span class="line" id="L225">                OP.lit0...OP.lit31 =&gt; |n| generic(n - OP.lit0),</span>
<span class="line" id="L226">                OP.reg0...OP.reg31 =&gt; |n| .{ .register = n - OP.reg0 },</span>
<span class="line" id="L227">                OP.breg0...OP.breg31 =&gt; |n| .{ .base_register = .{</span>
<span class="line" id="L228">                    .base_register = n - OP.breg0,</span>
<span class="line" id="L229">                    .offset = <span class="tok-kw">try</span> leb.readILEB128(<span class="tok-type">i64</span>, reader),</span>
<span class="line" id="L230">                } },</span>
<span class="line" id="L231">                OP.regx =&gt; .{ .register = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">u8</span>, reader) },</span>
<span class="line" id="L232">                OP.bregx =&gt; blk: {</span>
<span class="line" id="L233">                    <span class="tok-kw">const</span> base_register = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">u8</span>, reader);</span>
<span class="line" id="L234">                    <span class="tok-kw">const</span> offset = <span class="tok-kw">try</span> leb.readILEB128(<span class="tok-type">i64</span>, reader);</span>
<span class="line" id="L235">                    <span class="tok-kw">break</span> :blk .{ .base_register = .{</span>
<span class="line" id="L236">                        .base_register = base_register,</span>
<span class="line" id="L237">                        .offset = offset,</span>
<span class="line" id="L238">                    } };</span>
<span class="line" id="L239">                },</span>
<span class="line" id="L240">                OP.regval_type =&gt; blk: {</span>
<span class="line" id="L241">                    <span class="tok-kw">const</span> register = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">u8</span>, reader);</span>
<span class="line" id="L242">                    <span class="tok-kw">const</span> type_offset = <span class="tok-kw">try</span> leb.readULEB128(addr_type, reader);</span>
<span class="line" id="L243">                    <span class="tok-kw">break</span> :blk .{ .register_type = .{</span>
<span class="line" id="L244">                        .register = register,</span>
<span class="line" id="L245">                        .type_offset = type_offset,</span>
<span class="line" id="L246">                    } };</span>
<span class="line" id="L247">                },</span>
<span class="line" id="L248">                OP.piece =&gt; .{</span>
<span class="line" id="L249">                    .composite_location = .{</span>
<span class="line" id="L250">                        .size = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">u8</span>, reader),</span>
<span class="line" id="L251">                        .offset = <span class="tok-number">0</span>,</span>
<span class="line" id="L252">                    },</span>
<span class="line" id="L253">                },</span>
<span class="line" id="L254">                OP.bit_piece =&gt; blk: {</span>
<span class="line" id="L255">                    <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">u8</span>, reader);</span>
<span class="line" id="L256">                    <span class="tok-kw">const</span> offset = <span class="tok-kw">try</span> leb.readILEB128(<span class="tok-type">i64</span>, reader);</span>
<span class="line" id="L257">                    <span class="tok-kw">break</span> :blk .{ .composite_location = .{</span>
<span class="line" id="L258">                        .size = size,</span>
<span class="line" id="L259">                        .offset = offset,</span>
<span class="line" id="L260">                    } };</span>
<span class="line" id="L261">                },</span>
<span class="line" id="L262">                OP.implicit_value, OP.entry_value =&gt; blk: {</span>
<span class="line" id="L263">                    <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">u8</span>, reader);</span>
<span class="line" id="L264">                    <span class="tok-kw">if</span> (stream.pos + size &gt; stream.buffer.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L265">                    <span class="tok-kw">const</span> block = stream.buffer[stream.pos..][<span class="tok-number">0</span>..size];</span>
<span class="line" id="L266">                    stream.pos += size;</span>
<span class="line" id="L267">                    <span class="tok-kw">break</span> :blk .{</span>
<span class="line" id="L268">                        .block = block,</span>
<span class="line" id="L269">                    };</span>
<span class="line" id="L270">                },</span>
<span class="line" id="L271">                OP.const_type =&gt; blk: {</span>
<span class="line" id="L272">                    <span class="tok-kw">const</span> type_offset = <span class="tok-kw">try</span> leb.readULEB128(addr_type, reader);</span>
<span class="line" id="L273">                    <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> reader.readByte();</span>
<span class="line" id="L274">                    <span class="tok-kw">if</span> (stream.pos + size &gt; stream.buffer.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L275">                    <span class="tok-kw">const</span> value_bytes = stream.buffer[stream.pos..][<span class="tok-number">0</span>..size];</span>
<span class="line" id="L276">                    stream.pos += size;</span>
<span class="line" id="L277">                    <span class="tok-kw">break</span> :blk .{ .const_type = .{</span>
<span class="line" id="L278">                        .type_offset = type_offset,</span>
<span class="line" id="L279">                        .value_bytes = value_bytes,</span>
<span class="line" id="L280">                    } };</span>
<span class="line" id="L281">                },</span>
<span class="line" id="L282">                OP.deref_type,</span>
<span class="line" id="L283">                OP.xderef_type,</span>
<span class="line" id="L284">                =&gt; .{</span>
<span class="line" id="L285">                    .deref_type = .{</span>
<span class="line" id="L286">                        .size = <span class="tok-kw">try</span> reader.readByte(),</span>
<span class="line" id="L287">                        .type_offset = <span class="tok-kw">try</span> leb.readULEB128(addr_type, reader),</span>
<span class="line" id="L288">                    },</span>
<span class="line" id="L289">                },</span>
<span class="line" id="L290">                OP.lo_user...OP.hi_user =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedUserOpcode,</span>
<span class="line" id="L291">                <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,</span>
<span class="line" id="L292">            };</span>
<span class="line" id="L293">        }</span>
<span class="line" id="L294"></span>
<span class="line" id="L295">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">run</span>(</span>
<span class="line" id="L296">            self: *Self,</span>
<span class="line" id="L297">            expression: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L298">            allocator: std.mem.Allocator,</span>
<span class="line" id="L299">            context: ExpressionContext,</span>
<span class="line" id="L300">            initial_value: ?<span class="tok-type">usize</span>,</span>
<span class="line" id="L301">        ) ExpressionError!?Value {</span>
<span class="line" id="L302">            <span class="tok-kw">if</span> (initial_value) |i| <span class="tok-kw">try</span> self.stack.append(allocator, .{ .generic = i });</span>
<span class="line" id="L303">            <span class="tok-kw">var</span> stream = std.io.fixedBufferStream(expression);</span>
<span class="line" id="L304">            <span class="tok-kw">while</span> (<span class="tok-kw">try</span> self.step(&amp;stream, allocator, context)) {}</span>
<span class="line" id="L305">            <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L306">            <span class="tok-kw">return</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>];</span>
<span class="line" id="L307">        }</span>
<span class="line" id="L308"></span>
<span class="line" id="L309">        <span class="tok-comment">/// Reads an opcode and its operands from `stream`, then executes it</span></span>
<span class="line" id="L310">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">step</span>(</span>
<span class="line" id="L311">            self: *Self,</span>
<span class="line" id="L312">            stream: *std.io.FixedBufferStream([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>),</span>
<span class="line" id="L313">            allocator: std.mem.Allocator,</span>
<span class="line" id="L314">            context: ExpressionContext,</span>
<span class="line" id="L315">        ) ExpressionError!<span class="tok-type">bool</span> {</span>
<span class="line" id="L316">            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) != <span class="tok-builtin">@sizeOf</span>(addr_type) <span class="tok-kw">or</span> options.endian != <span class="tok-kw">comptime</span> builtin.target.cpu.arch.endian())</span>
<span class="line" id="L317">                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Execution of non-native address sizes / endianness is not supported&quot;</span>);</span>
<span class="line" id="L318"></span>
<span class="line" id="L319">            <span class="tok-kw">const</span> opcode = <span class="tok-kw">try</span> stream.reader().readByte();</span>
<span class="line" id="L320">            <span class="tok-kw">if</span> (options.call_frame_context <span class="tok-kw">and</span> !isOpcodeValidInCFA(opcode)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;</span>
<span class="line" id="L321">            <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> readOperand(stream, opcode, context);</span>
<span class="line" id="L322">            <span class="tok-kw">switch</span> (opcode) {</span>
<span class="line" id="L323"></span>
<span class="line" id="L324">                <span class="tok-comment">// 2.5.1.1: Literal Encodings</span>
</span>
<span class="line" id="L325">                OP.lit0...OP.lit31,</span>
<span class="line" id="L326">                OP.addr,</span>
<span class="line" id="L327">                OP.const1u,</span>
<span class="line" id="L328">                OP.const2u,</span>
<span class="line" id="L329">                OP.const4u,</span>
<span class="line" id="L330">                OP.const8u,</span>
<span class="line" id="L331">                OP.const1s,</span>
<span class="line" id="L332">                OP.const2s,</span>
<span class="line" id="L333">                OP.const4s,</span>
<span class="line" id="L334">                OP.const8s,</span>
<span class="line" id="L335">                OP.constu,</span>
<span class="line" id="L336">                OP.consts,</span>
<span class="line" id="L337">                =&gt; <span class="tok-kw">try</span> self.stack.append(allocator, .{ .generic = operand.?.generic }),</span>
<span class="line" id="L338"></span>
<span class="line" id="L339">                OP.const_type =&gt; {</span>
<span class="line" id="L340">                    <span class="tok-kw">const</span> const_type = operand.?.const_type;</span>
<span class="line" id="L341">                    <span class="tok-kw">try</span> self.stack.append(allocator, .{ .const_type = .{</span>
<span class="line" id="L342">                        .type_offset = const_type.type_offset,</span>
<span class="line" id="L343">                        .value_bytes = const_type.value_bytes,</span>
<span class="line" id="L344">                    } });</span>
<span class="line" id="L345">                },</span>
<span class="line" id="L346"></span>
<span class="line" id="L347">                OP.addrx,</span>
<span class="line" id="L348">                OP.constx,</span>
<span class="line" id="L349">                =&gt; {</span>
<span class="line" id="L350">                    <span class="tok-kw">if</span> (context.compile_unit == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;</span>
<span class="line" id="L351">                    <span class="tok-kw">if</span> (context.debug_addr == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;</span>
<span class="line" id="L352">                    <span class="tok-kw">const</span> debug_addr_index = operand.?.generic;</span>
<span class="line" id="L353">                    <span class="tok-kw">const</span> offset = context.compile_unit.?.addr_base + debug_addr_index;</span>
<span class="line" id="L354">                    <span class="tok-kw">if</span> (offset &gt;= context.debug_addr.?.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L355">                    <span class="tok-kw">const</span> value = mem.readIntSliceNative(<span class="tok-type">usize</span>, context.debug_addr.?[offset..][<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)]);</span>
<span class="line" id="L356">                    <span class="tok-kw">try</span> self.stack.append(allocator, .{ .generic = value });</span>
<span class="line" id="L357">                },</span>
<span class="line" id="L358"></span>
<span class="line" id="L359">                <span class="tok-comment">// 2.5.1.2: Register Values</span>
</span>
<span class="line" id="L360">                OP.fbreg =&gt; {</span>
<span class="line" id="L361">                    <span class="tok-kw">if</span> (context.compile_unit == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;</span>
<span class="line" id="L362">                    <span class="tok-kw">if</span> (context.compile_unit.?.frame_base == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;</span>
<span class="line" id="L363"></span>
<span class="line" id="L364">                    <span class="tok-kw">const</span> offset: <span class="tok-type">i64</span> = <span class="tok-builtin">@intCast</span>(operand.?.generic);</span>
<span class="line" id="L365">                    _ = offset;</span>
<span class="line" id="L366"></span>
<span class="line" id="L367">                    <span class="tok-kw">switch</span> (context.compile_unit.?.frame_base.?.*) {</span>
<span class="line" id="L368">                        .ExprLoc =&gt; {</span>
<span class="line" id="L369">                            <span class="tok-comment">// TODO: Run this expression in a nested stack machine</span>
</span>
<span class="line" id="L370">                            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedOpcode;</span>
<span class="line" id="L371">                        },</span>
<span class="line" id="L372">                        .LocListOffset =&gt; {</span>
<span class="line" id="L373">                            <span class="tok-comment">// TODO: Read value from .debug_loclists</span>
</span>
<span class="line" id="L374">                            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedOpcode;</span>
<span class="line" id="L375">                        },</span>
<span class="line" id="L376">                        .SecOffset =&gt; {</span>
<span class="line" id="L377">                            <span class="tok-comment">// TODO: Read value from .debug_loclists</span>
</span>
<span class="line" id="L378">                            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedOpcode;</span>
<span class="line" id="L379">                        },</span>
<span class="line" id="L380">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFrameBase,</span>
<span class="line" id="L381">                    }</span>
<span class="line" id="L382">                },</span>
<span class="line" id="L383">                OP.breg0...OP.breg31,</span>
<span class="line" id="L384">                OP.bregx,</span>
<span class="line" id="L385">                =&gt; {</span>
<span class="line" id="L386">                    <span class="tok-kw">if</span> (context.thread_context == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;</span>
<span class="line" id="L387"></span>
<span class="line" id="L388">                    <span class="tok-kw">const</span> base_register = operand.?.base_register;</span>
<span class="line" id="L389">                    <span class="tok-kw">var</span> value: <span class="tok-type">i64</span> = <span class="tok-builtin">@intCast</span>(mem.readIntSliceNative(<span class="tok-type">usize</span>, <span class="tok-kw">try</span> abi.regBytes(</span>
<span class="line" id="L390">                        context.thread_context.?,</span>
<span class="line" id="L391">                        base_register.base_register,</span>
<span class="line" id="L392">                        context.reg_context,</span>
<span class="line" id="L393">                    )));</span>
<span class="line" id="L394">                    value += base_register.offset;</span>
<span class="line" id="L395">                    <span class="tok-kw">try</span> self.stack.append(allocator, .{ .generic = <span class="tok-builtin">@intCast</span>(value) });</span>
<span class="line" id="L396">                },</span>
<span class="line" id="L397">                OP.regval_type =&gt; {</span>
<span class="line" id="L398">                    <span class="tok-kw">const</span> register_type = operand.?.register_type;</span>
<span class="line" id="L399">                    <span class="tok-kw">const</span> value = mem.readIntSliceNative(<span class="tok-type">usize</span>, <span class="tok-kw">try</span> abi.regBytes(</span>
<span class="line" id="L400">                        context.thread_context.?,</span>
<span class="line" id="L401">                        register_type.register,</span>
<span class="line" id="L402">                        context.reg_context,</span>
<span class="line" id="L403">                    ));</span>
<span class="line" id="L404">                    <span class="tok-kw">try</span> self.stack.append(allocator, .{</span>
<span class="line" id="L405">                        .regval_type = .{</span>
<span class="line" id="L406">                            .type_offset = register_type.type_offset,</span>
<span class="line" id="L407">                            .type_size = <span class="tok-builtin">@sizeOf</span>(addr_type),</span>
<span class="line" id="L408">                            .value = value,</span>
<span class="line" id="L409">                        },</span>
<span class="line" id="L410">                    });</span>
<span class="line" id="L411">                },</span>
<span class="line" id="L412"></span>
<span class="line" id="L413">                <span class="tok-comment">// 2.5.1.3: Stack Operations</span>
</span>
<span class="line" id="L414">                OP.dup =&gt; {</span>
<span class="line" id="L415">                    <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L416">                    <span class="tok-kw">try</span> self.stack.append(allocator, self.stack.items[self.stack.items.len - <span class="tok-number">1</span>]);</span>
<span class="line" id="L417">                },</span>
<span class="line" id="L418">                OP.drop =&gt; {</span>
<span class="line" id="L419">                    _ = self.stack.pop();</span>
<span class="line" id="L420">                },</span>
<span class="line" id="L421">                OP.pick, OP.over =&gt; {</span>
<span class="line" id="L422">                    <span class="tok-kw">const</span> stack_index = <span class="tok-kw">if</span> (opcode == OP.over) <span class="tok-number">1</span> <span class="tok-kw">else</span> operand.?.generic;</span>
<span class="line" id="L423">                    <span class="tok-kw">if</span> (stack_index &gt;= self.stack.items.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L424">                    <span class="tok-kw">try</span> self.stack.append(allocator, self.stack.items[self.stack.items.len - <span class="tok-number">1</span> - stack_index]);</span>
<span class="line" id="L425">                },</span>
<span class="line" id="L426">                OP.swap =&gt; {</span>
<span class="line" id="L427">                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L428">                    mem.swap(Value, &amp;self.stack.items[self.stack.items.len - <span class="tok-number">1</span>], &amp;self.stack.items[self.stack.items.len - <span class="tok-number">2</span>]);</span>
<span class="line" id="L429">                },</span>
<span class="line" id="L430">                OP.rot =&gt; {</span>
<span class="line" id="L431">                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">3</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L432">                    <span class="tok-kw">const</span> first = self.stack.items[self.stack.items.len - <span class="tok-number">1</span>];</span>
<span class="line" id="L433">                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = self.stack.items[self.stack.items.len - <span class="tok-number">2</span>];</span>
<span class="line" id="L434">                    self.stack.items[self.stack.items.len - <span class="tok-number">2</span>] = self.stack.items[self.stack.items.len - <span class="tok-number">3</span>];</span>
<span class="line" id="L435">                    self.stack.items[self.stack.items.len - <span class="tok-number">3</span>] = first;</span>
<span class="line" id="L436">                },</span>
<span class="line" id="L437">                OP.deref,</span>
<span class="line" id="L438">                OP.xderef,</span>
<span class="line" id="L439">                OP.deref_size,</span>
<span class="line" id="L440">                OP.xderef_size,</span>
<span class="line" id="L441">                OP.deref_type,</span>
<span class="line" id="L442">                OP.xderef_type,</span>
<span class="line" id="L443">                =&gt; {</span>
<span class="line" id="L444">                    <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L445">                    <span class="tok-kw">var</span> addr = <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral();</span>
<span class="line" id="L446">                    <span class="tok-kw">const</span> addr_space_identifier: ?<span class="tok-type">usize</span> = <span class="tok-kw">switch</span> (opcode) {</span>
<span class="line" id="L447">                        OP.xderef,</span>
<span class="line" id="L448">                        OP.xderef_size,</span>
<span class="line" id="L449">                        OP.xderef_type,</span>
<span class="line" id="L450">                        =&gt; blk: {</span>
<span class="line" id="L451">                            _ = self.stack.pop();</span>
<span class="line" id="L452">                            <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L453">                            <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral();</span>
<span class="line" id="L454">                        },</span>
<span class="line" id="L455">                        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,</span>
<span class="line" id="L456">                    };</span>
<span class="line" id="L457"></span>
<span class="line" id="L458">                    <span class="tok-comment">// Usage of addr_space_identifier in the address calculation is implementation defined.</span>
</span>
<span class="line" id="L459">                    <span class="tok-comment">// This code will need to be updated to handle any architectures that utilize this.</span>
</span>
<span class="line" id="L460">                    _ = addr_space_identifier;</span>
<span class="line" id="L461"></span>
<span class="line" id="L462">                    <span class="tok-kw">if</span> (context.isValidMemory) |isValidMemory| <span class="tok-kw">if</span> (!isValidMemory(addr)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L463">                    <span class="tok-kw">const</span> size = <span class="tok-kw">switch</span> (opcode) {</span>
<span class="line" id="L464">                        OP.deref,</span>
<span class="line" id="L465">                        OP.xderef,</span>
<span class="line" id="L466">                        =&gt; <span class="tok-builtin">@sizeOf</span>(addr_type),</span>
<span class="line" id="L467">                        OP.deref_size,</span>
<span class="line" id="L468">                        OP.xderef_size,</span>
<span class="line" id="L469">                        =&gt; operand.?.type_size,</span>
<span class="line" id="L470">                        OP.deref_type,</span>
<span class="line" id="L471">                        OP.xderef_type,</span>
<span class="line" id="L472">                        =&gt; operand.?.deref_type.size,</span>
<span class="line" id="L473">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L474">                    };</span>
<span class="line" id="L475"></span>
<span class="line" id="L476">                    <span class="tok-kw">const</span> value: addr_type = std.math.cast(addr_type, <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-kw">switch</span> (size) {</span>
<span class="line" id="L477">                        <span class="tok-number">1</span> =&gt; <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(addr)).*,</span>
<span class="line" id="L478">                        <span class="tok-number">2</span> =&gt; <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">u16</span>, <span class="tok-builtin">@ptrFromInt</span>(addr)).*,</span>
<span class="line" id="L479">                        <span class="tok-number">4</span> =&gt; <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">u32</span>, <span class="tok-builtin">@ptrFromInt</span>(addr)).*,</span>
<span class="line" id="L480">                        <span class="tok-number">8</span> =&gt; <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">u64</span>, <span class="tok-builtin">@ptrFromInt</span>(addr)).*,</span>
<span class="line" id="L481">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression,</span>
<span class="line" id="L482">                    })) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L483"></span>
<span class="line" id="L484">                    <span class="tok-kw">switch</span> (opcode) {</span>
<span class="line" id="L485">                        OP.deref_type,</span>
<span class="line" id="L486">                        OP.xderef_type,</span>
<span class="line" id="L487">                        =&gt; {</span>
<span class="line" id="L488">                            self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{</span>
<span class="line" id="L489">                                .regval_type = .{</span>
<span class="line" id="L490">                                    .type_offset = operand.?.deref_type.type_offset,</span>
<span class="line" id="L491">                                    .type_size = operand.?.deref_type.size,</span>
<span class="line" id="L492">                                    .value = value,</span>
<span class="line" id="L493">                                },</span>
<span class="line" id="L494">                            };</span>
<span class="line" id="L495">                        },</span>
<span class="line" id="L496">                        <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L497">                            self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{ .generic = value };</span>
<span class="line" id="L498">                        },</span>
<span class="line" id="L499">                    }</span>
<span class="line" id="L500">                },</span>
<span class="line" id="L501">                OP.push_object_address =&gt; {</span>
<span class="line" id="L502">                    <span class="tok-comment">// In sub-expressions, `push_object_address` is not meaningful (as per the</span>
</span>
<span class="line" id="L503">                    <span class="tok-comment">// spec), so treat it like a nop</span>
</span>
<span class="line" id="L504">                    <span class="tok-kw">if</span> (!context.entry_value_context) {</span>
<span class="line" id="L505">                        <span class="tok-kw">if</span> (context.object_address == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;</span>
<span class="line" id="L506">                        <span class="tok-kw">try</span> self.stack.append(allocator, .{ .generic = <span class="tok-builtin">@intFromPtr</span>(context.object_address.?) });</span>
<span class="line" id="L507">                    }</span>
<span class="line" id="L508">                },</span>
<span class="line" id="L509">                OP.form_tls_address =&gt; {</span>
<span class="line" id="L510">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedOpcode;</span>
<span class="line" id="L511">                },</span>
<span class="line" id="L512">                OP.call_frame_cfa =&gt; {</span>
<span class="line" id="L513">                    <span class="tok-kw">if</span> (context.cfa) |cfa| {</span>
<span class="line" id="L514">                        <span class="tok-kw">try</span> self.stack.append(allocator, .{ .generic = cfa });</span>
<span class="line" id="L515">                    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;</span>
<span class="line" id="L516">                },</span>
<span class="line" id="L517"></span>
<span class="line" id="L518">                <span class="tok-comment">// 2.5.1.4: Arithmetic and Logical Operations</span>
</span>
<span class="line" id="L519">                OP.abs =&gt; {</span>
<span class="line" id="L520">                    <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L521">                    <span class="tok-kw">const</span> value: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral());</span>
<span class="line" id="L522">                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{</span>
<span class="line" id="L523">                        .generic = std.math.absCast(value),</span>
<span class="line" id="L524">                    };</span>
<span class="line" id="L525">                },</span>
<span class="line" id="L526">                OP.@&quot;and&quot; =&gt; {</span>
<span class="line" id="L527">                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L528">                    <span class="tok-kw">const</span> a = <span class="tok-kw">try</span> self.stack.pop().asIntegral();</span>
<span class="line" id="L529">                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{</span>
<span class="line" id="L530">                        .generic = a &amp; <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral(),</span>
<span class="line" id="L531">                    };</span>
<span class="line" id="L532">                },</span>
<span class="line" id="L533">                OP.div =&gt; {</span>
<span class="line" id="L534">                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L535">                    <span class="tok-kw">const</span> a: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.pop().asIntegral());</span>
<span class="line" id="L536">                    <span class="tok-kw">const</span> b: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral());</span>
<span class="line" id="L537">                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{</span>
<span class="line" id="L538">                        .generic = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> std.math.divTrunc(<span class="tok-type">isize</span>, b, a)),</span>
<span class="line" id="L539">                    };</span>
<span class="line" id="L540">                },</span>
<span class="line" id="L541">                OP.minus =&gt; {</span>
<span class="line" id="L542">                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L543">                    <span class="tok-kw">const</span> b = <span class="tok-kw">try</span> self.stack.pop().asIntegral();</span>
<span class="line" id="L544">                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{</span>
<span class="line" id="L545">                        .generic = <span class="tok-kw">try</span> std.math.sub(addr_type, <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral(), b),</span>
<span class="line" id="L546">                    };</span>
<span class="line" id="L547">                },</span>
<span class="line" id="L548">                OP.mod =&gt; {</span>
<span class="line" id="L549">                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L550">                    <span class="tok-kw">const</span> a: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.pop().asIntegral());</span>
<span class="line" id="L551">                    <span class="tok-kw">const</span> b: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral());</span>
<span class="line" id="L552">                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{</span>
<span class="line" id="L553">                        .generic = <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@mod</span>(b, a)),</span>
<span class="line" id="L554">                    };</span>
<span class="line" id="L555">                },</span>
<span class="line" id="L556">                OP.mul =&gt; {</span>
<span class="line" id="L557">                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L558">                    <span class="tok-kw">const</span> a: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.pop().asIntegral());</span>
<span class="line" id="L559">                    <span class="tok-kw">const</span> b: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral());</span>
<span class="line" id="L560">                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{</span>
<span class="line" id="L561">                        .generic = <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@mulWithOverflow</span>(a, b)[<span class="tok-number">0</span>]),</span>
<span class="line" id="L562">                    };</span>
<span class="line" id="L563">                },</span>
<span class="line" id="L564">                OP.neg =&gt; {</span>
<span class="line" id="L565">                    <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L566">                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{</span>
<span class="line" id="L567">                        .generic = <span class="tok-builtin">@bitCast</span>(</span>
<span class="line" id="L568">                            <span class="tok-kw">try</span> std.math.negate(</span>
<span class="line" id="L569">                                <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral())),</span>
<span class="line" id="L570">                            ),</span>
<span class="line" id="L571">                        ),</span>
<span class="line" id="L572">                    };</span>
<span class="line" id="L573">                },</span>
<span class="line" id="L574">                OP.not =&gt; {</span>
<span class="line" id="L575">                    <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L576">                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{</span>
<span class="line" id="L577">                        .generic = ~<span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral(),</span>
<span class="line" id="L578">                    };</span>
<span class="line" id="L579">                },</span>
<span class="line" id="L580">                OP.@&quot;or&quot; =&gt; {</span>
<span class="line" id="L581">                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L582">                    <span class="tok-kw">const</span> a = <span class="tok-kw">try</span> self.stack.pop().asIntegral();</span>
<span class="line" id="L583">                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{</span>
<span class="line" id="L584">                        .generic = a | <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral(),</span>
<span class="line" id="L585">                    };</span>
<span class="line" id="L586">                },</span>
<span class="line" id="L587">                OP.plus =&gt; {</span>
<span class="line" id="L588">                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L589">                    <span class="tok-kw">const</span> b = <span class="tok-kw">try</span> self.stack.pop().asIntegral();</span>
<span class="line" id="L590">                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{</span>
<span class="line" id="L591">                        .generic = <span class="tok-kw">try</span> std.math.add(addr_type, <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral(), b),</span>
<span class="line" id="L592">                    };</span>
<span class="line" id="L593">                },</span>
<span class="line" id="L594">                OP.plus_uconst =&gt; {</span>
<span class="line" id="L595">                    <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L596">                    <span class="tok-kw">const</span> constant = operand.?.generic;</span>
<span class="line" id="L597">                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{</span>
<span class="line" id="L598">                        .generic = <span class="tok-kw">try</span> std.math.add(addr_type, <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral(), constant),</span>
<span class="line" id="L599">                    };</span>
<span class="line" id="L600">                },</span>
<span class="line" id="L601">                OP.shl =&gt; {</span>
<span class="line" id="L602">                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L603">                    <span class="tok-kw">const</span> a = <span class="tok-kw">try</span> self.stack.pop().asIntegral();</span>
<span class="line" id="L604">                    <span class="tok-kw">const</span> b = <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral();</span>
<span class="line" id="L605">                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{</span>
<span class="line" id="L606">                        .generic = std.math.shl(<span class="tok-type">usize</span>, b, a),</span>
<span class="line" id="L607">                    };</span>
<span class="line" id="L608">                },</span>
<span class="line" id="L609">                OP.shr =&gt; {</span>
<span class="line" id="L610">                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L611">                    <span class="tok-kw">const</span> a = <span class="tok-kw">try</span> self.stack.pop().asIntegral();</span>
<span class="line" id="L612">                    <span class="tok-kw">const</span> b = <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral();</span>
<span class="line" id="L613">                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{</span>
<span class="line" id="L614">                        .generic = std.math.shr(<span class="tok-type">usize</span>, b, a),</span>
<span class="line" id="L615">                    };</span>
<span class="line" id="L616">                },</span>
<span class="line" id="L617">                OP.shra =&gt; {</span>
<span class="line" id="L618">                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L619">                    <span class="tok-kw">const</span> a = <span class="tok-kw">try</span> self.stack.pop().asIntegral();</span>
<span class="line" id="L620">                    <span class="tok-kw">const</span> b: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral());</span>
<span class="line" id="L621">                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{</span>
<span class="line" id="L622">                        .generic = <span class="tok-builtin">@bitCast</span>(std.math.shr(<span class="tok-type">isize</span>, b, a)),</span>
<span class="line" id="L623">                    };</span>
<span class="line" id="L624">                },</span>
<span class="line" id="L625">                OP.xor =&gt; {</span>
<span class="line" id="L626">                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L627">                    <span class="tok-kw">const</span> a = <span class="tok-kw">try</span> self.stack.pop().asIntegral();</span>
<span class="line" id="L628">                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{</span>
<span class="line" id="L629">                        .generic = a ^ <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral(),</span>
<span class="line" id="L630">                    };</span>
<span class="line" id="L631">                },</span>
<span class="line" id="L632"></span>
<span class="line" id="L633">                <span class="tok-comment">// 2.5.1.5: Control Flow Operations</span>
</span>
<span class="line" id="L634">                OP.le,</span>
<span class="line" id="L635">                OP.ge,</span>
<span class="line" id="L636">                OP.eq,</span>
<span class="line" id="L637">                OP.lt,</span>
<span class="line" id="L638">                OP.gt,</span>
<span class="line" id="L639">                OP.ne,</span>
<span class="line" id="L640">                =&gt; {</span>
<span class="line" id="L641">                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L642">                    <span class="tok-kw">const</span> a = self.stack.pop();</span>
<span class="line" id="L643">                    <span class="tok-kw">const</span> b = self.stack.items[self.stack.items.len - <span class="tok-number">1</span>];</span>
<span class="line" id="L644"></span>
<span class="line" id="L645">                    <span class="tok-kw">if</span> (a == .generic <span class="tok-kw">and</span> b == .generic) {</span>
<span class="line" id="L646">                        <span class="tok-kw">const</span> a_int: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(a.asIntegral() <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>);</span>
<span class="line" id="L647">                        <span class="tok-kw">const</span> b_int: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(b.asIntegral() <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>);</span>
<span class="line" id="L648">                        <span class="tok-kw">const</span> result = <span class="tok-builtin">@intFromBool</span>(<span class="tok-kw">switch</span> (opcode) {</span>
<span class="line" id="L649">                            OP.le =&gt; b_int &lt;= a_int,</span>
<span class="line" id="L650">                            OP.ge =&gt; b_int &gt;= a_int,</span>
<span class="line" id="L651">                            OP.eq =&gt; b_int == a_int,</span>
<span class="line" id="L652">                            OP.lt =&gt; b_int &lt; a_int,</span>
<span class="line" id="L653">                            OP.gt =&gt; b_int &gt; a_int,</span>
<span class="line" id="L654">                            OP.ne =&gt; b_int != a_int,</span>
<span class="line" id="L655">                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L656">                        });</span>
<span class="line" id="L657"></span>
<span class="line" id="L658">                        self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{ .generic = result };</span>
<span class="line" id="L659">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L660">                        <span class="tok-comment">// TODO: Load the types referenced by these values, find their comparison operator, and run it</span>
</span>
<span class="line" id="L661">                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedTypedComparison;</span>
<span class="line" id="L662">                    }</span>
<span class="line" id="L663">                },</span>
<span class="line" id="L664">                OP.skip, OP.bra =&gt; {</span>
<span class="line" id="L665">                    <span class="tok-kw">const</span> branch_offset = operand.?.branch_offset;</span>
<span class="line" id="L666">                    <span class="tok-kw">const</span> condition = <span class="tok-kw">if</span> (opcode == OP.bra) blk: {</span>
<span class="line" id="L667">                        <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L668">                        <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> self.stack.pop().asIntegral() != <span class="tok-number">0</span>;</span>
<span class="line" id="L669">                    } <span class="tok-kw">else</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L670"></span>
<span class="line" id="L671">                    <span class="tok-kw">if</span> (condition) {</span>
<span class="line" id="L672">                        <span class="tok-kw">const</span> new_pos = std.math.cast(</span>
<span class="line" id="L673">                            <span class="tok-type">usize</span>,</span>
<span class="line" id="L674">                            <span class="tok-kw">try</span> std.math.add(<span class="tok-type">isize</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@intCast</span>(stream.pos)), branch_offset),</span>
<span class="line" id="L675">                        ) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L676"></span>
<span class="line" id="L677">                        <span class="tok-kw">if</span> (new_pos &lt; <span class="tok-number">0</span> <span class="tok-kw">or</span> new_pos &gt; stream.buffer.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L678">                        stream.pos = new_pos;</span>
<span class="line" id="L679">                    }</span>
<span class="line" id="L680">                },</span>
<span class="line" id="L681">                OP.call2,</span>
<span class="line" id="L682">                OP.call4,</span>
<span class="line" id="L683">                OP.call_ref,</span>
<span class="line" id="L684">                =&gt; {</span>
<span class="line" id="L685">                    <span class="tok-kw">const</span> debug_info_offset = operand.?.generic;</span>
<span class="line" id="L686">                    _ = debug_info_offset;</span>
<span class="line" id="L687"></span>
<span class="line" id="L688">                    <span class="tok-comment">// TODO: Load a DIE entry at debug_info_offset in a .debug_info section (the spec says that it</span>
</span>
<span class="line" id="L689">                    <span class="tok-comment">//       can be in a separate exe / shared object from the one containing this expression).</span>
</span>
<span class="line" id="L690">                    <span class="tok-comment">//       Transfer control to the DW_AT_location attribute, with the current stack as input.</span>
</span>
<span class="line" id="L691"></span>
<span class="line" id="L692">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedExpressionCall;</span>
<span class="line" id="L693">                },</span>
<span class="line" id="L694"></span>
<span class="line" id="L695">                <span class="tok-comment">// 2.5.1.6: Type Conversions</span>
</span>
<span class="line" id="L696">                OP.convert =&gt; {</span>
<span class="line" id="L697">                    <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L698">                    <span class="tok-kw">const</span> type_offset = operand.?.generic;</span>
<span class="line" id="L699"></span>
<span class="line" id="L700">                    <span class="tok-comment">// TODO: Load the DW_TAG_base_type entries in context.compile_unit and verify both types are the same size</span>
</span>
<span class="line" id="L701">                    <span class="tok-kw">const</span> value = self.stack.items[self.stack.items.len - <span class="tok-number">1</span>];</span>
<span class="line" id="L702">                    <span class="tok-kw">if</span> (type_offset == <span class="tok-number">0</span>) {</span>
<span class="line" id="L703">                        self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{ .generic = <span class="tok-kw">try</span> value.asIntegral() };</span>
<span class="line" id="L704">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L705">                        <span class="tok-comment">// TODO: Load the DW_TAG_base_type entry in context.compile_unit, find a conversion operator</span>
</span>
<span class="line" id="L706">                        <span class="tok-comment">//       from the old type to the new type, run it.</span>
</span>
<span class="line" id="L707">                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedTypeConversion;</span>
<span class="line" id="L708">                    }</span>
<span class="line" id="L709">                },</span>
<span class="line" id="L710">                OP.reinterpret =&gt; {</span>
<span class="line" id="L711">                    <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L712">                    <span class="tok-kw">const</span> type_offset = operand.?.generic;</span>
<span class="line" id="L713"></span>
<span class="line" id="L714">                    <span class="tok-comment">// TODO: Load the DW_TAG_base_type entries in context.compile_unit and verify both types are the same size</span>
</span>
<span class="line" id="L715">                    <span class="tok-kw">const</span> value = self.stack.items[self.stack.items.len - <span class="tok-number">1</span>];</span>
<span class="line" id="L716">                    <span class="tok-kw">if</span> (type_offset == <span class="tok-number">0</span>) {</span>
<span class="line" id="L717">                        self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{ .generic = <span class="tok-kw">try</span> value.asIntegral() };</span>
<span class="line" id="L718">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L719">                        self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = <span class="tok-kw">switch</span> (value) {</span>
<span class="line" id="L720">                            .generic =&gt; |v| .{</span>
<span class="line" id="L721">                                .regval_type = .{</span>
<span class="line" id="L722">                                    .type_offset = type_offset,</span>
<span class="line" id="L723">                                    .type_size = <span class="tok-builtin">@sizeOf</span>(addr_type),</span>
<span class="line" id="L724">                                    .value = v,</span>
<span class="line" id="L725">                                },</span>
<span class="line" id="L726">                            },</span>
<span class="line" id="L727">                            .regval_type =&gt; |r| .{</span>
<span class="line" id="L728">                                .regval_type = .{</span>
<span class="line" id="L729">                                    .type_offset = type_offset,</span>
<span class="line" id="L730">                                    .type_size = r.type_size,</span>
<span class="line" id="L731">                                    .value = r.value,</span>
<span class="line" id="L732">                                },</span>
<span class="line" id="L733">                            },</span>
<span class="line" id="L734">                            .const_type =&gt; |c| .{</span>
<span class="line" id="L735">                                .const_type = .{</span>
<span class="line" id="L736">                                    .type_offset = type_offset,</span>
<span class="line" id="L737">                                    .value_bytes = c.value_bytes,</span>
<span class="line" id="L738">                                },</span>
<span class="line" id="L739">                            },</span>
<span class="line" id="L740">                        };</span>
<span class="line" id="L741">                    }</span>
<span class="line" id="L742">                },</span>
<span class="line" id="L743"></span>
<span class="line" id="L744">                <span class="tok-comment">// 2.5.1.7: Special Operations</span>
</span>
<span class="line" id="L745">                OP.nop =&gt; {},</span>
<span class="line" id="L746">                OP.entry_value =&gt; {</span>
<span class="line" id="L747">                    <span class="tok-kw">const</span> block = operand.?.block;</span>
<span class="line" id="L748">                    <span class="tok-kw">if</span> (block.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidSubExpression;</span>
<span class="line" id="L749"></span>
<span class="line" id="L750">                    <span class="tok-comment">// TODO: The spec states that this sub-expression needs to observe the state (ie. registers)</span>
</span>
<span class="line" id="L751">                    <span class="tok-comment">//       as it was upon entering the current subprogram. If this isn't being called at the</span>
</span>
<span class="line" id="L752">                    <span class="tok-comment">//       end of a frame unwind operation, an additional ThreadContext with this state will be needed.</span>
</span>
<span class="line" id="L753"></span>
<span class="line" id="L754">                    <span class="tok-kw">if</span> (isOpcodeRegisterLocation(block[<span class="tok-number">0</span>])) {</span>
<span class="line" id="L755">                        <span class="tok-kw">if</span> (context.thread_context == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;</span>
<span class="line" id="L756"></span>
<span class="line" id="L757">                        <span class="tok-kw">var</span> block_stream = std.io.fixedBufferStream(block);</span>
<span class="line" id="L758">                        <span class="tok-kw">const</span> register = (<span class="tok-kw">try</span> readOperand(&amp;block_stream, block[<span class="tok-number">0</span>], context)).?.register;</span>
<span class="line" id="L759">                        <span class="tok-kw">const</span> value = mem.readIntSliceNative(<span class="tok-type">usize</span>, <span class="tok-kw">try</span> abi.regBytes(context.thread_context.?, register, context.reg_context));</span>
<span class="line" id="L760">                        <span class="tok-kw">try</span> self.stack.append(allocator, .{ .generic = value });</span>
<span class="line" id="L761">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L762">                        <span class="tok-kw">var</span> stack_machine: Self = .{};</span>
<span class="line" id="L763">                        <span class="tok-kw">defer</span> stack_machine.deinit(allocator);</span>
<span class="line" id="L764"></span>
<span class="line" id="L765">                        <span class="tok-kw">var</span> sub_context = context;</span>
<span class="line" id="L766">                        sub_context.entry_value_context = <span class="tok-null">true</span>;</span>
<span class="line" id="L767">                        <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> stack_machine.run(block, allocator, sub_context, <span class="tok-null">null</span>);</span>
<span class="line" id="L768">                        <span class="tok-kw">try</span> self.stack.append(allocator, result <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidSubExpression);</span>
<span class="line" id="L769">                    }</span>
<span class="line" id="L770">                },</span>
<span class="line" id="L771"></span>
<span class="line" id="L772">                <span class="tok-comment">// These have already been handled by readOperand</span>
</span>
<span class="line" id="L773">                OP.lo_user...OP.hi_user =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L774">                <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L775">                    <span class="tok-comment">//std.debug.print(&quot;Unknown DWARF expression opcode: {x}\n&quot;, .{opcode});</span>
</span>
<span class="line" id="L776">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownExpressionOpcode;</span>
<span class="line" id="L777">                },</span>
<span class="line" id="L778">            }</span>
<span class="line" id="L779"></span>
<span class="line" id="L780">            <span class="tok-kw">return</span> stream.pos &lt; stream.buffer.len;</span>
<span class="line" id="L781">        }</span>
<span class="line" id="L782">    };</span>
<span class="line" id="L783">}</span>
<span class="line" id="L784"></span>
<span class="line" id="L785"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Builder</span>(<span class="tok-kw">comptime</span> options: ExpressionOptions) <span class="tok-type">type</span> {</span>
<span class="line" id="L786">    <span class="tok-kw">const</span> addr_type = <span class="tok-kw">switch</span> (options.addr_size) {</span>
<span class="line" id="L787">        <span class="tok-number">2</span> =&gt; <span class="tok-type">u16</span>,</span>
<span class="line" id="L788">        <span class="tok-number">4</span> =&gt; <span class="tok-type">u32</span>,</span>
<span class="line" id="L789">        <span class="tok-number">8</span> =&gt; <span class="tok-type">u64</span>,</span>
<span class="line" id="L790">        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unsupported address size of &quot;</span> ++ options.addr_size),</span>
<span class="line" id="L791">    };</span>
<span class="line" id="L792"></span>
<span class="line" id="L793">    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L794">        <span class="tok-comment">/// Zero-operand instructions</span></span>
<span class="line" id="L795">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeOpcode</span>(writer: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> opcode: <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L796">            <span class="tok-kw">if</span> (options.call_frame_context <span class="tok-kw">and</span> !<span class="tok-kw">comptime</span> isOpcodeValidInCFA(opcode)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;</span>
<span class="line" id="L797">            <span class="tok-kw">switch</span> (opcode) {</span>
<span class="line" id="L798">                OP.dup,</span>
<span class="line" id="L799">                OP.drop,</span>
<span class="line" id="L800">                OP.over,</span>
<span class="line" id="L801">                OP.swap,</span>
<span class="line" id="L802">                OP.rot,</span>
<span class="line" id="L803">                OP.deref,</span>
<span class="line" id="L804">                OP.xderef,</span>
<span class="line" id="L805">                OP.push_object_address,</span>
<span class="line" id="L806">                OP.form_tls_address,</span>
<span class="line" id="L807">                OP.call_frame_cfa,</span>
<span class="line" id="L808">                OP.abs,</span>
<span class="line" id="L809">                OP.@&quot;and&quot;,</span>
<span class="line" id="L810">                OP.div,</span>
<span class="line" id="L811">                OP.minus,</span>
<span class="line" id="L812">                OP.mod,</span>
<span class="line" id="L813">                OP.mul,</span>
<span class="line" id="L814">                OP.neg,</span>
<span class="line" id="L815">                OP.not,</span>
<span class="line" id="L816">                OP.@&quot;or&quot;,</span>
<span class="line" id="L817">                OP.plus,</span>
<span class="line" id="L818">                OP.shl,</span>
<span class="line" id="L819">                OP.shr,</span>
<span class="line" id="L820">                OP.shra,</span>
<span class="line" id="L821">                OP.xor,</span>
<span class="line" id="L822">                OP.le,</span>
<span class="line" id="L823">                OP.ge,</span>
<span class="line" id="L824">                OP.eq,</span>
<span class="line" id="L825">                OP.lt,</span>
<span class="line" id="L826">                OP.gt,</span>
<span class="line" id="L827">                OP.ne,</span>
<span class="line" id="L828">                OP.nop,</span>
<span class="line" id="L829">                OP.stack_value,</span>
<span class="line" id="L830">                =&gt; <span class="tok-kw">try</span> writer.writeByte(opcode),</span>
<span class="line" id="L831">                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;This opcode requires operands, use `write&lt;Opcode&gt;()` instead&quot;</span>),</span>
<span class="line" id="L832">            }</span>
<span class="line" id="L833">        }</span>
<span class="line" id="L834"></span>
<span class="line" id="L835">        <span class="tok-comment">// 2.5.1.1: Literal Encodings</span>
</span>
<span class="line" id="L836">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeLiteral</span>(writer: <span class="tok-kw">anytype</span>, literal: <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L837">            <span class="tok-kw">switch</span> (literal) {</span>
<span class="line" id="L838">                <span class="tok-number">0</span>...<span class="tok-number">31</span> =&gt; |n| <span class="tok-kw">try</span> writer.writeByte(n + OP.lit0),</span>
<span class="line" id="L839">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidLiteral,</span>
<span class="line" id="L840">            }</span>
<span class="line" id="L841">        }</span>
<span class="line" id="L842"></span>
<span class="line" id="L843">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeConst</span>(writer: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, value: T) !<span class="tok-type">void</span> {</span>
<span class="line" id="L844">            <span class="tok-kw">if</span> (<span class="tok-builtin">@typeInfo</span>(T) != .Int) <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Constants must be integers&quot;</span>);</span>
<span class="line" id="L845"></span>
<span class="line" id="L846">            <span class="tok-kw">switch</span> (T) {</span>
<span class="line" id="L847">                <span class="tok-type">u8</span>, <span class="tok-type">i8</span>, <span class="tok-type">u16</span>, <span class="tok-type">i16</span>, <span class="tok-type">u32</span>, <span class="tok-type">i32</span>, <span class="tok-type">u64</span>, <span class="tok-type">i64</span> =&gt; {</span>
<span class="line" id="L848">                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-kw">switch</span> (T) {</span>
<span class="line" id="L849">                        <span class="tok-type">u8</span> =&gt; OP.const1u,</span>
<span class="line" id="L850">                        <span class="tok-type">i8</span> =&gt; OP.const1s,</span>
<span class="line" id="L851">                        <span class="tok-type">u16</span> =&gt; OP.const2u,</span>
<span class="line" id="L852">                        <span class="tok-type">i16</span> =&gt; OP.const2s,</span>
<span class="line" id="L853">                        <span class="tok-type">u32</span> =&gt; OP.const4u,</span>
<span class="line" id="L854">                        <span class="tok-type">i32</span> =&gt; OP.const4s,</span>
<span class="line" id="L855">                        <span class="tok-type">u64</span> =&gt; OP.const8u,</span>
<span class="line" id="L856">                        <span class="tok-type">i64</span> =&gt; OP.const8s,</span>
<span class="line" id="L857">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L858">                    });</span>
<span class="line" id="L859"></span>
<span class="line" id="L860">                    <span class="tok-kw">try</span> writer.writeInt(T, value, options.endian);</span>
<span class="line" id="L861">                },</span>
<span class="line" id="L862">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T).Int.signedness) {</span>
<span class="line" id="L863">                    .unsigned =&gt; {</span>
<span class="line" id="L864">                        <span class="tok-kw">try</span> writer.writeByte(OP.constu);</span>
<span class="line" id="L865">                        <span class="tok-kw">try</span> leb.writeULEB128(writer, value);</span>
<span class="line" id="L866">                    },</span>
<span class="line" id="L867">                    .signed =&gt; {</span>
<span class="line" id="L868">                        <span class="tok-kw">try</span> writer.writeByte(OP.consts);</span>
<span class="line" id="L869">                        <span class="tok-kw">try</span> leb.writeILEB128(writer, value);</span>
<span class="line" id="L870">                    },</span>
<span class="line" id="L871">                },</span>
<span class="line" id="L872">            }</span>
<span class="line" id="L873">        }</span>
<span class="line" id="L874"></span>
<span class="line" id="L875">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeConstx</span>(writer: <span class="tok-kw">anytype</span>, debug_addr_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L876">            <span class="tok-kw">try</span> writer.writeByte(OP.constx);</span>
<span class="line" id="L877">            <span class="tok-kw">try</span> leb.writeULEB128(writer, debug_addr_offset);</span>
<span class="line" id="L878">        }</span>
<span class="line" id="L879"></span>
<span class="line" id="L880">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeConstType</span>(writer: <span class="tok-kw">anytype</span>, die_offset: <span class="tok-kw">anytype</span>, value_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L881">            <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;</span>
<span class="line" id="L882">            <span class="tok-kw">if</span> (value_bytes.len &gt; <span class="tok-number">0xff</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidTypeLength;</span>
<span class="line" id="L883">            <span class="tok-kw">try</span> writer.writeByte(OP.const_type);</span>
<span class="line" id="L884">            <span class="tok-kw">try</span> leb.writeULEB128(writer, die_offset);</span>
<span class="line" id="L885">            <span class="tok-kw">try</span> writer.writeByte(<span class="tok-builtin">@intCast</span>(value_bytes.len));</span>
<span class="line" id="L886">            <span class="tok-kw">try</span> writer.writeAll(value_bytes);</span>
<span class="line" id="L887">        }</span>
<span class="line" id="L888"></span>
<span class="line" id="L889">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeAddr</span>(writer: <span class="tok-kw">anytype</span>, value: addr_type) !<span class="tok-type">void</span> {</span>
<span class="line" id="L890">            <span class="tok-kw">try</span> writer.writeByte(OP.addr);</span>
<span class="line" id="L891">            <span class="tok-kw">try</span> writer.writeInt(addr_type, value, options.endian);</span>
<span class="line" id="L892">        }</span>
<span class="line" id="L893"></span>
<span class="line" id="L894">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeAddrx</span>(writer: <span class="tok-kw">anytype</span>, debug_addr_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L895">            <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;</span>
<span class="line" id="L896">            <span class="tok-kw">try</span> writer.writeByte(OP.addrx);</span>
<span class="line" id="L897">            <span class="tok-kw">try</span> leb.writeULEB128(writer, debug_addr_offset);</span>
<span class="line" id="L898">        }</span>
<span class="line" id="L899"></span>
<span class="line" id="L900">        <span class="tok-comment">// 2.5.1.2: Register Values</span>
</span>
<span class="line" id="L901">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeFbreg</span>(writer: <span class="tok-kw">anytype</span>, offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L902">            <span class="tok-kw">try</span> writer.writeByte(OP.fbreg);</span>
<span class="line" id="L903">            <span class="tok-kw">try</span> leb.writeILEB128(writer, offset);</span>
<span class="line" id="L904">        }</span>
<span class="line" id="L905"></span>
<span class="line" id="L906">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeBreg</span>(writer: <span class="tok-kw">anytype</span>, register: <span class="tok-type">u8</span>, offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L907">            <span class="tok-kw">if</span> (register &gt; <span class="tok-number">31</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidRegister;</span>
<span class="line" id="L908">            <span class="tok-kw">try</span> writer.writeByte(OP.breg0 + register);</span>
<span class="line" id="L909">            <span class="tok-kw">try</span> leb.writeILEB128(writer, offset);</span>
<span class="line" id="L910">        }</span>
<span class="line" id="L911"></span>
<span class="line" id="L912">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeBregx</span>(writer: <span class="tok-kw">anytype</span>, register: <span class="tok-kw">anytype</span>, offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L913">            <span class="tok-kw">try</span> writer.writeByte(OP.bregx);</span>
<span class="line" id="L914">            <span class="tok-kw">try</span> leb.writeULEB128(writer, register);</span>
<span class="line" id="L915">            <span class="tok-kw">try</span> leb.writeILEB128(writer, offset);</span>
<span class="line" id="L916">        }</span>
<span class="line" id="L917"></span>
<span class="line" id="L918">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeRegvalType</span>(writer: <span class="tok-kw">anytype</span>, register: <span class="tok-kw">anytype</span>, offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L919">            <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;</span>
<span class="line" id="L920">            <span class="tok-kw">try</span> writer.writeByte(OP.regval_type);</span>
<span class="line" id="L921">            <span class="tok-kw">try</span> leb.writeULEB128(writer, register);</span>
<span class="line" id="L922">            <span class="tok-kw">try</span> leb.writeULEB128(writer, offset);</span>
<span class="line" id="L923">        }</span>
<span class="line" id="L924"></span>
<span class="line" id="L925">        <span class="tok-comment">// 2.5.1.3: Stack Operations</span>
</span>
<span class="line" id="L926">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writePick</span>(writer: <span class="tok-kw">anytype</span>, index: <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L927">            <span class="tok-kw">try</span> writer.writeByte(OP.pick);</span>
<span class="line" id="L928">            <span class="tok-kw">try</span> writer.writeByte(index);</span>
<span class="line" id="L929">        }</span>
<span class="line" id="L930"></span>
<span class="line" id="L931">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeDerefSize</span>(writer: <span class="tok-kw">anytype</span>, size: <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L932">            <span class="tok-kw">try</span> writer.writeByte(OP.deref_size);</span>
<span class="line" id="L933">            <span class="tok-kw">try</span> writer.writeByte(size);</span>
<span class="line" id="L934">        }</span>
<span class="line" id="L935"></span>
<span class="line" id="L936">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeXDerefSize</span>(writer: <span class="tok-kw">anytype</span>, size: <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L937">            <span class="tok-kw">try</span> writer.writeByte(OP.xderef_size);</span>
<span class="line" id="L938">            <span class="tok-kw">try</span> writer.writeByte(size);</span>
<span class="line" id="L939">        }</span>
<span class="line" id="L940"></span>
<span class="line" id="L941">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeDerefType</span>(writer: <span class="tok-kw">anytype</span>, size: <span class="tok-type">u8</span>, die_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L942">            <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;</span>
<span class="line" id="L943">            <span class="tok-kw">try</span> writer.writeByte(OP.deref_type);</span>
<span class="line" id="L944">            <span class="tok-kw">try</span> writer.writeByte(size);</span>
<span class="line" id="L945">            <span class="tok-kw">try</span> leb.writeULEB128(writer, die_offset);</span>
<span class="line" id="L946">        }</span>
<span class="line" id="L947"></span>
<span class="line" id="L948">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeXDerefType</span>(writer: <span class="tok-kw">anytype</span>, size: <span class="tok-type">u8</span>, die_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L949">            <span class="tok-kw">try</span> writer.writeByte(OP.xderef_type);</span>
<span class="line" id="L950">            <span class="tok-kw">try</span> writer.writeByte(size);</span>
<span class="line" id="L951">            <span class="tok-kw">try</span> leb.writeULEB128(writer, die_offset);</span>
<span class="line" id="L952">        }</span>
<span class="line" id="L953"></span>
<span class="line" id="L954">        <span class="tok-comment">// 2.5.1.4: Arithmetic and Logical Operations</span>
</span>
<span class="line" id="L955"></span>
<span class="line" id="L956">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writePlusUconst</span>(writer: <span class="tok-kw">anytype</span>, uint_value: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L957">            <span class="tok-kw">try</span> writer.writeByte(OP.plus_uconst);</span>
<span class="line" id="L958">            <span class="tok-kw">try</span> leb.writeULEB128(writer, uint_value);</span>
<span class="line" id="L959">        }</span>
<span class="line" id="L960"></span>
<span class="line" id="L961">        <span class="tok-comment">// 2.5.1.5: Control Flow Operations</span>
</span>
<span class="line" id="L962"></span>
<span class="line" id="L963">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeSkip</span>(writer: <span class="tok-kw">anytype</span>, offset: <span class="tok-type">i16</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L964">            <span class="tok-kw">try</span> writer.writeByte(OP.skip);</span>
<span class="line" id="L965">            <span class="tok-kw">try</span> writer.writeInt(<span class="tok-type">i16</span>, offset, options.endian);</span>
<span class="line" id="L966">        }</span>
<span class="line" id="L967"></span>
<span class="line" id="L968">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeBra</span>(writer: <span class="tok-kw">anytype</span>, offset: <span class="tok-type">i16</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L969">            <span class="tok-kw">try</span> writer.writeByte(OP.bra);</span>
<span class="line" id="L970">            <span class="tok-kw">try</span> writer.writeInt(<span class="tok-type">i16</span>, offset, options.endian);</span>
<span class="line" id="L971">        }</span>
<span class="line" id="L972"></span>
<span class="line" id="L973">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeCall</span>(writer: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, offset: T) !<span class="tok-type">void</span> {</span>
<span class="line" id="L974">            <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;</span>
<span class="line" id="L975">            <span class="tok-kw">switch</span> (T) {</span>
<span class="line" id="L976">                <span class="tok-type">u16</span> =&gt; <span class="tok-kw">try</span> writer.writeByte(OP.call2),</span>
<span class="line" id="L977">                <span class="tok-type">u32</span> =&gt; <span class="tok-kw">try</span> writer.writeByte(OP.call4),</span>
<span class="line" id="L978">                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Call operand must be a 2 or 4 byte offset&quot;</span>),</span>
<span class="line" id="L979">            }</span>
<span class="line" id="L980"></span>
<span class="line" id="L981">            <span class="tok-kw">try</span> writer.writeInt(T, offset, options.endian);</span>
<span class="line" id="L982">        }</span>
<span class="line" id="L983"></span>
<span class="line" id="L984">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeCallRef</span>(writer: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> is_64: <span class="tok-type">bool</span>, value: <span class="tok-kw">if</span> (is_64) <span class="tok-type">u64</span> <span class="tok-kw">else</span> <span class="tok-type">u32</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L985">            <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;</span>
<span class="line" id="L986">            <span class="tok-kw">try</span> writer.writeByte(OP.call_ref);</span>
<span class="line" id="L987">            <span class="tok-kw">try</span> writer.writeInt(<span class="tok-kw">if</span> (is_64) <span class="tok-type">u64</span> <span class="tok-kw">else</span> <span class="tok-type">u32</span>, value, options.endian);</span>
<span class="line" id="L988">        }</span>
<span class="line" id="L989"></span>
<span class="line" id="L990">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeConvert</span>(writer: <span class="tok-kw">anytype</span>, die_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L991">            <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;</span>
<span class="line" id="L992">            <span class="tok-kw">try</span> writer.writeByte(OP.convert);</span>
<span class="line" id="L993">            <span class="tok-kw">try</span> leb.writeULEB128(writer, die_offset);</span>
<span class="line" id="L994">        }</span>
<span class="line" id="L995"></span>
<span class="line" id="L996">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeReinterpret</span>(writer: <span class="tok-kw">anytype</span>, die_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L997">            <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;</span>
<span class="line" id="L998">            <span class="tok-kw">try</span> writer.writeByte(OP.reinterpret);</span>
<span class="line" id="L999">            <span class="tok-kw">try</span> leb.writeULEB128(writer, die_offset);</span>
<span class="line" id="L1000">        }</span>
<span class="line" id="L1001"></span>
<span class="line" id="L1002">        <span class="tok-comment">// 2.5.1.7: Special Operations</span>
</span>
<span class="line" id="L1003"></span>
<span class="line" id="L1004">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeEntryValue</span>(writer: <span class="tok-kw">anytype</span>, expression: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1005">            <span class="tok-kw">try</span> writer.writeByte(OP.entry_value);</span>
<span class="line" id="L1006">            <span class="tok-kw">try</span> leb.writeULEB128(writer, expression.len);</span>
<span class="line" id="L1007">            <span class="tok-kw">try</span> writer.writeAll(expression);</span>
<span class="line" id="L1008">        }</span>
<span class="line" id="L1009"></span>
<span class="line" id="L1010">        <span class="tok-comment">// 2.6: Location Descriptions</span>
</span>
<span class="line" id="L1011">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeReg</span>(writer: <span class="tok-kw">anytype</span>, register: <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1012">            <span class="tok-kw">try</span> writer.writeByte(OP.reg0 + register);</span>
<span class="line" id="L1013">        }</span>
<span class="line" id="L1014"></span>
<span class="line" id="L1015">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeRegx</span>(writer: <span class="tok-kw">anytype</span>, register: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1016">            <span class="tok-kw">try</span> writer.writeByte(OP.regx);</span>
<span class="line" id="L1017">            <span class="tok-kw">try</span> leb.writeULEB128(writer, register);</span>
<span class="line" id="L1018">        }</span>
<span class="line" id="L1019"></span>
<span class="line" id="L1020">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeImplicitValue</span>(writer: <span class="tok-kw">anytype</span>, value_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1021">            <span class="tok-kw">try</span> writer.writeByte(OP.implicit_value);</span>
<span class="line" id="L1022">            <span class="tok-kw">try</span> leb.writeULEB128(writer, value_bytes.len);</span>
<span class="line" id="L1023">            <span class="tok-kw">try</span> writer.writeAll(value_bytes);</span>
<span class="line" id="L1024">        }</span>
<span class="line" id="L1025">    };</span>
<span class="line" id="L1026">}</span>
<span class="line" id="L1027"></span>
<span class="line" id="L1028"><span class="tok-comment">// Certain opcodes are not allowed in a CFA context, see 6.4.2</span>
</span>
<span class="line" id="L1029"><span class="tok-kw">fn</span> <span class="tok-fn">isOpcodeValidInCFA</span>(opcode: <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L1030">    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (opcode) {</span>
<span class="line" id="L1031">        OP.addrx,</span>
<span class="line" id="L1032">        OP.call2,</span>
<span class="line" id="L1033">        OP.call4,</span>
<span class="line" id="L1034">        OP.call_ref,</span>
<span class="line" id="L1035">        OP.const_type,</span>
<span class="line" id="L1036">        OP.constx,</span>
<span class="line" id="L1037">        OP.convert,</span>
<span class="line" id="L1038">        OP.deref_type,</span>
<span class="line" id="L1039">        OP.regval_type,</span>
<span class="line" id="L1040">        OP.reinterpret,</span>
<span class="line" id="L1041">        OP.push_object_address,</span>
<span class="line" id="L1042">        OP.call_frame_cfa,</span>
<span class="line" id="L1043">        =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L1044">        <span class="tok-kw">else</span> =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L1045">    };</span>
<span class="line" id="L1046">}</span>
<span class="line" id="L1047"></span>
<span class="line" id="L1048"><span class="tok-kw">fn</span> <span class="tok-fn">isOpcodeRegisterLocation</span>(opcode: <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L1049">    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (opcode) {</span>
<span class="line" id="L1050">        OP.reg0...OP.reg31, OP.regx =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L1051">        <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L1052">    };</span>
<span class="line" id="L1053">}</span>
<span class="line" id="L1054"></span>
<span class="line" id="L1055"><span class="tok-kw">const</span> testing = std.testing;</span>
<span class="line" id="L1056"><span class="tok-kw">test</span> <span class="tok-str">&quot;DWARF expressions&quot;</span> {</span>
<span class="line" id="L1057">    <span class="tok-kw">const</span> allocator = std.testing.allocator;</span>
<span class="line" id="L1058"></span>
<span class="line" id="L1059">    <span class="tok-kw">const</span> options = ExpressionOptions{};</span>
<span class="line" id="L1060">    <span class="tok-kw">var</span> stack_machine = StackMachine(options){};</span>
<span class="line" id="L1061">    <span class="tok-kw">defer</span> stack_machine.deinit(allocator);</span>
<span class="line" id="L1062"></span>
<span class="line" id="L1063">    <span class="tok-kw">const</span> b = Builder(options);</span>
<span class="line" id="L1064"></span>
<span class="line" id="L1065">    <span class="tok-kw">var</span> program = std.ArrayList(<span class="tok-type">u8</span>).init(allocator);</span>
<span class="line" id="L1066">    <span class="tok-kw">defer</span> program.deinit();</span>
<span class="line" id="L1067"></span>
<span class="line" id="L1068">    <span class="tok-kw">const</span> writer = program.writer();</span>
<span class="line" id="L1069"></span>
<span class="line" id="L1070">    <span class="tok-comment">// Literals</span>
</span>
<span class="line" id="L1071">    {</span>
<span class="line" id="L1072">        <span class="tok-kw">const</span> context = ExpressionContext{};</span>
<span class="line" id="L1073">        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<span class="tok-number">32</span>) |i| {</span>
<span class="line" id="L1074">            <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-builtin">@intCast</span>(i));</span>
<span class="line" id="L1075">        }</span>
<span class="line" id="L1076"></span>
<span class="line" id="L1077">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-number">0</span>);</span>
<span class="line" id="L1078"></span>
<span class="line" id="L1079">        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<span class="tok-number">32</span>) |i| {</span>
<span class="line" id="L1080">            <span class="tok-kw">const</span> expected = <span class="tok-number">31</span> - i;</span>
<span class="line" id="L1081">            <span class="tok-kw">try</span> testing.expectEqual(expected, stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1082">        }</span>
<span class="line" id="L1083">    }</span>
<span class="line" id="L1084"></span>
<span class="line" id="L1085">    <span class="tok-comment">// Constants</span>
</span>
<span class="line" id="L1086">    {</span>
<span class="line" id="L1087">        stack_machine.reset();</span>
<span class="line" id="L1088">        program.clearRetainingCapacity();</span>
<span class="line" id="L1089"></span>
<span class="line" id="L1090">        <span class="tok-kw">const</span> input = [_]<span class="tok-type">comptime_int</span>{</span>
<span class="line" id="L1091">            <span class="tok-number">1</span>,</span>
<span class="line" id="L1092">            -<span class="tok-number">1</span>,</span>
<span class="line" id="L1093">            <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(<span class="tok-number">0x0fff</span>)),</span>
<span class="line" id="L1094">            <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@truncate</span>(-<span class="tok-number">0x0fff</span>)),</span>
<span class="line" id="L1095">            <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(<span class="tok-number">0x0fffffff</span>)),</span>
<span class="line" id="L1096">            <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@truncate</span>(-<span class="tok-number">0x0fffffff</span>)),</span>
<span class="line" id="L1097">            <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(<span class="tok-number">0x0fffffffffffffff</span>)),</span>
<span class="line" id="L1098">            <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@truncate</span>(-<span class="tok-number">0x0fffffffffffffff</span>)),</span>
<span class="line" id="L1099">            <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(<span class="tok-number">0x8000000</span>)),</span>
<span class="line" id="L1100">            <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@truncate</span>(-<span class="tok-number">0x8000000</span>)),</span>
<span class="line" id="L1101">            <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(<span class="tok-number">0x12345678_12345678</span>)),</span>
<span class="line" id="L1102">            <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(<span class="tok-number">0xffffffff_ffffffff</span>)),</span>
<span class="line" id="L1103">            <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(<span class="tok-number">0xeeeeeeee_eeeeeeee</span>)),</span>
<span class="line" id="L1104">        };</span>
<span class="line" id="L1105"></span>
<span class="line" id="L1106">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, input[<span class="tok-number">0</span>]);</span>
<span class="line" id="L1107">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">i8</span>, input[<span class="tok-number">1</span>]);</span>
<span class="line" id="L1108">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, input[<span class="tok-number">2</span>]);</span>
<span class="line" id="L1109">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">i16</span>, input[<span class="tok-number">3</span>]);</span>
<span class="line" id="L1110">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u32</span>, input[<span class="tok-number">4</span>]);</span>
<span class="line" id="L1111">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">i32</span>, input[<span class="tok-number">5</span>]);</span>
<span class="line" id="L1112">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u64</span>, input[<span class="tok-number">6</span>]);</span>
<span class="line" id="L1113">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">i64</span>, input[<span class="tok-number">7</span>]);</span>
<span class="line" id="L1114">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u28</span>, input[<span class="tok-number">8</span>]);</span>
<span class="line" id="L1115">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">i28</span>, input[<span class="tok-number">9</span>]);</span>
<span class="line" id="L1116">        <span class="tok-kw">try</span> b.writeAddr(writer, input[<span class="tok-number">10</span>]);</span>
<span class="line" id="L1117"></span>
<span class="line" id="L1118">        <span class="tok-kw">var</span> mock_compile_unit: dwarf.CompileUnit = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1119">        mock_compile_unit.addr_base = <span class="tok-number">1</span>;</span>
<span class="line" id="L1120"></span>
<span class="line" id="L1121">        <span class="tok-kw">var</span> mock_debug_addr = std.ArrayList(<span class="tok-type">u8</span>).init(allocator);</span>
<span class="line" id="L1122">        <span class="tok-kw">defer</span> mock_debug_addr.deinit();</span>
<span class="line" id="L1123"></span>
<span class="line" id="L1124">        <span class="tok-kw">try</span> mock_debug_addr.writer().writeIntNative(<span class="tok-type">u16</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L1125">        <span class="tok-kw">try</span> mock_debug_addr.writer().writeIntNative(<span class="tok-type">usize</span>, input[<span class="tok-number">11</span>]);</span>
<span class="line" id="L1126">        <span class="tok-kw">try</span> mock_debug_addr.writer().writeIntNative(<span class="tok-type">usize</span>, input[<span class="tok-number">12</span>]);</span>
<span class="line" id="L1127"></span>
<span class="line" id="L1128">        <span class="tok-kw">const</span> context = ExpressionContext{</span>
<span class="line" id="L1129">            .compile_unit = &amp;mock_compile_unit,</span>
<span class="line" id="L1130">            .debug_addr = mock_debug_addr.items,</span>
<span class="line" id="L1131">        };</span>
<span class="line" id="L1132"></span>
<span class="line" id="L1133">        <span class="tok-kw">try</span> b.writeConstx(writer, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>));</span>
<span class="line" id="L1134">        <span class="tok-kw">try</span> b.writeAddrx(writer, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span> + <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)));</span>
<span class="line" id="L1135"></span>
<span class="line" id="L1136">        <span class="tok-kw">const</span> die_offset: <span class="tok-type">usize</span> = <span class="tok-builtin">@truncate</span>(<span class="tok-number">0xaabbccdd</span>);</span>
<span class="line" id="L1137">        <span class="tok-kw">const</span> type_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;.{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };</span>
<span class="line" id="L1138">        <span class="tok-kw">try</span> b.writeConstType(writer, die_offset, type_bytes);</span>
<span class="line" id="L1139"></span>
<span class="line" id="L1140">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-number">0</span>);</span>
<span class="line" id="L1141"></span>
<span class="line" id="L1142">        <span class="tok-kw">const</span> const_type = stack_machine.stack.popOrNull().?.const_type;</span>
<span class="line" id="L1143">        <span class="tok-kw">try</span> testing.expectEqual(die_offset, const_type.type_offset);</span>
<span class="line" id="L1144">        <span class="tok-kw">try</span> testing.expectEqualSlices(<span class="tok-type">u8</span>, type_bytes, const_type.value_bytes);</span>
<span class="line" id="L1145"></span>
<span class="line" id="L1146">        <span class="tok-kw">const</span> expected = .{</span>
<span class="line" id="L1147">            .{ <span class="tok-type">usize</span>, input[<span class="tok-number">12</span>], <span class="tok-type">usize</span> },</span>
<span class="line" id="L1148">            .{ <span class="tok-type">usize</span>, input[<span class="tok-number">11</span>], <span class="tok-type">usize</span> },</span>
<span class="line" id="L1149">            .{ <span class="tok-type">usize</span>, input[<span class="tok-number">10</span>], <span class="tok-type">usize</span> },</span>
<span class="line" id="L1150">            .{ <span class="tok-type">isize</span>, input[<span class="tok-number">9</span>], <span class="tok-type">isize</span> },</span>
<span class="line" id="L1151">            .{ <span class="tok-type">usize</span>, input[<span class="tok-number">8</span>], <span class="tok-type">usize</span> },</span>
<span class="line" id="L1152">            .{ <span class="tok-type">isize</span>, input[<span class="tok-number">7</span>], <span class="tok-type">isize</span> },</span>
<span class="line" id="L1153">            .{ <span class="tok-type">usize</span>, input[<span class="tok-number">6</span>], <span class="tok-type">usize</span> },</span>
<span class="line" id="L1154">            .{ <span class="tok-type">isize</span>, input[<span class="tok-number">5</span>], <span class="tok-type">isize</span> },</span>
<span class="line" id="L1155">            .{ <span class="tok-type">usize</span>, input[<span class="tok-number">4</span>], <span class="tok-type">usize</span> },</span>
<span class="line" id="L1156">            .{ <span class="tok-type">isize</span>, input[<span class="tok-number">3</span>], <span class="tok-type">isize</span> },</span>
<span class="line" id="L1157">            .{ <span class="tok-type">usize</span>, input[<span class="tok-number">2</span>], <span class="tok-type">usize</span> },</span>
<span class="line" id="L1158">            .{ <span class="tok-type">isize</span>, input[<span class="tok-number">1</span>], <span class="tok-type">isize</span> },</span>
<span class="line" id="L1159">            .{ <span class="tok-type">usize</span>, input[<span class="tok-number">0</span>], <span class="tok-type">usize</span> },</span>
<span class="line" id="L1160">        };</span>
<span class="line" id="L1161"></span>
<span class="line" id="L1162">        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (expected) |e| {</span>
<span class="line" id="L1163">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(e[<span class="tok-number">0</span>], e[<span class="tok-number">1</span>]), <span class="tok-builtin">@as</span>(e[<span class="tok-number">2</span>], <span class="tok-builtin">@bitCast</span>(stack_machine.stack.popOrNull().?.generic)));</span>
<span class="line" id="L1164">        }</span>
<span class="line" id="L1165">    }</span>
<span class="line" id="L1166"></span>
<span class="line" id="L1167">    <span class="tok-comment">// Register values</span>
</span>
<span class="line" id="L1168">    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(std.debug.ThreadContext) != <span class="tok-number">0</span>) {</span>
<span class="line" id="L1169">        stack_machine.reset();</span>
<span class="line" id="L1170">        program.clearRetainingCapacity();</span>
<span class="line" id="L1171"></span>
<span class="line" id="L1172">        <span class="tok-kw">const</span> reg_context = abi.RegisterContext{</span>
<span class="line" id="L1173">            .eh_frame = <span class="tok-null">true</span>,</span>
<span class="line" id="L1174">            .is_macho = builtin.os.tag == .macos,</span>
<span class="line" id="L1175">        };</span>
<span class="line" id="L1176">        <span class="tok-kw">var</span> thread_context: std.debug.ThreadContext = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1177">        std.debug.relocateContext(&amp;thread_context);</span>
<span class="line" id="L1178">        <span class="tok-kw">const</span> context = ExpressionContext{</span>
<span class="line" id="L1179">            .thread_context = &amp;thread_context,</span>
<span class="line" id="L1180">            .reg_context = reg_context,</span>
<span class="line" id="L1181">        };</span>
<span class="line" id="L1182"></span>
<span class="line" id="L1183">        <span class="tok-comment">// Only test register operations on arch / os that have them implemented</span>
</span>
<span class="line" id="L1184">        <span class="tok-kw">if</span> (abi.regBytes(&amp;thread_context, <span class="tok-number">0</span>, reg_context)) |reg_bytes| {</span>
<span class="line" id="L1185"></span>
<span class="line" id="L1186">            <span class="tok-comment">// TODO: Test fbreg (once implemented): mock a DIE and point compile_unit.frame_base at it</span>
</span>
<span class="line" id="L1187"></span>
<span class="line" id="L1188">            mem.writeIntSliceNative(<span class="tok-type">usize</span>, reg_bytes, <span class="tok-number">0xee</span>);</span>
<span class="line" id="L1189">            (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, &amp;thread_context, abi.fpRegNum(reg_context), reg_context)).* = <span class="tok-number">1</span>;</span>
<span class="line" id="L1190">            (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, &amp;thread_context, abi.spRegNum(reg_context), reg_context)).* = <span class="tok-number">2</span>;</span>
<span class="line" id="L1191">            (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, &amp;thread_context, abi.ipRegNum(), reg_context)).* = <span class="tok-number">3</span>;</span>
<span class="line" id="L1192"></span>
<span class="line" id="L1193">            <span class="tok-kw">try</span> b.writeBreg(writer, abi.fpRegNum(reg_context), <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">100</span>));</span>
<span class="line" id="L1194">            <span class="tok-kw">try</span> b.writeBreg(writer, abi.spRegNum(reg_context), <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">200</span>));</span>
<span class="line" id="L1195">            <span class="tok-kw">try</span> b.writeBregx(writer, abi.ipRegNum(), <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">300</span>));</span>
<span class="line" id="L1196">            <span class="tok-kw">try</span> b.writeRegvalType(writer, <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0</span>), <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">400</span>));</span>
<span class="line" id="L1197"></span>
<span class="line" id="L1198">            _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-number">0</span>);</span>
<span class="line" id="L1199"></span>
<span class="line" id="L1200">            <span class="tok-kw">const</span> regval_type = stack_machine.stack.popOrNull().?.regval_type;</span>
<span class="line" id="L1201">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">400</span>), regval_type.type_offset);</span>
<span class="line" id="L1202">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)), regval_type.type_size);</span>
<span class="line" id="L1203">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0xee</span>), regval_type.value);</span>
<span class="line" id="L1204"></span>
<span class="line" id="L1205">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">303</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1206">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">202</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1207">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">101</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1208">        } <span class="tok-kw">else</span> |err| {</span>
<span class="line" id="L1209">            <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1210">                <span class="tok-kw">error</span>.UnimplementedArch,</span>
<span class="line" id="L1211">                <span class="tok-kw">error</span>.UnimplementedOs,</span>
<span class="line" id="L1212">                <span class="tok-kw">error</span>.ThreadContextNotSupported,</span>
<span class="line" id="L1213">                =&gt; {},</span>
<span class="line" id="L1214">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L1215">            }</span>
<span class="line" id="L1216">        }</span>
<span class="line" id="L1217">    }</span>
<span class="line" id="L1218"></span>
<span class="line" id="L1219">    <span class="tok-comment">// Stack operations</span>
</span>
<span class="line" id="L1220">    {</span>
<span class="line" id="L1221">        <span class="tok-kw">var</span> context = ExpressionContext{};</span>
<span class="line" id="L1222"></span>
<span class="line" id="L1223">        stack_machine.reset();</span>
<span class="line" id="L1224">        program.clearRetainingCapacity();</span>
<span class="line" id="L1225">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">1</span>);</span>
<span class="line" id="L1226">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.dup);</span>
<span class="line" id="L1227">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1228">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1229">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1230"></span>
<span class="line" id="L1231">        stack_machine.reset();</span>
<span class="line" id="L1232">        program.clearRetainingCapacity();</span>
<span class="line" id="L1233">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">1</span>);</span>
<span class="line" id="L1234">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.drop);</span>
<span class="line" id="L1235">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1236">        <span class="tok-kw">try</span> testing.expect(stack_machine.stack.popOrNull() == <span class="tok-null">null</span>);</span>
<span class="line" id="L1237"></span>
<span class="line" id="L1238">        stack_machine.reset();</span>
<span class="line" id="L1239">        program.clearRetainingCapacity();</span>
<span class="line" id="L1240">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">4</span>);</span>
<span class="line" id="L1241">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">5</span>);</span>
<span class="line" id="L1242">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">6</span>);</span>
<span class="line" id="L1243">        <span class="tok-kw">try</span> b.writePick(writer, <span class="tok-number">2</span>);</span>
<span class="line" id="L1244">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1245">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">4</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1246"></span>
<span class="line" id="L1247">        stack_machine.reset();</span>
<span class="line" id="L1248">        program.clearRetainingCapacity();</span>
<span class="line" id="L1249">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">4</span>);</span>
<span class="line" id="L1250">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">5</span>);</span>
<span class="line" id="L1251">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">6</span>);</span>
<span class="line" id="L1252">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.over);</span>
<span class="line" id="L1253">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1254">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">5</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1255"></span>
<span class="line" id="L1256">        stack_machine.reset();</span>
<span class="line" id="L1257">        program.clearRetainingCapacity();</span>
<span class="line" id="L1258">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">5</span>);</span>
<span class="line" id="L1259">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">6</span>);</span>
<span class="line" id="L1260">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.swap);</span>
<span class="line" id="L1261">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1262">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">5</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1263">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">6</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1264"></span>
<span class="line" id="L1265">        stack_machine.reset();</span>
<span class="line" id="L1266">        program.clearRetainingCapacity();</span>
<span class="line" id="L1267">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">4</span>);</span>
<span class="line" id="L1268">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">5</span>);</span>
<span class="line" id="L1269">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">6</span>);</span>
<span class="line" id="L1270">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.rot);</span>
<span class="line" id="L1271">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1272">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">5</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1273">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">4</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1274">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">6</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1275"></span>
<span class="line" id="L1276">        <span class="tok-kw">const</span> deref_target: <span class="tok-type">usize</span> = <span class="tok-builtin">@truncate</span>(<span class="tok-number">0xffeeffee_ffeeffee</span>);</span>
<span class="line" id="L1277"></span>
<span class="line" id="L1278">        stack_machine.reset();</span>
<span class="line" id="L1279">        program.clearRetainingCapacity();</span>
<span class="line" id="L1280">        <span class="tok-kw">try</span> b.writeAddr(writer, <span class="tok-builtin">@intFromPtr</span>(&amp;deref_target));</span>
<span class="line" id="L1281">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.deref);</span>
<span class="line" id="L1282">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1283">        <span class="tok-kw">try</span> testing.expectEqual(deref_target, stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1284"></span>
<span class="line" id="L1285">        stack_machine.reset();</span>
<span class="line" id="L1286">        program.clearRetainingCapacity();</span>
<span class="line" id="L1287">        <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-number">0</span>);</span>
<span class="line" id="L1288">        <span class="tok-kw">try</span> b.writeAddr(writer, <span class="tok-builtin">@intFromPtr</span>(&amp;deref_target));</span>
<span class="line" id="L1289">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.xderef);</span>
<span class="line" id="L1290">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1291">        <span class="tok-kw">try</span> testing.expectEqual(deref_target, stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1292"></span>
<span class="line" id="L1293">        stack_machine.reset();</span>
<span class="line" id="L1294">        program.clearRetainingCapacity();</span>
<span class="line" id="L1295">        <span class="tok-kw">try</span> b.writeAddr(writer, <span class="tok-builtin">@intFromPtr</span>(&amp;deref_target));</span>
<span class="line" id="L1296">        <span class="tok-kw">try</span> b.writeDerefSize(writer, <span class="tok-number">1</span>);</span>
<span class="line" id="L1297">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1298">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;deref_target)).*), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1299"></span>
<span class="line" id="L1300">        stack_machine.reset();</span>
<span class="line" id="L1301">        program.clearRetainingCapacity();</span>
<span class="line" id="L1302">        <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-number">0</span>);</span>
<span class="line" id="L1303">        <span class="tok-kw">try</span> b.writeAddr(writer, <span class="tok-builtin">@intFromPtr</span>(&amp;deref_target));</span>
<span class="line" id="L1304">        <span class="tok-kw">try</span> b.writeXDerefSize(writer, <span class="tok-number">1</span>);</span>
<span class="line" id="L1305">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1306">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;deref_target)).*), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1307"></span>
<span class="line" id="L1308">        <span class="tok-kw">const</span> type_offset: <span class="tok-type">usize</span> = <span class="tok-builtin">@truncate</span>(<span class="tok-number">0xaabbaabb_aabbaabb</span>);</span>
<span class="line" id="L1309"></span>
<span class="line" id="L1310">        stack_machine.reset();</span>
<span class="line" id="L1311">        program.clearRetainingCapacity();</span>
<span class="line" id="L1312">        <span class="tok-kw">try</span> b.writeAddr(writer, <span class="tok-builtin">@intFromPtr</span>(&amp;deref_target));</span>
<span class="line" id="L1313">        <span class="tok-kw">try</span> b.writeDerefType(writer, <span class="tok-number">1</span>, type_offset);</span>
<span class="line" id="L1314">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1315">        <span class="tok-kw">const</span> deref_type = stack_machine.stack.popOrNull().?.regval_type;</span>
<span class="line" id="L1316">        <span class="tok-kw">try</span> testing.expectEqual(type_offset, deref_type.type_offset);</span>
<span class="line" id="L1317">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">1</span>), deref_type.type_size);</span>
<span class="line" id="L1318">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;deref_target)).*), deref_type.value);</span>
<span class="line" id="L1319"></span>
<span class="line" id="L1320">        stack_machine.reset();</span>
<span class="line" id="L1321">        program.clearRetainingCapacity();</span>
<span class="line" id="L1322">        <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-number">0</span>);</span>
<span class="line" id="L1323">        <span class="tok-kw">try</span> b.writeAddr(writer, <span class="tok-builtin">@intFromPtr</span>(&amp;deref_target));</span>
<span class="line" id="L1324">        <span class="tok-kw">try</span> b.writeXDerefType(writer, <span class="tok-number">1</span>, type_offset);</span>
<span class="line" id="L1325">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1326">        <span class="tok-kw">const</span> xderef_type = stack_machine.stack.popOrNull().?.regval_type;</span>
<span class="line" id="L1327">        <span class="tok-kw">try</span> testing.expectEqual(type_offset, xderef_type.type_offset);</span>
<span class="line" id="L1328">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">1</span>), xderef_type.type_size);</span>
<span class="line" id="L1329">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;deref_target)).*), xderef_type.value);</span>
<span class="line" id="L1330"></span>
<span class="line" id="L1331">        context.object_address = &amp;deref_target;</span>
<span class="line" id="L1332"></span>
<span class="line" id="L1333">        stack_machine.reset();</span>
<span class="line" id="L1334">        program.clearRetainingCapacity();</span>
<span class="line" id="L1335">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.push_object_address);</span>
<span class="line" id="L1336">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1337">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intFromPtr</span>(context.object_address.?)), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1338"></span>
<span class="line" id="L1339">        <span class="tok-comment">// TODO: Test OP.form_tls_address</span>
</span>
<span class="line" id="L1340"></span>
<span class="line" id="L1341">        context.cfa = <span class="tok-builtin">@truncate</span>(<span class="tok-number">0xccddccdd_ccddccdd</span>);</span>
<span class="line" id="L1342"></span>
<span class="line" id="L1343">        stack_machine.reset();</span>
<span class="line" id="L1344">        program.clearRetainingCapacity();</span>
<span class="line" id="L1345">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.call_frame_cfa);</span>
<span class="line" id="L1346">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1347">        <span class="tok-kw">try</span> testing.expectEqual(context.cfa.?, stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1348">    }</span>
<span class="line" id="L1349"></span>
<span class="line" id="L1350">    <span class="tok-comment">// Arithmetic and Logical Operations</span>
</span>
<span class="line" id="L1351">    {</span>
<span class="line" id="L1352">        <span class="tok-kw">var</span> context = ExpressionContext{};</span>
<span class="line" id="L1353"></span>
<span class="line" id="L1354">        stack_machine.reset();</span>
<span class="line" id="L1355">        program.clearRetainingCapacity();</span>
<span class="line" id="L1356">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">i16</span>, -<span class="tok-number">4096</span>);</span>
<span class="line" id="L1357">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.abs);</span>
<span class="line" id="L1358">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1359">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">4096</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1360"></span>
<span class="line" id="L1361">        stack_machine.reset();</span>
<span class="line" id="L1362">        program.clearRetainingCapacity();</span>
<span class="line" id="L1363">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xff0f</span>);</span>
<span class="line" id="L1364">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xf0ff</span>);</span>
<span class="line" id="L1365">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.@&quot;and&quot;);</span>
<span class="line" id="L1366">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1367">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0xf00f</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1368"></span>
<span class="line" id="L1369">        stack_machine.reset();</span>
<span class="line" id="L1370">        program.clearRetainingCapacity();</span>
<span class="line" id="L1371">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">i16</span>, -<span class="tok-number">404</span>);</span>
<span class="line" id="L1372">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">i16</span>, <span class="tok-number">100</span>);</span>
<span class="line" id="L1373">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.div);</span>
<span class="line" id="L1374">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1375">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, -<span class="tok-number">404</span> / <span class="tok-number">100</span>), <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@bitCast</span>(stack_machine.stack.popOrNull().?.generic)));</span>
<span class="line" id="L1376"></span>
<span class="line" id="L1377">        stack_machine.reset();</span>
<span class="line" id="L1378">        program.clearRetainingCapacity();</span>
<span class="line" id="L1379">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">200</span>);</span>
<span class="line" id="L1380">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">50</span>);</span>
<span class="line" id="L1381">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.minus);</span>
<span class="line" id="L1382">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1383">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">150</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1384"></span>
<span class="line" id="L1385">        stack_machine.reset();</span>
<span class="line" id="L1386">        program.clearRetainingCapacity();</span>
<span class="line" id="L1387">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">123</span>);</span>
<span class="line" id="L1388">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">100</span>);</span>
<span class="line" id="L1389">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.mod);</span>
<span class="line" id="L1390">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1391">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">23</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1392"></span>
<span class="line" id="L1393">        stack_machine.reset();</span>
<span class="line" id="L1394">        program.clearRetainingCapacity();</span>
<span class="line" id="L1395">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xff</span>);</span>
<span class="line" id="L1396">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xee</span>);</span>
<span class="line" id="L1397">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.mul);</span>
<span class="line" id="L1398">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1399">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0xed12</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1400"></span>
<span class="line" id="L1401">        stack_machine.reset();</span>
<span class="line" id="L1402">        program.clearRetainingCapacity();</span>
<span class="line" id="L1403">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">5</span>);</span>
<span class="line" id="L1404">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.neg);</span>
<span class="line" id="L1405">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">i16</span>, -<span class="tok-number">6</span>);</span>
<span class="line" id="L1406">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.neg);</span>
<span class="line" id="L1407">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1408">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">6</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1409">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, -<span class="tok-number">5</span>), <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@bitCast</span>(stack_machine.stack.popOrNull().?.generic)));</span>
<span class="line" id="L1410"></span>
<span class="line" id="L1411">        stack_machine.reset();</span>
<span class="line" id="L1412">        program.clearRetainingCapacity();</span>
<span class="line" id="L1413">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xff0f</span>);</span>
<span class="line" id="L1414">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.not);</span>
<span class="line" id="L1415">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1416">        <span class="tok-kw">try</span> testing.expectEqual(~<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0xff0f</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1417"></span>
<span class="line" id="L1418">        stack_machine.reset();</span>
<span class="line" id="L1419">        program.clearRetainingCapacity();</span>
<span class="line" id="L1420">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xff0f</span>);</span>
<span class="line" id="L1421">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xf0ff</span>);</span>
<span class="line" id="L1422">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.@&quot;or&quot;);</span>
<span class="line" id="L1423">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1424">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0xffff</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1425"></span>
<span class="line" id="L1426">        stack_machine.reset();</span>
<span class="line" id="L1427">        program.clearRetainingCapacity();</span>
<span class="line" id="L1428">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">i16</span>, <span class="tok-number">402</span>);</span>
<span class="line" id="L1429">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">i16</span>, <span class="tok-number">100</span>);</span>
<span class="line" id="L1430">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.plus);</span>
<span class="line" id="L1431">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1432">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">502</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1433"></span>
<span class="line" id="L1434">        stack_machine.reset();</span>
<span class="line" id="L1435">        program.clearRetainingCapacity();</span>
<span class="line" id="L1436">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">4096</span>);</span>
<span class="line" id="L1437">        <span class="tok-kw">try</span> b.writePlusUconst(writer, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">8192</span>));</span>
<span class="line" id="L1438">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1439">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">4096</span> + <span class="tok-number">8192</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1440"></span>
<span class="line" id="L1441">        stack_machine.reset();</span>
<span class="line" id="L1442">        program.clearRetainingCapacity();</span>
<span class="line" id="L1443">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xfff</span>);</span>
<span class="line" id="L1444">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">1</span>);</span>
<span class="line" id="L1445">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.shl);</span>
<span class="line" id="L1446">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1447">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0xfff</span> &lt;&lt; <span class="tok-number">1</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1448"></span>
<span class="line" id="L1449">        stack_machine.reset();</span>
<span class="line" id="L1450">        program.clearRetainingCapacity();</span>
<span class="line" id="L1451">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xfff</span>);</span>
<span class="line" id="L1452">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">1</span>);</span>
<span class="line" id="L1453">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.shr);</span>
<span class="line" id="L1454">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1455">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0xfff</span> &gt;&gt; <span class="tok-number">1</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1456"></span>
<span class="line" id="L1457">        stack_machine.reset();</span>
<span class="line" id="L1458">        program.clearRetainingCapacity();</span>
<span class="line" id="L1459">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xfff</span>);</span>
<span class="line" id="L1460">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">1</span>);</span>
<span class="line" id="L1461">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.shr);</span>
<span class="line" id="L1462">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1463">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-number">0xfff</span>) &gt;&gt; <span class="tok-number">1</span>)), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1464"></span>
<span class="line" id="L1465">        stack_machine.reset();</span>
<span class="line" id="L1466">        program.clearRetainingCapacity();</span>
<span class="line" id="L1467">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xf0ff</span>);</span>
<span class="line" id="L1468">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xff0f</span>);</span>
<span class="line" id="L1469">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.xor);</span>
<span class="line" id="L1470">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1471">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0x0ff0</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1472">    }</span>
<span class="line" id="L1473"></span>
<span class="line" id="L1474">    <span class="tok-comment">// Control Flow Operations</span>
</span>
<span class="line" id="L1475">    {</span>
<span class="line" id="L1476">        <span class="tok-kw">var</span> context = ExpressionContext{};</span>
<span class="line" id="L1477">        <span class="tok-kw">const</span> expected = .{</span>
<span class="line" id="L1478">            .{ OP.le, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span> },</span>
<span class="line" id="L1479">            .{ OP.ge, <span class="tok-number">1</span>, <span class="tok-number">0</span>, <span class="tok-number">1</span> },</span>
<span class="line" id="L1480">            .{ OP.eq, <span class="tok-number">1</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span> },</span>
<span class="line" id="L1481">            .{ OP.lt, <span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span> },</span>
<span class="line" id="L1482">            .{ OP.gt, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">1</span> },</span>
<span class="line" id="L1483">            .{ OP.ne, <span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span> },</span>
<span class="line" id="L1484">        };</span>
<span class="line" id="L1485"></span>
<span class="line" id="L1486">        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (expected) |e| {</span>
<span class="line" id="L1487">            stack_machine.reset();</span>
<span class="line" id="L1488">            program.clearRetainingCapacity();</span>
<span class="line" id="L1489"></span>
<span class="line" id="L1490">            <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L1491">            <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L1492">            <span class="tok-kw">try</span> b.writeOpcode(writer, e[<span class="tok-number">0</span>]);</span>
<span class="line" id="L1493">            <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L1494">            <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">1</span>);</span>
<span class="line" id="L1495">            <span class="tok-kw">try</span> b.writeOpcode(writer, e[<span class="tok-number">0</span>]);</span>
<span class="line" id="L1496">            <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">1</span>);</span>
<span class="line" id="L1497">            <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L1498">            <span class="tok-kw">try</span> b.writeOpcode(writer, e[<span class="tok-number">0</span>]);</span>
<span class="line" id="L1499">            _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1500">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, e[<span class="tok-number">3</span>]), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1501">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, e[<span class="tok-number">2</span>]), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1502">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, e[<span class="tok-number">1</span>]), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1503">        }</span>
<span class="line" id="L1504"></span>
<span class="line" id="L1505">        stack_machine.reset();</span>
<span class="line" id="L1506">        program.clearRetainingCapacity();</span>
<span class="line" id="L1507">        <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-number">2</span>);</span>
<span class="line" id="L1508">        <span class="tok-kw">try</span> b.writeSkip(writer, <span class="tok-number">1</span>);</span>
<span class="line" id="L1509">        <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-number">3</span>);</span>
<span class="line" id="L1510">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1511">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">2</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1512"></span>
<span class="line" id="L1513">        stack_machine.reset();</span>
<span class="line" id="L1514">        program.clearRetainingCapacity();</span>
<span class="line" id="L1515">        <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-number">2</span>);</span>
<span class="line" id="L1516">        <span class="tok-kw">try</span> b.writeBra(writer, <span class="tok-number">1</span>);</span>
<span class="line" id="L1517">        <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-number">3</span>);</span>
<span class="line" id="L1518">        <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-number">0</span>);</span>
<span class="line" id="L1519">        <span class="tok-kw">try</span> b.writeBra(writer, <span class="tok-number">1</span>);</span>
<span class="line" id="L1520">        <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-number">4</span>);</span>
<span class="line" id="L1521">        <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-number">5</span>);</span>
<span class="line" id="L1522">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1523">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">5</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1524">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">4</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1525">        <span class="tok-kw">try</span> testing.expect(stack_machine.stack.popOrNull() == <span class="tok-null">null</span>);</span>
<span class="line" id="L1526"></span>
<span class="line" id="L1527">        <span class="tok-comment">// TODO: Test call2, call4, call_ref once implemented</span>
</span>
<span class="line" id="L1528"></span>
<span class="line" id="L1529">    }</span>
<span class="line" id="L1530"></span>
<span class="line" id="L1531">    <span class="tok-comment">// Type conversions</span>
</span>
<span class="line" id="L1532">    {</span>
<span class="line" id="L1533">        <span class="tok-kw">var</span> context = ExpressionContext{};</span>
<span class="line" id="L1534">        stack_machine.reset();</span>
<span class="line" id="L1535">        program.clearRetainingCapacity();</span>
<span class="line" id="L1536"></span>
<span class="line" id="L1537">        <span class="tok-comment">// TODO: Test typed OP.convert once implemented</span>
</span>
<span class="line" id="L1538"></span>
<span class="line" id="L1539">        <span class="tok-kw">const</span> value: <span class="tok-type">usize</span> = <span class="tok-builtin">@truncate</span>(<span class="tok-number">0xffeeffee_ffeeffee</span>);</span>
<span class="line" id="L1540">        <span class="tok-kw">var</span> value_bytes: [options.addr_size]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1541">        mem.writeIntSliceNative(<span class="tok-type">usize</span>, &amp;value_bytes, value);</span>
<span class="line" id="L1542"></span>
<span class="line" id="L1543">        <span class="tok-comment">// Convert to generic type</span>
</span>
<span class="line" id="L1544">        stack_machine.reset();</span>
<span class="line" id="L1545">        program.clearRetainingCapacity();</span>
<span class="line" id="L1546">        <span class="tok-kw">try</span> b.writeConstType(writer, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>), &amp;value_bytes);</span>
<span class="line" id="L1547">        <span class="tok-kw">try</span> b.writeConvert(writer, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>));</span>
<span class="line" id="L1548">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1549">        <span class="tok-kw">try</span> testing.expectEqual(value, stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1550"></span>
<span class="line" id="L1551">        <span class="tok-comment">// Reinterpret to generic type</span>
</span>
<span class="line" id="L1552">        stack_machine.reset();</span>
<span class="line" id="L1553">        program.clearRetainingCapacity();</span>
<span class="line" id="L1554">        <span class="tok-kw">try</span> b.writeConstType(writer, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>), &amp;value_bytes);</span>
<span class="line" id="L1555">        <span class="tok-kw">try</span> b.writeReinterpret(writer, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>));</span>
<span class="line" id="L1556">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1557">        <span class="tok-kw">try</span> testing.expectEqual(value, stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1558"></span>
<span class="line" id="L1559">        <span class="tok-comment">// Reinterpret to new type</span>
</span>
<span class="line" id="L1560">        <span class="tok-kw">const</span> die_offset: <span class="tok-type">usize</span> = <span class="tok-number">0xffee</span>;</span>
<span class="line" id="L1561"></span>
<span class="line" id="L1562">        stack_machine.reset();</span>
<span class="line" id="L1563">        program.clearRetainingCapacity();</span>
<span class="line" id="L1564">        <span class="tok-kw">try</span> b.writeConstType(writer, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>), &amp;value_bytes);</span>
<span class="line" id="L1565">        <span class="tok-kw">try</span> b.writeReinterpret(writer, die_offset);</span>
<span class="line" id="L1566">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1567">        <span class="tok-kw">const</span> const_type = stack_machine.stack.popOrNull().?.const_type;</span>
<span class="line" id="L1568">        <span class="tok-kw">try</span> testing.expectEqual(die_offset, const_type.type_offset);</span>
<span class="line" id="L1569"></span>
<span class="line" id="L1570">        stack_machine.reset();</span>
<span class="line" id="L1571">        program.clearRetainingCapacity();</span>
<span class="line" id="L1572">        <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-number">0</span>);</span>
<span class="line" id="L1573">        <span class="tok-kw">try</span> b.writeReinterpret(writer, die_offset);</span>
<span class="line" id="L1574">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1575">        <span class="tok-kw">const</span> regval_type = stack_machine.stack.popOrNull().?.regval_type;</span>
<span class="line" id="L1576">        <span class="tok-kw">try</span> testing.expectEqual(die_offset, regval_type.type_offset);</span>
<span class="line" id="L1577">    }</span>
<span class="line" id="L1578"></span>
<span class="line" id="L1579">    <span class="tok-comment">// Special operations</span>
</span>
<span class="line" id="L1580">    {</span>
<span class="line" id="L1581">        <span class="tok-kw">var</span> context = ExpressionContext{};</span>
<span class="line" id="L1582"></span>
<span class="line" id="L1583">        stack_machine.reset();</span>
<span class="line" id="L1584">        program.clearRetainingCapacity();</span>
<span class="line" id="L1585">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.nop);</span>
<span class="line" id="L1586">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1587">        <span class="tok-kw">try</span> testing.expect(stack_machine.stack.popOrNull() == <span class="tok-null">null</span>);</span>
<span class="line" id="L1588"></span>
<span class="line" id="L1589">        <span class="tok-comment">// Sub-expression</span>
</span>
<span class="line" id="L1590">        {</span>
<span class="line" id="L1591">            <span class="tok-kw">var</span> sub_program = std.ArrayList(<span class="tok-type">u8</span>).init(allocator);</span>
<span class="line" id="L1592">            <span class="tok-kw">defer</span> sub_program.deinit();</span>
<span class="line" id="L1593">            <span class="tok-kw">const</span> sub_writer = sub_program.writer();</span>
<span class="line" id="L1594">            <span class="tok-kw">try</span> b.writeLiteral(sub_writer, <span class="tok-number">3</span>);</span>
<span class="line" id="L1595"></span>
<span class="line" id="L1596">            stack_machine.reset();</span>
<span class="line" id="L1597">            program.clearRetainingCapacity();</span>
<span class="line" id="L1598">            <span class="tok-kw">try</span> b.writeEntryValue(writer, sub_program.items);</span>
<span class="line" id="L1599">            _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1600">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">3</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1601">        }</span>
<span class="line" id="L1602"></span>
<span class="line" id="L1603">        <span class="tok-comment">// Register location description</span>
</span>
<span class="line" id="L1604">        <span class="tok-kw">const</span> reg_context = abi.RegisterContext{</span>
<span class="line" id="L1605">            .eh_frame = <span class="tok-null">true</span>,</span>
<span class="line" id="L1606">            .is_macho = builtin.os.tag == .macos,</span>
<span class="line" id="L1607">        };</span>
<span class="line" id="L1608">        <span class="tok-kw">var</span> thread_context: std.debug.ThreadContext = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1609">        std.debug.relocateContext(&amp;thread_context);</span>
<span class="line" id="L1610">        context = ExpressionContext{</span>
<span class="line" id="L1611">            .thread_context = &amp;thread_context,</span>
<span class="line" id="L1612">            .reg_context = reg_context,</span>
<span class="line" id="L1613">        };</span>
<span class="line" id="L1614"></span>
<span class="line" id="L1615">        <span class="tok-kw">if</span> (abi.regBytes(&amp;thread_context, <span class="tok-number">0</span>, reg_context)) |reg_bytes| {</span>
<span class="line" id="L1616">            mem.writeIntSliceNative(<span class="tok-type">usize</span>, reg_bytes, <span class="tok-number">0xee</span>);</span>
<span class="line" id="L1617"></span>
<span class="line" id="L1618">            <span class="tok-kw">var</span> sub_program = std.ArrayList(<span class="tok-type">u8</span>).init(allocator);</span>
<span class="line" id="L1619">            <span class="tok-kw">defer</span> sub_program.deinit();</span>
<span class="line" id="L1620">            <span class="tok-kw">const</span> sub_writer = sub_program.writer();</span>
<span class="line" id="L1621">            <span class="tok-kw">try</span> b.writeReg(sub_writer, <span class="tok-number">0</span>);</span>
<span class="line" id="L1622"></span>
<span class="line" id="L1623">            stack_machine.reset();</span>
<span class="line" id="L1624">            program.clearRetainingCapacity();</span>
<span class="line" id="L1625">            <span class="tok-kw">try</span> b.writeEntryValue(writer, sub_program.items);</span>
<span class="line" id="L1626">            _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1627">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0xee</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1628">        } <span class="tok-kw">else</span> |err| {</span>
<span class="line" id="L1629">            <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1630">                <span class="tok-kw">error</span>.UnimplementedArch,</span>
<span class="line" id="L1631">                <span class="tok-kw">error</span>.UnimplementedOs,</span>
<span class="line" id="L1632">                <span class="tok-kw">error</span>.ThreadContextNotSupported,</span>
<span class="line" id="L1633">                =&gt; {},</span>
<span class="line" id="L1634">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L1635">            }</span>
<span class="line" id="L1636">        }</span>
<span class="line" id="L1637">    }</span>
<span class="line" id="L1638">}</span>
<span class="line" id="L1639"></span>
</code></pre></body>
</html>