<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>dwarf/expressions.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg==">
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);</span>
<span class="line" id="L2"><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);</span>
<span class="line" id="L3"><span class="tok-kw">const</span> OP = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;OP.zig&quot;</span>);</span>
<span class="line" id="L4"><span class="tok-kw">const</span> leb = std.leb;</span>
<span class="line" id="L5"><span class="tok-kw">const</span> dwarf = std.dwarf;</span>
<span class="line" id="L6"><span class="tok-kw">const</span> abi = dwarf.abi;</span>
<span class="line" id="L7"><span class="tok-kw">const</span> mem = std.mem;</span>
<span class="line" id="L8"><span class="tok-kw">const</span> assert = std.debug.assert;</span>
<span class="line" id="L9"><span class="tok-kw">const</span> native_endian = builtin.cpu.arch.endian();</span>
<span class="line" id="L10"></span>
<span class="line" id="L11"><span class="tok-comment">/// Expressions can be evaluated in different contexts, each requiring its own set of inputs.</span></span>
<span class="line" id="L12"><span class="tok-comment">/// Callers should specify all the fields relevant to their context. If a field is required</span></span>
<span class="line" id="L13"><span class="tok-comment">/// by the expression and it isn't in the context, error.IncompleteExpressionContext is returned.</span></span>
<span class="line" id="L14"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ExpressionContext = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L15">    <span class="tok-comment">/// This expression is from a DWARF64 section</span></span>
<span class="line" id="L16">    is_64: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L17"></span>
<span class="line" id="L18">    <span class="tok-comment">/// If specified, any addresses will pass through this function before being acccessed</span></span>
<span class="line" id="L19">    isValidMemory: ?*<span class="tok-kw">const</span> <span class="tok-kw">fn</span> (address: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L20"></span>
<span class="line" id="L21">    <span class="tok-comment">/// The compilation unit this expression relates to, if any</span></span>
<span class="line" id="L22">    compile_unit: ?*<span class="tok-kw">const</span> dwarf.CompileUnit = <span class="tok-null">null</span>,</span>
<span class="line" id="L23"></span>
<span class="line" id="L24">    <span class="tok-comment">/// When evaluating a user-presented expression, this is the address of the object being evaluated</span></span>
<span class="line" id="L25">    object_address: ?*<span class="tok-kw">const</span> <span class="tok-type">anyopaque</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L26"></span>
<span class="line" id="L27">    <span class="tok-comment">/// .debug_addr section</span></span>
<span class="line" id="L28">    debug_addr: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L29"></span>
<span class="line" id="L30">    <span class="tok-comment">/// Thread context</span></span>
<span class="line" id="L31">    thread_context: ?*std.debug.ThreadContext = <span class="tok-null">null</span>,</span>
<span class="line" id="L32">    reg_context: ?abi.RegisterContext = <span class="tok-null">null</span>,</span>
<span class="line" id="L33"></span>
<span class="line" id="L34">    <span class="tok-comment">/// Call frame address, if in a CFI context</span></span>
<span class="line" id="L35">    cfa: ?<span class="tok-type">usize</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L36"></span>
<span class="line" id="L37">    <span class="tok-comment">/// This expression is a sub-expression from an OP.entry_value instruction</span></span>
<span class="line" id="L38">    entry_value_context: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L39">};</span>
<span class="line" id="L40"></span>
<span class="line" id="L41"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ExpressionOptions = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L42">    <span class="tok-comment">/// The address size of the target architecture</span></span>
<span class="line" id="L43">    addr_size: <span class="tok-type">u8</span> = <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>),</span>
<span class="line" id="L44"></span>
<span class="line" id="L45">    <span class="tok-comment">/// Endianess of the target architecture</span></span>
<span class="line" id="L46">    endian: std.builtin.Endian = builtin.target.cpu.arch.endian(),</span>
<span class="line" id="L47"></span>
<span class="line" id="L48">    <span class="tok-comment">/// Restrict the stack machine to a subset of opcodes used in call frame instructions</span></span>
<span class="line" id="L49">    call_frame_context: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L50">};</span>
<span class="line" id="L51"></span>
<span class="line" id="L52"><span class="tok-comment">// Explcitly defined to support executing sub-expressions</span>
</span>
<span class="line" id="L53"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ExpressionError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L54">    UnimplementedExpressionCall,</span>
<span class="line" id="L55">    UnimplementedOpcode,</span>
<span class="line" id="L56">    UnimplementedUserOpcode,</span>
<span class="line" id="L57">    UnimplementedTypedComparison,</span>
<span class="line" id="L58">    UnimplementedTypeConversion,</span>
<span class="line" id="L59"></span>
<span class="line" id="L60">    UnknownExpressionOpcode,</span>
<span class="line" id="L61"></span>
<span class="line" id="L62">    IncompleteExpressionContext,</span>
<span class="line" id="L63"></span>
<span class="line" id="L64">    InvalidCFAOpcode,</span>
<span class="line" id="L65">    InvalidExpression,</span>
<span class="line" id="L66">    InvalidFrameBase,</span>
<span class="line" id="L67">    InvalidIntegralTypeSize,</span>
<span class="line" id="L68">    InvalidRegister,</span>
<span class="line" id="L69">    InvalidSubExpression,</span>
<span class="line" id="L70">    InvalidTypeLength,</span>
<span class="line" id="L71"></span>
<span class="line" id="L72">    TruncatedIntegralType,</span>
<span class="line" id="L73">} || abi.AbiError || <span class="tok-kw">error</span>{ EndOfStream, Overflow, OutOfMemory, DivisionByZero };</span>
<span class="line" id="L74"></span>
<span class="line" id="L75"><span class="tok-comment">/// A stack machine that can decode and run DWARF expressions.</span></span>
<span class="line" id="L76"><span class="tok-comment">/// Expressions can be decoded for non-native address size and endianness,</span></span>
<span class="line" id="L77"><span class="tok-comment">/// but can only be executed if the current target matches the configuration.</span></span>
<span class="line" id="L78"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">StackMachine</span>(<span class="tok-kw">comptime</span> options: ExpressionOptions) <span class="tok-type">type</span> {</span>
<span class="line" id="L79">    <span class="tok-kw">const</span> addr_type = <span class="tok-kw">switch</span> (options.addr_size) {</span>
<span class="line" id="L80">        <span class="tok-number">2</span> =&gt; <span class="tok-type">u16</span>,</span>
<span class="line" id="L81">        <span class="tok-number">4</span> =&gt; <span class="tok-type">u32</span>,</span>
<span class="line" id="L82">        <span class="tok-number">8</span> =&gt; <span class="tok-type">u64</span>,</span>
<span class="line" id="L83">        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unsupported address size of &quot;</span> ++ options.addr_size),</span>
<span class="line" id="L84">    };</span>
<span class="line" id="L85"></span>
<span class="line" id="L86">    <span class="tok-kw">const</span> addr_type_signed = <span class="tok-kw">switch</span> (options.addr_size) {</span>
<span class="line" id="L87">        <span class="tok-number">2</span> =&gt; <span class="tok-type">i16</span>,</span>
<span class="line" id="L88">        <span class="tok-number">4</span> =&gt; <span class="tok-type">i32</span>,</span>
<span class="line" id="L89">        <span class="tok-number">8</span> =&gt; <span class="tok-type">i64</span>,</span>
<span class="line" id="L90">        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unsupported address size of &quot;</span> ++ options.addr_size),</span>
<span class="line" id="L91">    };</span>
<span class="line" id="L92"></span>
<span class="line" id="L93">    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L94">        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L95"></span>
<span class="line" id="L96">        <span class="tok-kw">const</span> Operand = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L97">            generic: addr_type,</span>
<span class="line" id="L98">            register: <span class="tok-type">u8</span>,</span>
<span class="line" id="L99">            type_size: <span class="tok-type">u8</span>,</span>
<span class="line" id="L100">            branch_offset: <span class="tok-type">i16</span>,</span>
<span class="line" id="L101">            base_register: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L102">                base_register: <span class="tok-type">u8</span>,</span>
<span class="line" id="L103">                offset: <span class="tok-type">i64</span>,</span>
<span class="line" id="L104">            },</span>
<span class="line" id="L105">            composite_location: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L106">                size: <span class="tok-type">u64</span>,</span>
<span class="line" id="L107">                offset: <span class="tok-type">i64</span>,</span>
<span class="line" id="L108">            },</span>
<span class="line" id="L109">            block: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L110">            register_type: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L111">                register: <span class="tok-type">u8</span>,</span>
<span class="line" id="L112">                type_offset: addr_type,</span>
<span class="line" id="L113">            },</span>
<span class="line" id="L114">            const_type: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L115">                type_offset: addr_type,</span>
<span class="line" id="L116">                value_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L117">            },</span>
<span class="line" id="L118">            deref_type: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L119">                size: <span class="tok-type">u8</span>,</span>
<span class="line" id="L120">                type_offset: addr_type,</span>
<span class="line" id="L121">            },</span>
<span class="line" id="L122">        };</span>
<span class="line" id="L123"></span>
<span class="line" id="L124">        <span class="tok-kw">const</span> Value = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L125">            generic: addr_type,</span>
<span class="line" id="L126"></span>
<span class="line" id="L127">            <span class="tok-comment">// Typed value with a maximum size of a register</span>
</span>
<span class="line" id="L128">            regval_type: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L129">                <span class="tok-comment">// Offset of DW_TAG_base_type DIE</span>
</span>
<span class="line" id="L130">                type_offset: addr_type,</span>
<span class="line" id="L131">                type_size: <span class="tok-type">u8</span>,</span>
<span class="line" id="L132">                value: addr_type,</span>
<span class="line" id="L133">            },</span>
<span class="line" id="L134"></span>
<span class="line" id="L135">            <span class="tok-comment">// Typed value specified directly in the instruction stream</span>
</span>
<span class="line" id="L136">            const_type: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L137">                <span class="tok-comment">// Offset of DW_TAG_base_type DIE</span>
</span>
<span class="line" id="L138">                type_offset: addr_type,</span>
<span class="line" id="L139">                <span class="tok-comment">// Backed by the instruction stream</span>
</span>
<span class="line" id="L140">                value_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L141">            },</span>
<span class="line" id="L142"></span>
<span class="line" id="L143">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">asIntegral</span>(self: Value) !addr_type {</span>
<span class="line" id="L144">                <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self) {</span>
<span class="line" id="L145">                    .generic =&gt; |v| v,</span>
<span class="line" id="L146"></span>
<span class="line" id="L147">                    <span class="tok-comment">// TODO: For these two prongs, look up the type and assert it's integral?</span>
</span>
<span class="line" id="L148">                    .regval_type =&gt; |regval_type| regval_type.value,</span>
<span class="line" id="L149">                    .const_type =&gt; |const_type| {</span>
<span class="line" id="L150">                        <span class="tok-kw">const</span> value: <span class="tok-type">u64</span> = <span class="tok-kw">switch</span> (const_type.value_bytes.len) {</span>
<span class="line" id="L151">                            <span class="tok-number">1</span> =&gt; mem.readInt(<span class="tok-type">u8</span>, const_type.value_bytes[<span class="tok-number">0</span>..<span class="tok-number">1</span>], native_endian),</span>
<span class="line" id="L152">                            <span class="tok-number">2</span> =&gt; mem.readInt(<span class="tok-type">u16</span>, const_type.value_bytes[<span class="tok-number">0</span>..<span class="tok-number">2</span>], native_endian),</span>
<span class="line" id="L153">                            <span class="tok-number">4</span> =&gt; mem.readInt(<span class="tok-type">u32</span>, const_type.value_bytes[<span class="tok-number">0</span>..<span class="tok-number">4</span>], native_endian),</span>
<span class="line" id="L154">                            <span class="tok-number">8</span> =&gt; mem.readInt(<span class="tok-type">u64</span>, const_type.value_bytes[<span class="tok-number">0</span>..<span class="tok-number">8</span>], native_endian),</span>
<span class="line" id="L155">                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidIntegralTypeSize,</span>
<span class="line" id="L156">                        };</span>
<span class="line" id="L157"></span>
<span class="line" id="L158">                        <span class="tok-kw">return</span> std.math.cast(addr_type, value) <span class="tok-kw">orelse</span> <span class="tok-kw">error</span>.TruncatedIntegralType;</span>
<span class="line" id="L159">                    },</span>
<span class="line" id="L160">                };</span>
<span class="line" id="L161">            }</span>
<span class="line" id="L162">        };</span>
<span class="line" id="L163"></span>
<span class="line" id="L164">        stack: std.ArrayListUnmanaged(Value) = .{},</span>
<span class="line" id="L165"></span>
<span class="line" id="L166">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *Self) <span class="tok-type">void</span> {</span>
<span class="line" id="L167">            self.stack.clearRetainingCapacity();</span>
<span class="line" id="L168">        }</span>
<span class="line" id="L169"></span>
<span class="line" id="L170">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *Self, allocator: std.mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L171">            self.stack.deinit(allocator);</span>
<span class="line" id="L172">        }</span>
<span class="line" id="L173"></span>
<span class="line" id="L174">        <span class="tok-kw">fn</span> <span class="tok-fn">generic</span>(value: <span class="tok-kw">anytype</span>) Operand {</span>
<span class="line" id="L175">            <span class="tok-kw">const</span> int_info = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(value)).Int;</span>
<span class="line" id="L176">            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<span class="tok-builtin">@TypeOf</span>(value)) &gt; options.addr_size) {</span>
<span class="line" id="L177">                <span class="tok-kw">return</span> .{ .generic = <span class="tok-kw">switch</span> (int_info.signedness) {</span>
<span class="line" id="L178">                    .signed =&gt; <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(addr_type_signed, <span class="tok-builtin">@truncate</span>(value))),</span>
<span class="line" id="L179">                    .unsigned =&gt; <span class="tok-builtin">@truncate</span>(value),</span>
<span class="line" id="L180">                } };</span>
<span class="line" id="L181">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L182">                <span class="tok-kw">return</span> .{ .generic = <span class="tok-kw">switch</span> (int_info.signedness) {</span>
<span class="line" id="L183">                    .signed =&gt; <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(addr_type_signed, <span class="tok-builtin">@intCast</span>(value))),</span>
<span class="line" id="L184">                    .unsigned =&gt; <span class="tok-builtin">@intCast</span>(value),</span>
<span class="line" id="L185">                } };</span>
<span class="line" id="L186">            }</span>
<span class="line" id="L187">        }</span>
<span class="line" id="L188"></span>
<span class="line" id="L189">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readOperand</span>(stream: *std.io.FixedBufferStream([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>), opcode: <span class="tok-type">u8</span>, context: ExpressionContext) !?Operand {</span>
<span class="line" id="L190">            <span class="tok-kw">const</span> reader = stream.reader();</span>
<span class="line" id="L191">            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (opcode) {</span>
<span class="line" id="L192">                OP.addr =&gt; generic(<span class="tok-kw">try</span> reader.readInt(addr_type, options.endian)),</span>
<span class="line" id="L193">                OP.call_ref =&gt; <span class="tok-kw">if</span> (context.is_64)</span>
<span class="line" id="L194">                    generic(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u64</span>, options.endian))</span>
<span class="line" id="L195">                <span class="tok-kw">else</span></span>
<span class="line" id="L196">                    generic(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u32</span>, options.endian)),</span>
<span class="line" id="L197">                OP.const1u,</span>
<span class="line" id="L198">                OP.pick,</span>
<span class="line" id="L199">                =&gt; generic(<span class="tok-kw">try</span> reader.readByte()),</span>
<span class="line" id="L200">                OP.deref_size,</span>
<span class="line" id="L201">                OP.xderef_size,</span>
<span class="line" id="L202">                =&gt; .{ .type_size = <span class="tok-kw">try</span> reader.readByte() },</span>
<span class="line" id="L203">                OP.const1s =&gt; generic(<span class="tok-kw">try</span> reader.readByteSigned()),</span>
<span class="line" id="L204">                OP.const2u,</span>
<span class="line" id="L205">                OP.call2,</span>
<span class="line" id="L206">                =&gt; generic(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u16</span>, options.endian)),</span>
<span class="line" id="L207">                OP.call4 =&gt; generic(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u32</span>, options.endian)),</span>
<span class="line" id="L208">                OP.const2s =&gt; generic(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">i16</span>, options.endian)),</span>
<span class="line" id="L209">                OP.bra,</span>
<span class="line" id="L210">                OP.skip,</span>
<span class="line" id="L211">                =&gt; .{ .branch_offset = <span class="tok-kw">try</span> reader.readInt(<span class="tok-type">i16</span>, options.endian) },</span>
<span class="line" id="L212">                OP.const4u =&gt; generic(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u32</span>, options.endian)),</span>
<span class="line" id="L213">                OP.const4s =&gt; generic(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">i32</span>, options.endian)),</span>
<span class="line" id="L214">                OP.const8u =&gt; generic(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u64</span>, options.endian)),</span>
<span class="line" id="L215">                OP.const8s =&gt; generic(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">i64</span>, options.endian)),</span>
<span class="line" id="L216">                OP.constu,</span>
<span class="line" id="L217">                OP.plus_uconst,</span>
<span class="line" id="L218">                OP.addrx,</span>
<span class="line" id="L219">                OP.constx,</span>
<span class="line" id="L220">                OP.convert,</span>
<span class="line" id="L221">                OP.reinterpret,</span>
<span class="line" id="L222">                =&gt; generic(<span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">u64</span>, reader)),</span>
<span class="line" id="L223">                OP.consts,</span>
<span class="line" id="L224">                OP.fbreg,</span>
<span class="line" id="L225">                =&gt; generic(<span class="tok-kw">try</span> leb.readILEB128(<span class="tok-type">i64</span>, reader)),</span>
<span class="line" id="L226">                OP.lit0...OP.lit31 =&gt; |n| generic(n - OP.lit0),</span>
<span class="line" id="L227">                OP.reg0...OP.reg31 =&gt; |n| .{ .register = n - OP.reg0 },</span>
<span class="line" id="L228">                OP.breg0...OP.breg31 =&gt; |n| .{ .base_register = .{</span>
<span class="line" id="L229">                    .base_register = n - OP.breg0,</span>
<span class="line" id="L230">                    .offset = <span class="tok-kw">try</span> leb.readILEB128(<span class="tok-type">i64</span>, reader),</span>
<span class="line" id="L231">                } },</span>
<span class="line" id="L232">                OP.regx =&gt; .{ .register = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">u8</span>, reader) },</span>
<span class="line" id="L233">                OP.bregx =&gt; blk: {</span>
<span class="line" id="L234">                    <span class="tok-kw">const</span> base_register = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">u8</span>, reader);</span>
<span class="line" id="L235">                    <span class="tok-kw">const</span> offset = <span class="tok-kw">try</span> leb.readILEB128(<span class="tok-type">i64</span>, reader);</span>
<span class="line" id="L236">                    <span class="tok-kw">break</span> :blk .{ .base_register = .{</span>
<span class="line" id="L237">                        .base_register = base_register,</span>
<span class="line" id="L238">                        .offset = offset,</span>
<span class="line" id="L239">                    } };</span>
<span class="line" id="L240">                },</span>
<span class="line" id="L241">                OP.regval_type =&gt; blk: {</span>
<span class="line" id="L242">                    <span class="tok-kw">const</span> register = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">u8</span>, reader);</span>
<span class="line" id="L243">                    <span class="tok-kw">const</span> type_offset = <span class="tok-kw">try</span> leb.readULEB128(addr_type, reader);</span>
<span class="line" id="L244">                    <span class="tok-kw">break</span> :blk .{ .register_type = .{</span>
<span class="line" id="L245">                        .register = register,</span>
<span class="line" id="L246">                        .type_offset = type_offset,</span>
<span class="line" id="L247">                    } };</span>
<span class="line" id="L248">                },</span>
<span class="line" id="L249">                OP.piece =&gt; .{</span>
<span class="line" id="L250">                    .composite_location = .{</span>
<span class="line" id="L251">                        .size = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">u8</span>, reader),</span>
<span class="line" id="L252">                        .offset = <span class="tok-number">0</span>,</span>
<span class="line" id="L253">                    },</span>
<span class="line" id="L254">                },</span>
<span class="line" id="L255">                OP.bit_piece =&gt; blk: {</span>
<span class="line" id="L256">                    <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">u8</span>, reader);</span>
<span class="line" id="L257">                    <span class="tok-kw">const</span> offset = <span class="tok-kw">try</span> leb.readILEB128(<span class="tok-type">i64</span>, reader);</span>
<span class="line" id="L258">                    <span class="tok-kw">break</span> :blk .{ .composite_location = .{</span>
<span class="line" id="L259">                        .size = size,</span>
<span class="line" id="L260">                        .offset = offset,</span>
<span class="line" id="L261">                    } };</span>
<span class="line" id="L262">                },</span>
<span class="line" id="L263">                OP.implicit_value, OP.entry_value =&gt; blk: {</span>
<span class="line" id="L264">                    <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> leb.readULEB128(<span class="tok-type">u8</span>, reader);</span>
<span class="line" id="L265">                    <span class="tok-kw">if</span> (stream.pos + size &gt; stream.buffer.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L266">                    <span class="tok-kw">const</span> block = stream.buffer[stream.pos..][<span class="tok-number">0</span>..size];</span>
<span class="line" id="L267">                    stream.pos += size;</span>
<span class="line" id="L268">                    <span class="tok-kw">break</span> :blk .{</span>
<span class="line" id="L269">                        .block = block,</span>
<span class="line" id="L270">                    };</span>
<span class="line" id="L271">                },</span>
<span class="line" id="L272">                OP.const_type =&gt; blk: {</span>
<span class="line" id="L273">                    <span class="tok-kw">const</span> type_offset = <span class="tok-kw">try</span> leb.readULEB128(addr_type, reader);</span>
<span class="line" id="L274">                    <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> reader.readByte();</span>
<span class="line" id="L275">                    <span class="tok-kw">if</span> (stream.pos + size &gt; stream.buffer.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L276">                    <span class="tok-kw">const</span> value_bytes = stream.buffer[stream.pos..][<span class="tok-number">0</span>..size];</span>
<span class="line" id="L277">                    stream.pos += size;</span>
<span class="line" id="L278">                    <span class="tok-kw">break</span> :blk .{ .const_type = .{</span>
<span class="line" id="L279">                        .type_offset = type_offset,</span>
<span class="line" id="L280">                        .value_bytes = value_bytes,</span>
<span class="line" id="L281">                    } };</span>
<span class="line" id="L282">                },</span>
<span class="line" id="L283">                OP.deref_type,</span>
<span class="line" id="L284">                OP.xderef_type,</span>
<span class="line" id="L285">                =&gt; .{</span>
<span class="line" id="L286">                    .deref_type = .{</span>
<span class="line" id="L287">                        .size = <span class="tok-kw">try</span> reader.readByte(),</span>
<span class="line" id="L288">                        .type_offset = <span class="tok-kw">try</span> leb.readULEB128(addr_type, reader),</span>
<span class="line" id="L289">                    },</span>
<span class="line" id="L290">                },</span>
<span class="line" id="L291">                OP.lo_user...OP.hi_user =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedUserOpcode,</span>
<span class="line" id="L292">                <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,</span>
<span class="line" id="L293">            };</span>
<span class="line" id="L294">        }</span>
<span class="line" id="L295"></span>
<span class="line" id="L296">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">run</span>(</span>
<span class="line" id="L297">            self: *Self,</span>
<span class="line" id="L298">            expression: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L299">            allocator: std.mem.Allocator,</span>
<span class="line" id="L300">            context: ExpressionContext,</span>
<span class="line" id="L301">            initial_value: ?<span class="tok-type">usize</span>,</span>
<span class="line" id="L302">        ) ExpressionError!?Value {</span>
<span class="line" id="L303">            <span class="tok-kw">if</span> (initial_value) |i| <span class="tok-kw">try</span> self.stack.append(allocator, .{ .generic = i });</span>
<span class="line" id="L304">            <span class="tok-kw">var</span> stream = std.io.fixedBufferStream(expression);</span>
<span class="line" id="L305">            <span class="tok-kw">while</span> (<span class="tok-kw">try</span> self.step(&amp;stream, allocator, context)) {}</span>
<span class="line" id="L306">            <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L307">            <span class="tok-kw">return</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>];</span>
<span class="line" id="L308">        }</span>
<span class="line" id="L309"></span>
<span class="line" id="L310">        <span class="tok-comment">/// Reads an opcode and its operands from `stream`, then executes it</span></span>
<span class="line" id="L311">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">step</span>(</span>
<span class="line" id="L312">            self: *Self,</span>
<span class="line" id="L313">            stream: *std.io.FixedBufferStream([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>),</span>
<span class="line" id="L314">            allocator: std.mem.Allocator,</span>
<span class="line" id="L315">            context: ExpressionContext,</span>
<span class="line" id="L316">        ) ExpressionError!<span class="tok-type">bool</span> {</span>
<span class="line" id="L317">            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) != <span class="tok-builtin">@sizeOf</span>(addr_type) <span class="tok-kw">or</span> options.endian != <span class="tok-kw">comptime</span> builtin.target.cpu.arch.endian())</span>
<span class="line" id="L318">                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Execution of non-native address sizes / endianness is not supported&quot;</span>);</span>
<span class="line" id="L319"></span>
<span class="line" id="L320">            <span class="tok-kw">const</span> opcode = <span class="tok-kw">try</span> stream.reader().readByte();</span>
<span class="line" id="L321">            <span class="tok-kw">if</span> (options.call_frame_context <span class="tok-kw">and</span> !isOpcodeValidInCFA(opcode)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;</span>
<span class="line" id="L322">            <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> readOperand(stream, opcode, context);</span>
<span class="line" id="L323">            <span class="tok-kw">switch</span> (opcode) {</span>
<span class="line" id="L324"></span>
<span class="line" id="L325">                <span class="tok-comment">// 2.5.1.1: Literal Encodings</span>
</span>
<span class="line" id="L326">                OP.lit0...OP.lit31,</span>
<span class="line" id="L327">                OP.addr,</span>
<span class="line" id="L328">                OP.const1u,</span>
<span class="line" id="L329">                OP.const2u,</span>
<span class="line" id="L330">                OP.const4u,</span>
<span class="line" id="L331">                OP.const8u,</span>
<span class="line" id="L332">                OP.const1s,</span>
<span class="line" id="L333">                OP.const2s,</span>
<span class="line" id="L334">                OP.const4s,</span>
<span class="line" id="L335">                OP.const8s,</span>
<span class="line" id="L336">                OP.constu,</span>
<span class="line" id="L337">                OP.consts,</span>
<span class="line" id="L338">                =&gt; <span class="tok-kw">try</span> self.stack.append(allocator, .{ .generic = operand.?.generic }),</span>
<span class="line" id="L339"></span>
<span class="line" id="L340">                OP.const_type =&gt; {</span>
<span class="line" id="L341">                    <span class="tok-kw">const</span> const_type = operand.?.const_type;</span>
<span class="line" id="L342">                    <span class="tok-kw">try</span> self.stack.append(allocator, .{ .const_type = .{</span>
<span class="line" id="L343">                        .type_offset = const_type.type_offset,</span>
<span class="line" id="L344">                        .value_bytes = const_type.value_bytes,</span>
<span class="line" id="L345">                    } });</span>
<span class="line" id="L346">                },</span>
<span class="line" id="L347"></span>
<span class="line" id="L348">                OP.addrx,</span>
<span class="line" id="L349">                OP.constx,</span>
<span class="line" id="L350">                =&gt; {</span>
<span class="line" id="L351">                    <span class="tok-kw">if</span> (context.compile_unit == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;</span>
<span class="line" id="L352">                    <span class="tok-kw">if</span> (context.debug_addr == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;</span>
<span class="line" id="L353">                    <span class="tok-kw">const</span> debug_addr_index = operand.?.generic;</span>
<span class="line" id="L354">                    <span class="tok-kw">const</span> offset = context.compile_unit.?.addr_base + debug_addr_index;</span>
<span class="line" id="L355">                    <span class="tok-kw">if</span> (offset &gt;= context.debug_addr.?.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L356">                    <span class="tok-kw">const</span> value = mem.readInt(<span class="tok-type">usize</span>, context.debug_addr.?[offset..][<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)], native_endian);</span>
<span class="line" id="L357">                    <span class="tok-kw">try</span> self.stack.append(allocator, .{ .generic = value });</span>
<span class="line" id="L358">                },</span>
<span class="line" id="L359"></span>
<span class="line" id="L360">                <span class="tok-comment">// 2.5.1.2: Register Values</span>
</span>
<span class="line" id="L361">                OP.fbreg =&gt; {</span>
<span class="line" id="L362">                    <span class="tok-kw">if</span> (context.compile_unit == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;</span>
<span class="line" id="L363">                    <span class="tok-kw">if</span> (context.compile_unit.?.frame_base == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;</span>
<span class="line" id="L364"></span>
<span class="line" id="L365">                    <span class="tok-kw">const</span> offset: <span class="tok-type">i64</span> = <span class="tok-builtin">@intCast</span>(operand.?.generic);</span>
<span class="line" id="L366">                    _ = offset;</span>
<span class="line" id="L367"></span>
<span class="line" id="L368">                    <span class="tok-kw">switch</span> (context.compile_unit.?.frame_base.?.*) {</span>
<span class="line" id="L369">                        .ExprLoc =&gt; {</span>
<span class="line" id="L370">                            <span class="tok-comment">// TODO: Run this expression in a nested stack machine</span>
</span>
<span class="line" id="L371">                            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedOpcode;</span>
<span class="line" id="L372">                        },</span>
<span class="line" id="L373">                        .LocListOffset =&gt; {</span>
<span class="line" id="L374">                            <span class="tok-comment">// TODO: Read value from .debug_loclists</span>
</span>
<span class="line" id="L375">                            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedOpcode;</span>
<span class="line" id="L376">                        },</span>
<span class="line" id="L377">                        .SecOffset =&gt; {</span>
<span class="line" id="L378">                            <span class="tok-comment">// TODO: Read value from .debug_loclists</span>
</span>
<span class="line" id="L379">                            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedOpcode;</span>
<span class="line" id="L380">                        },</span>
<span class="line" id="L381">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFrameBase,</span>
<span class="line" id="L382">                    }</span>
<span class="line" id="L383">                },</span>
<span class="line" id="L384">                OP.breg0...OP.breg31,</span>
<span class="line" id="L385">                OP.bregx,</span>
<span class="line" id="L386">                =&gt; {</span>
<span class="line" id="L387">                    <span class="tok-kw">if</span> (context.thread_context == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;</span>
<span class="line" id="L388"></span>
<span class="line" id="L389">                    <span class="tok-kw">const</span> base_register = operand.?.base_register;</span>
<span class="line" id="L390">                    <span class="tok-kw">var</span> value: <span class="tok-type">i64</span> = <span class="tok-builtin">@intCast</span>(mem.readInt(<span class="tok-type">usize</span>, (<span class="tok-kw">try</span> abi.regBytes(</span>
<span class="line" id="L391">                        context.thread_context.?,</span>
<span class="line" id="L392">                        base_register.base_register,</span>
<span class="line" id="L393">                        context.reg_context,</span>
<span class="line" id="L394">                    ))[<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)], native_endian));</span>
<span class="line" id="L395">                    value += base_register.offset;</span>
<span class="line" id="L396">                    <span class="tok-kw">try</span> self.stack.append(allocator, .{ .generic = <span class="tok-builtin">@intCast</span>(value) });</span>
<span class="line" id="L397">                },</span>
<span class="line" id="L398">                OP.regval_type =&gt; {</span>
<span class="line" id="L399">                    <span class="tok-kw">const</span> register_type = operand.?.register_type;</span>
<span class="line" id="L400">                    <span class="tok-kw">const</span> value = mem.readInt(<span class="tok-type">usize</span>, (<span class="tok-kw">try</span> abi.regBytes(</span>
<span class="line" id="L401">                        context.thread_context.?,</span>
<span class="line" id="L402">                        register_type.register,</span>
<span class="line" id="L403">                        context.reg_context,</span>
<span class="line" id="L404">                    ))[<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)], native_endian);</span>
<span class="line" id="L405">                    <span class="tok-kw">try</span> self.stack.append(allocator, .{</span>
<span class="line" id="L406">                        .regval_type = .{</span>
<span class="line" id="L407">                            .type_offset = register_type.type_offset,</span>
<span class="line" id="L408">                            .type_size = <span class="tok-builtin">@sizeOf</span>(addr_type),</span>
<span class="line" id="L409">                            .value = value,</span>
<span class="line" id="L410">                        },</span>
<span class="line" id="L411">                    });</span>
<span class="line" id="L412">                },</span>
<span class="line" id="L413"></span>
<span class="line" id="L414">                <span class="tok-comment">// 2.5.1.3: Stack Operations</span>
</span>
<span class="line" id="L415">                OP.dup =&gt; {</span>
<span class="line" id="L416">                    <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L417">                    <span class="tok-kw">try</span> self.stack.append(allocator, self.stack.items[self.stack.items.len - <span class="tok-number">1</span>]);</span>
<span class="line" id="L418">                },</span>
<span class="line" id="L419">                OP.drop =&gt; {</span>
<span class="line" id="L420">                    _ = self.stack.pop();</span>
<span class="line" id="L421">                },</span>
<span class="line" id="L422">                OP.pick, OP.over =&gt; {</span>
<span class="line" id="L423">                    <span class="tok-kw">const</span> stack_index = <span class="tok-kw">if</span> (opcode == OP.over) <span class="tok-number">1</span> <span class="tok-kw">else</span> operand.?.generic;</span>
<span class="line" id="L424">                    <span class="tok-kw">if</span> (stack_index &gt;= self.stack.items.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L425">                    <span class="tok-kw">try</span> self.stack.append(allocator, self.stack.items[self.stack.items.len - <span class="tok-number">1</span> - stack_index]);</span>
<span class="line" id="L426">                },</span>
<span class="line" id="L427">                OP.swap =&gt; {</span>
<span class="line" id="L428">                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L429">                    mem.swap(Value, &amp;self.stack.items[self.stack.items.len - <span class="tok-number">1</span>], &amp;self.stack.items[self.stack.items.len - <span class="tok-number">2</span>]);</span>
<span class="line" id="L430">                },</span>
<span class="line" id="L431">                OP.rot =&gt; {</span>
<span class="line" id="L432">                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">3</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L433">                    <span class="tok-kw">const</span> first = self.stack.items[self.stack.items.len - <span class="tok-number">1</span>];</span>
<span class="line" id="L434">                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = self.stack.items[self.stack.items.len - <span class="tok-number">2</span>];</span>
<span class="line" id="L435">                    self.stack.items[self.stack.items.len - <span class="tok-number">2</span>] = self.stack.items[self.stack.items.len - <span class="tok-number">3</span>];</span>
<span class="line" id="L436">                    self.stack.items[self.stack.items.len - <span class="tok-number">3</span>] = first;</span>
<span class="line" id="L437">                },</span>
<span class="line" id="L438">                OP.deref,</span>
<span class="line" id="L439">                OP.xderef,</span>
<span class="line" id="L440">                OP.deref_size,</span>
<span class="line" id="L441">                OP.xderef_size,</span>
<span class="line" id="L442">                OP.deref_type,</span>
<span class="line" id="L443">                OP.xderef_type,</span>
<span class="line" id="L444">                =&gt; {</span>
<span class="line" id="L445">                    <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L446">                    <span class="tok-kw">var</span> addr = <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral();</span>
<span class="line" id="L447">                    <span class="tok-kw">const</span> addr_space_identifier: ?<span class="tok-type">usize</span> = <span class="tok-kw">switch</span> (opcode) {</span>
<span class="line" id="L448">                        OP.xderef,</span>
<span class="line" id="L449">                        OP.xderef_size,</span>
<span class="line" id="L450">                        OP.xderef_type,</span>
<span class="line" id="L451">                        =&gt; blk: {</span>
<span class="line" id="L452">                            _ = self.stack.pop();</span>
<span class="line" id="L453">                            <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L454">                            <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral();</span>
<span class="line" id="L455">                        },</span>
<span class="line" id="L456">                        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,</span>
<span class="line" id="L457">                    };</span>
<span class="line" id="L458"></span>
<span class="line" id="L459">                    <span class="tok-comment">// Usage of addr_space_identifier in the address calculation is implementation defined.</span>
</span>
<span class="line" id="L460">                    <span class="tok-comment">// This code will need to be updated to handle any architectures that utilize this.</span>
</span>
<span class="line" id="L461">                    _ = addr_space_identifier;</span>
<span class="line" id="L462"></span>
<span class="line" id="L463">                    <span class="tok-kw">if</span> (context.isValidMemory) |isValidMemory| <span class="tok-kw">if</span> (!isValidMemory(addr)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L464">                    <span class="tok-kw">const</span> size = <span class="tok-kw">switch</span> (opcode) {</span>
<span class="line" id="L465">                        OP.deref,</span>
<span class="line" id="L466">                        OP.xderef,</span>
<span class="line" id="L467">                        =&gt; <span class="tok-builtin">@sizeOf</span>(addr_type),</span>
<span class="line" id="L468">                        OP.deref_size,</span>
<span class="line" id="L469">                        OP.xderef_size,</span>
<span class="line" id="L470">                        =&gt; operand.?.type_size,</span>
<span class="line" id="L471">                        OP.deref_type,</span>
<span class="line" id="L472">                        OP.xderef_type,</span>
<span class="line" id="L473">                        =&gt; operand.?.deref_type.size,</span>
<span class="line" id="L474">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L475">                    };</span>
<span class="line" id="L476"></span>
<span class="line" id="L477">                    <span class="tok-kw">const</span> value: addr_type = std.math.cast(addr_type, <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-kw">switch</span> (size) {</span>
<span class="line" id="L478">                        <span class="tok-number">1</span> =&gt; <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(addr)).*,</span>
<span class="line" id="L479">                        <span class="tok-number">2</span> =&gt; <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">u16</span>, <span class="tok-builtin">@ptrFromInt</span>(addr)).*,</span>
<span class="line" id="L480">                        <span class="tok-number">4</span> =&gt; <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">u32</span>, <span class="tok-builtin">@ptrFromInt</span>(addr)).*,</span>
<span class="line" id="L481">                        <span class="tok-number">8</span> =&gt; <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">u64</span>, <span class="tok-builtin">@ptrFromInt</span>(addr)).*,</span>
<span class="line" id="L482">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression,</span>
<span class="line" id="L483">                    })) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L484"></span>
<span class="line" id="L485">                    <span class="tok-kw">switch</span> (opcode) {</span>
<span class="line" id="L486">                        OP.deref_type,</span>
<span class="line" id="L487">                        OP.xderef_type,</span>
<span class="line" id="L488">                        =&gt; {</span>
<span class="line" id="L489">                            self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{</span>
<span class="line" id="L490">                                .regval_type = .{</span>
<span class="line" id="L491">                                    .type_offset = operand.?.deref_type.type_offset,</span>
<span class="line" id="L492">                                    .type_size = operand.?.deref_type.size,</span>
<span class="line" id="L493">                                    .value = value,</span>
<span class="line" id="L494">                                },</span>
<span class="line" id="L495">                            };</span>
<span class="line" id="L496">                        },</span>
<span class="line" id="L497">                        <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L498">                            self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{ .generic = value };</span>
<span class="line" id="L499">                        },</span>
<span class="line" id="L500">                    }</span>
<span class="line" id="L501">                },</span>
<span class="line" id="L502">                OP.push_object_address =&gt; {</span>
<span class="line" id="L503">                    <span class="tok-comment">// In sub-expressions, `push_object_address` is not meaningful (as per the</span>
</span>
<span class="line" id="L504">                    <span class="tok-comment">// spec), so treat it like a nop</span>
</span>
<span class="line" id="L505">                    <span class="tok-kw">if</span> (!context.entry_value_context) {</span>
<span class="line" id="L506">                        <span class="tok-kw">if</span> (context.object_address == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;</span>
<span class="line" id="L507">                        <span class="tok-kw">try</span> self.stack.append(allocator, .{ .generic = <span class="tok-builtin">@intFromPtr</span>(context.object_address.?) });</span>
<span class="line" id="L508">                    }</span>
<span class="line" id="L509">                },</span>
<span class="line" id="L510">                OP.form_tls_address =&gt; {</span>
<span class="line" id="L511">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedOpcode;</span>
<span class="line" id="L512">                },</span>
<span class="line" id="L513">                OP.call_frame_cfa =&gt; {</span>
<span class="line" id="L514">                    <span class="tok-kw">if</span> (context.cfa) |cfa| {</span>
<span class="line" id="L515">                        <span class="tok-kw">try</span> self.stack.append(allocator, .{ .generic = cfa });</span>
<span class="line" id="L516">                    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;</span>
<span class="line" id="L517">                },</span>
<span class="line" id="L518"></span>
<span class="line" id="L519">                <span class="tok-comment">// 2.5.1.4: Arithmetic and Logical Operations</span>
</span>
<span class="line" id="L520">                OP.abs =&gt; {</span>
<span class="line" id="L521">                    <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L522">                    <span class="tok-kw">const</span> value: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral());</span>
<span class="line" id="L523">                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{</span>
<span class="line" id="L524">                        .generic = <span class="tok-builtin">@abs</span>(value),</span>
<span class="line" id="L525">                    };</span>
<span class="line" id="L526">                },</span>
<span class="line" id="L527">                OP.@&quot;and&quot; =&gt; {</span>
<span class="line" id="L528">                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L529">                    <span class="tok-kw">const</span> a = <span class="tok-kw">try</span> self.stack.pop().asIntegral();</span>
<span class="line" id="L530">                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{</span>
<span class="line" id="L531">                        .generic = a &amp; <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral(),</span>
<span class="line" id="L532">                    };</span>
<span class="line" id="L533">                },</span>
<span class="line" id="L534">                OP.div =&gt; {</span>
<span class="line" id="L535">                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L536">                    <span class="tok-kw">const</span> a: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.pop().asIntegral());</span>
<span class="line" id="L537">                    <span class="tok-kw">const</span> b: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral());</span>
<span class="line" id="L538">                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{</span>
<span class="line" id="L539">                        .generic = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> std.math.divTrunc(<span class="tok-type">isize</span>, b, a)),</span>
<span class="line" id="L540">                    };</span>
<span class="line" id="L541">                },</span>
<span class="line" id="L542">                OP.minus =&gt; {</span>
<span class="line" id="L543">                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L544">                    <span class="tok-kw">const</span> b = <span class="tok-kw">try</span> self.stack.pop().asIntegral();</span>
<span class="line" id="L545">                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{</span>
<span class="line" id="L546">                        .generic = <span class="tok-kw">try</span> std.math.sub(addr_type, <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral(), b),</span>
<span class="line" id="L547">                    };</span>
<span class="line" id="L548">                },</span>
<span class="line" id="L549">                OP.mod =&gt; {</span>
<span class="line" id="L550">                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L551">                    <span class="tok-kw">const</span> a: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.pop().asIntegral());</span>
<span class="line" id="L552">                    <span class="tok-kw">const</span> b: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral());</span>
<span class="line" id="L553">                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{</span>
<span class="line" id="L554">                        .generic = <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@mod</span>(b, a)),</span>
<span class="line" id="L555">                    };</span>
<span class="line" id="L556">                },</span>
<span class="line" id="L557">                OP.mul =&gt; {</span>
<span class="line" id="L558">                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L559">                    <span class="tok-kw">const</span> a: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.pop().asIntegral());</span>
<span class="line" id="L560">                    <span class="tok-kw">const</span> b: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral());</span>
<span class="line" id="L561">                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{</span>
<span class="line" id="L562">                        .generic = <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@mulWithOverflow</span>(a, b)[<span class="tok-number">0</span>]),</span>
<span class="line" id="L563">                    };</span>
<span class="line" id="L564">                },</span>
<span class="line" id="L565">                OP.neg =&gt; {</span>
<span class="line" id="L566">                    <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L567">                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{</span>
<span class="line" id="L568">                        .generic = <span class="tok-builtin">@bitCast</span>(</span>
<span class="line" id="L569">                            <span class="tok-kw">try</span> std.math.negate(</span>
<span class="line" id="L570">                                <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral())),</span>
<span class="line" id="L571">                            ),</span>
<span class="line" id="L572">                        ),</span>
<span class="line" id="L573">                    };</span>
<span class="line" id="L574">                },</span>
<span class="line" id="L575">                OP.not =&gt; {</span>
<span class="line" id="L576">                    <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L577">                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{</span>
<span class="line" id="L578">                        .generic = ~<span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral(),</span>
<span class="line" id="L579">                    };</span>
<span class="line" id="L580">                },</span>
<span class="line" id="L581">                OP.@&quot;or&quot; =&gt; {</span>
<span class="line" id="L582">                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L583">                    <span class="tok-kw">const</span> a = <span class="tok-kw">try</span> self.stack.pop().asIntegral();</span>
<span class="line" id="L584">                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{</span>
<span class="line" id="L585">                        .generic = a | <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral(),</span>
<span class="line" id="L586">                    };</span>
<span class="line" id="L587">                },</span>
<span class="line" id="L588">                OP.plus =&gt; {</span>
<span class="line" id="L589">                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L590">                    <span class="tok-kw">const</span> b = <span class="tok-kw">try</span> self.stack.pop().asIntegral();</span>
<span class="line" id="L591">                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{</span>
<span class="line" id="L592">                        .generic = <span class="tok-kw">try</span> std.math.add(addr_type, <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral(), b),</span>
<span class="line" id="L593">                    };</span>
<span class="line" id="L594">                },</span>
<span class="line" id="L595">                OP.plus_uconst =&gt; {</span>
<span class="line" id="L596">                    <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L597">                    <span class="tok-kw">const</span> constant = operand.?.generic;</span>
<span class="line" id="L598">                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{</span>
<span class="line" id="L599">                        .generic = <span class="tok-kw">try</span> std.math.add(addr_type, <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral(), constant),</span>
<span class="line" id="L600">                    };</span>
<span class="line" id="L601">                },</span>
<span class="line" id="L602">                OP.shl =&gt; {</span>
<span class="line" id="L603">                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L604">                    <span class="tok-kw">const</span> a = <span class="tok-kw">try</span> self.stack.pop().asIntegral();</span>
<span class="line" id="L605">                    <span class="tok-kw">const</span> b = <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral();</span>
<span class="line" id="L606">                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{</span>
<span class="line" id="L607">                        .generic = std.math.shl(<span class="tok-type">usize</span>, b, a),</span>
<span class="line" id="L608">                    };</span>
<span class="line" id="L609">                },</span>
<span class="line" id="L610">                OP.shr =&gt; {</span>
<span class="line" id="L611">                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L612">                    <span class="tok-kw">const</span> a = <span class="tok-kw">try</span> self.stack.pop().asIntegral();</span>
<span class="line" id="L613">                    <span class="tok-kw">const</span> b = <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral();</span>
<span class="line" id="L614">                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{</span>
<span class="line" id="L615">                        .generic = std.math.shr(<span class="tok-type">usize</span>, b, a),</span>
<span class="line" id="L616">                    };</span>
<span class="line" id="L617">                },</span>
<span class="line" id="L618">                OP.shra =&gt; {</span>
<span class="line" id="L619">                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L620">                    <span class="tok-kw">const</span> a = <span class="tok-kw">try</span> self.stack.pop().asIntegral();</span>
<span class="line" id="L621">                    <span class="tok-kw">const</span> b: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral());</span>
<span class="line" id="L622">                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{</span>
<span class="line" id="L623">                        .generic = <span class="tok-builtin">@bitCast</span>(std.math.shr(<span class="tok-type">isize</span>, b, a)),</span>
<span class="line" id="L624">                    };</span>
<span class="line" id="L625">                },</span>
<span class="line" id="L626">                OP.xor =&gt; {</span>
<span class="line" id="L627">                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L628">                    <span class="tok-kw">const</span> a = <span class="tok-kw">try</span> self.stack.pop().asIntegral();</span>
<span class="line" id="L629">                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{</span>
<span class="line" id="L630">                        .generic = a ^ <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral(),</span>
<span class="line" id="L631">                    };</span>
<span class="line" id="L632">                },</span>
<span class="line" id="L633"></span>
<span class="line" id="L634">                <span class="tok-comment">// 2.5.1.5: Control Flow Operations</span>
</span>
<span class="line" id="L635">                OP.le,</span>
<span class="line" id="L636">                OP.ge,</span>
<span class="line" id="L637">                OP.eq,</span>
<span class="line" id="L638">                OP.lt,</span>
<span class="line" id="L639">                OP.gt,</span>
<span class="line" id="L640">                OP.ne,</span>
<span class="line" id="L641">                =&gt; {</span>
<span class="line" id="L642">                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L643">                    <span class="tok-kw">const</span> a = self.stack.pop();</span>
<span class="line" id="L644">                    <span class="tok-kw">const</span> b = self.stack.items[self.stack.items.len - <span class="tok-number">1</span>];</span>
<span class="line" id="L645"></span>
<span class="line" id="L646">                    <span class="tok-kw">if</span> (a == .generic <span class="tok-kw">and</span> b == .generic) {</span>
<span class="line" id="L647">                        <span class="tok-kw">const</span> a_int: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(a.asIntegral() <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>);</span>
<span class="line" id="L648">                        <span class="tok-kw">const</span> b_int: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(b.asIntegral() <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>);</span>
<span class="line" id="L649">                        <span class="tok-kw">const</span> result = <span class="tok-builtin">@intFromBool</span>(<span class="tok-kw">switch</span> (opcode) {</span>
<span class="line" id="L650">                            OP.le =&gt; b_int &lt;= a_int,</span>
<span class="line" id="L651">                            OP.ge =&gt; b_int &gt;= a_int,</span>
<span class="line" id="L652">                            OP.eq =&gt; b_int == a_int,</span>
<span class="line" id="L653">                            OP.lt =&gt; b_int &lt; a_int,</span>
<span class="line" id="L654">                            OP.gt =&gt; b_int &gt; a_int,</span>
<span class="line" id="L655">                            OP.ne =&gt; b_int != a_int,</span>
<span class="line" id="L656">                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L657">                        });</span>
<span class="line" id="L658"></span>
<span class="line" id="L659">                        self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{ .generic = result };</span>
<span class="line" id="L660">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L661">                        <span class="tok-comment">// TODO: Load the types referenced by these values, find their comparison operator, and run it</span>
</span>
<span class="line" id="L662">                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedTypedComparison;</span>
<span class="line" id="L663">                    }</span>
<span class="line" id="L664">                },</span>
<span class="line" id="L665">                OP.skip, OP.bra =&gt; {</span>
<span class="line" id="L666">                    <span class="tok-kw">const</span> branch_offset = operand.?.branch_offset;</span>
<span class="line" id="L667">                    <span class="tok-kw">const</span> condition = <span class="tok-kw">if</span> (opcode == OP.bra) blk: {</span>
<span class="line" id="L668">                        <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L669">                        <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> self.stack.pop().asIntegral() != <span class="tok-number">0</span>;</span>
<span class="line" id="L670">                    } <span class="tok-kw">else</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L671"></span>
<span class="line" id="L672">                    <span class="tok-kw">if</span> (condition) {</span>
<span class="line" id="L673">                        <span class="tok-kw">const</span> new_pos = std.math.cast(</span>
<span class="line" id="L674">                            <span class="tok-type">usize</span>,</span>
<span class="line" id="L675">                            <span class="tok-kw">try</span> std.math.add(<span class="tok-type">isize</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@intCast</span>(stream.pos)), branch_offset),</span>
<span class="line" id="L676">                        ) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L677"></span>
<span class="line" id="L678">                        <span class="tok-kw">if</span> (new_pos &lt; <span class="tok-number">0</span> <span class="tok-kw">or</span> new_pos &gt; stream.buffer.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L679">                        stream.pos = new_pos;</span>
<span class="line" id="L680">                    }</span>
<span class="line" id="L681">                },</span>
<span class="line" id="L682">                OP.call2,</span>
<span class="line" id="L683">                OP.call4,</span>
<span class="line" id="L684">                OP.call_ref,</span>
<span class="line" id="L685">                =&gt; {</span>
<span class="line" id="L686">                    <span class="tok-kw">const</span> debug_info_offset = operand.?.generic;</span>
<span class="line" id="L687">                    _ = debug_info_offset;</span>
<span class="line" id="L688"></span>
<span class="line" id="L689">                    <span class="tok-comment">// TODO: Load a DIE entry at debug_info_offset in a .debug_info section (the spec says that it</span>
</span>
<span class="line" id="L690">                    <span class="tok-comment">//       can be in a separate exe / shared object from the one containing this expression).</span>
</span>
<span class="line" id="L691">                    <span class="tok-comment">//       Transfer control to the DW_AT_location attribute, with the current stack as input.</span>
</span>
<span class="line" id="L692"></span>
<span class="line" id="L693">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedExpressionCall;</span>
<span class="line" id="L694">                },</span>
<span class="line" id="L695"></span>
<span class="line" id="L696">                <span class="tok-comment">// 2.5.1.6: Type Conversions</span>
</span>
<span class="line" id="L697">                OP.convert =&gt; {</span>
<span class="line" id="L698">                    <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L699">                    <span class="tok-kw">const</span> type_offset = operand.?.generic;</span>
<span class="line" id="L700"></span>
<span class="line" id="L701">                    <span class="tok-comment">// TODO: Load the DW_TAG_base_type entries in context.compile_unit and verify both types are the same size</span>
</span>
<span class="line" id="L702">                    <span class="tok-kw">const</span> value = self.stack.items[self.stack.items.len - <span class="tok-number">1</span>];</span>
<span class="line" id="L703">                    <span class="tok-kw">if</span> (type_offset == <span class="tok-number">0</span>) {</span>
<span class="line" id="L704">                        self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{ .generic = <span class="tok-kw">try</span> value.asIntegral() };</span>
<span class="line" id="L705">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L706">                        <span class="tok-comment">// TODO: Load the DW_TAG_base_type entry in context.compile_unit, find a conversion operator</span>
</span>
<span class="line" id="L707">                        <span class="tok-comment">//       from the old type to the new type, run it.</span>
</span>
<span class="line" id="L708">                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedTypeConversion;</span>
<span class="line" id="L709">                    }</span>
<span class="line" id="L710">                },</span>
<span class="line" id="L711">                OP.reinterpret =&gt; {</span>
<span class="line" id="L712">                    <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;</span>
<span class="line" id="L713">                    <span class="tok-kw">const</span> type_offset = operand.?.generic;</span>
<span class="line" id="L714"></span>
<span class="line" id="L715">                    <span class="tok-comment">// TODO: Load the DW_TAG_base_type entries in context.compile_unit and verify both types are the same size</span>
</span>
<span class="line" id="L716">                    <span class="tok-kw">const</span> value = self.stack.items[self.stack.items.len - <span class="tok-number">1</span>];</span>
<span class="line" id="L717">                    <span class="tok-kw">if</span> (type_offset == <span class="tok-number">0</span>) {</span>
<span class="line" id="L718">                        self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{ .generic = <span class="tok-kw">try</span> value.asIntegral() };</span>
<span class="line" id="L719">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L720">                        self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = <span class="tok-kw">switch</span> (value) {</span>
<span class="line" id="L721">                            .generic =&gt; |v| .{</span>
<span class="line" id="L722">                                .regval_type = .{</span>
<span class="line" id="L723">                                    .type_offset = type_offset,</span>
<span class="line" id="L724">                                    .type_size = <span class="tok-builtin">@sizeOf</span>(addr_type),</span>
<span class="line" id="L725">                                    .value = v,</span>
<span class="line" id="L726">                                },</span>
<span class="line" id="L727">                            },</span>
<span class="line" id="L728">                            .regval_type =&gt; |r| .{</span>
<span class="line" id="L729">                                .regval_type = .{</span>
<span class="line" id="L730">                                    .type_offset = type_offset,</span>
<span class="line" id="L731">                                    .type_size = r.type_size,</span>
<span class="line" id="L732">                                    .value = r.value,</span>
<span class="line" id="L733">                                },</span>
<span class="line" id="L734">                            },</span>
<span class="line" id="L735">                            .const_type =&gt; |c| .{</span>
<span class="line" id="L736">                                .const_type = .{</span>
<span class="line" id="L737">                                    .type_offset = type_offset,</span>
<span class="line" id="L738">                                    .value_bytes = c.value_bytes,</span>
<span class="line" id="L739">                                },</span>
<span class="line" id="L740">                            },</span>
<span class="line" id="L741">                        };</span>
<span class="line" id="L742">                    }</span>
<span class="line" id="L743">                },</span>
<span class="line" id="L744"></span>
<span class="line" id="L745">                <span class="tok-comment">// 2.5.1.7: Special Operations</span>
</span>
<span class="line" id="L746">                OP.nop =&gt; {},</span>
<span class="line" id="L747">                OP.entry_value =&gt; {</span>
<span class="line" id="L748">                    <span class="tok-kw">const</span> block = operand.?.block;</span>
<span class="line" id="L749">                    <span class="tok-kw">if</span> (block.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidSubExpression;</span>
<span class="line" id="L750"></span>
<span class="line" id="L751">                    <span class="tok-comment">// TODO: The spec states that this sub-expression needs to observe the state (ie. registers)</span>
</span>
<span class="line" id="L752">                    <span class="tok-comment">//       as it was upon entering the current subprogram. If this isn't being called at the</span>
</span>
<span class="line" id="L753">                    <span class="tok-comment">//       end of a frame unwind operation, an additional ThreadContext with this state will be needed.</span>
</span>
<span class="line" id="L754"></span>
<span class="line" id="L755">                    <span class="tok-kw">if</span> (isOpcodeRegisterLocation(block[<span class="tok-number">0</span>])) {</span>
<span class="line" id="L756">                        <span class="tok-kw">if</span> (context.thread_context == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;</span>
<span class="line" id="L757"></span>
<span class="line" id="L758">                        <span class="tok-kw">var</span> block_stream = std.io.fixedBufferStream(block);</span>
<span class="line" id="L759">                        <span class="tok-kw">const</span> register = (<span class="tok-kw">try</span> readOperand(&amp;block_stream, block[<span class="tok-number">0</span>], context)).?.register;</span>
<span class="line" id="L760">                        <span class="tok-kw">const</span> value = mem.readInt(<span class="tok-type">usize</span>, (<span class="tok-kw">try</span> abi.regBytes(context.thread_context.?, register, context.reg_context))[<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)], native_endian);</span>
<span class="line" id="L761">                        <span class="tok-kw">try</span> self.stack.append(allocator, .{ .generic = value });</span>
<span class="line" id="L762">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L763">                        <span class="tok-kw">var</span> stack_machine: Self = .{};</span>
<span class="line" id="L764">                        <span class="tok-kw">defer</span> stack_machine.deinit(allocator);</span>
<span class="line" id="L765"></span>
<span class="line" id="L766">                        <span class="tok-kw">var</span> sub_context = context;</span>
<span class="line" id="L767">                        sub_context.entry_value_context = <span class="tok-null">true</span>;</span>
<span class="line" id="L768">                        <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> stack_machine.run(block, allocator, sub_context, <span class="tok-null">null</span>);</span>
<span class="line" id="L769">                        <span class="tok-kw">try</span> self.stack.append(allocator, result <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidSubExpression);</span>
<span class="line" id="L770">                    }</span>
<span class="line" id="L771">                },</span>
<span class="line" id="L772"></span>
<span class="line" id="L773">                <span class="tok-comment">// These have already been handled by readOperand</span>
</span>
<span class="line" id="L774">                OP.lo_user...OP.hi_user =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L775">                <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L776">                    <span class="tok-comment">//std.debug.print(&quot;Unknown DWARF expression opcode: {x}\n&quot;, .{opcode});</span>
</span>
<span class="line" id="L777">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownExpressionOpcode;</span>
<span class="line" id="L778">                },</span>
<span class="line" id="L779">            }</span>
<span class="line" id="L780"></span>
<span class="line" id="L781">            <span class="tok-kw">return</span> stream.pos &lt; stream.buffer.len;</span>
<span class="line" id="L782">        }</span>
<span class="line" id="L783">    };</span>
<span class="line" id="L784">}</span>
<span class="line" id="L785"></span>
<span class="line" id="L786"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Builder</span>(<span class="tok-kw">comptime</span> options: ExpressionOptions) <span class="tok-type">type</span> {</span>
<span class="line" id="L787">    <span class="tok-kw">const</span> addr_type = <span class="tok-kw">switch</span> (options.addr_size) {</span>
<span class="line" id="L788">        <span class="tok-number">2</span> =&gt; <span class="tok-type">u16</span>,</span>
<span class="line" id="L789">        <span class="tok-number">4</span> =&gt; <span class="tok-type">u32</span>,</span>
<span class="line" id="L790">        <span class="tok-number">8</span> =&gt; <span class="tok-type">u64</span>,</span>
<span class="line" id="L791">        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unsupported address size of &quot;</span> ++ options.addr_size),</span>
<span class="line" id="L792">    };</span>
<span class="line" id="L793"></span>
<span class="line" id="L794">    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L795">        <span class="tok-comment">/// Zero-operand instructions</span></span>
<span class="line" id="L796">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeOpcode</span>(writer: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> opcode: <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L797">            <span class="tok-kw">if</span> (options.call_frame_context <span class="tok-kw">and</span> !<span class="tok-kw">comptime</span> isOpcodeValidInCFA(opcode)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;</span>
<span class="line" id="L798">            <span class="tok-kw">switch</span> (opcode) {</span>
<span class="line" id="L799">                OP.dup,</span>
<span class="line" id="L800">                OP.drop,</span>
<span class="line" id="L801">                OP.over,</span>
<span class="line" id="L802">                OP.swap,</span>
<span class="line" id="L803">                OP.rot,</span>
<span class="line" id="L804">                OP.deref,</span>
<span class="line" id="L805">                OP.xderef,</span>
<span class="line" id="L806">                OP.push_object_address,</span>
<span class="line" id="L807">                OP.form_tls_address,</span>
<span class="line" id="L808">                OP.call_frame_cfa,</span>
<span class="line" id="L809">                OP.abs,</span>
<span class="line" id="L810">                OP.@&quot;and&quot;,</span>
<span class="line" id="L811">                OP.div,</span>
<span class="line" id="L812">                OP.minus,</span>
<span class="line" id="L813">                OP.mod,</span>
<span class="line" id="L814">                OP.mul,</span>
<span class="line" id="L815">                OP.neg,</span>
<span class="line" id="L816">                OP.not,</span>
<span class="line" id="L817">                OP.@&quot;or&quot;,</span>
<span class="line" id="L818">                OP.plus,</span>
<span class="line" id="L819">                OP.shl,</span>
<span class="line" id="L820">                OP.shr,</span>
<span class="line" id="L821">                OP.shra,</span>
<span class="line" id="L822">                OP.xor,</span>
<span class="line" id="L823">                OP.le,</span>
<span class="line" id="L824">                OP.ge,</span>
<span class="line" id="L825">                OP.eq,</span>
<span class="line" id="L826">                OP.lt,</span>
<span class="line" id="L827">                OP.gt,</span>
<span class="line" id="L828">                OP.ne,</span>
<span class="line" id="L829">                OP.nop,</span>
<span class="line" id="L830">                OP.stack_value,</span>
<span class="line" id="L831">                =&gt; <span class="tok-kw">try</span> writer.writeByte(opcode),</span>
<span class="line" id="L832">                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;This opcode requires operands, use `write&lt;Opcode&gt;()` instead&quot;</span>),</span>
<span class="line" id="L833">            }</span>
<span class="line" id="L834">        }</span>
<span class="line" id="L835"></span>
<span class="line" id="L836">        <span class="tok-comment">// 2.5.1.1: Literal Encodings</span>
</span>
<span class="line" id="L837">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeLiteral</span>(writer: <span class="tok-kw">anytype</span>, literal: <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L838">            <span class="tok-kw">switch</span> (literal) {</span>
<span class="line" id="L839">                <span class="tok-number">0</span>...<span class="tok-number">31</span> =&gt; |n| <span class="tok-kw">try</span> writer.writeByte(n + OP.lit0),</span>
<span class="line" id="L840">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidLiteral,</span>
<span class="line" id="L841">            }</span>
<span class="line" id="L842">        }</span>
<span class="line" id="L843"></span>
<span class="line" id="L844">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeConst</span>(writer: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, value: T) !<span class="tok-type">void</span> {</span>
<span class="line" id="L845">            <span class="tok-kw">if</span> (<span class="tok-builtin">@typeInfo</span>(T) != .Int) <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Constants must be integers&quot;</span>);</span>
<span class="line" id="L846"></span>
<span class="line" id="L847">            <span class="tok-kw">switch</span> (T) {</span>
<span class="line" id="L848">                <span class="tok-type">u8</span>, <span class="tok-type">i8</span>, <span class="tok-type">u16</span>, <span class="tok-type">i16</span>, <span class="tok-type">u32</span>, <span class="tok-type">i32</span>, <span class="tok-type">u64</span>, <span class="tok-type">i64</span> =&gt; {</span>
<span class="line" id="L849">                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-kw">switch</span> (T) {</span>
<span class="line" id="L850">                        <span class="tok-type">u8</span> =&gt; OP.const1u,</span>
<span class="line" id="L851">                        <span class="tok-type">i8</span> =&gt; OP.const1s,</span>
<span class="line" id="L852">                        <span class="tok-type">u16</span> =&gt; OP.const2u,</span>
<span class="line" id="L853">                        <span class="tok-type">i16</span> =&gt; OP.const2s,</span>
<span class="line" id="L854">                        <span class="tok-type">u32</span> =&gt; OP.const4u,</span>
<span class="line" id="L855">                        <span class="tok-type">i32</span> =&gt; OP.const4s,</span>
<span class="line" id="L856">                        <span class="tok-type">u64</span> =&gt; OP.const8u,</span>
<span class="line" id="L857">                        <span class="tok-type">i64</span> =&gt; OP.const8s,</span>
<span class="line" id="L858">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L859">                    });</span>
<span class="line" id="L860"></span>
<span class="line" id="L861">                    <span class="tok-kw">try</span> writer.writeInt(T, value, options.endian);</span>
<span class="line" id="L862">                },</span>
<span class="line" id="L863">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T).Int.signedness) {</span>
<span class="line" id="L864">                    .unsigned =&gt; {</span>
<span class="line" id="L865">                        <span class="tok-kw">try</span> writer.writeByte(OP.constu);</span>
<span class="line" id="L866">                        <span class="tok-kw">try</span> leb.writeULEB128(writer, value);</span>
<span class="line" id="L867">                    },</span>
<span class="line" id="L868">                    .signed =&gt; {</span>
<span class="line" id="L869">                        <span class="tok-kw">try</span> writer.writeByte(OP.consts);</span>
<span class="line" id="L870">                        <span class="tok-kw">try</span> leb.writeILEB128(writer, value);</span>
<span class="line" id="L871">                    },</span>
<span class="line" id="L872">                },</span>
<span class="line" id="L873">            }</span>
<span class="line" id="L874">        }</span>
<span class="line" id="L875"></span>
<span class="line" id="L876">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeConstx</span>(writer: <span class="tok-kw">anytype</span>, debug_addr_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L877">            <span class="tok-kw">try</span> writer.writeByte(OP.constx);</span>
<span class="line" id="L878">            <span class="tok-kw">try</span> leb.writeULEB128(writer, debug_addr_offset);</span>
<span class="line" id="L879">        }</span>
<span class="line" id="L880"></span>
<span class="line" id="L881">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeConstType</span>(writer: <span class="tok-kw">anytype</span>, die_offset: <span class="tok-kw">anytype</span>, value_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L882">            <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;</span>
<span class="line" id="L883">            <span class="tok-kw">if</span> (value_bytes.len &gt; <span class="tok-number">0xff</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidTypeLength;</span>
<span class="line" id="L884">            <span class="tok-kw">try</span> writer.writeByte(OP.const_type);</span>
<span class="line" id="L885">            <span class="tok-kw">try</span> leb.writeULEB128(writer, die_offset);</span>
<span class="line" id="L886">            <span class="tok-kw">try</span> writer.writeByte(<span class="tok-builtin">@intCast</span>(value_bytes.len));</span>
<span class="line" id="L887">            <span class="tok-kw">try</span> writer.writeAll(value_bytes);</span>
<span class="line" id="L888">        }</span>
<span class="line" id="L889"></span>
<span class="line" id="L890">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeAddr</span>(writer: <span class="tok-kw">anytype</span>, value: addr_type) !<span class="tok-type">void</span> {</span>
<span class="line" id="L891">            <span class="tok-kw">try</span> writer.writeByte(OP.addr);</span>
<span class="line" id="L892">            <span class="tok-kw">try</span> writer.writeInt(addr_type, value, options.endian);</span>
<span class="line" id="L893">        }</span>
<span class="line" id="L894"></span>
<span class="line" id="L895">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeAddrx</span>(writer: <span class="tok-kw">anytype</span>, debug_addr_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L896">            <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;</span>
<span class="line" id="L897">            <span class="tok-kw">try</span> writer.writeByte(OP.addrx);</span>
<span class="line" id="L898">            <span class="tok-kw">try</span> leb.writeULEB128(writer, debug_addr_offset);</span>
<span class="line" id="L899">        }</span>
<span class="line" id="L900"></span>
<span class="line" id="L901">        <span class="tok-comment">// 2.5.1.2: Register Values</span>
</span>
<span class="line" id="L902">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeFbreg</span>(writer: <span class="tok-kw">anytype</span>, offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L903">            <span class="tok-kw">try</span> writer.writeByte(OP.fbreg);</span>
<span class="line" id="L904">            <span class="tok-kw">try</span> leb.writeILEB128(writer, offset);</span>
<span class="line" id="L905">        }</span>
<span class="line" id="L906"></span>
<span class="line" id="L907">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeBreg</span>(writer: <span class="tok-kw">anytype</span>, register: <span class="tok-type">u8</span>, offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L908">            <span class="tok-kw">if</span> (register &gt; <span class="tok-number">31</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidRegister;</span>
<span class="line" id="L909">            <span class="tok-kw">try</span> writer.writeByte(OP.breg0 + register);</span>
<span class="line" id="L910">            <span class="tok-kw">try</span> leb.writeILEB128(writer, offset);</span>
<span class="line" id="L911">        }</span>
<span class="line" id="L912"></span>
<span class="line" id="L913">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeBregx</span>(writer: <span class="tok-kw">anytype</span>, register: <span class="tok-kw">anytype</span>, offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L914">            <span class="tok-kw">try</span> writer.writeByte(OP.bregx);</span>
<span class="line" id="L915">            <span class="tok-kw">try</span> leb.writeULEB128(writer, register);</span>
<span class="line" id="L916">            <span class="tok-kw">try</span> leb.writeILEB128(writer, offset);</span>
<span class="line" id="L917">        }</span>
<span class="line" id="L918"></span>
<span class="line" id="L919">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeRegvalType</span>(writer: <span class="tok-kw">anytype</span>, register: <span class="tok-kw">anytype</span>, offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L920">            <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;</span>
<span class="line" id="L921">            <span class="tok-kw">try</span> writer.writeByte(OP.regval_type);</span>
<span class="line" id="L922">            <span class="tok-kw">try</span> leb.writeULEB128(writer, register);</span>
<span class="line" id="L923">            <span class="tok-kw">try</span> leb.writeULEB128(writer, offset);</span>
<span class="line" id="L924">        }</span>
<span class="line" id="L925"></span>
<span class="line" id="L926">        <span class="tok-comment">// 2.5.1.3: Stack Operations</span>
</span>
<span class="line" id="L927">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writePick</span>(writer: <span class="tok-kw">anytype</span>, index: <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L928">            <span class="tok-kw">try</span> writer.writeByte(OP.pick);</span>
<span class="line" id="L929">            <span class="tok-kw">try</span> writer.writeByte(index);</span>
<span class="line" id="L930">        }</span>
<span class="line" id="L931"></span>
<span class="line" id="L932">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeDerefSize</span>(writer: <span class="tok-kw">anytype</span>, size: <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L933">            <span class="tok-kw">try</span> writer.writeByte(OP.deref_size);</span>
<span class="line" id="L934">            <span class="tok-kw">try</span> writer.writeByte(size);</span>
<span class="line" id="L935">        }</span>
<span class="line" id="L936"></span>
<span class="line" id="L937">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeXDerefSize</span>(writer: <span class="tok-kw">anytype</span>, size: <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L938">            <span class="tok-kw">try</span> writer.writeByte(OP.xderef_size);</span>
<span class="line" id="L939">            <span class="tok-kw">try</span> writer.writeByte(size);</span>
<span class="line" id="L940">        }</span>
<span class="line" id="L941"></span>
<span class="line" id="L942">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeDerefType</span>(writer: <span class="tok-kw">anytype</span>, size: <span class="tok-type">u8</span>, die_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L943">            <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;</span>
<span class="line" id="L944">            <span class="tok-kw">try</span> writer.writeByte(OP.deref_type);</span>
<span class="line" id="L945">            <span class="tok-kw">try</span> writer.writeByte(size);</span>
<span class="line" id="L946">            <span class="tok-kw">try</span> leb.writeULEB128(writer, die_offset);</span>
<span class="line" id="L947">        }</span>
<span class="line" id="L948"></span>
<span class="line" id="L949">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeXDerefType</span>(writer: <span class="tok-kw">anytype</span>, size: <span class="tok-type">u8</span>, die_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L950">            <span class="tok-kw">try</span> writer.writeByte(OP.xderef_type);</span>
<span class="line" id="L951">            <span class="tok-kw">try</span> writer.writeByte(size);</span>
<span class="line" id="L952">            <span class="tok-kw">try</span> leb.writeULEB128(writer, die_offset);</span>
<span class="line" id="L953">        }</span>
<span class="line" id="L954"></span>
<span class="line" id="L955">        <span class="tok-comment">// 2.5.1.4: Arithmetic and Logical Operations</span>
</span>
<span class="line" id="L956"></span>
<span class="line" id="L957">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writePlusUconst</span>(writer: <span class="tok-kw">anytype</span>, uint_value: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L958">            <span class="tok-kw">try</span> writer.writeByte(OP.plus_uconst);</span>
<span class="line" id="L959">            <span class="tok-kw">try</span> leb.writeULEB128(writer, uint_value);</span>
<span class="line" id="L960">        }</span>
<span class="line" id="L961"></span>
<span class="line" id="L962">        <span class="tok-comment">// 2.5.1.5: Control Flow Operations</span>
</span>
<span class="line" id="L963"></span>
<span class="line" id="L964">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeSkip</span>(writer: <span class="tok-kw">anytype</span>, offset: <span class="tok-type">i16</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L965">            <span class="tok-kw">try</span> writer.writeByte(OP.skip);</span>
<span class="line" id="L966">            <span class="tok-kw">try</span> writer.writeInt(<span class="tok-type">i16</span>, offset, options.endian);</span>
<span class="line" id="L967">        }</span>
<span class="line" id="L968"></span>
<span class="line" id="L969">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeBra</span>(writer: <span class="tok-kw">anytype</span>, offset: <span class="tok-type">i16</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L970">            <span class="tok-kw">try</span> writer.writeByte(OP.bra);</span>
<span class="line" id="L971">            <span class="tok-kw">try</span> writer.writeInt(<span class="tok-type">i16</span>, offset, options.endian);</span>
<span class="line" id="L972">        }</span>
<span class="line" id="L973"></span>
<span class="line" id="L974">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeCall</span>(writer: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, offset: T) !<span class="tok-type">void</span> {</span>
<span class="line" id="L975">            <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;</span>
<span class="line" id="L976">            <span class="tok-kw">switch</span> (T) {</span>
<span class="line" id="L977">                <span class="tok-type">u16</span> =&gt; <span class="tok-kw">try</span> writer.writeByte(OP.call2),</span>
<span class="line" id="L978">                <span class="tok-type">u32</span> =&gt; <span class="tok-kw">try</span> writer.writeByte(OP.call4),</span>
<span class="line" id="L979">                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Call operand must be a 2 or 4 byte offset&quot;</span>),</span>
<span class="line" id="L980">            }</span>
<span class="line" id="L981"></span>
<span class="line" id="L982">            <span class="tok-kw">try</span> writer.writeInt(T, offset, options.endian);</span>
<span class="line" id="L983">        }</span>
<span class="line" id="L984"></span>
<span class="line" id="L985">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeCallRef</span>(writer: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> is_64: <span class="tok-type">bool</span>, value: <span class="tok-kw">if</span> (is_64) <span class="tok-type">u64</span> <span class="tok-kw">else</span> <span class="tok-type">u32</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L986">            <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;</span>
<span class="line" id="L987">            <span class="tok-kw">try</span> writer.writeByte(OP.call_ref);</span>
<span class="line" id="L988">            <span class="tok-kw">try</span> writer.writeInt(<span class="tok-kw">if</span> (is_64) <span class="tok-type">u64</span> <span class="tok-kw">else</span> <span class="tok-type">u32</span>, value, options.endian);</span>
<span class="line" id="L989">        }</span>
<span class="line" id="L990"></span>
<span class="line" id="L991">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeConvert</span>(writer: <span class="tok-kw">anytype</span>, die_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L992">            <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;</span>
<span class="line" id="L993">            <span class="tok-kw">try</span> writer.writeByte(OP.convert);</span>
<span class="line" id="L994">            <span class="tok-kw">try</span> leb.writeULEB128(writer, die_offset);</span>
<span class="line" id="L995">        }</span>
<span class="line" id="L996"></span>
<span class="line" id="L997">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeReinterpret</span>(writer: <span class="tok-kw">anytype</span>, die_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L998">            <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;</span>
<span class="line" id="L999">            <span class="tok-kw">try</span> writer.writeByte(OP.reinterpret);</span>
<span class="line" id="L1000">            <span class="tok-kw">try</span> leb.writeULEB128(writer, die_offset);</span>
<span class="line" id="L1001">        }</span>
<span class="line" id="L1002"></span>
<span class="line" id="L1003">        <span class="tok-comment">// 2.5.1.7: Special Operations</span>
</span>
<span class="line" id="L1004"></span>
<span class="line" id="L1005">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeEntryValue</span>(writer: <span class="tok-kw">anytype</span>, expression: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1006">            <span class="tok-kw">try</span> writer.writeByte(OP.entry_value);</span>
<span class="line" id="L1007">            <span class="tok-kw">try</span> leb.writeULEB128(writer, expression.len);</span>
<span class="line" id="L1008">            <span class="tok-kw">try</span> writer.writeAll(expression);</span>
<span class="line" id="L1009">        }</span>
<span class="line" id="L1010"></span>
<span class="line" id="L1011">        <span class="tok-comment">// 2.6: Location Descriptions</span>
</span>
<span class="line" id="L1012">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeReg</span>(writer: <span class="tok-kw">anytype</span>, register: <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1013">            <span class="tok-kw">try</span> writer.writeByte(OP.reg0 + register);</span>
<span class="line" id="L1014">        }</span>
<span class="line" id="L1015"></span>
<span class="line" id="L1016">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeRegx</span>(writer: <span class="tok-kw">anytype</span>, register: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1017">            <span class="tok-kw">try</span> writer.writeByte(OP.regx);</span>
<span class="line" id="L1018">            <span class="tok-kw">try</span> leb.writeULEB128(writer, register);</span>
<span class="line" id="L1019">        }</span>
<span class="line" id="L1020"></span>
<span class="line" id="L1021">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeImplicitValue</span>(writer: <span class="tok-kw">anytype</span>, value_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1022">            <span class="tok-kw">try</span> writer.writeByte(OP.implicit_value);</span>
<span class="line" id="L1023">            <span class="tok-kw">try</span> leb.writeULEB128(writer, value_bytes.len);</span>
<span class="line" id="L1024">            <span class="tok-kw">try</span> writer.writeAll(value_bytes);</span>
<span class="line" id="L1025">        }</span>
<span class="line" id="L1026">    };</span>
<span class="line" id="L1027">}</span>
<span class="line" id="L1028"></span>
<span class="line" id="L1029"><span class="tok-comment">// Certain opcodes are not allowed in a CFA context, see 6.4.2</span>
</span>
<span class="line" id="L1030"><span class="tok-kw">fn</span> <span class="tok-fn">isOpcodeValidInCFA</span>(opcode: <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L1031">    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (opcode) {</span>
<span class="line" id="L1032">        OP.addrx,</span>
<span class="line" id="L1033">        OP.call2,</span>
<span class="line" id="L1034">        OP.call4,</span>
<span class="line" id="L1035">        OP.call_ref,</span>
<span class="line" id="L1036">        OP.const_type,</span>
<span class="line" id="L1037">        OP.constx,</span>
<span class="line" id="L1038">        OP.convert,</span>
<span class="line" id="L1039">        OP.deref_type,</span>
<span class="line" id="L1040">        OP.regval_type,</span>
<span class="line" id="L1041">        OP.reinterpret,</span>
<span class="line" id="L1042">        OP.push_object_address,</span>
<span class="line" id="L1043">        OP.call_frame_cfa,</span>
<span class="line" id="L1044">        =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L1045">        <span class="tok-kw">else</span> =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L1046">    };</span>
<span class="line" id="L1047">}</span>
<span class="line" id="L1048"></span>
<span class="line" id="L1049"><span class="tok-kw">fn</span> <span class="tok-fn">isOpcodeRegisterLocation</span>(opcode: <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L1050">    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (opcode) {</span>
<span class="line" id="L1051">        OP.reg0...OP.reg31, OP.regx =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L1052">        <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L1053">    };</span>
<span class="line" id="L1054">}</span>
<span class="line" id="L1055"></span>
<span class="line" id="L1056"><span class="tok-kw">const</span> testing = std.testing;</span>
<span class="line" id="L1057"><span class="tok-kw">test</span> <span class="tok-str">&quot;DWARF expressions&quot;</span> {</span>
<span class="line" id="L1058">    <span class="tok-kw">const</span> allocator = std.testing.allocator;</span>
<span class="line" id="L1059"></span>
<span class="line" id="L1060">    <span class="tok-kw">const</span> options = ExpressionOptions{};</span>
<span class="line" id="L1061">    <span class="tok-kw">var</span> stack_machine = StackMachine(options){};</span>
<span class="line" id="L1062">    <span class="tok-kw">defer</span> stack_machine.deinit(allocator);</span>
<span class="line" id="L1063"></span>
<span class="line" id="L1064">    <span class="tok-kw">const</span> b = Builder(options);</span>
<span class="line" id="L1065"></span>
<span class="line" id="L1066">    <span class="tok-kw">var</span> program = std.ArrayList(<span class="tok-type">u8</span>).init(allocator);</span>
<span class="line" id="L1067">    <span class="tok-kw">defer</span> program.deinit();</span>
<span class="line" id="L1068"></span>
<span class="line" id="L1069">    <span class="tok-kw">const</span> writer = program.writer();</span>
<span class="line" id="L1070"></span>
<span class="line" id="L1071">    <span class="tok-comment">// Literals</span>
</span>
<span class="line" id="L1072">    {</span>
<span class="line" id="L1073">        <span class="tok-kw">const</span> context = ExpressionContext{};</span>
<span class="line" id="L1074">        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<span class="tok-number">32</span>) |i| {</span>
<span class="line" id="L1075">            <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-builtin">@intCast</span>(i));</span>
<span class="line" id="L1076">        }</span>
<span class="line" id="L1077"></span>
<span class="line" id="L1078">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-number">0</span>);</span>
<span class="line" id="L1079"></span>
<span class="line" id="L1080">        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<span class="tok-number">32</span>) |i| {</span>
<span class="line" id="L1081">            <span class="tok-kw">const</span> expected = <span class="tok-number">31</span> - i;</span>
<span class="line" id="L1082">            <span class="tok-kw">try</span> testing.expectEqual(expected, stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1083">        }</span>
<span class="line" id="L1084">    }</span>
<span class="line" id="L1085"></span>
<span class="line" id="L1086">    <span class="tok-comment">// Constants</span>
</span>
<span class="line" id="L1087">    {</span>
<span class="line" id="L1088">        stack_machine.reset();</span>
<span class="line" id="L1089">        program.clearRetainingCapacity();</span>
<span class="line" id="L1090"></span>
<span class="line" id="L1091">        <span class="tok-kw">const</span> input = [_]<span class="tok-type">comptime_int</span>{</span>
<span class="line" id="L1092">            <span class="tok-number">1</span>,</span>
<span class="line" id="L1093">            -<span class="tok-number">1</span>,</span>
<span class="line" id="L1094">            <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(<span class="tok-number">0x0fff</span>)),</span>
<span class="line" id="L1095">            <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@truncate</span>(-<span class="tok-number">0x0fff</span>)),</span>
<span class="line" id="L1096">            <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(<span class="tok-number">0x0fffffff</span>)),</span>
<span class="line" id="L1097">            <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@truncate</span>(-<span class="tok-number">0x0fffffff</span>)),</span>
<span class="line" id="L1098">            <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(<span class="tok-number">0x0fffffffffffffff</span>)),</span>
<span class="line" id="L1099">            <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@truncate</span>(-<span class="tok-number">0x0fffffffffffffff</span>)),</span>
<span class="line" id="L1100">            <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(<span class="tok-number">0x8000000</span>)),</span>
<span class="line" id="L1101">            <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@truncate</span>(-<span class="tok-number">0x8000000</span>)),</span>
<span class="line" id="L1102">            <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(<span class="tok-number">0x12345678_12345678</span>)),</span>
<span class="line" id="L1103">            <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(<span class="tok-number">0xffffffff_ffffffff</span>)),</span>
<span class="line" id="L1104">            <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(<span class="tok-number">0xeeeeeeee_eeeeeeee</span>)),</span>
<span class="line" id="L1105">        };</span>
<span class="line" id="L1106"></span>
<span class="line" id="L1107">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, input[<span class="tok-number">0</span>]);</span>
<span class="line" id="L1108">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">i8</span>, input[<span class="tok-number">1</span>]);</span>
<span class="line" id="L1109">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, input[<span class="tok-number">2</span>]);</span>
<span class="line" id="L1110">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">i16</span>, input[<span class="tok-number">3</span>]);</span>
<span class="line" id="L1111">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u32</span>, input[<span class="tok-number">4</span>]);</span>
<span class="line" id="L1112">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">i32</span>, input[<span class="tok-number">5</span>]);</span>
<span class="line" id="L1113">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u64</span>, input[<span class="tok-number">6</span>]);</span>
<span class="line" id="L1114">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">i64</span>, input[<span class="tok-number">7</span>]);</span>
<span class="line" id="L1115">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u28</span>, input[<span class="tok-number">8</span>]);</span>
<span class="line" id="L1116">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">i28</span>, input[<span class="tok-number">9</span>]);</span>
<span class="line" id="L1117">        <span class="tok-kw">try</span> b.writeAddr(writer, input[<span class="tok-number">10</span>]);</span>
<span class="line" id="L1118"></span>
<span class="line" id="L1119">        <span class="tok-kw">var</span> mock_compile_unit: dwarf.CompileUnit = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1120">        mock_compile_unit.addr_base = <span class="tok-number">1</span>;</span>
<span class="line" id="L1121"></span>
<span class="line" id="L1122">        <span class="tok-kw">var</span> mock_debug_addr = std.ArrayList(<span class="tok-type">u8</span>).init(allocator);</span>
<span class="line" id="L1123">        <span class="tok-kw">defer</span> mock_debug_addr.deinit();</span>
<span class="line" id="L1124"></span>
<span class="line" id="L1125">        <span class="tok-kw">try</span> mock_debug_addr.writer().writeInt(<span class="tok-type">u16</span>, <span class="tok-number">0</span>, native_endian);</span>
<span class="line" id="L1126">        <span class="tok-kw">try</span> mock_debug_addr.writer().writeInt(<span class="tok-type">usize</span>, input[<span class="tok-number">11</span>], native_endian);</span>
<span class="line" id="L1127">        <span class="tok-kw">try</span> mock_debug_addr.writer().writeInt(<span class="tok-type">usize</span>, input[<span class="tok-number">12</span>], native_endian);</span>
<span class="line" id="L1128"></span>
<span class="line" id="L1129">        <span class="tok-kw">const</span> context = ExpressionContext{</span>
<span class="line" id="L1130">            .compile_unit = &amp;mock_compile_unit,</span>
<span class="line" id="L1131">            .debug_addr = mock_debug_addr.items,</span>
<span class="line" id="L1132">        };</span>
<span class="line" id="L1133"></span>
<span class="line" id="L1134">        <span class="tok-kw">try</span> b.writeConstx(writer, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>));</span>
<span class="line" id="L1135">        <span class="tok-kw">try</span> b.writeAddrx(writer, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span> + <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)));</span>
<span class="line" id="L1136"></span>
<span class="line" id="L1137">        <span class="tok-kw">const</span> die_offset: <span class="tok-type">usize</span> = <span class="tok-builtin">@truncate</span>(<span class="tok-number">0xaabbccdd</span>);</span>
<span class="line" id="L1138">        <span class="tok-kw">const</span> type_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;.{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };</span>
<span class="line" id="L1139">        <span class="tok-kw">try</span> b.writeConstType(writer, die_offset, type_bytes);</span>
<span class="line" id="L1140"></span>
<span class="line" id="L1141">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-number">0</span>);</span>
<span class="line" id="L1142"></span>
<span class="line" id="L1143">        <span class="tok-kw">const</span> const_type = stack_machine.stack.popOrNull().?.const_type;</span>
<span class="line" id="L1144">        <span class="tok-kw">try</span> testing.expectEqual(die_offset, const_type.type_offset);</span>
<span class="line" id="L1145">        <span class="tok-kw">try</span> testing.expectEqualSlices(<span class="tok-type">u8</span>, type_bytes, const_type.value_bytes);</span>
<span class="line" id="L1146"></span>
<span class="line" id="L1147">        <span class="tok-kw">const</span> expected = .{</span>
<span class="line" id="L1148">            .{ <span class="tok-type">usize</span>, input[<span class="tok-number">12</span>], <span class="tok-type">usize</span> },</span>
<span class="line" id="L1149">            .{ <span class="tok-type">usize</span>, input[<span class="tok-number">11</span>], <span class="tok-type">usize</span> },</span>
<span class="line" id="L1150">            .{ <span class="tok-type">usize</span>, input[<span class="tok-number">10</span>], <span class="tok-type">usize</span> },</span>
<span class="line" id="L1151">            .{ <span class="tok-type">isize</span>, input[<span class="tok-number">9</span>], <span class="tok-type">isize</span> },</span>
<span class="line" id="L1152">            .{ <span class="tok-type">usize</span>, input[<span class="tok-number">8</span>], <span class="tok-type">usize</span> },</span>
<span class="line" id="L1153">            .{ <span class="tok-type">isize</span>, input[<span class="tok-number">7</span>], <span class="tok-type">isize</span> },</span>
<span class="line" id="L1154">            .{ <span class="tok-type">usize</span>, input[<span class="tok-number">6</span>], <span class="tok-type">usize</span> },</span>
<span class="line" id="L1155">            .{ <span class="tok-type">isize</span>, input[<span class="tok-number">5</span>], <span class="tok-type">isize</span> },</span>
<span class="line" id="L1156">            .{ <span class="tok-type">usize</span>, input[<span class="tok-number">4</span>], <span class="tok-type">usize</span> },</span>
<span class="line" id="L1157">            .{ <span class="tok-type">isize</span>, input[<span class="tok-number">3</span>], <span class="tok-type">isize</span> },</span>
<span class="line" id="L1158">            .{ <span class="tok-type">usize</span>, input[<span class="tok-number">2</span>], <span class="tok-type">usize</span> },</span>
<span class="line" id="L1159">            .{ <span class="tok-type">isize</span>, input[<span class="tok-number">1</span>], <span class="tok-type">isize</span> },</span>
<span class="line" id="L1160">            .{ <span class="tok-type">usize</span>, input[<span class="tok-number">0</span>], <span class="tok-type">usize</span> },</span>
<span class="line" id="L1161">        };</span>
<span class="line" id="L1162"></span>
<span class="line" id="L1163">        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (expected) |e| {</span>
<span class="line" id="L1164">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(e[<span class="tok-number">0</span>], e[<span class="tok-number">1</span>]), <span class="tok-builtin">@as</span>(e[<span class="tok-number">2</span>], <span class="tok-builtin">@bitCast</span>(stack_machine.stack.popOrNull().?.generic)));</span>
<span class="line" id="L1165">        }</span>
<span class="line" id="L1166">    }</span>
<span class="line" id="L1167"></span>
<span class="line" id="L1168">    <span class="tok-comment">// Register values</span>
</span>
<span class="line" id="L1169">    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(std.debug.ThreadContext) != <span class="tok-number">0</span>) {</span>
<span class="line" id="L1170">        stack_machine.reset();</span>
<span class="line" id="L1171">        program.clearRetainingCapacity();</span>
<span class="line" id="L1172"></span>
<span class="line" id="L1173">        <span class="tok-kw">const</span> reg_context = abi.RegisterContext{</span>
<span class="line" id="L1174">            .eh_frame = <span class="tok-null">true</span>,</span>
<span class="line" id="L1175">            .is_macho = builtin.os.tag == .macos,</span>
<span class="line" id="L1176">        };</span>
<span class="line" id="L1177">        <span class="tok-kw">var</span> thread_context: std.debug.ThreadContext = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1178">        std.debug.relocateContext(&amp;thread_context);</span>
<span class="line" id="L1179">        <span class="tok-kw">const</span> context = ExpressionContext{</span>
<span class="line" id="L1180">            .thread_context = &amp;thread_context,</span>
<span class="line" id="L1181">            .reg_context = reg_context,</span>
<span class="line" id="L1182">        };</span>
<span class="line" id="L1183"></span>
<span class="line" id="L1184">        <span class="tok-comment">// Only test register operations on arch / os that have them implemented</span>
</span>
<span class="line" id="L1185">        <span class="tok-kw">if</span> (abi.regBytes(&amp;thread_context, <span class="tok-number">0</span>, reg_context)) |reg_bytes| {</span>
<span class="line" id="L1186"></span>
<span class="line" id="L1187">            <span class="tok-comment">// TODO: Test fbreg (once implemented): mock a DIE and point compile_unit.frame_base at it</span>
</span>
<span class="line" id="L1188"></span>
<span class="line" id="L1189">            mem.writeInt(<span class="tok-type">usize</span>, reg_bytes[<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)], <span class="tok-number">0xee</span>, native_endian);</span>
<span class="line" id="L1190">            (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, &amp;thread_context, abi.fpRegNum(reg_context), reg_context)).* = <span class="tok-number">1</span>;</span>
<span class="line" id="L1191">            (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, &amp;thread_context, abi.spRegNum(reg_context), reg_context)).* = <span class="tok-number">2</span>;</span>
<span class="line" id="L1192">            (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, &amp;thread_context, abi.ipRegNum(), reg_context)).* = <span class="tok-number">3</span>;</span>
<span class="line" id="L1193"></span>
<span class="line" id="L1194">            <span class="tok-kw">try</span> b.writeBreg(writer, abi.fpRegNum(reg_context), <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">100</span>));</span>
<span class="line" id="L1195">            <span class="tok-kw">try</span> b.writeBreg(writer, abi.spRegNum(reg_context), <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">200</span>));</span>
<span class="line" id="L1196">            <span class="tok-kw">try</span> b.writeBregx(writer, abi.ipRegNum(), <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">300</span>));</span>
<span class="line" id="L1197">            <span class="tok-kw">try</span> b.writeRegvalType(writer, <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0</span>), <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">400</span>));</span>
<span class="line" id="L1198"></span>
<span class="line" id="L1199">            _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-number">0</span>);</span>
<span class="line" id="L1200"></span>
<span class="line" id="L1201">            <span class="tok-kw">const</span> regval_type = stack_machine.stack.popOrNull().?.regval_type;</span>
<span class="line" id="L1202">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">400</span>), regval_type.type_offset);</span>
<span class="line" id="L1203">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)), regval_type.type_size);</span>
<span class="line" id="L1204">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0xee</span>), regval_type.value);</span>
<span class="line" id="L1205"></span>
<span class="line" id="L1206">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">303</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1207">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">202</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1208">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">101</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1209">        } <span class="tok-kw">else</span> |err| {</span>
<span class="line" id="L1210">            <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1211">                <span class="tok-kw">error</span>.UnimplementedArch,</span>
<span class="line" id="L1212">                <span class="tok-kw">error</span>.UnimplementedOs,</span>
<span class="line" id="L1213">                <span class="tok-kw">error</span>.ThreadContextNotSupported,</span>
<span class="line" id="L1214">                =&gt; {},</span>
<span class="line" id="L1215">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L1216">            }</span>
<span class="line" id="L1217">        }</span>
<span class="line" id="L1218">    }</span>
<span class="line" id="L1219"></span>
<span class="line" id="L1220">    <span class="tok-comment">// Stack operations</span>
</span>
<span class="line" id="L1221">    {</span>
<span class="line" id="L1222">        <span class="tok-kw">var</span> context = ExpressionContext{};</span>
<span class="line" id="L1223"></span>
<span class="line" id="L1224">        stack_machine.reset();</span>
<span class="line" id="L1225">        program.clearRetainingCapacity();</span>
<span class="line" id="L1226">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">1</span>);</span>
<span class="line" id="L1227">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.dup);</span>
<span class="line" id="L1228">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1229">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1230">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1231"></span>
<span class="line" id="L1232">        stack_machine.reset();</span>
<span class="line" id="L1233">        program.clearRetainingCapacity();</span>
<span class="line" id="L1234">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">1</span>);</span>
<span class="line" id="L1235">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.drop);</span>
<span class="line" id="L1236">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1237">        <span class="tok-kw">try</span> testing.expect(stack_machine.stack.popOrNull() == <span class="tok-null">null</span>);</span>
<span class="line" id="L1238"></span>
<span class="line" id="L1239">        stack_machine.reset();</span>
<span class="line" id="L1240">        program.clearRetainingCapacity();</span>
<span class="line" id="L1241">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">4</span>);</span>
<span class="line" id="L1242">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">5</span>);</span>
<span class="line" id="L1243">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">6</span>);</span>
<span class="line" id="L1244">        <span class="tok-kw">try</span> b.writePick(writer, <span class="tok-number">2</span>);</span>
<span class="line" id="L1245">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1246">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">4</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1247"></span>
<span class="line" id="L1248">        stack_machine.reset();</span>
<span class="line" id="L1249">        program.clearRetainingCapacity();</span>
<span class="line" id="L1250">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">4</span>);</span>
<span class="line" id="L1251">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">5</span>);</span>
<span class="line" id="L1252">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">6</span>);</span>
<span class="line" id="L1253">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.over);</span>
<span class="line" id="L1254">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1255">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">5</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1256"></span>
<span class="line" id="L1257">        stack_machine.reset();</span>
<span class="line" id="L1258">        program.clearRetainingCapacity();</span>
<span class="line" id="L1259">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">5</span>);</span>
<span class="line" id="L1260">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">6</span>);</span>
<span class="line" id="L1261">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.swap);</span>
<span class="line" id="L1262">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1263">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">5</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1264">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">6</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1265"></span>
<span class="line" id="L1266">        stack_machine.reset();</span>
<span class="line" id="L1267">        program.clearRetainingCapacity();</span>
<span class="line" id="L1268">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">4</span>);</span>
<span class="line" id="L1269">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">5</span>);</span>
<span class="line" id="L1270">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">6</span>);</span>
<span class="line" id="L1271">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.rot);</span>
<span class="line" id="L1272">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1273">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">5</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1274">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">4</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1275">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">6</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1276"></span>
<span class="line" id="L1277">        <span class="tok-kw">const</span> deref_target: <span class="tok-type">usize</span> = <span class="tok-builtin">@truncate</span>(<span class="tok-number">0xffeeffee_ffeeffee</span>);</span>
<span class="line" id="L1278"></span>
<span class="line" id="L1279">        stack_machine.reset();</span>
<span class="line" id="L1280">        program.clearRetainingCapacity();</span>
<span class="line" id="L1281">        <span class="tok-kw">try</span> b.writeAddr(writer, <span class="tok-builtin">@intFromPtr</span>(&amp;deref_target));</span>
<span class="line" id="L1282">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.deref);</span>
<span class="line" id="L1283">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1284">        <span class="tok-kw">try</span> testing.expectEqual(deref_target, stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1285"></span>
<span class="line" id="L1286">        stack_machine.reset();</span>
<span class="line" id="L1287">        program.clearRetainingCapacity();</span>
<span class="line" id="L1288">        <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-number">0</span>);</span>
<span class="line" id="L1289">        <span class="tok-kw">try</span> b.writeAddr(writer, <span class="tok-builtin">@intFromPtr</span>(&amp;deref_target));</span>
<span class="line" id="L1290">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.xderef);</span>
<span class="line" id="L1291">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1292">        <span class="tok-kw">try</span> testing.expectEqual(deref_target, stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1293"></span>
<span class="line" id="L1294">        stack_machine.reset();</span>
<span class="line" id="L1295">        program.clearRetainingCapacity();</span>
<span class="line" id="L1296">        <span class="tok-kw">try</span> b.writeAddr(writer, <span class="tok-builtin">@intFromPtr</span>(&amp;deref_target));</span>
<span class="line" id="L1297">        <span class="tok-kw">try</span> b.writeDerefSize(writer, <span class="tok-number">1</span>);</span>
<span class="line" id="L1298">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1299">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;deref_target)).*), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1300"></span>
<span class="line" id="L1301">        stack_machine.reset();</span>
<span class="line" id="L1302">        program.clearRetainingCapacity();</span>
<span class="line" id="L1303">        <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-number">0</span>);</span>
<span class="line" id="L1304">        <span class="tok-kw">try</span> b.writeAddr(writer, <span class="tok-builtin">@intFromPtr</span>(&amp;deref_target));</span>
<span class="line" id="L1305">        <span class="tok-kw">try</span> b.writeXDerefSize(writer, <span class="tok-number">1</span>);</span>
<span class="line" id="L1306">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1307">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;deref_target)).*), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1308"></span>
<span class="line" id="L1309">        <span class="tok-kw">const</span> type_offset: <span class="tok-type">usize</span> = <span class="tok-builtin">@truncate</span>(<span class="tok-number">0xaabbaabb_aabbaabb</span>);</span>
<span class="line" id="L1310"></span>
<span class="line" id="L1311">        stack_machine.reset();</span>
<span class="line" id="L1312">        program.clearRetainingCapacity();</span>
<span class="line" id="L1313">        <span class="tok-kw">try</span> b.writeAddr(writer, <span class="tok-builtin">@intFromPtr</span>(&amp;deref_target));</span>
<span class="line" id="L1314">        <span class="tok-kw">try</span> b.writeDerefType(writer, <span class="tok-number">1</span>, type_offset);</span>
<span class="line" id="L1315">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1316">        <span class="tok-kw">const</span> deref_type = stack_machine.stack.popOrNull().?.regval_type;</span>
<span class="line" id="L1317">        <span class="tok-kw">try</span> testing.expectEqual(type_offset, deref_type.type_offset);</span>
<span class="line" id="L1318">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">1</span>), deref_type.type_size);</span>
<span class="line" id="L1319">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;deref_target)).*), deref_type.value);</span>
<span class="line" id="L1320"></span>
<span class="line" id="L1321">        stack_machine.reset();</span>
<span class="line" id="L1322">        program.clearRetainingCapacity();</span>
<span class="line" id="L1323">        <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-number">0</span>);</span>
<span class="line" id="L1324">        <span class="tok-kw">try</span> b.writeAddr(writer, <span class="tok-builtin">@intFromPtr</span>(&amp;deref_target));</span>
<span class="line" id="L1325">        <span class="tok-kw">try</span> b.writeXDerefType(writer, <span class="tok-number">1</span>, type_offset);</span>
<span class="line" id="L1326">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1327">        <span class="tok-kw">const</span> xderef_type = stack_machine.stack.popOrNull().?.regval_type;</span>
<span class="line" id="L1328">        <span class="tok-kw">try</span> testing.expectEqual(type_offset, xderef_type.type_offset);</span>
<span class="line" id="L1329">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">1</span>), xderef_type.type_size);</span>
<span class="line" id="L1330">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;deref_target)).*), xderef_type.value);</span>
<span class="line" id="L1331"></span>
<span class="line" id="L1332">        context.object_address = &amp;deref_target;</span>
<span class="line" id="L1333"></span>
<span class="line" id="L1334">        stack_machine.reset();</span>
<span class="line" id="L1335">        program.clearRetainingCapacity();</span>
<span class="line" id="L1336">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.push_object_address);</span>
<span class="line" id="L1337">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1338">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intFromPtr</span>(context.object_address.?)), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1339"></span>
<span class="line" id="L1340">        <span class="tok-comment">// TODO: Test OP.form_tls_address</span>
</span>
<span class="line" id="L1341"></span>
<span class="line" id="L1342">        context.cfa = <span class="tok-builtin">@truncate</span>(<span class="tok-number">0xccddccdd_ccddccdd</span>);</span>
<span class="line" id="L1343"></span>
<span class="line" id="L1344">        stack_machine.reset();</span>
<span class="line" id="L1345">        program.clearRetainingCapacity();</span>
<span class="line" id="L1346">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.call_frame_cfa);</span>
<span class="line" id="L1347">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1348">        <span class="tok-kw">try</span> testing.expectEqual(context.cfa.?, stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1349">    }</span>
<span class="line" id="L1350"></span>
<span class="line" id="L1351">    <span class="tok-comment">// Arithmetic and Logical Operations</span>
</span>
<span class="line" id="L1352">    {</span>
<span class="line" id="L1353">        <span class="tok-kw">var</span> context = ExpressionContext{};</span>
<span class="line" id="L1354"></span>
<span class="line" id="L1355">        stack_machine.reset();</span>
<span class="line" id="L1356">        program.clearRetainingCapacity();</span>
<span class="line" id="L1357">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">i16</span>, -<span class="tok-number">4096</span>);</span>
<span class="line" id="L1358">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.abs);</span>
<span class="line" id="L1359">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1360">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">4096</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1361"></span>
<span class="line" id="L1362">        stack_machine.reset();</span>
<span class="line" id="L1363">        program.clearRetainingCapacity();</span>
<span class="line" id="L1364">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xff0f</span>);</span>
<span class="line" id="L1365">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xf0ff</span>);</span>
<span class="line" id="L1366">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.@&quot;and&quot;);</span>
<span class="line" id="L1367">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1368">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0xf00f</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1369"></span>
<span class="line" id="L1370">        stack_machine.reset();</span>
<span class="line" id="L1371">        program.clearRetainingCapacity();</span>
<span class="line" id="L1372">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">i16</span>, -<span class="tok-number">404</span>);</span>
<span class="line" id="L1373">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">i16</span>, <span class="tok-number">100</span>);</span>
<span class="line" id="L1374">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.div);</span>
<span class="line" id="L1375">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1376">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, -<span class="tok-number">404</span> / <span class="tok-number">100</span>), <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@bitCast</span>(stack_machine.stack.popOrNull().?.generic)));</span>
<span class="line" id="L1377"></span>
<span class="line" id="L1378">        stack_machine.reset();</span>
<span class="line" id="L1379">        program.clearRetainingCapacity();</span>
<span class="line" id="L1380">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">200</span>);</span>
<span class="line" id="L1381">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">50</span>);</span>
<span class="line" id="L1382">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.minus);</span>
<span class="line" id="L1383">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1384">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">150</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1385"></span>
<span class="line" id="L1386">        stack_machine.reset();</span>
<span class="line" id="L1387">        program.clearRetainingCapacity();</span>
<span class="line" id="L1388">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">123</span>);</span>
<span class="line" id="L1389">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">100</span>);</span>
<span class="line" id="L1390">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.mod);</span>
<span class="line" id="L1391">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1392">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">23</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1393"></span>
<span class="line" id="L1394">        stack_machine.reset();</span>
<span class="line" id="L1395">        program.clearRetainingCapacity();</span>
<span class="line" id="L1396">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xff</span>);</span>
<span class="line" id="L1397">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xee</span>);</span>
<span class="line" id="L1398">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.mul);</span>
<span class="line" id="L1399">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1400">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0xed12</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1401"></span>
<span class="line" id="L1402">        stack_machine.reset();</span>
<span class="line" id="L1403">        program.clearRetainingCapacity();</span>
<span class="line" id="L1404">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">5</span>);</span>
<span class="line" id="L1405">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.neg);</span>
<span class="line" id="L1406">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">i16</span>, -<span class="tok-number">6</span>);</span>
<span class="line" id="L1407">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.neg);</span>
<span class="line" id="L1408">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1409">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">6</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1410">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, -<span class="tok-number">5</span>), <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@bitCast</span>(stack_machine.stack.popOrNull().?.generic)));</span>
<span class="line" id="L1411"></span>
<span class="line" id="L1412">        stack_machine.reset();</span>
<span class="line" id="L1413">        program.clearRetainingCapacity();</span>
<span class="line" id="L1414">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xff0f</span>);</span>
<span class="line" id="L1415">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.not);</span>
<span class="line" id="L1416">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1417">        <span class="tok-kw">try</span> testing.expectEqual(~<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0xff0f</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1418"></span>
<span class="line" id="L1419">        stack_machine.reset();</span>
<span class="line" id="L1420">        program.clearRetainingCapacity();</span>
<span class="line" id="L1421">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xff0f</span>);</span>
<span class="line" id="L1422">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xf0ff</span>);</span>
<span class="line" id="L1423">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.@&quot;or&quot;);</span>
<span class="line" id="L1424">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1425">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0xffff</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1426"></span>
<span class="line" id="L1427">        stack_machine.reset();</span>
<span class="line" id="L1428">        program.clearRetainingCapacity();</span>
<span class="line" id="L1429">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">i16</span>, <span class="tok-number">402</span>);</span>
<span class="line" id="L1430">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">i16</span>, <span class="tok-number">100</span>);</span>
<span class="line" id="L1431">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.plus);</span>
<span class="line" id="L1432">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1433">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">502</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1434"></span>
<span class="line" id="L1435">        stack_machine.reset();</span>
<span class="line" id="L1436">        program.clearRetainingCapacity();</span>
<span class="line" id="L1437">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">4096</span>);</span>
<span class="line" id="L1438">        <span class="tok-kw">try</span> b.writePlusUconst(writer, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">8192</span>));</span>
<span class="line" id="L1439">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1440">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">4096</span> + <span class="tok-number">8192</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1441"></span>
<span class="line" id="L1442">        stack_machine.reset();</span>
<span class="line" id="L1443">        program.clearRetainingCapacity();</span>
<span class="line" id="L1444">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xfff</span>);</span>
<span class="line" id="L1445">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">1</span>);</span>
<span class="line" id="L1446">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.shl);</span>
<span class="line" id="L1447">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1448">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0xfff</span> &lt;&lt; <span class="tok-number">1</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1449"></span>
<span class="line" id="L1450">        stack_machine.reset();</span>
<span class="line" id="L1451">        program.clearRetainingCapacity();</span>
<span class="line" id="L1452">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xfff</span>);</span>
<span class="line" id="L1453">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">1</span>);</span>
<span class="line" id="L1454">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.shr);</span>
<span class="line" id="L1455">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1456">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0xfff</span> &gt;&gt; <span class="tok-number">1</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1457"></span>
<span class="line" id="L1458">        stack_machine.reset();</span>
<span class="line" id="L1459">        program.clearRetainingCapacity();</span>
<span class="line" id="L1460">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xfff</span>);</span>
<span class="line" id="L1461">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">1</span>);</span>
<span class="line" id="L1462">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.shr);</span>
<span class="line" id="L1463">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1464">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-number">0xfff</span>) &gt;&gt; <span class="tok-number">1</span>)), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1465"></span>
<span class="line" id="L1466">        stack_machine.reset();</span>
<span class="line" id="L1467">        program.clearRetainingCapacity();</span>
<span class="line" id="L1468">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xf0ff</span>);</span>
<span class="line" id="L1469">        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xff0f</span>);</span>
<span class="line" id="L1470">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.xor);</span>
<span class="line" id="L1471">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1472">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0x0ff0</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1473">    }</span>
<span class="line" id="L1474"></span>
<span class="line" id="L1475">    <span class="tok-comment">// Control Flow Operations</span>
</span>
<span class="line" id="L1476">    {</span>
<span class="line" id="L1477">        <span class="tok-kw">var</span> context = ExpressionContext{};</span>
<span class="line" id="L1478">        <span class="tok-kw">const</span> expected = .{</span>
<span class="line" id="L1479">            .{ OP.le, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span> },</span>
<span class="line" id="L1480">            .{ OP.ge, <span class="tok-number">1</span>, <span class="tok-number">0</span>, <span class="tok-number">1</span> },</span>
<span class="line" id="L1481">            .{ OP.eq, <span class="tok-number">1</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span> },</span>
<span class="line" id="L1482">            .{ OP.lt, <span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span> },</span>
<span class="line" id="L1483">            .{ OP.gt, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">1</span> },</span>
<span class="line" id="L1484">            .{ OP.ne, <span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span> },</span>
<span class="line" id="L1485">        };</span>
<span class="line" id="L1486"></span>
<span class="line" id="L1487">        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (expected) |e| {</span>
<span class="line" id="L1488">            stack_machine.reset();</span>
<span class="line" id="L1489">            program.clearRetainingCapacity();</span>
<span class="line" id="L1490"></span>
<span class="line" id="L1491">            <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L1492">            <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L1493">            <span class="tok-kw">try</span> b.writeOpcode(writer, e[<span class="tok-number">0</span>]);</span>
<span class="line" id="L1494">            <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L1495">            <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">1</span>);</span>
<span class="line" id="L1496">            <span class="tok-kw">try</span> b.writeOpcode(writer, e[<span class="tok-number">0</span>]);</span>
<span class="line" id="L1497">            <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">1</span>);</span>
<span class="line" id="L1498">            <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L1499">            <span class="tok-kw">try</span> b.writeOpcode(writer, e[<span class="tok-number">0</span>]);</span>
<span class="line" id="L1500">            _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1501">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, e[<span class="tok-number">3</span>]), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1502">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, e[<span class="tok-number">2</span>]), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1503">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, e[<span class="tok-number">1</span>]), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1504">        }</span>
<span class="line" id="L1505"></span>
<span class="line" id="L1506">        stack_machine.reset();</span>
<span class="line" id="L1507">        program.clearRetainingCapacity();</span>
<span class="line" id="L1508">        <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-number">2</span>);</span>
<span class="line" id="L1509">        <span class="tok-kw">try</span> b.writeSkip(writer, <span class="tok-number">1</span>);</span>
<span class="line" id="L1510">        <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-number">3</span>);</span>
<span class="line" id="L1511">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1512">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">2</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1513"></span>
<span class="line" id="L1514">        stack_machine.reset();</span>
<span class="line" id="L1515">        program.clearRetainingCapacity();</span>
<span class="line" id="L1516">        <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-number">2</span>);</span>
<span class="line" id="L1517">        <span class="tok-kw">try</span> b.writeBra(writer, <span class="tok-number">1</span>);</span>
<span class="line" id="L1518">        <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-number">3</span>);</span>
<span class="line" id="L1519">        <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-number">0</span>);</span>
<span class="line" id="L1520">        <span class="tok-kw">try</span> b.writeBra(writer, <span class="tok-number">1</span>);</span>
<span class="line" id="L1521">        <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-number">4</span>);</span>
<span class="line" id="L1522">        <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-number">5</span>);</span>
<span class="line" id="L1523">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1524">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">5</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1525">        <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">4</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1526">        <span class="tok-kw">try</span> testing.expect(stack_machine.stack.popOrNull() == <span class="tok-null">null</span>);</span>
<span class="line" id="L1527"></span>
<span class="line" id="L1528">        <span class="tok-comment">// TODO: Test call2, call4, call_ref once implemented</span>
</span>
<span class="line" id="L1529"></span>
<span class="line" id="L1530">    }</span>
<span class="line" id="L1531"></span>
<span class="line" id="L1532">    <span class="tok-comment">// Type conversions</span>
</span>
<span class="line" id="L1533">    {</span>
<span class="line" id="L1534">        <span class="tok-kw">var</span> context = ExpressionContext{};</span>
<span class="line" id="L1535">        stack_machine.reset();</span>
<span class="line" id="L1536">        program.clearRetainingCapacity();</span>
<span class="line" id="L1537"></span>
<span class="line" id="L1538">        <span class="tok-comment">// TODO: Test typed OP.convert once implemented</span>
</span>
<span class="line" id="L1539"></span>
<span class="line" id="L1540">        <span class="tok-kw">const</span> value: <span class="tok-type">usize</span> = <span class="tok-builtin">@truncate</span>(<span class="tok-number">0xffeeffee_ffeeffee</span>);</span>
<span class="line" id="L1541">        <span class="tok-kw">var</span> value_bytes: [options.addr_size]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1542">        mem.writeInt(<span class="tok-type">usize</span>, &amp;value_bytes, value, native_endian);</span>
<span class="line" id="L1543"></span>
<span class="line" id="L1544">        <span class="tok-comment">// Convert to generic type</span>
</span>
<span class="line" id="L1545">        stack_machine.reset();</span>
<span class="line" id="L1546">        program.clearRetainingCapacity();</span>
<span class="line" id="L1547">        <span class="tok-kw">try</span> b.writeConstType(writer, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>), &amp;value_bytes);</span>
<span class="line" id="L1548">        <span class="tok-kw">try</span> b.writeConvert(writer, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>));</span>
<span class="line" id="L1549">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1550">        <span class="tok-kw">try</span> testing.expectEqual(value, stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1551"></span>
<span class="line" id="L1552">        <span class="tok-comment">// Reinterpret to generic type</span>
</span>
<span class="line" id="L1553">        stack_machine.reset();</span>
<span class="line" id="L1554">        program.clearRetainingCapacity();</span>
<span class="line" id="L1555">        <span class="tok-kw">try</span> b.writeConstType(writer, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>), &amp;value_bytes);</span>
<span class="line" id="L1556">        <span class="tok-kw">try</span> b.writeReinterpret(writer, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>));</span>
<span class="line" id="L1557">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1558">        <span class="tok-kw">try</span> testing.expectEqual(value, stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1559"></span>
<span class="line" id="L1560">        <span class="tok-comment">// Reinterpret to new type</span>
</span>
<span class="line" id="L1561">        <span class="tok-kw">const</span> die_offset: <span class="tok-type">usize</span> = <span class="tok-number">0xffee</span>;</span>
<span class="line" id="L1562"></span>
<span class="line" id="L1563">        stack_machine.reset();</span>
<span class="line" id="L1564">        program.clearRetainingCapacity();</span>
<span class="line" id="L1565">        <span class="tok-kw">try</span> b.writeConstType(writer, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>), &amp;value_bytes);</span>
<span class="line" id="L1566">        <span class="tok-kw">try</span> b.writeReinterpret(writer, die_offset);</span>
<span class="line" id="L1567">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1568">        <span class="tok-kw">const</span> const_type = stack_machine.stack.popOrNull().?.const_type;</span>
<span class="line" id="L1569">        <span class="tok-kw">try</span> testing.expectEqual(die_offset, const_type.type_offset);</span>
<span class="line" id="L1570"></span>
<span class="line" id="L1571">        stack_machine.reset();</span>
<span class="line" id="L1572">        program.clearRetainingCapacity();</span>
<span class="line" id="L1573">        <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-number">0</span>);</span>
<span class="line" id="L1574">        <span class="tok-kw">try</span> b.writeReinterpret(writer, die_offset);</span>
<span class="line" id="L1575">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1576">        <span class="tok-kw">const</span> regval_type = stack_machine.stack.popOrNull().?.regval_type;</span>
<span class="line" id="L1577">        <span class="tok-kw">try</span> testing.expectEqual(die_offset, regval_type.type_offset);</span>
<span class="line" id="L1578">    }</span>
<span class="line" id="L1579"></span>
<span class="line" id="L1580">    <span class="tok-comment">// Special operations</span>
</span>
<span class="line" id="L1581">    {</span>
<span class="line" id="L1582">        <span class="tok-kw">var</span> context = ExpressionContext{};</span>
<span class="line" id="L1583"></span>
<span class="line" id="L1584">        stack_machine.reset();</span>
<span class="line" id="L1585">        program.clearRetainingCapacity();</span>
<span class="line" id="L1586">        <span class="tok-kw">try</span> b.writeOpcode(writer, OP.nop);</span>
<span class="line" id="L1587">        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1588">        <span class="tok-kw">try</span> testing.expect(stack_machine.stack.popOrNull() == <span class="tok-null">null</span>);</span>
<span class="line" id="L1589"></span>
<span class="line" id="L1590">        <span class="tok-comment">// Sub-expression</span>
</span>
<span class="line" id="L1591">        {</span>
<span class="line" id="L1592">            <span class="tok-kw">var</span> sub_program = std.ArrayList(<span class="tok-type">u8</span>).init(allocator);</span>
<span class="line" id="L1593">            <span class="tok-kw">defer</span> sub_program.deinit();</span>
<span class="line" id="L1594">            <span class="tok-kw">const</span> sub_writer = sub_program.writer();</span>
<span class="line" id="L1595">            <span class="tok-kw">try</span> b.writeLiteral(sub_writer, <span class="tok-number">3</span>);</span>
<span class="line" id="L1596"></span>
<span class="line" id="L1597">            stack_machine.reset();</span>
<span class="line" id="L1598">            program.clearRetainingCapacity();</span>
<span class="line" id="L1599">            <span class="tok-kw">try</span> b.writeEntryValue(writer, sub_program.items);</span>
<span class="line" id="L1600">            _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1601">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">3</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1602">        }</span>
<span class="line" id="L1603"></span>
<span class="line" id="L1604">        <span class="tok-comment">// Register location description</span>
</span>
<span class="line" id="L1605">        <span class="tok-kw">const</span> reg_context = abi.RegisterContext{</span>
<span class="line" id="L1606">            .eh_frame = <span class="tok-null">true</span>,</span>
<span class="line" id="L1607">            .is_macho = builtin.os.tag == .macos,</span>
<span class="line" id="L1608">        };</span>
<span class="line" id="L1609">        <span class="tok-kw">var</span> thread_context: std.debug.ThreadContext = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1610">        std.debug.relocateContext(&amp;thread_context);</span>
<span class="line" id="L1611">        context = ExpressionContext{</span>
<span class="line" id="L1612">            .thread_context = &amp;thread_context,</span>
<span class="line" id="L1613">            .reg_context = reg_context,</span>
<span class="line" id="L1614">        };</span>
<span class="line" id="L1615"></span>
<span class="line" id="L1616">        <span class="tok-kw">if</span> (abi.regBytes(&amp;thread_context, <span class="tok-number">0</span>, reg_context)) |reg_bytes| {</span>
<span class="line" id="L1617">            mem.writeInt(<span class="tok-type">usize</span>, reg_bytes[<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)], <span class="tok-number">0xee</span>, native_endian);</span>
<span class="line" id="L1618"></span>
<span class="line" id="L1619">            <span class="tok-kw">var</span> sub_program = std.ArrayList(<span class="tok-type">u8</span>).init(allocator);</span>
<span class="line" id="L1620">            <span class="tok-kw">defer</span> sub_program.deinit();</span>
<span class="line" id="L1621">            <span class="tok-kw">const</span> sub_writer = sub_program.writer();</span>
<span class="line" id="L1622">            <span class="tok-kw">try</span> b.writeReg(sub_writer, <span class="tok-number">0</span>);</span>
<span class="line" id="L1623"></span>
<span class="line" id="L1624">            stack_machine.reset();</span>
<span class="line" id="L1625">            program.clearRetainingCapacity();</span>
<span class="line" id="L1626">            <span class="tok-kw">try</span> b.writeEntryValue(writer, sub_program.items);</span>
<span class="line" id="L1627">            _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);</span>
<span class="line" id="L1628">            <span class="tok-kw">try</span> testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0xee</span>), stack_machine.stack.popOrNull().?.generic);</span>
<span class="line" id="L1629">        } <span class="tok-kw">else</span> |err| {</span>
<span class="line" id="L1630">            <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1631">                <span class="tok-kw">error</span>.UnimplementedArch,</span>
<span class="line" id="L1632">                <span class="tok-kw">error</span>.UnimplementedOs,</span>
<span class="line" id="L1633">                <span class="tok-kw">error</span>.ThreadContextNotSupported,</span>
<span class="line" id="L1634">                =&gt; {},</span>
<span class="line" id="L1635">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L1636">            }</span>
<span class="line" id="L1637">        }</span>
<span class="line" id="L1638">    }</span>
<span class="line" id="L1639">}</span>
<span class="line" id="L1640"></span>
</code></pre></body>
</html>