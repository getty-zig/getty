<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>fs.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAPNJREFUeNpi/P//PwMlgOXHUjly9E0G4hwgZmQiQZMqEK8H4v9QzUEgQSaoADK+zhH9iAGL+C0gDoAaNg9mGLoLfgA1awK9hS9gzgJxA9RQBmQDrgMxJzRMGKE4HYj/Ial5A8QmQLwCJoBsgBYW2+TR1ChDaWt4LOBxKsi/VUh8XiD+gq4IVyzwQAMJBoKwacZlAB8Qf0bi96IZhtOAe1D6LpqaEiz6rmEzQAeIzwGxCJpieFqApo/vQKyJboAaEBsAsSEupwI1MwKjGBTVHOhegMX5UajYRqiBjMgYmj400cVh0XgTiKdC0zhJgJHS7AwQYABm9EAdCKrEfAAAAABJRU5ErkJggg=="/>
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std.zig&quot;</span>);</span>
<span class="line" id="L2"><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);</span>
<span class="line" id="L3"><span class="tok-kw">const</span> root = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;root&quot;</span>);</span>
<span class="line" id="L4"><span class="tok-kw">const</span> os = std.os;</span>
<span class="line" id="L5"><span class="tok-kw">const</span> mem = std.mem;</span>
<span class="line" id="L6"><span class="tok-kw">const</span> base64 = std.base64;</span>
<span class="line" id="L7"><span class="tok-kw">const</span> crypto = std.crypto;</span>
<span class="line" id="L8"><span class="tok-kw">const</span> Allocator = std.mem.Allocator;</span>
<span class="line" id="L9"><span class="tok-kw">const</span> assert = std.debug.assert;</span>
<span class="line" id="L10"><span class="tok-kw">const</span> math = std.math;</span>
<span class="line" id="L11"></span>
<span class="line" id="L12"><span class="tok-kw">const</span> is_darwin = builtin.os.tag.isDarwin();</span>
<span class="line" id="L13"></span>
<span class="line" id="L14"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> has_executable_bit = <span class="tok-kw">switch</span> (builtin.os.tag) {</span>
<span class="line" id="L15">    .windows, .wasi =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L16">    <span class="tok-kw">else</span> =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L17">};</span>
<span class="line" id="L18"></span>
<span class="line" id="L19"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> path = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fs/path.zig&quot;</span>);</span>
<span class="line" id="L20"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> File = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fs/file.zig&quot;</span>).File;</span>
<span class="line" id="L21"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> wasi = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fs/wasi.zig&quot;</span>);</span>
<span class="line" id="L22"></span>
<span class="line" id="L23"><span class="tok-comment">// TODO audit these APIs with respect to Dir and absolute paths</span>
</span>
<span class="line" id="L24"></span>
<span class="line" id="L25"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> realpath = os.realpath;</span>
<span class="line" id="L26"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> realpathZ = os.realpathZ;</span>
<span class="line" id="L27"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> realpathW = os.realpathW;</span>
<span class="line" id="L28"></span>
<span class="line" id="L29"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> getAppDataDir = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fs/get_app_data_dir.zig&quot;</span>).getAppDataDir;</span>
<span class="line" id="L30"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetAppDataDirError = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fs/get_app_data_dir.zig&quot;</span>).GetAppDataDirError;</span>
<span class="line" id="L31"></span>
<span class="line" id="L32"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Watch = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fs/watch.zig&quot;</span>).Watch;</span>
<span class="line" id="L33"></span>
<span class="line" id="L34"><span class="tok-comment">/// This represents the maximum size of a UTF-8 encoded file path that the</span></span>
<span class="line" id="L35"><span class="tok-comment">/// operating system will accept. Paths, including those returned from file</span></span>
<span class="line" id="L36"><span class="tok-comment">/// system operations, may be longer than this length, but such paths cannot</span></span>
<span class="line" id="L37"><span class="tok-comment">/// be successfully passed back in other file system operations. However,</span></span>
<span class="line" id="L38"><span class="tok-comment">/// all path components returned by file system operations are assumed to</span></span>
<span class="line" id="L39"><span class="tok-comment">/// fit into a UTF-8 encoded array of this length.</span></span>
<span class="line" id="L40"><span class="tok-comment">/// The byte count includes room for a null sentinel byte.</span></span>
<span class="line" id="L41"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> MAX_PATH_BYTES = <span class="tok-kw">switch</span> (builtin.os.tag) {</span>
<span class="line" id="L42">    .linux, .macos, .ios, .freebsd, .openbsd, .netbsd, .dragonfly, .haiku, .solaris, .plan9 =&gt; os.PATH_MAX,</span>
<span class="line" id="L43">    <span class="tok-comment">// Each UTF-16LE character may be expanded to 3 UTF-8 bytes.</span>
</span>
<span class="line" id="L44">    <span class="tok-comment">// If it would require 4 UTF-8 bytes, then there would be a surrogate</span>
</span>
<span class="line" id="L45">    <span class="tok-comment">// pair in the UTF-16LE, and we (over)account 3 bytes for it that way.</span>
</span>
<span class="line" id="L46">    <span class="tok-comment">// +1 for the null byte at the end, which can be encoded in 1 byte.</span>
</span>
<span class="line" id="L47">    .windows =&gt; os.windows.PATH_MAX_WIDE * <span class="tok-number">3</span> + <span class="tok-number">1</span>,</span>
<span class="line" id="L48">    <span class="tok-comment">// TODO work out what a reasonable value we should use here</span>
</span>
<span class="line" id="L49">    .wasi =&gt; <span class="tok-number">4096</span>,</span>
<span class="line" id="L50">    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(root, <span class="tok-str">&quot;os&quot;</span>) <span class="tok-kw">and</span> <span class="tok-builtin">@hasDecl</span>(root.os, <span class="tok-str">&quot;PATH_MAX&quot;</span>))</span>
<span class="line" id="L51">        root.os.PATH_MAX</span>
<span class="line" id="L52">    <span class="tok-kw">else</span></span>
<span class="line" id="L53">        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;PATH_MAX not implemented for &quot;</span> ++ <span class="tok-builtin">@tagName</span>(builtin.os.tag)),</span>
<span class="line" id="L54">};</span>
<span class="line" id="L55"></span>
<span class="line" id="L56"><span class="tok-comment">/// This represents the maximum size of a UTF-8 encoded file name component that</span></span>
<span class="line" id="L57"><span class="tok-comment">/// the platform's common file systems support. File name components returned by file system</span></span>
<span class="line" id="L58"><span class="tok-comment">/// operations are likely to fit into a UTF-8 encoded array of this length, but</span></span>
<span class="line" id="L59"><span class="tok-comment">/// (depending on the platform) this assumption may not hold for every configuration.</span></span>
<span class="line" id="L60"><span class="tok-comment">/// The byte count does not include a null sentinel byte.</span></span>
<span class="line" id="L61"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> MAX_NAME_BYTES = <span class="tok-kw">switch</span> (builtin.os.tag) {</span>
<span class="line" id="L62">    .linux, .macos, .ios, .freebsd, .openbsd, .netbsd, .dragonfly =&gt; os.NAME_MAX,</span>
<span class="line" id="L63">    <span class="tok-comment">// Haiku's NAME_MAX includes the null terminator, so subtract one.</span>
</span>
<span class="line" id="L64">    .haiku =&gt; os.NAME_MAX - <span class="tok-number">1</span>,</span>
<span class="line" id="L65">    .solaris =&gt; os.system.MAXNAMLEN,</span>
<span class="line" id="L66">    <span class="tok-comment">// Each UTF-16LE character may be expanded to 3 UTF-8 bytes.</span>
</span>
<span class="line" id="L67">    <span class="tok-comment">// If it would require 4 UTF-8 bytes, then there would be a surrogate</span>
</span>
<span class="line" id="L68">    <span class="tok-comment">// pair in the UTF-16LE, and we (over)account 3 bytes for it that way.</span>
</span>
<span class="line" id="L69">    .windows =&gt; os.windows.NAME_MAX * <span class="tok-number">3</span>,</span>
<span class="line" id="L70">    <span class="tok-comment">// For WASI, the MAX_NAME will depend on the host OS, so it needs to be</span>
</span>
<span class="line" id="L71">    <span class="tok-comment">// as large as the largest MAX_NAME_BYTES (Windows) in order to work on any host OS.</span>
</span>
<span class="line" id="L72">    <span class="tok-comment">// TODO determine if this is a reasonable approach</span>
</span>
<span class="line" id="L73">    .wasi =&gt; os.windows.NAME_MAX * <span class="tok-number">3</span>,</span>
<span class="line" id="L74">    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(root, <span class="tok-str">&quot;os&quot;</span>) <span class="tok-kw">and</span> <span class="tok-builtin">@hasDecl</span>(root.os, <span class="tok-str">&quot;NAME_MAX&quot;</span>))</span>
<span class="line" id="L75">        root.os.NAME_MAX</span>
<span class="line" id="L76">    <span class="tok-kw">else</span></span>
<span class="line" id="L77">        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;NAME_MAX not implemented for &quot;</span> ++ <span class="tok-builtin">@tagName</span>(builtin.os.tag)),</span>
<span class="line" id="L78">};</span>
<span class="line" id="L79"></span>
<span class="line" id="L80"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> base64_alphabet = <span class="tok-str">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_&quot;</span>.*;</span>
<span class="line" id="L81"></span>
<span class="line" id="L82"><span class="tok-comment">/// Base64 encoder, replacing the standard `+/` with `-_` so that it can be used in a file name on any filesystem.</span></span>
<span class="line" id="L83"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> base64_encoder = base64.Base64Encoder.init(base64_alphabet, <span class="tok-null">null</span>);</span>
<span class="line" id="L84"></span>
<span class="line" id="L85"><span class="tok-comment">/// Base64 decoder, replacing the standard `+/` with `-_` so that it can be used in a file name on any filesystem.</span></span>
<span class="line" id="L86"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> base64_decoder = base64.Base64Decoder.init(base64_alphabet, <span class="tok-null">null</span>);</span>
<span class="line" id="L87"></span>
<span class="line" id="L88"><span class="tok-comment">/// Whether or not async file system syscalls need a dedicated thread because the operating</span></span>
<span class="line" id="L89"><span class="tok-comment">/// system does not support non-blocking I/O on the file system.</span></span>
<span class="line" id="L90"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> need_async_thread = std.io.is_async <span class="tok-kw">and</span> <span class="tok-kw">switch</span> (builtin.os.tag) {</span>
<span class="line" id="L91">    .windows, .other =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L92">    <span class="tok-kw">else</span> =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L93">};</span>
<span class="line" id="L94"></span>
<span class="line" id="L95"><span class="tok-comment">/// TODO remove the allocator requirement from this API</span></span>
<span class="line" id="L96"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">atomicSymLink</span>(allocator: Allocator, existing_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L97">    <span class="tok-kw">if</span> (cwd().symLink(existing_path, new_path, .{})) {</span>
<span class="line" id="L98">        <span class="tok-kw">return</span>;</span>
<span class="line" id="L99">    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L100">        <span class="tok-kw">error</span>.PathAlreadyExists =&gt; {},</span>
<span class="line" id="L101">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err, <span class="tok-comment">// TODO zig should know this set does not include PathAlreadyExists</span>
</span>
<span class="line" id="L102">    }</span>
<span class="line" id="L103"></span>
<span class="line" id="L104">    <span class="tok-kw">const</span> dirname = path.dirname(new_path) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;.&quot;</span>;</span>
<span class="line" id="L105"></span>
<span class="line" id="L106">    <span class="tok-kw">var</span> rand_buf: [AtomicFile.RANDOM_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L107">    <span class="tok-kw">const</span> tmp_path = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, dirname.len + <span class="tok-number">1</span> + base64_encoder.calcSize(rand_buf.len));</span>
<span class="line" id="L108">    <span class="tok-kw">defer</span> allocator.free(tmp_path);</span>
<span class="line" id="L109">    <span class="tok-builtin">@memcpy</span>(tmp_path[<span class="tok-number">0</span>..dirname.len], dirname);</span>
<span class="line" id="L110">    tmp_path[dirname.len] = path.sep;</span>
<span class="line" id="L111">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L112">        crypto.random.bytes(rand_buf[<span class="tok-number">0</span>..]);</span>
<span class="line" id="L113">        _ = base64_encoder.encode(tmp_path[dirname.len + <span class="tok-number">1</span> ..], &amp;rand_buf);</span>
<span class="line" id="L114"></span>
<span class="line" id="L115">        <span class="tok-kw">if</span> (cwd().symLink(existing_path, tmp_path, .{})) {</span>
<span class="line" id="L116">            <span class="tok-kw">return</span> cwd().rename(tmp_path, new_path);</span>
<span class="line" id="L117">        } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L118">            <span class="tok-kw">error</span>.PathAlreadyExists =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L119">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err, <span class="tok-comment">// TODO zig should know this set does not include PathAlreadyExists</span>
</span>
<span class="line" id="L120">        }</span>
<span class="line" id="L121">    }</span>
<span class="line" id="L122">}</span>
<span class="line" id="L123"></span>
<span class="line" id="L124"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> PrevStatus = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L125">    stale,</span>
<span class="line" id="L126">    fresh,</span>
<span class="line" id="L127">};</span>
<span class="line" id="L128"></span>
<span class="line" id="L129"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CopyFileOptions = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L130">    <span class="tok-comment">/// When this is `null` the mode is copied from the source file.</span></span>
<span class="line" id="L131">    override_mode: ?File.Mode = <span class="tok-null">null</span>,</span>
<span class="line" id="L132">};</span>
<span class="line" id="L133"></span>
<span class="line" id="L134"><span class="tok-comment">/// Same as `Dir.updateFile`, except asserts that both `source_path` and `dest_path`</span></span>
<span class="line" id="L135"><span class="tok-comment">/// are absolute. See `Dir.updateFile` for a function that operates on both</span></span>
<span class="line" id="L136"><span class="tok-comment">/// absolute and relative paths.</span></span>
<span class="line" id="L137"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">updateFileAbsolute</span>(</span>
<span class="line" id="L138">    source_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L139">    dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L140">    args: CopyFileOptions,</span>
<span class="line" id="L141">) !PrevStatus {</span>
<span class="line" id="L142">    assert(path.isAbsolute(source_path));</span>
<span class="line" id="L143">    assert(path.isAbsolute(dest_path));</span>
<span class="line" id="L144">    <span class="tok-kw">const</span> my_cwd = cwd();</span>
<span class="line" id="L145">    <span class="tok-kw">return</span> Dir.updateFile(my_cwd, source_path, my_cwd, dest_path, args);</span>
<span class="line" id="L146">}</span>
<span class="line" id="L147"></span>
<span class="line" id="L148"><span class="tok-comment">/// Same as `Dir.copyFile`, except asserts that both `source_path` and `dest_path`</span></span>
<span class="line" id="L149"><span class="tok-comment">/// are absolute. See `Dir.copyFile` for a function that operates on both</span></span>
<span class="line" id="L150"><span class="tok-comment">/// absolute and relative paths.</span></span>
<span class="line" id="L151"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copyFileAbsolute</span>(source_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: CopyFileOptions) !<span class="tok-type">void</span> {</span>
<span class="line" id="L152">    assert(path.isAbsolute(source_path));</span>
<span class="line" id="L153">    assert(path.isAbsolute(dest_path));</span>
<span class="line" id="L154">    <span class="tok-kw">const</span> my_cwd = cwd();</span>
<span class="line" id="L155">    <span class="tok-kw">return</span> Dir.copyFile(my_cwd, source_path, my_cwd, dest_path, args);</span>
<span class="line" id="L156">}</span>
<span class="line" id="L157"></span>
<span class="line" id="L158"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> AtomicFile = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L159">    file: File,</span>
<span class="line" id="L160">    <span class="tok-comment">// TODO either replace this with rand_buf or use []u16 on Windows</span>
</span>
<span class="line" id="L161">    tmp_path_buf: [TMP_PATH_LEN:<span class="tok-number">0</span>]<span class="tok-type">u8</span>,</span>
<span class="line" id="L162">    dest_basename: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L163">    file_open: <span class="tok-type">bool</span>,</span>
<span class="line" id="L164">    file_exists: <span class="tok-type">bool</span>,</span>
<span class="line" id="L165">    close_dir_on_deinit: <span class="tok-type">bool</span>,</span>
<span class="line" id="L166">    dir: Dir,</span>
<span class="line" id="L167"></span>
<span class="line" id="L168">    <span class="tok-kw">const</span> InitError = File.OpenError;</span>
<span class="line" id="L169"></span>
<span class="line" id="L170">    <span class="tok-kw">const</span> RANDOM_BYTES = <span class="tok-number">12</span>;</span>
<span class="line" id="L171">    <span class="tok-kw">const</span> TMP_PATH_LEN = base64_encoder.calcSize(RANDOM_BYTES);</span>
<span class="line" id="L172"></span>
<span class="line" id="L173">    <span class="tok-comment">/// Note that the `Dir.atomicFile` API may be more handy than this lower-level function.</span></span>
<span class="line" id="L174">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(</span>
<span class="line" id="L175">        dest_basename: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L176">        mode: File.Mode,</span>
<span class="line" id="L177">        dir: Dir,</span>
<span class="line" id="L178">        close_dir_on_deinit: <span class="tok-type">bool</span>,</span>
<span class="line" id="L179">    ) InitError!AtomicFile {</span>
<span class="line" id="L180">        <span class="tok-kw">var</span> rand_buf: [RANDOM_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L181">        <span class="tok-kw">var</span> tmp_path_buf: [TMP_PATH_LEN:<span class="tok-number">0</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L182"></span>
<span class="line" id="L183">        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L184">            crypto.random.bytes(rand_buf[<span class="tok-number">0</span>..]);</span>
<span class="line" id="L185">            <span class="tok-kw">const</span> tmp_path = base64_encoder.encode(&amp;tmp_path_buf, &amp;rand_buf);</span>
<span class="line" id="L186">            tmp_path_buf[tmp_path.len] = <span class="tok-number">0</span>;</span>
<span class="line" id="L187"></span>
<span class="line" id="L188">            <span class="tok-kw">const</span> file = dir.createFile(</span>
<span class="line" id="L189">                tmp_path,</span>
<span class="line" id="L190">                .{ .mode = mode, .exclusive = <span class="tok-null">true</span> },</span>
<span class="line" id="L191">            ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L192">                <span class="tok-kw">error</span>.PathAlreadyExists =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L193">                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L194">            };</span>
<span class="line" id="L195"></span>
<span class="line" id="L196">            <span class="tok-kw">return</span> AtomicFile{</span>
<span class="line" id="L197">                .file = file,</span>
<span class="line" id="L198">                .tmp_path_buf = tmp_path_buf,</span>
<span class="line" id="L199">                .dest_basename = dest_basename,</span>
<span class="line" id="L200">                .file_open = <span class="tok-null">true</span>,</span>
<span class="line" id="L201">                .file_exists = <span class="tok-null">true</span>,</span>
<span class="line" id="L202">                .close_dir_on_deinit = close_dir_on_deinit,</span>
<span class="line" id="L203">                .dir = dir,</span>
<span class="line" id="L204">            };</span>
<span class="line" id="L205">        }</span>
<span class="line" id="L206">    }</span>
<span class="line" id="L207"></span>
<span class="line" id="L208">    <span class="tok-comment">/// always call deinit, even after successful finish()</span></span>
<span class="line" id="L209">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *AtomicFile) <span class="tok-type">void</span> {</span>
<span class="line" id="L210">        <span class="tok-kw">if</span> (self.file_open) {</span>
<span class="line" id="L211">            self.file.close();</span>
<span class="line" id="L212">            self.file_open = <span class="tok-null">false</span>;</span>
<span class="line" id="L213">        }</span>
<span class="line" id="L214">        <span class="tok-kw">if</span> (self.file_exists) {</span>
<span class="line" id="L215">            self.dir.deleteFile(&amp;self.tmp_path_buf) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L216">            self.file_exists = <span class="tok-null">false</span>;</span>
<span class="line" id="L217">        }</span>
<span class="line" id="L218">        <span class="tok-kw">if</span> (self.close_dir_on_deinit) {</span>
<span class="line" id="L219">            self.dir.close();</span>
<span class="line" id="L220">        }</span>
<span class="line" id="L221">        self.* = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L222">    }</span>
<span class="line" id="L223"></span>
<span class="line" id="L224">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FinishError = std.os.RenameError;</span>
<span class="line" id="L225"></span>
<span class="line" id="L226">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">finish</span>(self: *AtomicFile) FinishError!<span class="tok-type">void</span> {</span>
<span class="line" id="L227">        assert(self.file_exists);</span>
<span class="line" id="L228">        <span class="tok-kw">if</span> (self.file_open) {</span>
<span class="line" id="L229">            self.file.close();</span>
<span class="line" id="L230">            self.file_open = <span class="tok-null">false</span>;</span>
<span class="line" id="L231">        }</span>
<span class="line" id="L232">        <span class="tok-kw">try</span> os.renameat(self.dir.fd, self.tmp_path_buf[<span class="tok-number">0</span>..], self.dir.fd, self.dest_basename);</span>
<span class="line" id="L233">        self.file_exists = <span class="tok-null">false</span>;</span>
<span class="line" id="L234">    }</span>
<span class="line" id="L235">};</span>
<span class="line" id="L236"></span>
<span class="line" id="L237"><span class="tok-kw">const</span> default_new_dir_mode = <span class="tok-number">0o755</span>;</span>
<span class="line" id="L238"></span>
<span class="line" id="L239"><span class="tok-comment">/// Create a new directory, based on an absolute path.</span></span>
<span class="line" id="L240"><span class="tok-comment">/// Asserts that the path is absolute. See `Dir.makeDir` for a function that operates</span></span>
<span class="line" id="L241"><span class="tok-comment">/// on both absolute and relative paths.</span></span>
<span class="line" id="L242"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeDirAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L243">    assert(path.isAbsolute(absolute_path));</span>
<span class="line" id="L244">    <span class="tok-kw">return</span> os.mkdir(absolute_path, default_new_dir_mode);</span>
<span class="line" id="L245">}</span>
<span class="line" id="L246"></span>
<span class="line" id="L247"><span class="tok-comment">/// Same as `makeDirAbsolute` except the parameter is a null-terminated UTF-8-encoded string.</span></span>
<span class="line" id="L248"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeDirAbsoluteZ</span>(absolute_path_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L249">    assert(path.isAbsoluteZ(absolute_path_z));</span>
<span class="line" id="L250">    <span class="tok-kw">return</span> os.mkdirZ(absolute_path_z, default_new_dir_mode);</span>
<span class="line" id="L251">}</span>
<span class="line" id="L252"></span>
<span class="line" id="L253"><span class="tok-comment">/// Same as `makeDirAbsolute` except the parameter is a null-terminated WTF-16-encoded string.</span></span>
<span class="line" id="L254"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeDirAbsoluteW</span>(absolute_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L255">    assert(path.isAbsoluteWindowsW(absolute_path_w));</span>
<span class="line" id="L256">    <span class="tok-kw">return</span> os.mkdirW(absolute_path_w, default_new_dir_mode);</span>
<span class="line" id="L257">}</span>
<span class="line" id="L258"></span>
<span class="line" id="L259"><span class="tok-comment">/// Same as `Dir.deleteDir` except the path is absolute.</span></span>
<span class="line" id="L260"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteDirAbsolute</span>(dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L261">    assert(path.isAbsolute(dir_path));</span>
<span class="line" id="L262">    <span class="tok-kw">return</span> os.rmdir(dir_path);</span>
<span class="line" id="L263">}</span>
<span class="line" id="L264"></span>
<span class="line" id="L265"><span class="tok-comment">/// Same as `deleteDirAbsolute` except the path parameter is null-terminated.</span></span>
<span class="line" id="L266"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteDirAbsoluteZ</span>(dir_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L267">    assert(path.isAbsoluteZ(dir_path));</span>
<span class="line" id="L268">    <span class="tok-kw">return</span> os.rmdirZ(dir_path);</span>
<span class="line" id="L269">}</span>
<span class="line" id="L270"></span>
<span class="line" id="L271"><span class="tok-comment">/// Same as `deleteDirAbsolute` except the path parameter is WTF-16 and target OS is assumed Windows.</span></span>
<span class="line" id="L272"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteDirAbsoluteW</span>(dir_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L273">    assert(path.isAbsoluteWindowsW(dir_path));</span>
<span class="line" id="L274">    <span class="tok-kw">return</span> os.rmdirW(dir_path);</span>
<span class="line" id="L275">}</span>
<span class="line" id="L276"></span>
<span class="line" id="L277"><span class="tok-comment">/// Same as `Dir.rename` except the paths are absolute.</span></span>
<span class="line" id="L278"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameAbsolute</span>(old_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L279">    assert(path.isAbsolute(old_path));</span>
<span class="line" id="L280">    assert(path.isAbsolute(new_path));</span>
<span class="line" id="L281">    <span class="tok-kw">return</span> os.rename(old_path, new_path);</span>
<span class="line" id="L282">}</span>
<span class="line" id="L283"></span>
<span class="line" id="L284"><span class="tok-comment">/// Same as `renameAbsolute` except the path parameters are null-terminated.</span></span>
<span class="line" id="L285"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameAbsoluteZ</span>(old_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L286">    assert(path.isAbsoluteZ(old_path));</span>
<span class="line" id="L287">    assert(path.isAbsoluteZ(new_path));</span>
<span class="line" id="L288">    <span class="tok-kw">return</span> os.renameZ(old_path, new_path);</span>
<span class="line" id="L289">}</span>
<span class="line" id="L290"></span>
<span class="line" id="L291"><span class="tok-comment">/// Same as `renameAbsolute` except the path parameters are WTF-16 and target OS is assumed Windows.</span></span>
<span class="line" id="L292"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameAbsoluteW</span>(old_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, new_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L293">    assert(path.isAbsoluteWindowsW(old_path));</span>
<span class="line" id="L294">    assert(path.isAbsoluteWindowsW(new_path));</span>
<span class="line" id="L295">    <span class="tok-kw">return</span> os.renameW(old_path, new_path);</span>
<span class="line" id="L296">}</span>
<span class="line" id="L297"></span>
<span class="line" id="L298"><span class="tok-comment">/// Same as `Dir.rename`, except `new_sub_path` is relative to `new_dir`</span></span>
<span class="line" id="L299"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rename</span>(old_dir: Dir, old_sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_dir: Dir, new_sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L300">    <span class="tok-kw">return</span> os.renameat(old_dir.fd, old_sub_path, new_dir.fd, new_sub_path);</span>
<span class="line" id="L301">}</span>
<span class="line" id="L302"></span>
<span class="line" id="L303"><span class="tok-comment">/// Same as `rename` except the parameters are null-terminated.</span></span>
<span class="line" id="L304"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameZ</span>(old_dir: Dir, old_sub_path_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_dir: Dir, new_sub_path_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L305">    <span class="tok-kw">return</span> os.renameatZ(old_dir.fd, old_sub_path_z, new_dir.fd, new_sub_path_z);</span>
<span class="line" id="L306">}</span>
<span class="line" id="L307"></span>
<span class="line" id="L308"><span class="tok-comment">/// Same as `rename` except the parameters are UTF16LE, NT prefixed.</span></span>
<span class="line" id="L309"><span class="tok-comment">/// This function is Windows-only.</span></span>
<span class="line" id="L310"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameW</span>(old_dir: Dir, old_sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, new_dir: Dir, new_sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L311">    <span class="tok-kw">return</span> os.renameatW(old_dir.fd, old_sub_path_w, new_dir.fd, new_sub_path_w);</span>
<span class="line" id="L312">}</span>
<span class="line" id="L313"></span>
<span class="line" id="L314"><span class="tok-comment">/// A directory that can be iterated. It is *NOT* legal to initialize this with a regular `Dir`</span></span>
<span class="line" id="L315"><span class="tok-comment">/// that has been opened without iteration permission.</span></span>
<span class="line" id="L316"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> IterableDir = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L317">    dir: Dir,</span>
<span class="line" id="L318"></span>
<span class="line" id="L319">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L320">        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L321">        kind: Kind,</span>
<span class="line" id="L322"></span>
<span class="line" id="L323">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Kind = File.Kind;</span>
<span class="line" id="L324">    };</span>
<span class="line" id="L325"></span>
<span class="line" id="L326">    <span class="tok-kw">const</span> IteratorError = <span class="tok-kw">error</span>{ AccessDenied, SystemResources } || os.UnexpectedError;</span>
<span class="line" id="L327"></span>
<span class="line" id="L328">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <span class="tok-kw">switch</span> (builtin.os.tag) {</span>
<span class="line" id="L329">        .macos, .ios, .freebsd, .netbsd, .dragonfly, .openbsd, .solaris =&gt; <span class="tok-kw">struct</span> {</span>
<span class="line" id="L330">            dir: Dir,</span>
<span class="line" id="L331">            seek: <span class="tok-type">i64</span>,</span>
<span class="line" id="L332">            buf: [<span class="tok-number">1024</span>]<span class="tok-type">u8</span>, <span class="tok-comment">// TODO align(@alignOf(os.system.dirent)),</span>
</span>
<span class="line" id="L333">            index: <span class="tok-type">usize</span>,</span>
<span class="line" id="L334">            end_index: <span class="tok-type">usize</span>,</span>
<span class="line" id="L335">            first_iter: <span class="tok-type">bool</span>,</span>
<span class="line" id="L336"></span>
<span class="line" id="L337">            <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L338"></span>
<span class="line" id="L339">            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = IteratorError;</span>
<span class="line" id="L340"></span>
<span class="line" id="L341">            <span class="tok-comment">/// Memory such as file names referenced in this returned entry becomes invalid</span></span>
<span class="line" id="L342">            <span class="tok-comment">/// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.</span></span>
<span class="line" id="L343">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *Self) Error!?Entry {</span>
<span class="line" id="L344">                <span class="tok-kw">switch</span> (builtin.os.tag) {</span>
<span class="line" id="L345">                    .macos, .ios =&gt; <span class="tok-kw">return</span> self.nextDarwin(),</span>
<span class="line" id="L346">                    .freebsd, .netbsd, .dragonfly, .openbsd =&gt; <span class="tok-kw">return</span> self.nextBsd(),</span>
<span class="line" id="L347">                    .solaris =&gt; <span class="tok-kw">return</span> self.nextSolaris(),</span>
<span class="line" id="L348">                    <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unimplemented&quot;</span>),</span>
<span class="line" id="L349">                }</span>
<span class="line" id="L350">            }</span>
<span class="line" id="L351"></span>
<span class="line" id="L352">            <span class="tok-kw">fn</span> <span class="tok-fn">nextDarwin</span>(self: *Self) !?Entry {</span>
<span class="line" id="L353">                start_over: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L354">                    <span class="tok-kw">if</span> (self.index &gt;= self.end_index) {</span>
<span class="line" id="L355">                        <span class="tok-kw">if</span> (self.first_iter) {</span>
<span class="line" id="L356">                            std.os.lseek_SET(self.dir.fd, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>; <span class="tok-comment">// EBADF here likely means that the Dir was not opened with iteration permissions</span>
</span>
<span class="line" id="L357">                            self.first_iter = <span class="tok-null">false</span>;</span>
<span class="line" id="L358">                        }</span>
<span class="line" id="L359">                        <span class="tok-kw">const</span> rc = os.system.__getdirentries64(</span>
<span class="line" id="L360">                            self.dir.fd,</span>
<span class="line" id="L361">                            &amp;self.buf,</span>
<span class="line" id="L362">                            self.buf.len,</span>
<span class="line" id="L363">                            &amp;self.seek,</span>
<span class="line" id="L364">                        );</span>
<span class="line" id="L365">                        <span class="tok-kw">if</span> (rc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L366">                        <span class="tok-kw">if</span> (rc &lt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L367">                            <span class="tok-kw">switch</span> (os.errno(rc)) {</span>
<span class="line" id="L368">                                .BADF =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Dir is invalid or was opened without iteration ability</span>
</span>
<span class="line" id="L369">                                .FAULT =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L370">                                .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L371">                                .INVAL =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L372">                                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> os.unexpectedErrno(err),</span>
<span class="line" id="L373">                            }</span>
<span class="line" id="L374">                        }</span>
<span class="line" id="L375">                        self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L376">                        self.end_index = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(rc));</span>
<span class="line" id="L377">                    }</span>
<span class="line" id="L378">                    <span class="tok-kw">const</span> darwin_entry = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) os.system.dirent, <span class="tok-builtin">@ptrCast</span>(&amp;self.buf[self.index]));</span>
<span class="line" id="L379">                    <span class="tok-kw">const</span> next_index = self.index + darwin_entry.reclen();</span>
<span class="line" id="L380">                    self.index = next_index;</span>
<span class="line" id="L381"></span>
<span class="line" id="L382">                    <span class="tok-kw">const</span> name = <span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;darwin_entry.d_name))[<span class="tok-number">0</span>..darwin_entry.d_namlen];</span>
<span class="line" id="L383"></span>
<span class="line" id="L384">                    <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>) <span class="tok-kw">or</span> mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;..&quot;</span>) <span class="tok-kw">or</span> (darwin_entry.d_ino == <span class="tok-number">0</span>)) {</span>
<span class="line" id="L385">                        <span class="tok-kw">continue</span> :start_over;</span>
<span class="line" id="L386">                    }</span>
<span class="line" id="L387"></span>
<span class="line" id="L388">                    <span class="tok-kw">const</span> entry_kind: Entry.Kind = <span class="tok-kw">switch</span> (darwin_entry.d_type) {</span>
<span class="line" id="L389">                        os.DT.BLK =&gt; .block_device,</span>
<span class="line" id="L390">                        os.DT.CHR =&gt; .character_device,</span>
<span class="line" id="L391">                        os.DT.DIR =&gt; .directory,</span>
<span class="line" id="L392">                        os.DT.FIFO =&gt; .named_pipe,</span>
<span class="line" id="L393">                        os.DT.LNK =&gt; .sym_link,</span>
<span class="line" id="L394">                        os.DT.REG =&gt; .file,</span>
<span class="line" id="L395">                        os.DT.SOCK =&gt; .unix_domain_socket,</span>
<span class="line" id="L396">                        os.DT.WHT =&gt; .whiteout,</span>
<span class="line" id="L397">                        <span class="tok-kw">else</span> =&gt; .unknown,</span>
<span class="line" id="L398">                    };</span>
<span class="line" id="L399">                    <span class="tok-kw">return</span> Entry{</span>
<span class="line" id="L400">                        .name = name,</span>
<span class="line" id="L401">                        .kind = entry_kind,</span>
<span class="line" id="L402">                    };</span>
<span class="line" id="L403">                }</span>
<span class="line" id="L404">            }</span>
<span class="line" id="L405"></span>
<span class="line" id="L406">            <span class="tok-kw">fn</span> <span class="tok-fn">nextSolaris</span>(self: *Self) !?Entry {</span>
<span class="line" id="L407">                start_over: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L408">                    <span class="tok-kw">if</span> (self.index &gt;= self.end_index) {</span>
<span class="line" id="L409">                        <span class="tok-kw">if</span> (self.first_iter) {</span>
<span class="line" id="L410">                            std.os.lseek_SET(self.dir.fd, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>; <span class="tok-comment">// EBADF here likely means that the Dir was not opened with iteration permissions</span>
</span>
<span class="line" id="L411">                            self.first_iter = <span class="tok-null">false</span>;</span>
<span class="line" id="L412">                        }</span>
<span class="line" id="L413">                        <span class="tok-kw">const</span> rc = os.system.getdents(self.dir.fd, &amp;self.buf, self.buf.len);</span>
<span class="line" id="L414">                        <span class="tok-kw">switch</span> (os.errno(rc)) {</span>
<span class="line" id="L415">                            .SUCCESS =&gt; {},</span>
<span class="line" id="L416">                            .BADF =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Dir is invalid or was opened without iteration ability</span>
</span>
<span class="line" id="L417">                            .FAULT =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L418">                            .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L419">                            .INVAL =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L420">                            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> os.unexpectedErrno(err),</span>
<span class="line" id="L421">                        }</span>
<span class="line" id="L422">                        <span class="tok-kw">if</span> (rc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L423">                        self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L424">                        self.end_index = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(rc));</span>
<span class="line" id="L425">                    }</span>
<span class="line" id="L426">                    <span class="tok-kw">const</span> entry = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) os.system.dirent, <span class="tok-builtin">@ptrCast</span>(&amp;self.buf[self.index]));</span>
<span class="line" id="L427">                    <span class="tok-kw">const</span> next_index = self.index + entry.reclen();</span>
<span class="line" id="L428">                    self.index = next_index;</span>
<span class="line" id="L429"></span>
<span class="line" id="L430">                    <span class="tok-kw">const</span> name = mem.sliceTo(<span class="tok-builtin">@as</span>([*:<span class="tok-number">0</span>]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;entry.d_name)), <span class="tok-number">0</span>);</span>
<span class="line" id="L431">                    <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>) <span class="tok-kw">or</span> mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;..&quot;</span>))</span>
<span class="line" id="L432">                        <span class="tok-kw">continue</span> :start_over;</span>
<span class="line" id="L433"></span>
<span class="line" id="L434">                    <span class="tok-comment">// Solaris dirent doesn't expose d_type, so we have to call stat to get it.</span>
</span>
<span class="line" id="L435">                    <span class="tok-kw">const</span> stat_info = os.fstatat(</span>
<span class="line" id="L436">                        self.dir.fd,</span>
<span class="line" id="L437">                        name,</span>
<span class="line" id="L438">                        os.AT.SYMLINK_NOFOLLOW,</span>
<span class="line" id="L439">                    ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L440">                        <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L441">                        <span class="tok-kw">error</span>.SymLinkLoop =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L442">                        <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// lost the race</span>
</span>
<span class="line" id="L443">                        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L444">                    };</span>
<span class="line" id="L445">                    <span class="tok-kw">const</span> entry_kind: Entry.Kind = <span class="tok-kw">switch</span> (stat_info.mode &amp; os.S.IFMT) {</span>
<span class="line" id="L446">                        os.S.IFIFO =&gt; .named_pipe,</span>
<span class="line" id="L447">                        os.S.IFCHR =&gt; .character_device,</span>
<span class="line" id="L448">                        os.S.IFDIR =&gt; .directory,</span>
<span class="line" id="L449">                        os.S.IFBLK =&gt; .block_device,</span>
<span class="line" id="L450">                        os.S.IFREG =&gt; .file,</span>
<span class="line" id="L451">                        os.S.IFLNK =&gt; .sym_link,</span>
<span class="line" id="L452">                        os.S.IFSOCK =&gt; .unix_domain_socket,</span>
<span class="line" id="L453">                        os.S.IFDOOR =&gt; .door,</span>
<span class="line" id="L454">                        os.S.IFPORT =&gt; .event_port,</span>
<span class="line" id="L455">                        <span class="tok-kw">else</span> =&gt; .unknown,</span>
<span class="line" id="L456">                    };</span>
<span class="line" id="L457">                    <span class="tok-kw">return</span> Entry{</span>
<span class="line" id="L458">                        .name = name,</span>
<span class="line" id="L459">                        .kind = entry_kind,</span>
<span class="line" id="L460">                    };</span>
<span class="line" id="L461">                }</span>
<span class="line" id="L462">            }</span>
<span class="line" id="L463"></span>
<span class="line" id="L464">            <span class="tok-kw">fn</span> <span class="tok-fn">nextBsd</span>(self: *Self) !?Entry {</span>
<span class="line" id="L465">                start_over: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L466">                    <span class="tok-kw">if</span> (self.index &gt;= self.end_index) {</span>
<span class="line" id="L467">                        <span class="tok-kw">if</span> (self.first_iter) {</span>
<span class="line" id="L468">                            std.os.lseek_SET(self.dir.fd, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>; <span class="tok-comment">// EBADF here likely means that the Dir was not opened with iteration permissions</span>
</span>
<span class="line" id="L469">                            self.first_iter = <span class="tok-null">false</span>;</span>
<span class="line" id="L470">                        }</span>
<span class="line" id="L471">                        <span class="tok-kw">const</span> rc = <span class="tok-kw">if</span> (builtin.os.tag == .netbsd)</span>
<span class="line" id="L472">                            os.system.__getdents30(self.dir.fd, &amp;self.buf, self.buf.len)</span>
<span class="line" id="L473">                        <span class="tok-kw">else</span></span>
<span class="line" id="L474">                            os.system.getdents(self.dir.fd, &amp;self.buf, self.buf.len);</span>
<span class="line" id="L475">                        <span class="tok-kw">switch</span> (os.errno(rc)) {</span>
<span class="line" id="L476">                            .SUCCESS =&gt; {},</span>
<span class="line" id="L477">                            .BADF =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Dir is invalid or was opened without iteration ability</span>
</span>
<span class="line" id="L478">                            .FAULT =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L479">                            .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L480">                            .INVAL =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L481">                            <span class="tok-comment">// Introduced in freebsd 13.2: directory unlinked but still open.</span>
</span>
<span class="line" id="L482">                            <span class="tok-comment">// To be consistent, iteration ends if the directory being iterated is deleted during iteration.</span>
</span>
<span class="line" id="L483">                            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,</span>
<span class="line" id="L484">                            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> os.unexpectedErrno(err),</span>
<span class="line" id="L485">                        }</span>
<span class="line" id="L486">                        <span class="tok-kw">if</span> (rc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L487">                        self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L488">                        self.end_index = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(rc));</span>
<span class="line" id="L489">                    }</span>
<span class="line" id="L490">                    <span class="tok-kw">const</span> bsd_entry = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) os.system.dirent, <span class="tok-builtin">@ptrCast</span>(&amp;self.buf[self.index]));</span>
<span class="line" id="L491">                    <span class="tok-kw">const</span> next_index = self.index + bsd_entry.reclen();</span>
<span class="line" id="L492">                    self.index = next_index;</span>
<span class="line" id="L493"></span>
<span class="line" id="L494">                    <span class="tok-kw">const</span> name = <span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;bsd_entry.d_name))[<span class="tok-number">0</span>..bsd_entry.d_namlen];</span>
<span class="line" id="L495"></span>
<span class="line" id="L496">                    <span class="tok-kw">const</span> skip_zero_fileno = <span class="tok-kw">switch</span> (builtin.os.tag) {</span>
<span class="line" id="L497">                        <span class="tok-comment">// d_fileno=0 is used to mark invalid entries or deleted files.</span>
</span>
<span class="line" id="L498">                        .openbsd, .netbsd =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L499">                        <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L500">                    };</span>
<span class="line" id="L501">                    <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>) <span class="tok-kw">or</span> mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;..&quot;</span>) <span class="tok-kw">or</span></span>
<span class="line" id="L502">                        (skip_zero_fileno <span class="tok-kw">and</span> bsd_entry.d_fileno == <span class="tok-number">0</span>))</span>
<span class="line" id="L503">                    {</span>
<span class="line" id="L504">                        <span class="tok-kw">continue</span> :start_over;</span>
<span class="line" id="L505">                    }</span>
<span class="line" id="L506"></span>
<span class="line" id="L507">                    <span class="tok-kw">const</span> entry_kind: Entry.Kind = <span class="tok-kw">switch</span> (bsd_entry.d_type) {</span>
<span class="line" id="L508">                        os.DT.BLK =&gt; .block_device,</span>
<span class="line" id="L509">                        os.DT.CHR =&gt; .character_device,</span>
<span class="line" id="L510">                        os.DT.DIR =&gt; .directory,</span>
<span class="line" id="L511">                        os.DT.FIFO =&gt; .named_pipe,</span>
<span class="line" id="L512">                        os.DT.LNK =&gt; .sym_link,</span>
<span class="line" id="L513">                        os.DT.REG =&gt; .file,</span>
<span class="line" id="L514">                        os.DT.SOCK =&gt; .unix_domain_socket,</span>
<span class="line" id="L515">                        os.DT.WHT =&gt; .whiteout,</span>
<span class="line" id="L516">                        <span class="tok-kw">else</span> =&gt; .unknown,</span>
<span class="line" id="L517">                    };</span>
<span class="line" id="L518">                    <span class="tok-kw">return</span> Entry{</span>
<span class="line" id="L519">                        .name = name,</span>
<span class="line" id="L520">                        .kind = entry_kind,</span>
<span class="line" id="L521">                    };</span>
<span class="line" id="L522">                }</span>
<span class="line" id="L523">            }</span>
<span class="line" id="L524"></span>
<span class="line" id="L525">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *Self) <span class="tok-type">void</span> {</span>
<span class="line" id="L526">                self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L527">                self.end_index = <span class="tok-number">0</span>;</span>
<span class="line" id="L528">                self.first_iter = <span class="tok-null">true</span>;</span>
<span class="line" id="L529">            }</span>
<span class="line" id="L530">        },</span>
<span class="line" id="L531">        .haiku =&gt; <span class="tok-kw">struct</span> {</span>
<span class="line" id="L532">            dir: Dir,</span>
<span class="line" id="L533">            buf: [<span class="tok-number">1024</span>]<span class="tok-type">u8</span>, <span class="tok-comment">// TODO align(@alignOf(os.dirent64)),</span>
</span>
<span class="line" id="L534">            index: <span class="tok-type">usize</span>,</span>
<span class="line" id="L535">            end_index: <span class="tok-type">usize</span>,</span>
<span class="line" id="L536">            first_iter: <span class="tok-type">bool</span>,</span>
<span class="line" id="L537"></span>
<span class="line" id="L538">            <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L539"></span>
<span class="line" id="L540">            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = IteratorError;</span>
<span class="line" id="L541"></span>
<span class="line" id="L542">            <span class="tok-comment">/// Memory such as file names referenced in this returned entry becomes invalid</span></span>
<span class="line" id="L543">            <span class="tok-comment">/// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.</span></span>
<span class="line" id="L544">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *Self) Error!?Entry {</span>
<span class="line" id="L545">                start_over: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L546">                    <span class="tok-comment">// TODO: find a better max</span>
</span>
<span class="line" id="L547">                    <span class="tok-kw">const</span> HAIKU_MAX_COUNT = <span class="tok-number">10000</span>;</span>
<span class="line" id="L548">                    <span class="tok-kw">if</span> (self.index &gt;= self.end_index) {</span>
<span class="line" id="L549">                        <span class="tok-kw">if</span> (self.first_iter) {</span>
<span class="line" id="L550">                            std.os.lseek_SET(self.dir.fd, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>; <span class="tok-comment">// EBADF here likely means that the Dir was not opened with iteration permissions</span>
</span>
<span class="line" id="L551">                            self.first_iter = <span class="tok-null">false</span>;</span>
<span class="line" id="L552">                        }</span>
<span class="line" id="L553">                        <span class="tok-kw">const</span> rc = os.system._kern_read_dir(</span>
<span class="line" id="L554">                            self.dir.fd,</span>
<span class="line" id="L555">                            &amp;self.buf,</span>
<span class="line" id="L556">                            self.buf.len,</span>
<span class="line" id="L557">                            HAIKU_MAX_COUNT,</span>
<span class="line" id="L558">                        );</span>
<span class="line" id="L559">                        <span class="tok-kw">if</span> (rc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L560">                        <span class="tok-kw">if</span> (rc &lt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L561">                            <span class="tok-kw">switch</span> (os.errno(rc)) {</span>
<span class="line" id="L562">                                .BADF =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Dir is invalid or was opened without iteration ability</span>
</span>
<span class="line" id="L563">                                .FAULT =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L564">                                .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L565">                                .INVAL =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L566">                                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> os.unexpectedErrno(err),</span>
<span class="line" id="L567">                            }</span>
<span class="line" id="L568">                        }</span>
<span class="line" id="L569">                        self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L570">                        self.end_index = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(rc));</span>
<span class="line" id="L571">                    }</span>
<span class="line" id="L572">                    <span class="tok-kw">const</span> haiku_entry = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) os.system.dirent, <span class="tok-builtin">@ptrCast</span>(&amp;self.buf[self.index]));</span>
<span class="line" id="L573">                    <span class="tok-kw">const</span> next_index = self.index + haiku_entry.reclen();</span>
<span class="line" id="L574">                    self.index = next_index;</span>
<span class="line" id="L575">                    <span class="tok-kw">const</span> name = mem.sliceTo(<span class="tok-builtin">@as</span>([*:<span class="tok-number">0</span>]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;haiku_entry.d_name)), <span class="tok-number">0</span>);</span>
<span class="line" id="L576"></span>
<span class="line" id="L577">                    <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>) <span class="tok-kw">or</span> mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;..&quot;</span>) <span class="tok-kw">or</span> (haiku_entry.d_ino == <span class="tok-number">0</span>)) {</span>
<span class="line" id="L578">                        <span class="tok-kw">continue</span> :start_over;</span>
<span class="line" id="L579">                    }</span>
<span class="line" id="L580"></span>
<span class="line" id="L581">                    <span class="tok-kw">var</span> stat_info: os.Stat = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L582">                    <span class="tok-kw">const</span> rc = os.system._kern_read_stat(</span>
<span class="line" id="L583">                        self.dir.fd,</span>
<span class="line" id="L584">                        &amp;haiku_entry.d_name,</span>
<span class="line" id="L585">                        <span class="tok-null">false</span>,</span>
<span class="line" id="L586">                        &amp;stat_info,</span>
<span class="line" id="L587">                        <span class="tok-number">0</span>,</span>
<span class="line" id="L588">                    );</span>
<span class="line" id="L589">                    <span class="tok-kw">if</span> (rc != <span class="tok-number">0</span>) {</span>
<span class="line" id="L590">                        <span class="tok-kw">switch</span> (os.errno(rc)) {</span>
<span class="line" id="L591">                            .SUCCESS =&gt; {},</span>
<span class="line" id="L592">                            .BADF =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Dir is invalid or was opened without iteration ability</span>
</span>
<span class="line" id="L593">                            .FAULT =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L594">                            .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L595">                            .INVAL =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L596">                            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> os.unexpectedErrno(err),</span>
<span class="line" id="L597">                        }</span>
<span class="line" id="L598">                    }</span>
<span class="line" id="L599">                    <span class="tok-kw">const</span> statmode = stat_info.mode &amp; os.S.IFMT;</span>
<span class="line" id="L600"></span>
<span class="line" id="L601">                    <span class="tok-kw">const</span> entry_kind: Entry.Kind = <span class="tok-kw">switch</span> (statmode) {</span>
<span class="line" id="L602">                        os.S.IFDIR =&gt; .directory,</span>
<span class="line" id="L603">                        os.S.IFBLK =&gt; .block_device,</span>
<span class="line" id="L604">                        os.S.IFCHR =&gt; .character_device,</span>
<span class="line" id="L605">                        os.S.IFLNK =&gt; .sym_link,</span>
<span class="line" id="L606">                        os.S.IFREG =&gt; .file,</span>
<span class="line" id="L607">                        os.S.IFIFO =&gt; .named_pipe,</span>
<span class="line" id="L608">                        <span class="tok-kw">else</span> =&gt; .unknown,</span>
<span class="line" id="L609">                    };</span>
<span class="line" id="L610"></span>
<span class="line" id="L611">                    <span class="tok-kw">return</span> Entry{</span>
<span class="line" id="L612">                        .name = name,</span>
<span class="line" id="L613">                        .kind = entry_kind,</span>
<span class="line" id="L614">                    };</span>
<span class="line" id="L615">                }</span>
<span class="line" id="L616">            }</span>
<span class="line" id="L617"></span>
<span class="line" id="L618">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *Self) <span class="tok-type">void</span> {</span>
<span class="line" id="L619">                self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L620">                self.end_index = <span class="tok-number">0</span>;</span>
<span class="line" id="L621">                self.first_iter = <span class="tok-null">true</span>;</span>
<span class="line" id="L622">            }</span>
<span class="line" id="L623">        },</span>
<span class="line" id="L624">        .linux =&gt; <span class="tok-kw">struct</span> {</span>
<span class="line" id="L625">            dir: Dir,</span>
<span class="line" id="L626">            <span class="tok-comment">// The if guard is solely there to prevent compile errors from missing `linux.dirent64`</span>
</span>
<span class="line" id="L627">            <span class="tok-comment">// definition when compiling for other OSes. It doesn't do anything when compiling for Linux.</span>
</span>
<span class="line" id="L628">            buf: [<span class="tok-number">1024</span>]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-kw">if</span> (builtin.os.tag != .linux) <span class="tok-number">1</span> <span class="tok-kw">else</span> <span class="tok-builtin">@alignOf</span>(linux.dirent64)),</span>
<span class="line" id="L629">            index: <span class="tok-type">usize</span>,</span>
<span class="line" id="L630">            end_index: <span class="tok-type">usize</span>,</span>
<span class="line" id="L631">            first_iter: <span class="tok-type">bool</span>,</span>
<span class="line" id="L632"></span>
<span class="line" id="L633">            <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L634">            <span class="tok-kw">const</span> linux = os.linux;</span>
<span class="line" id="L635"></span>
<span class="line" id="L636">            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = IteratorError;</span>
<span class="line" id="L637"></span>
<span class="line" id="L638">            <span class="tok-comment">/// Memory such as file names referenced in this returned entry becomes invalid</span></span>
<span class="line" id="L639">            <span class="tok-comment">/// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.</span></span>
<span class="line" id="L640">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *Self) Error!?Entry {</span>
<span class="line" id="L641">                <span class="tok-kw">return</span> self.nextLinux() <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L642">                    <span class="tok-comment">// To be consistent across platforms, iteration ends if the directory being iterated is deleted during iteration.</span>
</span>
<span class="line" id="L643">                    <span class="tok-comment">// This matches the behavior of non-Linux UNIX platforms.</span>
</span>
<span class="line" id="L644">                    <span class="tok-kw">error</span>.DirNotFound =&gt; <span class="tok-null">null</span>,</span>
<span class="line" id="L645">                    <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L646">                };</span>
<span class="line" id="L647">            }</span>
<span class="line" id="L648"></span>
<span class="line" id="L649">            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ErrorLinux = <span class="tok-kw">error</span>{DirNotFound} || IteratorError;</span>
<span class="line" id="L650"></span>
<span class="line" id="L651">            <span class="tok-comment">/// Implementation of `next` that can return `error.DirNotFound` if the directory being</span></span>
<span class="line" id="L652">            <span class="tok-comment">/// iterated was deleted during iteration (this error is Linux specific).</span></span>
<span class="line" id="L653">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextLinux</span>(self: *Self) ErrorLinux!?Entry {</span>
<span class="line" id="L654">                start_over: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L655">                    <span class="tok-kw">if</span> (self.index &gt;= self.end_index) {</span>
<span class="line" id="L656">                        <span class="tok-kw">if</span> (self.first_iter) {</span>
<span class="line" id="L657">                            std.os.lseek_SET(self.dir.fd, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>; <span class="tok-comment">// EBADF here likely means that the Dir was not opened with iteration permissions</span>
</span>
<span class="line" id="L658">                            self.first_iter = <span class="tok-null">false</span>;</span>
<span class="line" id="L659">                        }</span>
<span class="line" id="L660">                        <span class="tok-kw">const</span> rc = linux.getdents64(self.dir.fd, &amp;self.buf, self.buf.len);</span>
<span class="line" id="L661">                        <span class="tok-kw">switch</span> (linux.getErrno(rc)) {</span>
<span class="line" id="L662">                            .SUCCESS =&gt; {},</span>
<span class="line" id="L663">                            .BADF =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Dir is invalid or was opened without iteration ability</span>
</span>
<span class="line" id="L664">                            .FAULT =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L665">                            .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L666">                            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DirNotFound, <span class="tok-comment">// The directory being iterated was deleted during iteration.</span>
</span>
<span class="line" id="L667">                            .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected, <span class="tok-comment">// Linux may in some cases return EINVAL when reading /proc/$PID/net.</span>
</span>
<span class="line" id="L668">                            .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied, <span class="tok-comment">// Do not have permission to iterate this directory.</span>
</span>
<span class="line" id="L669">                            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> os.unexpectedErrno(err),</span>
<span class="line" id="L670">                        }</span>
<span class="line" id="L671">                        <span class="tok-kw">if</span> (rc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L672">                        self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L673">                        self.end_index = rc;</span>
<span class="line" id="L674">                    }</span>
<span class="line" id="L675">                    <span class="tok-kw">const</span> linux_entry = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) linux.dirent64, <span class="tok-builtin">@ptrCast</span>(&amp;self.buf[self.index]));</span>
<span class="line" id="L676">                    <span class="tok-kw">const</span> next_index = self.index + linux_entry.reclen();</span>
<span class="line" id="L677">                    self.index = next_index;</span>
<span class="line" id="L678"></span>
<span class="line" id="L679">                    <span class="tok-kw">const</span> name = mem.sliceTo(<span class="tok-builtin">@as</span>([*:<span class="tok-number">0</span>]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;linux_entry.d_name)), <span class="tok-number">0</span>);</span>
<span class="line" id="L680"></span>
<span class="line" id="L681">                    <span class="tok-comment">// skip . and .. entries</span>
</span>
<span class="line" id="L682">                    <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>) <span class="tok-kw">or</span> mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;..&quot;</span>)) {</span>
<span class="line" id="L683">                        <span class="tok-kw">continue</span> :start_over;</span>
<span class="line" id="L684">                    }</span>
<span class="line" id="L685"></span>
<span class="line" id="L686">                    <span class="tok-kw">const</span> entry_kind: Entry.Kind = <span class="tok-kw">switch</span> (linux_entry.d_type) {</span>
<span class="line" id="L687">                        linux.DT.BLK =&gt; .block_device,</span>
<span class="line" id="L688">                        linux.DT.CHR =&gt; .character_device,</span>
<span class="line" id="L689">                        linux.DT.DIR =&gt; .directory,</span>
<span class="line" id="L690">                        linux.DT.FIFO =&gt; .named_pipe,</span>
<span class="line" id="L691">                        linux.DT.LNK =&gt; .sym_link,</span>
<span class="line" id="L692">                        linux.DT.REG =&gt; .file,</span>
<span class="line" id="L693">                        linux.DT.SOCK =&gt; .unix_domain_socket,</span>
<span class="line" id="L694">                        <span class="tok-kw">else</span> =&gt; .unknown,</span>
<span class="line" id="L695">                    };</span>
<span class="line" id="L696">                    <span class="tok-kw">return</span> Entry{</span>
<span class="line" id="L697">                        .name = name,</span>
<span class="line" id="L698">                        .kind = entry_kind,</span>
<span class="line" id="L699">                    };</span>
<span class="line" id="L700">                }</span>
<span class="line" id="L701">            }</span>
<span class="line" id="L702"></span>
<span class="line" id="L703">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *Self) <span class="tok-type">void</span> {</span>
<span class="line" id="L704">                self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L705">                self.end_index = <span class="tok-number">0</span>;</span>
<span class="line" id="L706">                self.first_iter = <span class="tok-null">true</span>;</span>
<span class="line" id="L707">            }</span>
<span class="line" id="L708">        },</span>
<span class="line" id="L709">        .windows =&gt; <span class="tok-kw">struct</span> {</span>
<span class="line" id="L710">            dir: Dir,</span>
<span class="line" id="L711">            buf: [<span class="tok-number">1024</span>]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(os.windows.FILE_BOTH_DIR_INFORMATION)),</span>
<span class="line" id="L712">            index: <span class="tok-type">usize</span>,</span>
<span class="line" id="L713">            end_index: <span class="tok-type">usize</span>,</span>
<span class="line" id="L714">            first_iter: <span class="tok-type">bool</span>,</span>
<span class="line" id="L715">            name_data: [MAX_NAME_BYTES]<span class="tok-type">u8</span>,</span>
<span class="line" id="L716"></span>
<span class="line" id="L717">            <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L718"></span>
<span class="line" id="L719">            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = IteratorError;</span>
<span class="line" id="L720"></span>
<span class="line" id="L721">            <span class="tok-comment">/// Memory such as file names referenced in this returned entry becomes invalid</span></span>
<span class="line" id="L722">            <span class="tok-comment">/// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.</span></span>
<span class="line" id="L723">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *Self) Error!?Entry {</span>
<span class="line" id="L724">                <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L725">                    <span class="tok-kw">const</span> w = os.windows;</span>
<span class="line" id="L726">                    <span class="tok-kw">if</span> (self.index &gt;= self.end_index) {</span>
<span class="line" id="L727">                        <span class="tok-kw">var</span> io: w.IO_STATUS_BLOCK = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L728">                        <span class="tok-kw">const</span> rc = w.ntdll.NtQueryDirectoryFile(</span>
<span class="line" id="L729">                            self.dir.fd,</span>
<span class="line" id="L730">                            <span class="tok-null">null</span>,</span>
<span class="line" id="L731">                            <span class="tok-null">null</span>,</span>
<span class="line" id="L732">                            <span class="tok-null">null</span>,</span>
<span class="line" id="L733">                            &amp;io,</span>
<span class="line" id="L734">                            &amp;self.buf,</span>
<span class="line" id="L735">                            self.buf.len,</span>
<span class="line" id="L736">                            .FileBothDirectoryInformation,</span>
<span class="line" id="L737">                            w.FALSE,</span>
<span class="line" id="L738">                            <span class="tok-null">null</span>,</span>
<span class="line" id="L739">                            <span class="tok-kw">if</span> (self.first_iter) <span class="tok-builtin">@as</span>(w.BOOLEAN, w.TRUE) <span class="tok-kw">else</span> <span class="tok-builtin">@as</span>(w.BOOLEAN, w.FALSE),</span>
<span class="line" id="L740">                        );</span>
<span class="line" id="L741">                        self.first_iter = <span class="tok-null">false</span>;</span>
<span class="line" id="L742">                        <span class="tok-kw">if</span> (io.Information == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L743">                        self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L744">                        self.end_index = io.Information;</span>
<span class="line" id="L745">                        <span class="tok-kw">switch</span> (rc) {</span>
<span class="line" id="L746">                            .SUCCESS =&gt; {},</span>
<span class="line" id="L747">                            .ACCESS_DENIED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied, <span class="tok-comment">// Double-check that the Dir was opened with iteration ability</span>
</span>
<span class="line" id="L748"></span>
<span class="line" id="L749">                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> w.unexpectedStatus(rc),</span>
<span class="line" id="L750">                        }</span>
<span class="line" id="L751">                    }</span>
<span class="line" id="L752"></span>
<span class="line" id="L753">                    <span class="tok-kw">const</span> dir_info: *w.FILE_BOTH_DIR_INFORMATION = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;self.buf[self.index]));</span>
<span class="line" id="L754">                    <span class="tok-kw">if</span> (dir_info.NextEntryOffset != <span class="tok-number">0</span>) {</span>
<span class="line" id="L755">                        self.index += dir_info.NextEntryOffset;</span>
<span class="line" id="L756">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L757">                        self.index = self.buf.len;</span>
<span class="line" id="L758">                    }</span>
<span class="line" id="L759"></span>
<span class="line" id="L760">                    <span class="tok-kw">const</span> name_utf16le = <span class="tok-builtin">@as</span>([*]<span class="tok-type">u16</span>, <span class="tok-builtin">@ptrCast</span>(&amp;dir_info.FileName))[<span class="tok-number">0</span> .. dir_info.FileNameLength / <span class="tok-number">2</span>];</span>
<span class="line" id="L761"></span>
<span class="line" id="L762">                    <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u16</span>, name_utf16le, &amp;[_]<span class="tok-type">u16</span>{<span class="tok-str">'.'</span>}) <span class="tok-kw">or</span> mem.eql(<span class="tok-type">u16</span>, name_utf16le, &amp;[_]<span class="tok-type">u16</span>{ <span class="tok-str">'.'</span>, <span class="tok-str">'.'</span> }))</span>
<span class="line" id="L763">                        <span class="tok-kw">continue</span>;</span>
<span class="line" id="L764">                    <span class="tok-comment">// Trust that Windows gives us valid UTF-16LE</span>
</span>
<span class="line" id="L765">                    <span class="tok-kw">const</span> name_utf8_len = std.unicode.utf16leToUtf8(self.name_data[<span class="tok-number">0</span>..], name_utf16le) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L766">                    <span class="tok-kw">const</span> name_utf8 = self.name_data[<span class="tok-number">0</span>..name_utf8_len];</span>
<span class="line" id="L767">                    <span class="tok-kw">const</span> kind: Entry.Kind = blk: {</span>
<span class="line" id="L768">                        <span class="tok-kw">const</span> attrs = dir_info.FileAttributes;</span>
<span class="line" id="L769">                        <span class="tok-kw">if</span> (attrs &amp; w.FILE_ATTRIBUTE_DIRECTORY != <span class="tok-number">0</span>) <span class="tok-kw">break</span> :blk .directory;</span>
<span class="line" id="L770">                        <span class="tok-kw">if</span> (attrs &amp; w.FILE_ATTRIBUTE_REPARSE_POINT != <span class="tok-number">0</span>) <span class="tok-kw">break</span> :blk .sym_link;</span>
<span class="line" id="L771">                        <span class="tok-kw">break</span> :blk .file;</span>
<span class="line" id="L772">                    };</span>
<span class="line" id="L773">                    <span class="tok-kw">return</span> Entry{</span>
<span class="line" id="L774">                        .name = name_utf8,</span>
<span class="line" id="L775">                        .kind = kind,</span>
<span class="line" id="L776">                    };</span>
<span class="line" id="L777">                }</span>
<span class="line" id="L778">            }</span>
<span class="line" id="L779"></span>
<span class="line" id="L780">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *Self) <span class="tok-type">void</span> {</span>
<span class="line" id="L781">                self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L782">                self.end_index = <span class="tok-number">0</span>;</span>
<span class="line" id="L783">                self.first_iter = <span class="tok-null">true</span>;</span>
<span class="line" id="L784">            }</span>
<span class="line" id="L785">        },</span>
<span class="line" id="L786">        .wasi =&gt; <span class="tok-kw">struct</span> {</span>
<span class="line" id="L787">            dir: Dir,</span>
<span class="line" id="L788">            buf: [<span class="tok-number">1024</span>]<span class="tok-type">u8</span>, <span class="tok-comment">// TODO align(@alignOf(os.wasi.dirent_t)),</span>
</span>
<span class="line" id="L789">            cookie: <span class="tok-type">u64</span>,</span>
<span class="line" id="L790">            index: <span class="tok-type">usize</span>,</span>
<span class="line" id="L791">            end_index: <span class="tok-type">usize</span>,</span>
<span class="line" id="L792"></span>
<span class="line" id="L793">            <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L794"></span>
<span class="line" id="L795">            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = IteratorError;</span>
<span class="line" id="L796"></span>
<span class="line" id="L797">            <span class="tok-comment">/// Memory such as file names referenced in this returned entry becomes invalid</span></span>
<span class="line" id="L798">            <span class="tok-comment">/// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.</span></span>
<span class="line" id="L799">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *Self) Error!?Entry {</span>
<span class="line" id="L800">                <span class="tok-kw">return</span> self.nextWasi() <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L801">                    <span class="tok-comment">// To be consistent across platforms, iteration ends if the directory being iterated is deleted during iteration.</span>
</span>
<span class="line" id="L802">                    <span class="tok-comment">// This matches the behavior of non-Linux UNIX platforms.</span>
</span>
<span class="line" id="L803">                    <span class="tok-kw">error</span>.DirNotFound =&gt; <span class="tok-null">null</span>,</span>
<span class="line" id="L804">                    <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L805">                };</span>
<span class="line" id="L806">            }</span>
<span class="line" id="L807"></span>
<span class="line" id="L808">            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ErrorWasi = <span class="tok-kw">error</span>{DirNotFound} || IteratorError;</span>
<span class="line" id="L809"></span>
<span class="line" id="L810">            <span class="tok-comment">/// Implementation of `next` that can return platform-dependent errors depending on the host platform.</span></span>
<span class="line" id="L811">            <span class="tok-comment">/// When the host platform is Linux, `error.DirNotFound` can be returned if the directory being</span></span>
<span class="line" id="L812">            <span class="tok-comment">/// iterated was deleted during iteration.</span></span>
<span class="line" id="L813">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextWasi</span>(self: *Self) ErrorWasi!?Entry {</span>
<span class="line" id="L814">                <span class="tok-comment">// We intentinally use fd_readdir even when linked with libc,</span>
</span>
<span class="line" id="L815">                <span class="tok-comment">// since its implementation is exactly the same as below,</span>
</span>
<span class="line" id="L816">                <span class="tok-comment">// and we avoid the code complexity here.</span>
</span>
<span class="line" id="L817">                <span class="tok-kw">const</span> w = os.wasi;</span>
<span class="line" id="L818">                start_over: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L819">                    <span class="tok-comment">// According to the WASI spec, the last entry might be truncated,</span>
</span>
<span class="line" id="L820">                    <span class="tok-comment">// so we need to check if the left buffer contains the whole dirent.</span>
</span>
<span class="line" id="L821">                    <span class="tok-kw">if</span> (self.end_index - self.index &lt; <span class="tok-builtin">@sizeOf</span>(w.dirent_t)) {</span>
<span class="line" id="L822">                        <span class="tok-kw">var</span> bufused: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L823">                        <span class="tok-kw">switch</span> (w.fd_readdir(self.dir.fd, &amp;self.buf, self.buf.len, self.cookie, &amp;bufused)) {</span>
<span class="line" id="L824">                            .SUCCESS =&gt; {},</span>
<span class="line" id="L825">                            .BADF =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Dir is invalid or was opened without iteration ability</span>
</span>
<span class="line" id="L826">                            .FAULT =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L827">                            .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L828">                            .INVAL =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L829">                            .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DirNotFound, <span class="tok-comment">// The directory being iterated was deleted during iteration.</span>
</span>
<span class="line" id="L830">                            .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L831">                            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> os.unexpectedErrno(err),</span>
<span class="line" id="L832">                        }</span>
<span class="line" id="L833">                        <span class="tok-kw">if</span> (bufused == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L834">                        self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L835">                        self.end_index = bufused;</span>
<span class="line" id="L836">                    }</span>
<span class="line" id="L837">                    <span class="tok-kw">const</span> entry = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) w.dirent_t, <span class="tok-builtin">@ptrCast</span>(&amp;self.buf[self.index]));</span>
<span class="line" id="L838">                    <span class="tok-kw">const</span> entry_size = <span class="tok-builtin">@sizeOf</span>(w.dirent_t);</span>
<span class="line" id="L839">                    <span class="tok-kw">const</span> name_index = self.index + entry_size;</span>
<span class="line" id="L840">                    <span class="tok-kw">if</span> (name_index + entry.d_namlen &gt; self.end_index) {</span>
<span class="line" id="L841">                        <span class="tok-comment">// This case, the name is truncated, so we need to call readdir to store the entire name.</span>
</span>
<span class="line" id="L842">                        self.end_index = self.index; <span class="tok-comment">// Force fd_readdir in the next loop.</span>
</span>
<span class="line" id="L843">                        <span class="tok-kw">continue</span> :start_over;</span>
<span class="line" id="L844">                    }</span>
<span class="line" id="L845">                    <span class="tok-kw">const</span> name = self.buf[name_index .. name_index + entry.d_namlen];</span>
<span class="line" id="L846"></span>
<span class="line" id="L847">                    <span class="tok-kw">const</span> next_index = name_index + entry.d_namlen;</span>
<span class="line" id="L848">                    self.index = next_index;</span>
<span class="line" id="L849">                    self.cookie = entry.d_next;</span>
<span class="line" id="L850"></span>
<span class="line" id="L851">                    <span class="tok-comment">// skip . and .. entries</span>
</span>
<span class="line" id="L852">                    <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>) <span class="tok-kw">or</span> mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;..&quot;</span>)) {</span>
<span class="line" id="L853">                        <span class="tok-kw">continue</span> :start_over;</span>
<span class="line" id="L854">                    }</span>
<span class="line" id="L855"></span>
<span class="line" id="L856">                    <span class="tok-kw">const</span> entry_kind: Entry.Kind = <span class="tok-kw">switch</span> (entry.d_type) {</span>
<span class="line" id="L857">                        .BLOCK_DEVICE =&gt; .block_device,</span>
<span class="line" id="L858">                        .CHARACTER_DEVICE =&gt; .character_device,</span>
<span class="line" id="L859">                        .DIRECTORY =&gt; .directory,</span>
<span class="line" id="L860">                        .SYMBOLIC_LINK =&gt; .sym_link,</span>
<span class="line" id="L861">                        .REGULAR_FILE =&gt; .file,</span>
<span class="line" id="L862">                        .SOCKET_STREAM, .SOCKET_DGRAM =&gt; .unix_domain_socket,</span>
<span class="line" id="L863">                        <span class="tok-kw">else</span> =&gt; .unknown,</span>
<span class="line" id="L864">                    };</span>
<span class="line" id="L865">                    <span class="tok-kw">return</span> Entry{</span>
<span class="line" id="L866">                        .name = name,</span>
<span class="line" id="L867">                        .kind = entry_kind,</span>
<span class="line" id="L868">                    };</span>
<span class="line" id="L869">                }</span>
<span class="line" id="L870">            }</span>
<span class="line" id="L871"></span>
<span class="line" id="L872">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *Self) <span class="tok-type">void</span> {</span>
<span class="line" id="L873">                self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L874">                self.end_index = <span class="tok-number">0</span>;</span>
<span class="line" id="L875">                self.cookie = os.wasi.DIRCOOKIE_START;</span>
<span class="line" id="L876">            }</span>
<span class="line" id="L877">        },</span>
<span class="line" id="L878">        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unimplemented&quot;</span>),</span>
<span class="line" id="L879">    };</span>
<span class="line" id="L880"></span>
<span class="line" id="L881">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterate</span>(self: IterableDir) Iterator {</span>
<span class="line" id="L882">        <span class="tok-kw">return</span> self.iterateImpl(<span class="tok-null">true</span>);</span>
<span class="line" id="L883">    }</span>
<span class="line" id="L884"></span>
<span class="line" id="L885">    <span class="tok-comment">/// Like `iterate`, but will not reset the directory cursor before the first</span></span>
<span class="line" id="L886">    <span class="tok-comment">/// iteration. This should only be used in cases where it is known that the</span></span>
<span class="line" id="L887">    <span class="tok-comment">/// `IterableDir` has not had its cursor modified yet (e.g. it was just opened).</span></span>
<span class="line" id="L888">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterateAssumeFirstIteration</span>(self: IterableDir) Iterator {</span>
<span class="line" id="L889">        <span class="tok-kw">return</span> self.iterateImpl(<span class="tok-null">false</span>);</span>
<span class="line" id="L890">    }</span>
<span class="line" id="L891"></span>
<span class="line" id="L892">    <span class="tok-kw">fn</span> <span class="tok-fn">iterateImpl</span>(self: IterableDir, first_iter_start_value: <span class="tok-type">bool</span>) Iterator {</span>
<span class="line" id="L893">        <span class="tok-kw">switch</span> (builtin.os.tag) {</span>
<span class="line" id="L894">            .macos,</span>
<span class="line" id="L895">            .ios,</span>
<span class="line" id="L896">            .freebsd,</span>
<span class="line" id="L897">            .netbsd,</span>
<span class="line" id="L898">            .dragonfly,</span>
<span class="line" id="L899">            .openbsd,</span>
<span class="line" id="L900">            .solaris,</span>
<span class="line" id="L901">            =&gt; <span class="tok-kw">return</span> Iterator{</span>
<span class="line" id="L902">                .dir = self.dir,</span>
<span class="line" id="L903">                .seek = <span class="tok-number">0</span>,</span>
<span class="line" id="L904">                .index = <span class="tok-number">0</span>,</span>
<span class="line" id="L905">                .end_index = <span class="tok-number">0</span>,</span>
<span class="line" id="L906">                .buf = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L907">                .first_iter = first_iter_start_value,</span>
<span class="line" id="L908">            },</span>
<span class="line" id="L909">            .linux, .haiku =&gt; <span class="tok-kw">return</span> Iterator{</span>
<span class="line" id="L910">                .dir = self.dir,</span>
<span class="line" id="L911">                .index = <span class="tok-number">0</span>,</span>
<span class="line" id="L912">                .end_index = <span class="tok-number">0</span>,</span>
<span class="line" id="L913">                .buf = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L914">                .first_iter = first_iter_start_value,</span>
<span class="line" id="L915">            },</span>
<span class="line" id="L916">            .windows =&gt; <span class="tok-kw">return</span> Iterator{</span>
<span class="line" id="L917">                .dir = self.dir,</span>
<span class="line" id="L918">                .index = <span class="tok-number">0</span>,</span>
<span class="line" id="L919">                .end_index = <span class="tok-number">0</span>,</span>
<span class="line" id="L920">                .first_iter = first_iter_start_value,</span>
<span class="line" id="L921">                .buf = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L922">                .name_data = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L923">            },</span>
<span class="line" id="L924">            .wasi =&gt; <span class="tok-kw">return</span> Iterator{</span>
<span class="line" id="L925">                .dir = self.dir,</span>
<span class="line" id="L926">                .cookie = os.wasi.DIRCOOKIE_START,</span>
<span class="line" id="L927">                .index = <span class="tok-number">0</span>,</span>
<span class="line" id="L928">                .end_index = <span class="tok-number">0</span>,</span>
<span class="line" id="L929">                .buf = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L930">            },</span>
<span class="line" id="L931">            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unimplemented&quot;</span>),</span>
<span class="line" id="L932">        }</span>
<span class="line" id="L933">    }</span>
<span class="line" id="L934"></span>
<span class="line" id="L935">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Walker = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L936">        stack: std.ArrayList(StackItem),</span>
<span class="line" id="L937">        name_buffer: std.ArrayList(<span class="tok-type">u8</span>),</span>
<span class="line" id="L938"></span>
<span class="line" id="L939">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> WalkerEntry = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L940">            <span class="tok-comment">/// The containing directory. This can be used to operate directly on `basename`</span></span>
<span class="line" id="L941">            <span class="tok-comment">/// rather than `path`, avoiding `error.NameTooLong` for deeply nested paths.</span></span>
<span class="line" id="L942">            <span class="tok-comment">/// The directory remains open until `next` or `deinit` is called.</span></span>
<span class="line" id="L943">            dir: Dir,</span>
<span class="line" id="L944">            basename: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L945">            path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L946">            kind: IterableDir.Entry.Kind,</span>
<span class="line" id="L947">        };</span>
<span class="line" id="L948"></span>
<span class="line" id="L949">        <span class="tok-kw">const</span> StackItem = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L950">            iter: IterableDir.Iterator,</span>
<span class="line" id="L951">            dirname_len: <span class="tok-type">usize</span>,</span>
<span class="line" id="L952">        };</span>
<span class="line" id="L953"></span>
<span class="line" id="L954">        <span class="tok-comment">/// After each call to this function, and on deinit(), the memory returned</span></span>
<span class="line" id="L955">        <span class="tok-comment">/// from this function becomes invalid. A copy must be made in order to keep</span></span>
<span class="line" id="L956">        <span class="tok-comment">/// a reference to the path.</span></span>
<span class="line" id="L957">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *Walker) !?WalkerEntry {</span>
<span class="line" id="L958">            <span class="tok-kw">while</span> (self.stack.items.len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L959">                <span class="tok-comment">// `top` and `containing` become invalid after appending to `self.stack`</span>
</span>
<span class="line" id="L960">                <span class="tok-kw">var</span> top = &amp;self.stack.items[self.stack.items.len - <span class="tok-number">1</span>];</span>
<span class="line" id="L961">                <span class="tok-kw">var</span> containing = top;</span>
<span class="line" id="L962">                <span class="tok-kw">var</span> dirname_len = top.dirname_len;</span>
<span class="line" id="L963">                <span class="tok-kw">if</span> (top.iter.next() <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L964">                    <span class="tok-comment">// If we get an error, then we want the user to be able to continue</span>
</span>
<span class="line" id="L965">                    <span class="tok-comment">// walking if they want, which means that we need to pop the directory</span>
</span>
<span class="line" id="L966">                    <span class="tok-comment">// that errored from the stack. Otherwise, all future `next` calls would</span>
</span>
<span class="line" id="L967">                    <span class="tok-comment">// likely just fail with the same error.</span>
</span>
<span class="line" id="L968">                    <span class="tok-kw">var</span> item = self.stack.pop();</span>
<span class="line" id="L969">                    <span class="tok-kw">if</span> (self.stack.items.len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L970">                        item.iter.dir.close();</span>
<span class="line" id="L971">                    }</span>
<span class="line" id="L972">                    <span class="tok-kw">return</span> err;</span>
<span class="line" id="L973">                }) |base| {</span>
<span class="line" id="L974">                    self.name_buffer.shrinkRetainingCapacity(dirname_len);</span>
<span class="line" id="L975">                    <span class="tok-kw">if</span> (self.name_buffer.items.len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L976">                        <span class="tok-kw">try</span> self.name_buffer.append(path.sep);</span>
<span class="line" id="L977">                        dirname_len += <span class="tok-number">1</span>;</span>
<span class="line" id="L978">                    }</span>
<span class="line" id="L979">                    <span class="tok-kw">try</span> self.name_buffer.appendSlice(base.name);</span>
<span class="line" id="L980">                    <span class="tok-kw">if</span> (base.kind == .directory) {</span>
<span class="line" id="L981">                        <span class="tok-kw">var</span> new_dir = top.iter.dir.openIterableDir(base.name, .{}) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L982">                            <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// no path sep in base.name</span>
</span>
<span class="line" id="L983">                            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L984">                        };</span>
<span class="line" id="L985">                        {</span>
<span class="line" id="L986">                            <span class="tok-kw">errdefer</span> new_dir.close();</span>
<span class="line" id="L987">                            <span class="tok-kw">try</span> self.stack.append(StackItem{</span>
<span class="line" id="L988">                                .iter = new_dir.iterateAssumeFirstIteration(),</span>
<span class="line" id="L989">                                .dirname_len = self.name_buffer.items.len,</span>
<span class="line" id="L990">                            });</span>
<span class="line" id="L991">                            top = &amp;self.stack.items[self.stack.items.len - <span class="tok-number">1</span>];</span>
<span class="line" id="L992">                            containing = &amp;self.stack.items[self.stack.items.len - <span class="tok-number">2</span>];</span>
<span class="line" id="L993">                        }</span>
<span class="line" id="L994">                    }</span>
<span class="line" id="L995">                    <span class="tok-kw">return</span> WalkerEntry{</span>
<span class="line" id="L996">                        .dir = containing.iter.dir,</span>
<span class="line" id="L997">                        .basename = self.name_buffer.items[dirname_len..],</span>
<span class="line" id="L998">                        .path = self.name_buffer.items,</span>
<span class="line" id="L999">                        .kind = base.kind,</span>
<span class="line" id="L1000">                    };</span>
<span class="line" id="L1001">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1002">                    <span class="tok-kw">var</span> item = self.stack.pop();</span>
<span class="line" id="L1003">                    <span class="tok-kw">if</span> (self.stack.items.len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L1004">                        item.iter.dir.close();</span>
<span class="line" id="L1005">                    }</span>
<span class="line" id="L1006">                }</span>
<span class="line" id="L1007">            }</span>
<span class="line" id="L1008">            <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1009">        }</span>
<span class="line" id="L1010"></span>
<span class="line" id="L1011">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *Walker) <span class="tok-type">void</span> {</span>
<span class="line" id="L1012">            <span class="tok-comment">// Close any remaining directories except the initial one (which is always at index 0)</span>
</span>
<span class="line" id="L1013">            <span class="tok-kw">if</span> (self.stack.items.len &gt; <span class="tok-number">1</span>) {</span>
<span class="line" id="L1014">                <span class="tok-kw">for</span> (self.stack.items[<span class="tok-number">1</span>..]) |*item| {</span>
<span class="line" id="L1015">                    item.iter.dir.close();</span>
<span class="line" id="L1016">                }</span>
<span class="line" id="L1017">            }</span>
<span class="line" id="L1018">            self.stack.deinit();</span>
<span class="line" id="L1019">            self.name_buffer.deinit();</span>
<span class="line" id="L1020">        }</span>
<span class="line" id="L1021">    };</span>
<span class="line" id="L1022"></span>
<span class="line" id="L1023">    <span class="tok-comment">/// Recursively iterates over a directory.</span></span>
<span class="line" id="L1024">    <span class="tok-comment">/// Must call `Walker.deinit` when done.</span></span>
<span class="line" id="L1025">    <span class="tok-comment">/// The order of returned file system entries is undefined.</span></span>
<span class="line" id="L1026">    <span class="tok-comment">/// `self` will not be closed after walking it.</span></span>
<span class="line" id="L1027">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">walk</span>(self: IterableDir, allocator: Allocator) !Walker {</span>
<span class="line" id="L1028">        <span class="tok-kw">var</span> name_buffer = std.ArrayList(<span class="tok-type">u8</span>).init(allocator);</span>
<span class="line" id="L1029">        <span class="tok-kw">errdefer</span> name_buffer.deinit();</span>
<span class="line" id="L1030"></span>
<span class="line" id="L1031">        <span class="tok-kw">var</span> stack = std.ArrayList(Walker.StackItem).init(allocator);</span>
<span class="line" id="L1032">        <span class="tok-kw">errdefer</span> stack.deinit();</span>
<span class="line" id="L1033"></span>
<span class="line" id="L1034">        <span class="tok-kw">try</span> stack.append(Walker.StackItem{</span>
<span class="line" id="L1035">            .iter = self.iterate(),</span>
<span class="line" id="L1036">            .dirname_len = <span class="tok-number">0</span>,</span>
<span class="line" id="L1037">        });</span>
<span class="line" id="L1038"></span>
<span class="line" id="L1039">        <span class="tok-kw">return</span> Walker{</span>
<span class="line" id="L1040">            .stack = stack,</span>
<span class="line" id="L1041">            .name_buffer = name_buffer,</span>
<span class="line" id="L1042">        };</span>
<span class="line" id="L1043">    }</span>
<span class="line" id="L1044"></span>
<span class="line" id="L1045">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">close</span>(self: *IterableDir) <span class="tok-type">void</span> {</span>
<span class="line" id="L1046">        self.dir.close();</span>
<span class="line" id="L1047">        self.* = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1048">    }</span>
<span class="line" id="L1049"></span>
<span class="line" id="L1050">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ChmodError = File.ChmodError;</span>
<span class="line" id="L1051"></span>
<span class="line" id="L1052">    <span class="tok-comment">/// Changes the mode of the directory.</span></span>
<span class="line" id="L1053">    <span class="tok-comment">/// The process must have the correct privileges in order to do this</span></span>
<span class="line" id="L1054">    <span class="tok-comment">/// successfully, or must have the effective user ID matching the owner</span></span>
<span class="line" id="L1055">    <span class="tok-comment">/// of the directory.</span></span>
<span class="line" id="L1056">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chmod</span>(self: IterableDir, new_mode: File.Mode) ChmodError!<span class="tok-type">void</span> {</span>
<span class="line" id="L1057">        <span class="tok-kw">const</span> file: File = .{</span>
<span class="line" id="L1058">            .handle = self.dir.fd,</span>
<span class="line" id="L1059">            .capable_io_mode = .blocking,</span>
<span class="line" id="L1060">        };</span>
<span class="line" id="L1061">        <span class="tok-kw">try</span> file.chmod(new_mode);</span>
<span class="line" id="L1062">    }</span>
<span class="line" id="L1063"></span>
<span class="line" id="L1064">    <span class="tok-comment">/// Changes the owner and group of the directory.</span></span>
<span class="line" id="L1065">    <span class="tok-comment">/// The process must have the correct privileges in order to do this</span></span>
<span class="line" id="L1066">    <span class="tok-comment">/// successfully. The group may be changed by the owner of the directory to</span></span>
<span class="line" id="L1067">    <span class="tok-comment">/// any group of which the owner is a member. If the</span></span>
<span class="line" id="L1068">    <span class="tok-comment">/// owner or group is specified as `null`, the ID is not changed.</span></span>
<span class="line" id="L1069">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chown</span>(self: IterableDir, owner: ?File.Uid, group: ?File.Gid) ChownError!<span class="tok-type">void</span> {</span>
<span class="line" id="L1070">        <span class="tok-kw">const</span> file: File = .{</span>
<span class="line" id="L1071">            .handle = self.dir.fd,</span>
<span class="line" id="L1072">            .capable_io_mode = .blocking,</span>
<span class="line" id="L1073">        };</span>
<span class="line" id="L1074">        <span class="tok-kw">try</span> file.chown(owner, group);</span>
<span class="line" id="L1075">    }</span>
<span class="line" id="L1076"></span>
<span class="line" id="L1077">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ChownError = File.ChownError;</span>
<span class="line" id="L1078">};</span>
<span class="line" id="L1079"></span>
<span class="line" id="L1080"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Dir = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1081">    fd: os.fd_t,</span>
<span class="line" id="L1082"></span>
<span class="line" id="L1083">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> iterate = <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;only 'IterableDir' can be iterated; 'IterableDir' can be obtained with 'openIterableDir'&quot;</span>);</span>
<span class="line" id="L1084">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> walk = <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;only 'IterableDir' can be walked; 'IterableDir' can be obtained with 'openIterableDir'&quot;</span>);</span>
<span class="line" id="L1085">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> chmod = <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;only 'IterableDir' can have its mode changed; 'IterableDir' can be obtained with 'openIterableDir'&quot;</span>);</span>
<span class="line" id="L1086">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> chown = <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;only 'IterableDir' can have its owner changed; 'IterableDir' can be obtained with 'openIterableDir'&quot;</span>);</span>
<span class="line" id="L1087"></span>
<span class="line" id="L1088">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> OpenError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L1089">        FileNotFound,</span>
<span class="line" id="L1090">        NotDir,</span>
<span class="line" id="L1091">        InvalidHandle,</span>
<span class="line" id="L1092">        AccessDenied,</span>
<span class="line" id="L1093">        SymLinkLoop,</span>
<span class="line" id="L1094">        ProcessFdQuotaExceeded,</span>
<span class="line" id="L1095">        NameTooLong,</span>
<span class="line" id="L1096">        SystemFdQuotaExceeded,</span>
<span class="line" id="L1097">        NoDevice,</span>
<span class="line" id="L1098">        SystemResources,</span>
<span class="line" id="L1099">        InvalidUtf8,</span>
<span class="line" id="L1100">        BadPathName,</span>
<span class="line" id="L1101">        DeviceBusy,</span>
<span class="line" id="L1102">        <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span></span>
<span class="line" id="L1103">        NetworkNotFound,</span>
<span class="line" id="L1104">    } || os.UnexpectedError;</span>
<span class="line" id="L1105"></span>
<span class="line" id="L1106">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">close</span>(self: *Dir) <span class="tok-type">void</span> {</span>
<span class="line" id="L1107">        <span class="tok-kw">if</span> (need_async_thread) {</span>
<span class="line" id="L1108">            std.event.Loop.instance.?.close(self.fd);</span>
<span class="line" id="L1109">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1110">            os.close(self.fd);</span>
<span class="line" id="L1111">        }</span>
<span class="line" id="L1112">        self.* = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1113">    }</span>
<span class="line" id="L1114"></span>
<span class="line" id="L1115">    <span class="tok-comment">/// Opens a file for reading or writing, without attempting to create a new file.</span></span>
<span class="line" id="L1116">    <span class="tok-comment">/// To create a new file, see `createFile`.</span></span>
<span class="line" id="L1117">    <span class="tok-comment">/// Call `File.close` to release the resource.</span></span>
<span class="line" id="L1118">    <span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span></span>
<span class="line" id="L1119">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openFile</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: File.OpenFlags) File.OpenError!File {</span>
<span class="line" id="L1120">        <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L1121">            <span class="tok-kw">const</span> path_w = <span class="tok-kw">try</span> os.windows.sliceToPrefixedFileW(sub_path);</span>
<span class="line" id="L1122">            <span class="tok-kw">return</span> self.openFileW(path_w.span(), flags);</span>
<span class="line" id="L1123">        }</span>
<span class="line" id="L1124">        <span class="tok-kw">if</span> (builtin.os.tag == .wasi <span class="tok-kw">and</span> !builtin.link_libc) {</span>
<span class="line" id="L1125">            <span class="tok-kw">return</span> self.openFileWasi(sub_path, flags);</span>
<span class="line" id="L1126">        }</span>
<span class="line" id="L1127">        <span class="tok-kw">const</span> path_c = <span class="tok-kw">try</span> os.toPosixPath(sub_path);</span>
<span class="line" id="L1128">        <span class="tok-kw">return</span> self.openFileZ(&amp;path_c, flags);</span>
<span class="line" id="L1129">    }</span>
<span class="line" id="L1130"></span>
<span class="line" id="L1131">    <span class="tok-comment">/// Same as `openFile` but WASI only.</span></span>
<span class="line" id="L1132">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openFileWasi</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: File.OpenFlags) File.OpenError!File {</span>
<span class="line" id="L1133">        <span class="tok-kw">const</span> w = os.wasi;</span>
<span class="line" id="L1134">        <span class="tok-kw">var</span> fdflags: w.fdflags_t = <span class="tok-number">0x0</span>;</span>
<span class="line" id="L1135">        <span class="tok-kw">var</span> base: w.rights_t = <span class="tok-number">0x0</span>;</span>
<span class="line" id="L1136">        <span class="tok-kw">if</span> (flags.isRead()) {</span>
<span class="line" id="L1137">            base |= w.RIGHT.FD_READ | w.RIGHT.FD_TELL | w.RIGHT.FD_SEEK | w.RIGHT.FD_FILESTAT_GET;</span>
<span class="line" id="L1138">        }</span>
<span class="line" id="L1139">        <span class="tok-kw">if</span> (flags.isWrite()) {</span>
<span class="line" id="L1140">            fdflags |= w.FDFLAG.APPEND;</span>
<span class="line" id="L1141">            base |= w.RIGHT.FD_WRITE |</span>
<span class="line" id="L1142">                w.RIGHT.FD_TELL |</span>
<span class="line" id="L1143">                w.RIGHT.FD_SEEK |</span>
<span class="line" id="L1144">                w.RIGHT.FD_DATASYNC |</span>
<span class="line" id="L1145">                w.RIGHT.FD_FDSTAT_SET_FLAGS |</span>
<span class="line" id="L1146">                w.RIGHT.FD_SYNC |</span>
<span class="line" id="L1147">                w.RIGHT.FD_ALLOCATE |</span>
<span class="line" id="L1148">                w.RIGHT.FD_ADVISE |</span>
<span class="line" id="L1149">                w.RIGHT.FD_FILESTAT_SET_TIMES |</span>
<span class="line" id="L1150">                w.RIGHT.FD_FILESTAT_SET_SIZE;</span>
<span class="line" id="L1151">        }</span>
<span class="line" id="L1152">        <span class="tok-kw">const</span> fd = <span class="tok-kw">try</span> os.openatWasi(self.fd, sub_path, <span class="tok-number">0x0</span>, <span class="tok-number">0x0</span>, fdflags, base, <span class="tok-number">0x0</span>);</span>
<span class="line" id="L1153">        <span class="tok-kw">return</span> File{ .handle = fd };</span>
<span class="line" id="L1154">    }</span>
<span class="line" id="L1155"></span>
<span class="line" id="L1156">    <span class="tok-comment">/// Same as `openFile` but the path parameter is null-terminated.</span></span>
<span class="line" id="L1157">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openFileZ</span>(self: Dir, sub_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: File.OpenFlags) File.OpenError!File {</span>
<span class="line" id="L1158">        <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L1159">            <span class="tok-kw">const</span> path_w = <span class="tok-kw">try</span> os.windows.cStrToPrefixedFileW(sub_path);</span>
<span class="line" id="L1160">            <span class="tok-kw">return</span> self.openFileW(path_w.span(), flags);</span>
<span class="line" id="L1161">        }</span>
<span class="line" id="L1162"></span>
<span class="line" id="L1163">        <span class="tok-kw">var</span> os_flags: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1164">        <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(os.O, <span class="tok-str">&quot;CLOEXEC&quot;</span>)) os_flags = os.O.CLOEXEC;</span>
<span class="line" id="L1165"></span>
<span class="line" id="L1166">        <span class="tok-comment">// Use the O locking flags if the os supports them to acquire the lock</span>
</span>
<span class="line" id="L1167">        <span class="tok-comment">// atomically.</span>
</span>
<span class="line" id="L1168">        <span class="tok-kw">const</span> has_flock_open_flags = <span class="tok-builtin">@hasDecl</span>(os.O, <span class="tok-str">&quot;EXLOCK&quot;</span>);</span>
<span class="line" id="L1169">        <span class="tok-kw">if</span> (has_flock_open_flags) {</span>
<span class="line" id="L1170">            <span class="tok-comment">// Note that the O.NONBLOCK flag is removed after the openat() call</span>
</span>
<span class="line" id="L1171">            <span class="tok-comment">// is successful.</span>
</span>
<span class="line" id="L1172">            <span class="tok-kw">const</span> nonblocking_lock_flag: <span class="tok-type">u32</span> = <span class="tok-kw">if</span> (flags.lock_nonblocking)</span>
<span class="line" id="L1173">                os.O.NONBLOCK</span>
<span class="line" id="L1174">            <span class="tok-kw">else</span></span>
<span class="line" id="L1175">                <span class="tok-number">0</span>;</span>
<span class="line" id="L1176">            os_flags |= <span class="tok-kw">switch</span> (flags.lock) {</span>
<span class="line" id="L1177">                .none =&gt; <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>),</span>
<span class="line" id="L1178">                .shared =&gt; os.O.SHLOCK | nonblocking_lock_flag,</span>
<span class="line" id="L1179">                .exclusive =&gt; os.O.EXLOCK | nonblocking_lock_flag,</span>
<span class="line" id="L1180">            };</span>
<span class="line" id="L1181">        }</span>
<span class="line" id="L1182">        <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(os.O, <span class="tok-str">&quot;LARGEFILE&quot;</span>)) {</span>
<span class="line" id="L1183">            os_flags |= os.O.LARGEFILE;</span>
<span class="line" id="L1184">        }</span>
<span class="line" id="L1185">        <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(os.O, <span class="tok-str">&quot;NOCTTY&quot;</span>) <span class="tok-kw">and</span> !flags.allow_ctty) {</span>
<span class="line" id="L1186">            os_flags |= os.O.NOCTTY;</span>
<span class="line" id="L1187">        }</span>
<span class="line" id="L1188">        os_flags |= <span class="tok-kw">switch</span> (flags.mode) {</span>
<span class="line" id="L1189">            .read_only =&gt; <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, os.O.RDONLY),</span>
<span class="line" id="L1190">            .write_only =&gt; <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, os.O.WRONLY),</span>
<span class="line" id="L1191">            .read_write =&gt; <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, os.O.RDWR),</span>
<span class="line" id="L1192">        };</span>
<span class="line" id="L1193">        <span class="tok-kw">const</span> fd = <span class="tok-kw">if</span> (flags.intended_io_mode != .blocking)</span>
<span class="line" id="L1194">            <span class="tok-kw">try</span> std.event.Loop.instance.?.openatZ(self.fd, sub_path, os_flags, <span class="tok-number">0</span>)</span>
<span class="line" id="L1195">        <span class="tok-kw">else</span></span>
<span class="line" id="L1196">            <span class="tok-kw">try</span> os.openatZ(self.fd, sub_path, os_flags, <span class="tok-number">0</span>);</span>
<span class="line" id="L1197">        <span class="tok-kw">errdefer</span> os.close(fd);</span>
<span class="line" id="L1198"></span>
<span class="line" id="L1199">        <span class="tok-comment">// WASI doesn't have os.flock so we intetinally check OS prior to the inner if block</span>
</span>
<span class="line" id="L1200">        <span class="tok-comment">// since it is not compiltime-known and we need to avoid undefined symbol in Wasm.</span>
</span>
<span class="line" id="L1201">        <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(os.system, <span class="tok-str">&quot;LOCK&quot;</span>) <span class="tok-kw">and</span> builtin.target.os.tag != .wasi) {</span>
<span class="line" id="L1202">            <span class="tok-kw">if</span> (!has_flock_open_flags <span class="tok-kw">and</span> flags.lock != .none) {</span>
<span class="line" id="L1203">                <span class="tok-comment">// TODO: integrate async I/O</span>
</span>
<span class="line" id="L1204">                <span class="tok-kw">const</span> lock_nonblocking = <span class="tok-kw">if</span> (flags.lock_nonblocking) os.LOCK.NB <span class="tok-kw">else</span> <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L1205">                <span class="tok-kw">try</span> os.flock(fd, <span class="tok-kw">switch</span> (flags.lock) {</span>
<span class="line" id="L1206">                    .none =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1207">                    .shared =&gt; os.LOCK.SH | lock_nonblocking,</span>
<span class="line" id="L1208">                    .exclusive =&gt; os.LOCK.EX | lock_nonblocking,</span>
<span class="line" id="L1209">                });</span>
<span class="line" id="L1210">            }</span>
<span class="line" id="L1211">        }</span>
<span class="line" id="L1212"></span>
<span class="line" id="L1213">        <span class="tok-kw">if</span> (has_flock_open_flags <span class="tok-kw">and</span> flags.lock_nonblocking) {</span>
<span class="line" id="L1214">            <span class="tok-kw">var</span> fl_flags = os.fcntl(fd, os.F.GETFL, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1215">                <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1216">                <span class="tok-kw">error</span>.Locked =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1217">                <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1218">                <span class="tok-kw">error</span>.DeadLock =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1219">                <span class="tok-kw">error</span>.LockedRegionLimitExceeded =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1220">                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1221">            };</span>
<span class="line" id="L1222">            fl_flags &amp;= ~<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, os.O.NONBLOCK);</span>
<span class="line" id="L1223">            _ = os.fcntl(fd, os.F.SETFL, fl_flags) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1224">                <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1225">                <span class="tok-kw">error</span>.Locked =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1226">                <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1227">                <span class="tok-kw">error</span>.DeadLock =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1228">                <span class="tok-kw">error</span>.LockedRegionLimitExceeded =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1229">                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1230">            };</span>
<span class="line" id="L1231">        }</span>
<span class="line" id="L1232"></span>
<span class="line" id="L1233">        <span class="tok-kw">return</span> File{</span>
<span class="line" id="L1234">            .handle = fd,</span>
<span class="line" id="L1235">            .capable_io_mode = .blocking,</span>
<span class="line" id="L1236">            .intended_io_mode = flags.intended_io_mode,</span>
<span class="line" id="L1237">        };</span>
<span class="line" id="L1238">    }</span>
<span class="line" id="L1239"></span>
<span class="line" id="L1240">    <span class="tok-comment">/// Same as `openFile` but Windows-only and the path parameter is</span></span>
<span class="line" id="L1241">    <span class="tok-comment">/// [WTF-16](https://simonsapin.github.io/wtf-8/#potentially-ill-formed-utf-16) encoded.</span></span>
<span class="line" id="L1242">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openFileW</span>(self: Dir, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: File.OpenFlags) File.OpenError!File {</span>
<span class="line" id="L1243">        <span class="tok-kw">const</span> w = os.windows;</span>
<span class="line" id="L1244">        <span class="tok-kw">const</span> file: File = .{</span>
<span class="line" id="L1245">            .handle = <span class="tok-kw">try</span> w.OpenFile(sub_path_w, .{</span>
<span class="line" id="L1246">                .dir = self.fd,</span>
<span class="line" id="L1247">                .access_mask = w.SYNCHRONIZE |</span>
<span class="line" id="L1248">                    (<span class="tok-kw">if</span> (flags.isRead()) <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, w.GENERIC_READ) <span class="tok-kw">else</span> <span class="tok-number">0</span>) |</span>
<span class="line" id="L1249">                    (<span class="tok-kw">if</span> (flags.isWrite()) <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, w.GENERIC_WRITE) <span class="tok-kw">else</span> <span class="tok-number">0</span>),</span>
<span class="line" id="L1250">                .creation = w.FILE_OPEN,</span>
<span class="line" id="L1251">                .io_mode = flags.intended_io_mode,</span>
<span class="line" id="L1252">            }),</span>
<span class="line" id="L1253">            .capable_io_mode = std.io.default_mode,</span>
<span class="line" id="L1254">            .intended_io_mode = flags.intended_io_mode,</span>
<span class="line" id="L1255">        };</span>
<span class="line" id="L1256">        <span class="tok-kw">errdefer</span> file.close();</span>
<span class="line" id="L1257">        <span class="tok-kw">var</span> io: w.IO_STATUS_BLOCK = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1258">        <span class="tok-kw">const</span> range_off: w.LARGE_INTEGER = <span class="tok-number">0</span>;</span>
<span class="line" id="L1259">        <span class="tok-kw">const</span> range_len: w.LARGE_INTEGER = <span class="tok-number">1</span>;</span>
<span class="line" id="L1260">        <span class="tok-kw">const</span> exclusive = <span class="tok-kw">switch</span> (flags.lock) {</span>
<span class="line" id="L1261">            .none =&gt; <span class="tok-kw">return</span> file,</span>
<span class="line" id="L1262">            .shared =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L1263">            .exclusive =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L1264">        };</span>
<span class="line" id="L1265">        <span class="tok-kw">try</span> w.LockFile(</span>
<span class="line" id="L1266">            file.handle,</span>
<span class="line" id="L1267">            <span class="tok-null">null</span>,</span>
<span class="line" id="L1268">            <span class="tok-null">null</span>,</span>
<span class="line" id="L1269">            <span class="tok-null">null</span>,</span>
<span class="line" id="L1270">            &amp;io,</span>
<span class="line" id="L1271">            &amp;range_off,</span>
<span class="line" id="L1272">            &amp;range_len,</span>
<span class="line" id="L1273">            <span class="tok-null">null</span>,</span>
<span class="line" id="L1274">            <span class="tok-builtin">@intFromBool</span>(flags.lock_nonblocking),</span>
<span class="line" id="L1275">            <span class="tok-builtin">@intFromBool</span>(exclusive),</span>
<span class="line" id="L1276">        );</span>
<span class="line" id="L1277">        <span class="tok-kw">return</span> file;</span>
<span class="line" id="L1278">    }</span>
<span class="line" id="L1279"></span>
<span class="line" id="L1280">    <span class="tok-comment">/// Creates, opens, or overwrites a file with write access.</span></span>
<span class="line" id="L1281">    <span class="tok-comment">/// Call `File.close` on the result when done.</span></span>
<span class="line" id="L1282">    <span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span></span>
<span class="line" id="L1283">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createFile</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: File.CreateFlags) File.OpenError!File {</span>
<span class="line" id="L1284">        <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L1285">            <span class="tok-kw">const</span> path_w = <span class="tok-kw">try</span> os.windows.sliceToPrefixedFileW(sub_path);</span>
<span class="line" id="L1286">            <span class="tok-kw">return</span> self.createFileW(path_w.span(), flags);</span>
<span class="line" id="L1287">        }</span>
<span class="line" id="L1288">        <span class="tok-kw">if</span> (builtin.os.tag == .wasi <span class="tok-kw">and</span> !builtin.link_libc) {</span>
<span class="line" id="L1289">            <span class="tok-kw">return</span> self.createFileWasi(sub_path, flags);</span>
<span class="line" id="L1290">        }</span>
<span class="line" id="L1291">        <span class="tok-kw">const</span> path_c = <span class="tok-kw">try</span> os.toPosixPath(sub_path);</span>
<span class="line" id="L1292">        <span class="tok-kw">return</span> self.createFileZ(&amp;path_c, flags);</span>
<span class="line" id="L1293">    }</span>
<span class="line" id="L1294"></span>
<span class="line" id="L1295">    <span class="tok-comment">/// Same as `createFile` but WASI only.</span></span>
<span class="line" id="L1296">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createFileWasi</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: File.CreateFlags) File.OpenError!File {</span>
<span class="line" id="L1297">        <span class="tok-kw">const</span> w = os.wasi;</span>
<span class="line" id="L1298">        <span class="tok-kw">var</span> oflags = w.O.CREAT;</span>
<span class="line" id="L1299">        <span class="tok-kw">var</span> base: w.rights_t = w.RIGHT.FD_WRITE |</span>
<span class="line" id="L1300">            w.RIGHT.FD_DATASYNC |</span>
<span class="line" id="L1301">            w.RIGHT.FD_SEEK |</span>
<span class="line" id="L1302">            w.RIGHT.FD_TELL |</span>
<span class="line" id="L1303">            w.RIGHT.FD_FDSTAT_SET_FLAGS |</span>
<span class="line" id="L1304">            w.RIGHT.FD_SYNC |</span>
<span class="line" id="L1305">            w.RIGHT.FD_ALLOCATE |</span>
<span class="line" id="L1306">            w.RIGHT.FD_ADVISE |</span>
<span class="line" id="L1307">            w.RIGHT.FD_FILESTAT_SET_TIMES |</span>
<span class="line" id="L1308">            w.RIGHT.FD_FILESTAT_SET_SIZE |</span>
<span class="line" id="L1309">            w.RIGHT.FD_FILESTAT_GET;</span>
<span class="line" id="L1310">        <span class="tok-kw">if</span> (flags.read) {</span>
<span class="line" id="L1311">            base |= w.RIGHT.FD_READ;</span>
<span class="line" id="L1312">        }</span>
<span class="line" id="L1313">        <span class="tok-kw">if</span> (flags.truncate) {</span>
<span class="line" id="L1314">            oflags |= w.O.TRUNC;</span>
<span class="line" id="L1315">        }</span>
<span class="line" id="L1316">        <span class="tok-kw">if</span> (flags.exclusive) {</span>
<span class="line" id="L1317">            oflags |= w.O.EXCL;</span>
<span class="line" id="L1318">        }</span>
<span class="line" id="L1319">        <span class="tok-kw">const</span> fd = <span class="tok-kw">try</span> os.openatWasi(self.fd, sub_path, <span class="tok-number">0x0</span>, oflags, <span class="tok-number">0x0</span>, base, <span class="tok-number">0x0</span>);</span>
<span class="line" id="L1320">        <span class="tok-kw">return</span> File{ .handle = fd };</span>
<span class="line" id="L1321">    }</span>
<span class="line" id="L1322"></span>
<span class="line" id="L1323">    <span class="tok-comment">/// Same as `createFile` but the path parameter is null-terminated.</span></span>
<span class="line" id="L1324">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createFileZ</span>(self: Dir, sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: File.CreateFlags) File.OpenError!File {</span>
<span class="line" id="L1325">        <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L1326">            <span class="tok-kw">const</span> path_w = <span class="tok-kw">try</span> os.windows.cStrToPrefixedFileW(sub_path_c);</span>
<span class="line" id="L1327">            <span class="tok-kw">return</span> self.createFileW(path_w.span(), flags);</span>
<span class="line" id="L1328">        }</span>
<span class="line" id="L1329"></span>
<span class="line" id="L1330">        <span class="tok-comment">// Use the O locking flags if the os supports them to acquire the lock</span>
</span>
<span class="line" id="L1331">        <span class="tok-comment">// atomically.</span>
</span>
<span class="line" id="L1332">        <span class="tok-kw">const</span> has_flock_open_flags = <span class="tok-builtin">@hasDecl</span>(os.O, <span class="tok-str">&quot;EXLOCK&quot;</span>);</span>
<span class="line" id="L1333">        <span class="tok-comment">// Note that the O.NONBLOCK flag is removed after the openat() call</span>
</span>
<span class="line" id="L1334">        <span class="tok-comment">// is successful.</span>
</span>
<span class="line" id="L1335">        <span class="tok-kw">const</span> nonblocking_lock_flag: <span class="tok-type">u32</span> = <span class="tok-kw">if</span> (has_flock_open_flags <span class="tok-kw">and</span> flags.lock_nonblocking)</span>
<span class="line" id="L1336">            os.O.NONBLOCK</span>
<span class="line" id="L1337">        <span class="tok-kw">else</span></span>
<span class="line" id="L1338">            <span class="tok-number">0</span>;</span>
<span class="line" id="L1339">        <span class="tok-kw">const</span> lock_flag: <span class="tok-type">u32</span> = <span class="tok-kw">if</span> (has_flock_open_flags) <span class="tok-kw">switch</span> (flags.lock) {</span>
<span class="line" id="L1340">            .none =&gt; <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>),</span>
<span class="line" id="L1341">            .shared =&gt; os.O.SHLOCK | nonblocking_lock_flag,</span>
<span class="line" id="L1342">            .exclusive =&gt; os.O.EXLOCK | nonblocking_lock_flag,</span>
<span class="line" id="L1343">        } <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L1344"></span>
<span class="line" id="L1345">        <span class="tok-kw">const</span> O_LARGEFILE = <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(os.O, <span class="tok-str">&quot;LARGEFILE&quot;</span>)) os.O.LARGEFILE <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L1346">        <span class="tok-kw">const</span> os_flags = lock_flag | O_LARGEFILE | os.O.CREAT | os.O.CLOEXEC |</span>
<span class="line" id="L1347">            (<span class="tok-kw">if</span> (flags.truncate) <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, os.O.TRUNC) <span class="tok-kw">else</span> <span class="tok-number">0</span>) |</span>
<span class="line" id="L1348">            (<span class="tok-kw">if</span> (flags.read) <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, os.O.RDWR) <span class="tok-kw">else</span> os.O.WRONLY) |</span>
<span class="line" id="L1349">            (<span class="tok-kw">if</span> (flags.exclusive) <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, os.O.EXCL) <span class="tok-kw">else</span> <span class="tok-number">0</span>);</span>
<span class="line" id="L1350">        <span class="tok-kw">const</span> fd = <span class="tok-kw">if</span> (flags.intended_io_mode != .blocking)</span>
<span class="line" id="L1351">            <span class="tok-kw">try</span> std.event.Loop.instance.?.openatZ(self.fd, sub_path_c, os_flags, flags.mode)</span>
<span class="line" id="L1352">        <span class="tok-kw">else</span></span>
<span class="line" id="L1353">            <span class="tok-kw">try</span> os.openatZ(self.fd, sub_path_c, os_flags, flags.mode);</span>
<span class="line" id="L1354">        <span class="tok-kw">errdefer</span> os.close(fd);</span>
<span class="line" id="L1355"></span>
<span class="line" id="L1356">        <span class="tok-comment">// WASI doesn't have os.flock so we intetinally check OS prior to the inner if block</span>
</span>
<span class="line" id="L1357">        <span class="tok-comment">// since it is not compiltime-known and we need to avoid undefined symbol in Wasm.</span>
</span>
<span class="line" id="L1358">        <span class="tok-kw">if</span> (builtin.target.os.tag != .wasi) {</span>
<span class="line" id="L1359">            <span class="tok-kw">if</span> (!has_flock_open_flags <span class="tok-kw">and</span> flags.lock != .none) {</span>
<span class="line" id="L1360">                <span class="tok-comment">// TODO: integrate async I/O</span>
</span>
<span class="line" id="L1361">                <span class="tok-kw">const</span> lock_nonblocking = <span class="tok-kw">if</span> (flags.lock_nonblocking) os.LOCK.NB <span class="tok-kw">else</span> <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L1362">                <span class="tok-kw">try</span> os.flock(fd, <span class="tok-kw">switch</span> (flags.lock) {</span>
<span class="line" id="L1363">                    .none =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1364">                    .shared =&gt; os.LOCK.SH | lock_nonblocking,</span>
<span class="line" id="L1365">                    .exclusive =&gt; os.LOCK.EX | lock_nonblocking,</span>
<span class="line" id="L1366">                });</span>
<span class="line" id="L1367">            }</span>
<span class="line" id="L1368">        }</span>
<span class="line" id="L1369"></span>
<span class="line" id="L1370">        <span class="tok-kw">if</span> (has_flock_open_flags <span class="tok-kw">and</span> flags.lock_nonblocking) {</span>
<span class="line" id="L1371">            <span class="tok-kw">var</span> fl_flags = os.fcntl(fd, os.F.GETFL, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1372">                <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1373">                <span class="tok-kw">error</span>.Locked =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1374">                <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1375">                <span class="tok-kw">error</span>.DeadLock =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1376">                <span class="tok-kw">error</span>.LockedRegionLimitExceeded =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1377">                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1378">            };</span>
<span class="line" id="L1379">            fl_flags &amp;= ~<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, os.O.NONBLOCK);</span>
<span class="line" id="L1380">            _ = os.fcntl(fd, os.F.SETFL, fl_flags) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1381">                <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1382">                <span class="tok-kw">error</span>.Locked =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1383">                <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1384">                <span class="tok-kw">error</span>.DeadLock =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1385">                <span class="tok-kw">error</span>.LockedRegionLimitExceeded =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1386">                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1387">            };</span>
<span class="line" id="L1388">        }</span>
<span class="line" id="L1389"></span>
<span class="line" id="L1390">        <span class="tok-kw">return</span> File{</span>
<span class="line" id="L1391">            .handle = fd,</span>
<span class="line" id="L1392">            .capable_io_mode = .blocking,</span>
<span class="line" id="L1393">            .intended_io_mode = flags.intended_io_mode,</span>
<span class="line" id="L1394">        };</span>
<span class="line" id="L1395">    }</span>
<span class="line" id="L1396"></span>
<span class="line" id="L1397">    <span class="tok-comment">/// Same as `createFile` but Windows-only and the path parameter is</span></span>
<span class="line" id="L1398">    <span class="tok-comment">/// [WTF-16](https://simonsapin.github.io/wtf-8/#potentially-ill-formed-utf-16) encoded.</span></span>
<span class="line" id="L1399">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createFileW</span>(self: Dir, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: File.CreateFlags) File.OpenError!File {</span>
<span class="line" id="L1400">        <span class="tok-kw">const</span> w = os.windows;</span>
<span class="line" id="L1401">        <span class="tok-kw">const</span> read_flag = <span class="tok-kw">if</span> (flags.read) <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, w.GENERIC_READ) <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L1402">        <span class="tok-kw">const</span> file: File = .{</span>
<span class="line" id="L1403">            .handle = <span class="tok-kw">try</span> os.windows.OpenFile(sub_path_w, .{</span>
<span class="line" id="L1404">                .dir = self.fd,</span>
<span class="line" id="L1405">                .access_mask = w.SYNCHRONIZE | w.GENERIC_WRITE | read_flag,</span>
<span class="line" id="L1406">                .creation = <span class="tok-kw">if</span> (flags.exclusive)</span>
<span class="line" id="L1407">                    <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, w.FILE_CREATE)</span>
<span class="line" id="L1408">                <span class="tok-kw">else</span> <span class="tok-kw">if</span> (flags.truncate)</span>
<span class="line" id="L1409">                    <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, w.FILE_OVERWRITE_IF)</span>
<span class="line" id="L1410">                <span class="tok-kw">else</span></span>
<span class="line" id="L1411">                    <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, w.FILE_OPEN_IF),</span>
<span class="line" id="L1412">                .io_mode = flags.intended_io_mode,</span>
<span class="line" id="L1413">            }),</span>
<span class="line" id="L1414">            .capable_io_mode = std.io.default_mode,</span>
<span class="line" id="L1415">            .intended_io_mode = flags.intended_io_mode,</span>
<span class="line" id="L1416">        };</span>
<span class="line" id="L1417">        <span class="tok-kw">errdefer</span> file.close();</span>
<span class="line" id="L1418">        <span class="tok-kw">var</span> io: w.IO_STATUS_BLOCK = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1419">        <span class="tok-kw">const</span> range_off: w.LARGE_INTEGER = <span class="tok-number">0</span>;</span>
<span class="line" id="L1420">        <span class="tok-kw">const</span> range_len: w.LARGE_INTEGER = <span class="tok-number">1</span>;</span>
<span class="line" id="L1421">        <span class="tok-kw">const</span> exclusive = <span class="tok-kw">switch</span> (flags.lock) {</span>
<span class="line" id="L1422">            .none =&gt; <span class="tok-kw">return</span> file,</span>
<span class="line" id="L1423">            .shared =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L1424">            .exclusive =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L1425">        };</span>
<span class="line" id="L1426">        <span class="tok-kw">try</span> w.LockFile(</span>
<span class="line" id="L1427">            file.handle,</span>
<span class="line" id="L1428">            <span class="tok-null">null</span>,</span>
<span class="line" id="L1429">            <span class="tok-null">null</span>,</span>
<span class="line" id="L1430">            <span class="tok-null">null</span>,</span>
<span class="line" id="L1431">            &amp;io,</span>
<span class="line" id="L1432">            &amp;range_off,</span>
<span class="line" id="L1433">            &amp;range_len,</span>
<span class="line" id="L1434">            <span class="tok-null">null</span>,</span>
<span class="line" id="L1435">            <span class="tok-builtin">@intFromBool</span>(flags.lock_nonblocking),</span>
<span class="line" id="L1436">            <span class="tok-builtin">@intFromBool</span>(exclusive),</span>
<span class="line" id="L1437">        );</span>
<span class="line" id="L1438">        <span class="tok-kw">return</span> file;</span>
<span class="line" id="L1439">    }</span>
<span class="line" id="L1440"></span>
<span class="line" id="L1441">    <span class="tok-comment">/// Creates a single directory with a relative or absolute path.</span></span>
<span class="line" id="L1442">    <span class="tok-comment">/// To create multiple directories to make an entire path, see `makePath`.</span></span>
<span class="line" id="L1443">    <span class="tok-comment">/// To operate on only absolute paths, see `makeDirAbsolute`.</span></span>
<span class="line" id="L1444">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeDir</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1445">        <span class="tok-kw">try</span> os.mkdirat(self.fd, sub_path, default_new_dir_mode);</span>
<span class="line" id="L1446">    }</span>
<span class="line" id="L1447"></span>
<span class="line" id="L1448">    <span class="tok-comment">/// Creates a single directory with a relative or absolute null-terminated UTF-8-encoded path.</span></span>
<span class="line" id="L1449">    <span class="tok-comment">/// To create multiple directories to make an entire path, see `makePath`.</span></span>
<span class="line" id="L1450">    <span class="tok-comment">/// To operate on only absolute paths, see `makeDirAbsoluteZ`.</span></span>
<span class="line" id="L1451">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeDirZ</span>(self: Dir, sub_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1452">        <span class="tok-kw">try</span> os.mkdiratZ(self.fd, sub_path, default_new_dir_mode);</span>
<span class="line" id="L1453">    }</span>
<span class="line" id="L1454"></span>
<span class="line" id="L1455">    <span class="tok-comment">/// Creates a single directory with a relative or absolute null-terminated WTF-16-encoded path.</span></span>
<span class="line" id="L1456">    <span class="tok-comment">/// To create multiple directories to make an entire path, see `makePath`.</span></span>
<span class="line" id="L1457">    <span class="tok-comment">/// To operate on only absolute paths, see `makeDirAbsoluteW`.</span></span>
<span class="line" id="L1458">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeDirW</span>(self: Dir, sub_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1459">        <span class="tok-kw">try</span> os.mkdiratW(self.fd, sub_path, default_new_dir_mode);</span>
<span class="line" id="L1460">    }</span>
<span class="line" id="L1461"></span>
<span class="line" id="L1462">    <span class="tok-comment">/// Calls makeDir recursively to make an entire path. Returns success if the path</span></span>
<span class="line" id="L1463">    <span class="tok-comment">/// already exists and is a directory.</span></span>
<span class="line" id="L1464">    <span class="tok-comment">/// This function is not atomic, and if it returns an error, the file system may</span></span>
<span class="line" id="L1465">    <span class="tok-comment">/// have been modified regardless.</span></span>
<span class="line" id="L1466">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makePath</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1467">        <span class="tok-kw">var</span> it = <span class="tok-kw">try</span> path.componentIterator(sub_path);</span>
<span class="line" id="L1468">        <span class="tok-kw">var</span> component = it.last() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L1469">        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L1470">            self.makeDir(component.path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1471">                <span class="tok-kw">error</span>.PathAlreadyExists =&gt; {</span>
<span class="line" id="L1472">                    <span class="tok-comment">// TODO stat the file and return an error if it's not a directory</span>
</span>
<span class="line" id="L1473">                    <span class="tok-comment">// this is important because otherwise a dangling symlink</span>
</span>
<span class="line" id="L1474">                    <span class="tok-comment">// could cause an infinite loop</span>
</span>
<span class="line" id="L1475">                },</span>
<span class="line" id="L1476">                <span class="tok-kw">error</span>.FileNotFound =&gt; |e| {</span>
<span class="line" id="L1477">                    component = it.previous() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> e;</span>
<span class="line" id="L1478">                    <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1479">                },</span>
<span class="line" id="L1480">                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1481">            };</span>
<span class="line" id="L1482">            component = it.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L1483">        }</span>
<span class="line" id="L1484">    }</span>
<span class="line" id="L1485"></span>
<span class="line" id="L1486">    <span class="tok-comment">/// This function performs `makePath`, followed by `openDir`.</span></span>
<span class="line" id="L1487">    <span class="tok-comment">/// If supported by the OS, this operation is atomic. It is not atomic on</span></span>
<span class="line" id="L1488">    <span class="tok-comment">/// all operating systems.</span></span>
<span class="line" id="L1489">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeOpenPath</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, open_dir_options: OpenDirOptions) !Dir {</span>
<span class="line" id="L1490">        <span class="tok-comment">// TODO improve this implementation on Windows; we can avoid 1 call to NtClose</span>
</span>
<span class="line" id="L1491">        <span class="tok-kw">try</span> self.makePath(sub_path);</span>
<span class="line" id="L1492">        <span class="tok-kw">return</span> self.openDir(sub_path, open_dir_options);</span>
<span class="line" id="L1493">    }</span>
<span class="line" id="L1494"></span>
<span class="line" id="L1495">    <span class="tok-comment">/// This function performs `makePath`, followed by `openIterableDir`.</span></span>
<span class="line" id="L1496">    <span class="tok-comment">/// If supported by the OS, this operation is atomic. It is not atomic on</span></span>
<span class="line" id="L1497">    <span class="tok-comment">/// all operating systems.</span></span>
<span class="line" id="L1498">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeOpenPathIterable</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, open_dir_options: OpenDirOptions) !IterableDir {</span>
<span class="line" id="L1499">        <span class="tok-comment">// TODO improve this implementation on Windows; we can avoid 1 call to NtClose</span>
</span>
<span class="line" id="L1500">        <span class="tok-kw">try</span> self.makePath(sub_path);</span>
<span class="line" id="L1501">        <span class="tok-kw">return</span> self.openIterableDir(sub_path, open_dir_options);</span>
<span class="line" id="L1502">    }</span>
<span class="line" id="L1503"></span>
<span class="line" id="L1504">    <span class="tok-comment">///  This function returns the canonicalized absolute pathname of</span></span>
<span class="line" id="L1505">    <span class="tok-comment">/// `pathname` relative to this `Dir`. If `pathname` is absolute, ignores this</span></span>
<span class="line" id="L1506">    <span class="tok-comment">/// `Dir` handle and returns the canonicalized absolute pathname of `pathname`</span></span>
<span class="line" id="L1507">    <span class="tok-comment">/// argument.</span></span>
<span class="line" id="L1508">    <span class="tok-comment">/// This function is not universally supported by all platforms.</span></span>
<span class="line" id="L1509">    <span class="tok-comment">/// Currently supported hosts are: Linux, macOS, and Windows.</span></span>
<span class="line" id="L1510">    <span class="tok-comment">/// See also `Dir.realpathZ`, `Dir.realpathW`, and `Dir.realpathAlloc`.</span></span>
<span class="line" id="L1511">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpath</span>(self: Dir, pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L1512">        <span class="tok-kw">if</span> (builtin.os.tag == .wasi) {</span>
<span class="line" id="L1513">            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;realpath is not available on WASI&quot;</span>);</span>
<span class="line" id="L1514">        }</span>
<span class="line" id="L1515">        <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L1516">            <span class="tok-kw">const</span> pathname_w = <span class="tok-kw">try</span> os.windows.sliceToPrefixedFileW(pathname);</span>
<span class="line" id="L1517">            <span class="tok-kw">return</span> self.realpathW(pathname_w.span(), out_buffer);</span>
<span class="line" id="L1518">        }</span>
<span class="line" id="L1519">        <span class="tok-kw">const</span> pathname_c = <span class="tok-kw">try</span> os.toPosixPath(pathname);</span>
<span class="line" id="L1520">        <span class="tok-kw">return</span> self.realpathZ(&amp;pathname_c, out_buffer);</span>
<span class="line" id="L1521">    }</span>
<span class="line" id="L1522"></span>
<span class="line" id="L1523">    <span class="tok-comment">/// Same as `Dir.realpath` except `pathname` is null-terminated.</span></span>
<span class="line" id="L1524">    <span class="tok-comment">/// See also `Dir.realpath`, `realpathZ`.</span></span>
<span class="line" id="L1525">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpathZ</span>(self: Dir, pathname: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L1526">        <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L1527">            <span class="tok-kw">const</span> pathname_w = <span class="tok-kw">try</span> os.windows.cStrToPrefixedFileW(pathname);</span>
<span class="line" id="L1528">            <span class="tok-kw">return</span> self.realpathW(pathname_w.span(), out_buffer);</span>
<span class="line" id="L1529">        }</span>
<span class="line" id="L1530"></span>
<span class="line" id="L1531">        <span class="tok-kw">const</span> flags = <span class="tok-kw">if</span> (builtin.os.tag == .linux) os.O.PATH | os.O.NONBLOCK | os.O.CLOEXEC <span class="tok-kw">else</span> os.O.NONBLOCK | os.O.CLOEXEC;</span>
<span class="line" id="L1532">        <span class="tok-kw">const</span> fd = os.openatZ(self.fd, pathname, flags, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1533">            <span class="tok-kw">error</span>.FileLocksNotSupported =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1534">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1535">        };</span>
<span class="line" id="L1536">        <span class="tok-kw">defer</span> os.close(fd);</span>
<span class="line" id="L1537"></span>
<span class="line" id="L1538">        <span class="tok-comment">// Use of MAX_PATH_BYTES here is valid as the realpath function does not</span>
</span>
<span class="line" id="L1539">        <span class="tok-comment">// have a variant that takes an arbitrary-size buffer.</span>
</span>
<span class="line" id="L1540">        <span class="tok-comment">// TODO(#4812): Consider reimplementing realpath or using the POSIX.1-2008</span>
</span>
<span class="line" id="L1541">        <span class="tok-comment">// NULL out parameter (GNU's canonicalize_file_name) to handle overelong</span>
</span>
<span class="line" id="L1542">        <span class="tok-comment">// paths. musl supports passing NULL but restricts the output to PATH_MAX</span>
</span>
<span class="line" id="L1543">        <span class="tok-comment">// anyway.</span>
</span>
<span class="line" id="L1544">        <span class="tok-kw">var</span> buffer: [MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1545">        <span class="tok-kw">const</span> out_path = <span class="tok-kw">try</span> os.getFdPath(fd, &amp;buffer);</span>
<span class="line" id="L1546"></span>
<span class="line" id="L1547">        <span class="tok-kw">if</span> (out_path.len &gt; out_buffer.len) {</span>
<span class="line" id="L1548">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;</span>
<span class="line" id="L1549">        }</span>
<span class="line" id="L1550"></span>
<span class="line" id="L1551">        <span class="tok-kw">const</span> result = out_buffer[<span class="tok-number">0</span>..out_path.len];</span>
<span class="line" id="L1552">        <span class="tok-builtin">@memcpy</span>(result, out_path);</span>
<span class="line" id="L1553">        <span class="tok-kw">return</span> result;</span>
<span class="line" id="L1554">    }</span>
<span class="line" id="L1555"></span>
<span class="line" id="L1556">    <span class="tok-comment">/// Windows-only. Same as `Dir.realpath` except `pathname` is WTF16 encoded.</span></span>
<span class="line" id="L1557">    <span class="tok-comment">/// See also `Dir.realpath`, `realpathW`.</span></span>
<span class="line" id="L1558">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpathW</span>(self: Dir, pathname: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, out_buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L1559">        <span class="tok-kw">const</span> w = os.windows;</span>
<span class="line" id="L1560"></span>
<span class="line" id="L1561">        <span class="tok-kw">const</span> access_mask = w.GENERIC_READ | w.SYNCHRONIZE;</span>
<span class="line" id="L1562">        <span class="tok-kw">const</span> share_access = w.FILE_SHARE_READ;</span>
<span class="line" id="L1563">        <span class="tok-kw">const</span> creation = w.FILE_OPEN;</span>
<span class="line" id="L1564">        <span class="tok-kw">const</span> h_file = blk: {</span>
<span class="line" id="L1565">            <span class="tok-kw">const</span> res = w.OpenFile(pathname, .{</span>
<span class="line" id="L1566">                .dir = self.fd,</span>
<span class="line" id="L1567">                .access_mask = access_mask,</span>
<span class="line" id="L1568">                .share_access = share_access,</span>
<span class="line" id="L1569">                .creation = creation,</span>
<span class="line" id="L1570">                .io_mode = .blocking,</span>
<span class="line" id="L1571">            }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1572">                <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">break</span> :blk w.OpenFile(pathname, .{</span>
<span class="line" id="L1573">                    .dir = self.fd,</span>
<span class="line" id="L1574">                    .access_mask = access_mask,</span>
<span class="line" id="L1575">                    .share_access = share_access,</span>
<span class="line" id="L1576">                    .creation = creation,</span>
<span class="line" id="L1577">                    .io_mode = .blocking,</span>
<span class="line" id="L1578">                    .filter = .dir_only,</span>
<span class="line" id="L1579">                }) <span class="tok-kw">catch</span> |er| <span class="tok-kw">switch</span> (er) {</span>
<span class="line" id="L1580">                    <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1581">                    <span class="tok-kw">else</span> =&gt; |e2| <span class="tok-kw">return</span> e2,</span>
<span class="line" id="L1582">                },</span>
<span class="line" id="L1583">                <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1584">                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1585">            };</span>
<span class="line" id="L1586">            <span class="tok-kw">break</span> :blk res;</span>
<span class="line" id="L1587">        };</span>
<span class="line" id="L1588">        <span class="tok-kw">defer</span> w.CloseHandle(h_file);</span>
<span class="line" id="L1589"></span>
<span class="line" id="L1590">        <span class="tok-comment">// Use of MAX_PATH_BYTES here is valid as the realpath function does not</span>
</span>
<span class="line" id="L1591">        <span class="tok-comment">// have a variant that takes an arbitrary-size buffer.</span>
</span>
<span class="line" id="L1592">        <span class="tok-comment">// TODO(#4812): Consider reimplementing realpath or using the POSIX.1-2008</span>
</span>
<span class="line" id="L1593">        <span class="tok-comment">// NULL out parameter (GNU's canonicalize_file_name) to handle overelong</span>
</span>
<span class="line" id="L1594">        <span class="tok-comment">// paths. musl supports passing NULL but restricts the output to PATH_MAX</span>
</span>
<span class="line" id="L1595">        <span class="tok-comment">// anyway.</span>
</span>
<span class="line" id="L1596">        <span class="tok-kw">var</span> buffer: [MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1597">        <span class="tok-kw">const</span> out_path = <span class="tok-kw">try</span> os.getFdPath(h_file, &amp;buffer);</span>
<span class="line" id="L1598"></span>
<span class="line" id="L1599">        <span class="tok-kw">if</span> (out_path.len &gt; out_buffer.len) {</span>
<span class="line" id="L1600">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;</span>
<span class="line" id="L1601">        }</span>
<span class="line" id="L1602"></span>
<span class="line" id="L1603">        <span class="tok-kw">const</span> result = out_buffer[<span class="tok-number">0</span>..out_path.len];</span>
<span class="line" id="L1604">        <span class="tok-builtin">@memcpy</span>(result, out_path);</span>
<span class="line" id="L1605">        <span class="tok-kw">return</span> result;</span>
<span class="line" id="L1606">    }</span>
<span class="line" id="L1607"></span>
<span class="line" id="L1608">    <span class="tok-comment">/// Same as `Dir.realpath` except caller must free the returned memory.</span></span>
<span class="line" id="L1609">    <span class="tok-comment">/// See also `Dir.realpath`.</span></span>
<span class="line" id="L1610">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpathAlloc</span>(self: Dir, allocator: Allocator, pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L1611">        <span class="tok-comment">// Use of MAX_PATH_BYTES here is valid as the realpath function does not</span>
</span>
<span class="line" id="L1612">        <span class="tok-comment">// have a variant that takes an arbitrary-size buffer.</span>
</span>
<span class="line" id="L1613">        <span class="tok-comment">// TODO(#4812): Consider reimplementing realpath or using the POSIX.1-2008</span>
</span>
<span class="line" id="L1614">        <span class="tok-comment">// NULL out parameter (GNU's canonicalize_file_name) to handle overelong</span>
</span>
<span class="line" id="L1615">        <span class="tok-comment">// paths. musl supports passing NULL but restricts the output to PATH_MAX</span>
</span>
<span class="line" id="L1616">        <span class="tok-comment">// anyway.</span>
</span>
<span class="line" id="L1617">        <span class="tok-kw">var</span> buf: [MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1618">        <span class="tok-kw">return</span> allocator.dupe(<span class="tok-type">u8</span>, <span class="tok-kw">try</span> self.realpath(pathname, buf[<span class="tok-number">0</span>..]));</span>
<span class="line" id="L1619">    }</span>
<span class="line" id="L1620"></span>
<span class="line" id="L1621">    <span class="tok-comment">/// Changes the current working directory to the open directory handle.</span></span>
<span class="line" id="L1622">    <span class="tok-comment">/// This modifies global state and can have surprising effects in multi-</span></span>
<span class="line" id="L1623">    <span class="tok-comment">/// threaded applications. Most applications and especially libraries should</span></span>
<span class="line" id="L1624">    <span class="tok-comment">/// not call this function as a general rule, however it can have use cases</span></span>
<span class="line" id="L1625">    <span class="tok-comment">/// in, for example, implementing a shell, or child process execution.</span></span>
<span class="line" id="L1626">    <span class="tok-comment">/// Not all targets support this. For example, WASI does not have the concept</span></span>
<span class="line" id="L1627">    <span class="tok-comment">/// of a current working directory.</span></span>
<span class="line" id="L1628">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setAsCwd</span>(self: Dir) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1629">        <span class="tok-kw">if</span> (builtin.os.tag == .wasi) {</span>
<span class="line" id="L1630">            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;changing cwd is not currently possible in WASI&quot;</span>);</span>
<span class="line" id="L1631">        }</span>
<span class="line" id="L1632">        <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L1633">            <span class="tok-kw">var</span> dir_path_buffer: [os.windows.PATH_MAX_WIDE]<span class="tok-type">u16</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1634">            <span class="tok-kw">var</span> dir_path = <span class="tok-kw">try</span> os.windows.GetFinalPathNameByHandle(self.fd, .{}, &amp;dir_path_buffer);</span>
<span class="line" id="L1635">            <span class="tok-kw">if</span> (builtin.link_libc) {</span>
<span class="line" id="L1636">                <span class="tok-kw">return</span> os.chdirW(dir_path);</span>
<span class="line" id="L1637">            }</span>
<span class="line" id="L1638">            <span class="tok-kw">return</span> os.windows.SetCurrentDirectory(dir_path);</span>
<span class="line" id="L1639">        }</span>
<span class="line" id="L1640">        <span class="tok-kw">try</span> os.fchdir(self.fd);</span>
<span class="line" id="L1641">    }</span>
<span class="line" id="L1642"></span>
<span class="line" id="L1643">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> OpenDirOptions = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1644">        <span class="tok-comment">/// `true` means the opened directory can be used as the `Dir` parameter</span></span>
<span class="line" id="L1645">        <span class="tok-comment">/// for functions which operate based on an open directory handle. When `false`,</span></span>
<span class="line" id="L1646">        <span class="tok-comment">/// such operations are Illegal Behavior.</span></span>
<span class="line" id="L1647">        access_sub_paths: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,</span>
<span class="line" id="L1648"></span>
<span class="line" id="L1649">        <span class="tok-comment">/// `true` means it won't dereference the symlinks.</span></span>
<span class="line" id="L1650">        no_follow: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L1651">    };</span>
<span class="line" id="L1652"></span>
<span class="line" id="L1653">    <span class="tok-comment">/// Opens a directory at the given path. The directory is a system resource that remains</span></span>
<span class="line" id="L1654">    <span class="tok-comment">/// open until `close` is called on the result.</span></span>
<span class="line" id="L1655">    <span class="tok-comment">///</span></span>
<span class="line" id="L1656">    <span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span></span>
<span class="line" id="L1657">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDir</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: OpenDirOptions) OpenError!Dir {</span>
<span class="line" id="L1658">        <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L1659">            <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> os.windows.sliceToPrefixedFileW(sub_path);</span>
<span class="line" id="L1660">            <span class="tok-kw">return</span> self.openDirW(sub_path_w.span().ptr, args, <span class="tok-null">false</span>);</span>
<span class="line" id="L1661">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (builtin.os.tag == .wasi <span class="tok-kw">and</span> !builtin.link_libc) {</span>
<span class="line" id="L1662">            <span class="tok-kw">return</span> self.openDirWasi(sub_path, args);</span>
<span class="line" id="L1663">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1664">            <span class="tok-kw">const</span> sub_path_c = <span class="tok-kw">try</span> os.toPosixPath(sub_path);</span>
<span class="line" id="L1665">            <span class="tok-kw">return</span> self.openDirZ(&amp;sub_path_c, args, <span class="tok-null">false</span>);</span>
<span class="line" id="L1666">        }</span>
<span class="line" id="L1667">    }</span>
<span class="line" id="L1668"></span>
<span class="line" id="L1669">    <span class="tok-comment">/// Opens an iterable directory at the given path. The directory is a system resource that remains</span></span>
<span class="line" id="L1670">    <span class="tok-comment">/// open until `close` is called on the result.</span></span>
<span class="line" id="L1671">    <span class="tok-comment">///</span></span>
<span class="line" id="L1672">    <span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span></span>
<span class="line" id="L1673">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openIterableDir</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: OpenDirOptions) OpenError!IterableDir {</span>
<span class="line" id="L1674">        <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L1675">            <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> os.windows.sliceToPrefixedFileW(sub_path);</span>
<span class="line" id="L1676">            <span class="tok-kw">return</span> IterableDir{ .dir = <span class="tok-kw">try</span> self.openDirW(sub_path_w.span().ptr, args, <span class="tok-null">true</span>) };</span>
<span class="line" id="L1677">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (builtin.os.tag == .wasi <span class="tok-kw">and</span> !builtin.link_libc) {</span>
<span class="line" id="L1678">            <span class="tok-kw">return</span> IterableDir{ .dir = <span class="tok-kw">try</span> self.openDirWasi(sub_path, args) };</span>
<span class="line" id="L1679">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1680">            <span class="tok-kw">const</span> sub_path_c = <span class="tok-kw">try</span> os.toPosixPath(sub_path);</span>
<span class="line" id="L1681">            <span class="tok-kw">return</span> IterableDir{ .dir = <span class="tok-kw">try</span> self.openDirZ(&amp;sub_path_c, args, <span class="tok-null">true</span>) };</span>
<span class="line" id="L1682">        }</span>
<span class="line" id="L1683">    }</span>
<span class="line" id="L1684"></span>
<span class="line" id="L1685">    <span class="tok-comment">/// Same as `openDir` except only WASI.</span></span>
<span class="line" id="L1686">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDirWasi</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: OpenDirOptions) OpenError!Dir {</span>
<span class="line" id="L1687">        <span class="tok-kw">const</span> w = os.wasi;</span>
<span class="line" id="L1688">        <span class="tok-kw">var</span> base: w.rights_t = w.RIGHT.FD_FILESTAT_GET | w.RIGHT.FD_FDSTAT_SET_FLAGS | w.RIGHT.FD_FILESTAT_SET_TIMES;</span>
<span class="line" id="L1689">        <span class="tok-kw">if</span> (args.access_sub_paths) {</span>
<span class="line" id="L1690">            base |= w.RIGHT.FD_READDIR |</span>
<span class="line" id="L1691">                w.RIGHT.PATH_CREATE_DIRECTORY |</span>
<span class="line" id="L1692">                w.RIGHT.PATH_CREATE_FILE |</span>
<span class="line" id="L1693">                w.RIGHT.PATH_LINK_SOURCE |</span>
<span class="line" id="L1694">                w.RIGHT.PATH_LINK_TARGET |</span>
<span class="line" id="L1695">                w.RIGHT.PATH_OPEN |</span>
<span class="line" id="L1696">                w.RIGHT.PATH_READLINK |</span>
<span class="line" id="L1697">                w.RIGHT.PATH_RENAME_SOURCE |</span>
<span class="line" id="L1698">                w.RIGHT.PATH_RENAME_TARGET |</span>
<span class="line" id="L1699">                w.RIGHT.PATH_FILESTAT_GET |</span>
<span class="line" id="L1700">                w.RIGHT.PATH_FILESTAT_SET_SIZE |</span>
<span class="line" id="L1701">                w.RIGHT.PATH_FILESTAT_SET_TIMES |</span>
<span class="line" id="L1702">                w.RIGHT.PATH_SYMLINK |</span>
<span class="line" id="L1703">                w.RIGHT.PATH_REMOVE_DIRECTORY |</span>
<span class="line" id="L1704">                w.RIGHT.PATH_UNLINK_FILE;</span>
<span class="line" id="L1705">        }</span>
<span class="line" id="L1706">        <span class="tok-kw">const</span> symlink_flags: w.lookupflags_t = <span class="tok-kw">if</span> (args.no_follow) <span class="tok-number">0x0</span> <span class="tok-kw">else</span> w.LOOKUP_SYMLINK_FOLLOW;</span>
<span class="line" id="L1707">        <span class="tok-comment">// TODO do we really need all the rights here?</span>
</span>
<span class="line" id="L1708">        <span class="tok-kw">const</span> inheriting: w.rights_t = w.RIGHT.ALL ^ w.RIGHT.SOCK_SHUTDOWN;</span>
<span class="line" id="L1709"></span>
<span class="line" id="L1710">        <span class="tok-kw">const</span> result = os.openatWasi(</span>
<span class="line" id="L1711">            self.fd,</span>
<span class="line" id="L1712">            sub_path,</span>
<span class="line" id="L1713">            symlink_flags,</span>
<span class="line" id="L1714">            w.O.DIRECTORY,</span>
<span class="line" id="L1715">            <span class="tok-number">0x0</span>,</span>
<span class="line" id="L1716">            base,</span>
<span class="line" id="L1717">            inheriting,</span>
<span class="line" id="L1718">        );</span>
<span class="line" id="L1719">        <span class="tok-kw">const</span> fd = result <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1720">            <span class="tok-kw">error</span>.FileTooBig =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// can't happen for directories</span>
</span>
<span class="line" id="L1721">            <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// we're providing O.DIRECTORY</span>
</span>
<span class="line" id="L1722">            <span class="tok-kw">error</span>.NoSpaceLeft =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// not providing O.CREAT</span>
</span>
<span class="line" id="L1723">            <span class="tok-kw">error</span>.PathAlreadyExists =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// not providing O.CREAT</span>
</span>
<span class="line" id="L1724">            <span class="tok-kw">error</span>.FileLocksNotSupported =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// locking folders is not supported</span>
</span>
<span class="line" id="L1725">            <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// can't happen for directories</span>
</span>
<span class="line" id="L1726">            <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// can't happen for directories</span>
</span>
<span class="line" id="L1727">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1728">        };</span>
<span class="line" id="L1729">        <span class="tok-kw">return</span> Dir{ .fd = fd };</span>
<span class="line" id="L1730">    }</span>
<span class="line" id="L1731"></span>
<span class="line" id="L1732">    <span class="tok-comment">/// Same as `openDir` except the parameter is null-terminated.</span></span>
<span class="line" id="L1733">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDirZ</span>(self: Dir, sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: OpenDirOptions, iterable: <span class="tok-type">bool</span>) OpenError!Dir {</span>
<span class="line" id="L1734">        <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L1735">            <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> os.windows.cStrToPrefixedFileW(sub_path_c);</span>
<span class="line" id="L1736">            <span class="tok-kw">return</span> self.openDirW(sub_path_w.span().ptr, args, iterable);</span>
<span class="line" id="L1737">        }</span>
<span class="line" id="L1738">        <span class="tok-kw">const</span> symlink_flags: <span class="tok-type">u32</span> = <span class="tok-kw">if</span> (args.no_follow) os.O.NOFOLLOW <span class="tok-kw">else</span> <span class="tok-number">0x0</span>;</span>
<span class="line" id="L1739">        <span class="tok-kw">if</span> (!iterable) {</span>
<span class="line" id="L1740">            <span class="tok-kw">const</span> O_PATH = <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(os.O, <span class="tok-str">&quot;PATH&quot;</span>)) os.O.PATH <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L1741">            <span class="tok-kw">return</span> self.openDirFlagsZ(sub_path_c, os.O.DIRECTORY | os.O.RDONLY | os.O.CLOEXEC | O_PATH | symlink_flags);</span>
<span class="line" id="L1742">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1743">            <span class="tok-kw">return</span> self.openDirFlagsZ(sub_path_c, os.O.DIRECTORY | os.O.RDONLY | os.O.CLOEXEC | symlink_flags);</span>
<span class="line" id="L1744">        }</span>
<span class="line" id="L1745">    }</span>
<span class="line" id="L1746"></span>
<span class="line" id="L1747">    <span class="tok-comment">/// Same as `openDir` except the path parameter is WTF-16 encoded, NT-prefixed.</span></span>
<span class="line" id="L1748">    <span class="tok-comment">/// This function asserts the target OS is Windows.</span></span>
<span class="line" id="L1749">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDirW</span>(self: Dir, sub_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, args: OpenDirOptions, iterable: <span class="tok-type">bool</span>) OpenError!Dir {</span>
<span class="line" id="L1750">        <span class="tok-kw">const</span> w = os.windows;</span>
<span class="line" id="L1751">        <span class="tok-comment">// TODO remove some of these flags if args.access_sub_paths is false</span>
</span>
<span class="line" id="L1752">        <span class="tok-kw">const</span> base_flags = w.STANDARD_RIGHTS_READ | w.FILE_READ_ATTRIBUTES | w.FILE_READ_EA |</span>
<span class="line" id="L1753">            w.SYNCHRONIZE | w.FILE_TRAVERSE;</span>
<span class="line" id="L1754">        <span class="tok-kw">const</span> flags: <span class="tok-type">u32</span> = <span class="tok-kw">if</span> (iterable) base_flags | w.FILE_LIST_DIRECTORY <span class="tok-kw">else</span> base_flags;</span>
<span class="line" id="L1755">        <span class="tok-kw">var</span> dir = <span class="tok-kw">try</span> self.openDirAccessMaskW(sub_path_w, flags, args.no_follow);</span>
<span class="line" id="L1756">        <span class="tok-kw">return</span> dir;</span>
<span class="line" id="L1757">    }</span>
<span class="line" id="L1758"></span>
<span class="line" id="L1759">    <span class="tok-comment">/// `flags` must contain `os.O.DIRECTORY`.</span></span>
<span class="line" id="L1760">    <span class="tok-kw">fn</span> <span class="tok-fn">openDirFlagsZ</span>(self: Dir, sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <span class="tok-type">u32</span>) OpenError!Dir {</span>
<span class="line" id="L1761">        <span class="tok-kw">const</span> result = <span class="tok-kw">if</span> (need_async_thread)</span>
<span class="line" id="L1762">            std.event.Loop.instance.?.openatZ(self.fd, sub_path_c, flags, <span class="tok-number">0</span>)</span>
<span class="line" id="L1763">        <span class="tok-kw">else</span></span>
<span class="line" id="L1764">            os.openatZ(self.fd, sub_path_c, flags, <span class="tok-number">0</span>);</span>
<span class="line" id="L1765">        <span class="tok-kw">const</span> fd = result <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1766">            <span class="tok-kw">error</span>.FileTooBig =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// can't happen for directories</span>
</span>
<span class="line" id="L1767">            <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// we're providing O.DIRECTORY</span>
</span>
<span class="line" id="L1768">            <span class="tok-kw">error</span>.NoSpaceLeft =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// not providing O.CREAT</span>
</span>
<span class="line" id="L1769">            <span class="tok-kw">error</span>.PathAlreadyExists =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// not providing O.CREAT</span>
</span>
<span class="line" id="L1770">            <span class="tok-kw">error</span>.FileLocksNotSupported =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// locking folders is not supported</span>
</span>
<span class="line" id="L1771">            <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// can't happen for directories</span>
</span>
<span class="line" id="L1772">            <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// can't happen for directories</span>
</span>
<span class="line" id="L1773">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1774">        };</span>
<span class="line" id="L1775">        <span class="tok-kw">return</span> Dir{ .fd = fd };</span>
<span class="line" id="L1776">    }</span>
<span class="line" id="L1777"></span>
<span class="line" id="L1778">    <span class="tok-kw">fn</span> <span class="tok-fn">openDirAccessMaskW</span>(self: Dir, sub_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, access_mask: <span class="tok-type">u32</span>, no_follow: <span class="tok-type">bool</span>) OpenError!Dir {</span>
<span class="line" id="L1779">        <span class="tok-kw">const</span> w = os.windows;</span>
<span class="line" id="L1780"></span>
<span class="line" id="L1781">        <span class="tok-kw">var</span> result = Dir{</span>
<span class="line" id="L1782">            .fd = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L1783">        };</span>
<span class="line" id="L1784"></span>
<span class="line" id="L1785">        <span class="tok-kw">const</span> path_len_bytes = <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intCast</span>(mem.sliceTo(sub_path_w, <span class="tok-number">0</span>).len * <span class="tok-number">2</span>));</span>
<span class="line" id="L1786">        <span class="tok-kw">var</span> nt_name = w.UNICODE_STRING{</span>
<span class="line" id="L1787">            .Length = path_len_bytes,</span>
<span class="line" id="L1788">            .MaximumLength = path_len_bytes,</span>
<span class="line" id="L1789">            .Buffer = <span class="tok-builtin">@constCast</span>(sub_path_w),</span>
<span class="line" id="L1790">        };</span>
<span class="line" id="L1791">        <span class="tok-kw">var</span> attr = w.OBJECT_ATTRIBUTES{</span>
<span class="line" id="L1792">            .Length = <span class="tok-builtin">@sizeOf</span>(w.OBJECT_ATTRIBUTES),</span>
<span class="line" id="L1793">            .RootDirectory = <span class="tok-kw">if</span> (path.isAbsoluteWindowsW(sub_path_w)) <span class="tok-null">null</span> <span class="tok-kw">else</span> self.fd,</span>
<span class="line" id="L1794">            .Attributes = <span class="tok-number">0</span>, <span class="tok-comment">// Note we do not use OBJ_CASE_INSENSITIVE here.</span>
</span>
<span class="line" id="L1795">            .ObjectName = &amp;nt_name,</span>
<span class="line" id="L1796">            .SecurityDescriptor = <span class="tok-null">null</span>,</span>
<span class="line" id="L1797">            .SecurityQualityOfService = <span class="tok-null">null</span>,</span>
<span class="line" id="L1798">        };</span>
<span class="line" id="L1799">        <span class="tok-kw">const</span> open_reparse_point: w.DWORD = <span class="tok-kw">if</span> (no_follow) w.FILE_OPEN_REPARSE_POINT <span class="tok-kw">else</span> <span class="tok-number">0x0</span>;</span>
<span class="line" id="L1800">        <span class="tok-kw">var</span> io: w.IO_STATUS_BLOCK = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1801">        <span class="tok-kw">const</span> rc = w.ntdll.NtCreateFile(</span>
<span class="line" id="L1802">            &amp;result.fd,</span>
<span class="line" id="L1803">            access_mask,</span>
<span class="line" id="L1804">            &amp;attr,</span>
<span class="line" id="L1805">            &amp;io,</span>
<span class="line" id="L1806">            <span class="tok-null">null</span>,</span>
<span class="line" id="L1807">            <span class="tok-number">0</span>,</span>
<span class="line" id="L1808">            w.FILE_SHARE_READ | w.FILE_SHARE_WRITE,</span>
<span class="line" id="L1809">            w.FILE_OPEN,</span>
<span class="line" id="L1810">            w.FILE_DIRECTORY_FILE | w.FILE_SYNCHRONOUS_IO_NONALERT | w.FILE_OPEN_FOR_BACKUP_INTENT | open_reparse_point,</span>
<span class="line" id="L1811">            <span class="tok-null">null</span>,</span>
<span class="line" id="L1812">            <span class="tok-number">0</span>,</span>
<span class="line" id="L1813">        );</span>
<span class="line" id="L1814">        <span class="tok-kw">switch</span> (rc) {</span>
<span class="line" id="L1815">            .SUCCESS =&gt; <span class="tok-kw">return</span> result,</span>
<span class="line" id="L1816">            .OBJECT_NAME_INVALID =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1817">            .OBJECT_NAME_NOT_FOUND =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,</span>
<span class="line" id="L1818">            .OBJECT_PATH_NOT_FOUND =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,</span>
<span class="line" id="L1819">            .NOT_A_DIRECTORY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,</span>
<span class="line" id="L1820">            <span class="tok-comment">// This can happen if the directory has 'List folder contents' permission set to 'Deny'</span>
</span>
<span class="line" id="L1821">            <span class="tok-comment">// and the directory is trying to be opened for iteration.</span>
</span>
<span class="line" id="L1822">            .ACCESS_DENIED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L1823">            .INVALID_PARAMETER =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1824">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> w.unexpectedStatus(rc),</span>
<span class="line" id="L1825">        }</span>
<span class="line" id="L1826">    }</span>
<span class="line" id="L1827"></span>
<span class="line" id="L1828">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> DeleteFileError = os.UnlinkError;</span>
<span class="line" id="L1829"></span>
<span class="line" id="L1830">    <span class="tok-comment">/// Delete a file name and possibly the file it refers to, based on an open directory handle.</span></span>
<span class="line" id="L1831">    <span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span></span>
<span class="line" id="L1832">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteFile</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) DeleteFileError!<span class="tok-type">void</span> {</span>
<span class="line" id="L1833">        <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L1834">            <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> os.windows.sliceToPrefixedFileW(sub_path);</span>
<span class="line" id="L1835">            <span class="tok-kw">return</span> self.deleteFileW(sub_path_w.span());</span>
<span class="line" id="L1836">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (builtin.os.tag == .wasi <span class="tok-kw">and</span> !builtin.link_libc) {</span>
<span class="line" id="L1837">            os.unlinkat(self.fd, sub_path, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1838">                <span class="tok-kw">error</span>.DirNotEmpty =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// not passing AT.REMOVEDIR</span>
</span>
<span class="line" id="L1839">                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1840">            };</span>
<span class="line" id="L1841">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1842">            <span class="tok-kw">const</span> sub_path_c = <span class="tok-kw">try</span> os.toPosixPath(sub_path);</span>
<span class="line" id="L1843">            <span class="tok-kw">return</span> self.deleteFileZ(&amp;sub_path_c);</span>
<span class="line" id="L1844">        }</span>
<span class="line" id="L1845">    }</span>
<span class="line" id="L1846"></span>
<span class="line" id="L1847">    <span class="tok-comment">/// Same as `deleteFile` except the parameter is null-terminated.</span></span>
<span class="line" id="L1848">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteFileZ</span>(self: Dir, sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) DeleteFileError!<span class="tok-type">void</span> {</span>
<span class="line" id="L1849">        os.unlinkatZ(self.fd, sub_path_c, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1850">            <span class="tok-kw">error</span>.DirNotEmpty =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// not passing AT.REMOVEDIR</span>
</span>
<span class="line" id="L1851">            <span class="tok-kw">error</span>.AccessDenied =&gt; |e| <span class="tok-kw">switch</span> (builtin.os.tag) {</span>
<span class="line" id="L1852">                <span class="tok-comment">// non-Linux POSIX systems return EPERM when trying to delete a directory, so</span>
</span>
<span class="line" id="L1853">                <span class="tok-comment">// we need to handle that case specifically and translate the error</span>
</span>
<span class="line" id="L1854">                .macos, .ios, .freebsd, .netbsd, .dragonfly, .openbsd, .solaris =&gt; {</span>
<span class="line" id="L1855">                    <span class="tok-comment">// Don't follow symlinks to match unlinkat (which acts on symlinks rather than follows them)</span>
</span>
<span class="line" id="L1856">                    <span class="tok-kw">const</span> fstat = os.fstatatZ(self.fd, sub_path_c, os.AT.SYMLINK_NOFOLLOW) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> e;</span>
<span class="line" id="L1857">                    <span class="tok-kw">const</span> is_dir = fstat.mode &amp; os.S.IFMT == os.S.IFDIR;</span>
<span class="line" id="L1858">                    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (is_dir) <span class="tok-kw">error</span>.IsDir <span class="tok-kw">else</span> e;</span>
<span class="line" id="L1859">                },</span>
<span class="line" id="L1860">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1861">            },</span>
<span class="line" id="L1862">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1863">        };</span>
<span class="line" id="L1864">    }</span>
<span class="line" id="L1865"></span>
<span class="line" id="L1866">    <span class="tok-comment">/// Same as `deleteFile` except the parameter is WTF-16 encoded.</span></span>
<span class="line" id="L1867">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteFileW</span>(self: Dir, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>) DeleteFileError!<span class="tok-type">void</span> {</span>
<span class="line" id="L1868">        os.unlinkatW(self.fd, sub_path_w, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1869">            <span class="tok-kw">error</span>.DirNotEmpty =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// not passing AT.REMOVEDIR</span>
</span>
<span class="line" id="L1870">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1871">        };</span>
<span class="line" id="L1872">    }</span>
<span class="line" id="L1873"></span>
<span class="line" id="L1874">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> DeleteDirError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L1875">        DirNotEmpty,</span>
<span class="line" id="L1876">        FileNotFound,</span>
<span class="line" id="L1877">        AccessDenied,</span>
<span class="line" id="L1878">        FileBusy,</span>
<span class="line" id="L1879">        FileSystem,</span>
<span class="line" id="L1880">        SymLinkLoop,</span>
<span class="line" id="L1881">        NameTooLong,</span>
<span class="line" id="L1882">        NotDir,</span>
<span class="line" id="L1883">        SystemResources,</span>
<span class="line" id="L1884">        ReadOnlyFileSystem,</span>
<span class="line" id="L1885">        InvalidUtf8,</span>
<span class="line" id="L1886">        BadPathName,</span>
<span class="line" id="L1887">        <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span></span>
<span class="line" id="L1888">        NetworkNotFound,</span>
<span class="line" id="L1889">        Unexpected,</span>
<span class="line" id="L1890">    };</span>
<span class="line" id="L1891"></span>
<span class="line" id="L1892">    <span class="tok-comment">/// Returns `error.DirNotEmpty` if the directory is not empty.</span></span>
<span class="line" id="L1893">    <span class="tok-comment">/// To delete a directory recursively, see `deleteTree`.</span></span>
<span class="line" id="L1894">    <span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span></span>
<span class="line" id="L1895">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteDir</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) DeleteDirError!<span class="tok-type">void</span> {</span>
<span class="line" id="L1896">        <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L1897">            <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> os.windows.sliceToPrefixedFileW(sub_path);</span>
<span class="line" id="L1898">            <span class="tok-kw">return</span> self.deleteDirW(sub_path_w.span());</span>
<span class="line" id="L1899">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (builtin.os.tag == .wasi <span class="tok-kw">and</span> !builtin.link_libc) {</span>
<span class="line" id="L1900">            os.unlinkat(self.fd, sub_path, os.AT.REMOVEDIR) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1901">                <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// not possible since we pass AT.REMOVEDIR</span>
</span>
<span class="line" id="L1902">                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1903">            };</span>
<span class="line" id="L1904">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1905">            <span class="tok-kw">const</span> sub_path_c = <span class="tok-kw">try</span> os.toPosixPath(sub_path);</span>
<span class="line" id="L1906">            <span class="tok-kw">return</span> self.deleteDirZ(&amp;sub_path_c);</span>
<span class="line" id="L1907">        }</span>
<span class="line" id="L1908">    }</span>
<span class="line" id="L1909"></span>
<span class="line" id="L1910">    <span class="tok-comment">/// Same as `deleteDir` except the parameter is null-terminated.</span></span>
<span class="line" id="L1911">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteDirZ</span>(self: Dir, sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) DeleteDirError!<span class="tok-type">void</span> {</span>
<span class="line" id="L1912">        os.unlinkatZ(self.fd, sub_path_c, os.AT.REMOVEDIR) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1913">            <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// not possible since we pass AT.REMOVEDIR</span>
</span>
<span class="line" id="L1914">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1915">        };</span>
<span class="line" id="L1916">    }</span>
<span class="line" id="L1917"></span>
<span class="line" id="L1918">    <span class="tok-comment">/// Same as `deleteDir` except the parameter is UTF16LE, NT prefixed.</span></span>
<span class="line" id="L1919">    <span class="tok-comment">/// This function is Windows-only.</span></span>
<span class="line" id="L1920">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteDirW</span>(self: Dir, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>) DeleteDirError!<span class="tok-type">void</span> {</span>
<span class="line" id="L1921">        os.unlinkatW(self.fd, sub_path_w, os.AT.REMOVEDIR) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1922">            <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// not possible since we pass AT.REMOVEDIR</span>
</span>
<span class="line" id="L1923">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1924">        };</span>
<span class="line" id="L1925">    }</span>
<span class="line" id="L1926"></span>
<span class="line" id="L1927">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> RenameError = os.RenameError;</span>
<span class="line" id="L1928"></span>
<span class="line" id="L1929">    <span class="tok-comment">/// Change the name or location of a file or directory.</span></span>
<span class="line" id="L1930">    <span class="tok-comment">/// If new_sub_path already exists, it will be replaced.</span></span>
<span class="line" id="L1931">    <span class="tok-comment">/// Renaming a file over an existing directory or a directory</span></span>
<span class="line" id="L1932">    <span class="tok-comment">/// over an existing file will fail with `error.IsDir` or `error.NotDir`</span></span>
<span class="line" id="L1933">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rename</span>(self: Dir, old_sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) RenameError!<span class="tok-type">void</span> {</span>
<span class="line" id="L1934">        <span class="tok-kw">return</span> os.renameat(self.fd, old_sub_path, self.fd, new_sub_path);</span>
<span class="line" id="L1935">    }</span>
<span class="line" id="L1936"></span>
<span class="line" id="L1937">    <span class="tok-comment">/// Same as `rename` except the parameters are null-terminated.</span></span>
<span class="line" id="L1938">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameZ</span>(self: Dir, old_sub_path_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_sub_path_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) RenameError!<span class="tok-type">void</span> {</span>
<span class="line" id="L1939">        <span class="tok-kw">return</span> os.renameatZ(self.fd, old_sub_path_z, self.fd, new_sub_path_z);</span>
<span class="line" id="L1940">    }</span>
<span class="line" id="L1941"></span>
<span class="line" id="L1942">    <span class="tok-comment">/// Same as `rename` except the parameters are UTF16LE, NT prefixed.</span></span>
<span class="line" id="L1943">    <span class="tok-comment">/// This function is Windows-only.</span></span>
<span class="line" id="L1944">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameW</span>(self: Dir, old_sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, new_sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>) RenameError!<span class="tok-type">void</span> {</span>
<span class="line" id="L1945">        <span class="tok-kw">return</span> os.renameatW(self.fd, old_sub_path_w, self.fd, new_sub_path_w);</span>
<span class="line" id="L1946">    }</span>
<span class="line" id="L1947"></span>
<span class="line" id="L1948">    <span class="tok-comment">/// Creates a symbolic link named `sym_link_path` which contains the string `target_path`.</span></span>
<span class="line" id="L1949">    <span class="tok-comment">/// A symbolic link (also known as a soft link) may point to an existing file or to a nonexistent</span></span>
<span class="line" id="L1950">    <span class="tok-comment">/// one; the latter case is known as a dangling link.</span></span>
<span class="line" id="L1951">    <span class="tok-comment">/// If `sym_link_path` exists, it will not be overwritten.</span></span>
<span class="line" id="L1952">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLink</span>(</span>
<span class="line" id="L1953">        self: Dir,</span>
<span class="line" id="L1954">        target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1955">        sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1956">        flags: SymLinkFlags,</span>
<span class="line" id="L1957">    ) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1958">        <span class="tok-kw">if</span> (builtin.os.tag == .wasi <span class="tok-kw">and</span> !builtin.link_libc) {</span>
<span class="line" id="L1959">            <span class="tok-kw">return</span> self.symLinkWasi(target_path, sym_link_path, flags);</span>
<span class="line" id="L1960">        }</span>
<span class="line" id="L1961">        <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L1962">            <span class="tok-kw">const</span> target_path_w = <span class="tok-kw">try</span> os.windows.sliceToPrefixedFileW(target_path);</span>
<span class="line" id="L1963">            <span class="tok-kw">const</span> sym_link_path_w = <span class="tok-kw">try</span> os.windows.sliceToPrefixedFileW(sym_link_path);</span>
<span class="line" id="L1964">            <span class="tok-kw">return</span> self.symLinkW(target_path_w.span(), sym_link_path_w.span(), flags);</span>
<span class="line" id="L1965">        }</span>
<span class="line" id="L1966">        <span class="tok-kw">const</span> target_path_c = <span class="tok-kw">try</span> os.toPosixPath(target_path);</span>
<span class="line" id="L1967">        <span class="tok-kw">const</span> sym_link_path_c = <span class="tok-kw">try</span> os.toPosixPath(sym_link_path);</span>
<span class="line" id="L1968">        <span class="tok-kw">return</span> self.symLinkZ(&amp;target_path_c, &amp;sym_link_path_c, flags);</span>
<span class="line" id="L1969">    }</span>
<span class="line" id="L1970"></span>
<span class="line" id="L1971">    <span class="tok-comment">/// WASI-only. Same as `symLink` except targeting WASI.</span></span>
<span class="line" id="L1972">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLinkWasi</span>(</span>
<span class="line" id="L1973">        self: Dir,</span>
<span class="line" id="L1974">        target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1975">        sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1976">        _: SymLinkFlags,</span>
<span class="line" id="L1977">    ) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1978">        <span class="tok-kw">return</span> os.symlinkat(target_path, self.fd, sym_link_path);</span>
<span class="line" id="L1979">    }</span>
<span class="line" id="L1980"></span>
<span class="line" id="L1981">    <span class="tok-comment">/// Same as `symLink`, except the pathname parameters are null-terminated.</span></span>
<span class="line" id="L1982">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLinkZ</span>(</span>
<span class="line" id="L1983">        self: Dir,</span>
<span class="line" id="L1984">        target_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1985">        sym_link_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1986">        flags: SymLinkFlags,</span>
<span class="line" id="L1987">    ) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1988">        <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L1989">            <span class="tok-kw">const</span> target_path_w = <span class="tok-kw">try</span> os.windows.cStrToPrefixedFileW(target_path_c);</span>
<span class="line" id="L1990">            <span class="tok-kw">const</span> sym_link_path_w = <span class="tok-kw">try</span> os.windows.cStrToPrefixedFileW(sym_link_path_c);</span>
<span class="line" id="L1991">            <span class="tok-kw">return</span> self.symLinkW(target_path_w.span(), sym_link_path_w.span(), flags);</span>
<span class="line" id="L1992">        }</span>
<span class="line" id="L1993">        <span class="tok-kw">return</span> os.symlinkatZ(target_path_c, self.fd, sym_link_path_c);</span>
<span class="line" id="L1994">    }</span>
<span class="line" id="L1995"></span>
<span class="line" id="L1996">    <span class="tok-comment">/// Windows-only. Same as `symLink` except the pathname parameters</span></span>
<span class="line" id="L1997">    <span class="tok-comment">/// are null-terminated, WTF16 encoded.</span></span>
<span class="line" id="L1998">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLinkW</span>(</span>
<span class="line" id="L1999">        self: Dir,</span>
<span class="line" id="L2000">        target_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>,</span>
<span class="line" id="L2001">        sym_link_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>,</span>
<span class="line" id="L2002">        flags: SymLinkFlags,</span>
<span class="line" id="L2003">    ) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2004">        <span class="tok-kw">return</span> os.windows.CreateSymbolicLink(self.fd, sym_link_path_w, target_path_w, flags.is_directory);</span>
<span class="line" id="L2005">    }</span>
<span class="line" id="L2006"></span>
<span class="line" id="L2007">    <span class="tok-comment">/// Read value of a symbolic link.</span></span>
<span class="line" id="L2008">    <span class="tok-comment">/// The return value is a slice of `buffer`, from index `0`.</span></span>
<span class="line" id="L2009">    <span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span></span>
<span class="line" id="L2010">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLink</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L2011">        <span class="tok-kw">if</span> (builtin.os.tag == .wasi <span class="tok-kw">and</span> !builtin.link_libc) {</span>
<span class="line" id="L2012">            <span class="tok-kw">return</span> self.readLinkWasi(sub_path, buffer);</span>
<span class="line" id="L2013">        }</span>
<span class="line" id="L2014">        <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L2015">            <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> os.windows.sliceToPrefixedFileW(sub_path);</span>
<span class="line" id="L2016">            <span class="tok-kw">return</span> self.readLinkW(sub_path_w.span(), buffer);</span>
<span class="line" id="L2017">        }</span>
<span class="line" id="L2018">        <span class="tok-kw">const</span> sub_path_c = <span class="tok-kw">try</span> os.toPosixPath(sub_path);</span>
<span class="line" id="L2019">        <span class="tok-kw">return</span> self.readLinkZ(&amp;sub_path_c, buffer);</span>
<span class="line" id="L2020">    }</span>
<span class="line" id="L2021"></span>
<span class="line" id="L2022">    <span class="tok-comment">/// WASI-only. Same as `readLink` except targeting WASI.</span></span>
<span class="line" id="L2023">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLinkWasi</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L2024">        <span class="tok-kw">return</span> os.readlinkat(self.fd, sub_path, buffer);</span>
<span class="line" id="L2025">    }</span>
<span class="line" id="L2026"></span>
<span class="line" id="L2027">    <span class="tok-comment">/// Same as `readLink`, except the `pathname` parameter is null-terminated.</span></span>
<span class="line" id="L2028">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLinkZ</span>(self: Dir, sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L2029">        <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L2030">            <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> os.windows.cStrToPrefixedFileW(sub_path_c);</span>
<span class="line" id="L2031">            <span class="tok-kw">return</span> self.readLinkW(sub_path_w.span(), buffer);</span>
<span class="line" id="L2032">        }</span>
<span class="line" id="L2033">        <span class="tok-kw">return</span> os.readlinkatZ(self.fd, sub_path_c, buffer);</span>
<span class="line" id="L2034">    }</span>
<span class="line" id="L2035"></span>
<span class="line" id="L2036">    <span class="tok-comment">/// Windows-only. Same as `readLink` except the pathname parameter</span></span>
<span class="line" id="L2037">    <span class="tok-comment">/// is null-terminated, WTF16 encoded.</span></span>
<span class="line" id="L2038">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLinkW</span>(self: Dir, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L2039">        <span class="tok-kw">return</span> os.windows.ReadLink(self.fd, sub_path_w, buffer);</span>
<span class="line" id="L2040">    }</span>
<span class="line" id="L2041"></span>
<span class="line" id="L2042">    <span class="tok-comment">/// Read all of file contents using a preallocated buffer.</span></span>
<span class="line" id="L2043">    <span class="tok-comment">/// The returned slice has the same pointer as `buffer`. If the length matches `buffer.len`</span></span>
<span class="line" id="L2044">    <span class="tok-comment">/// the situation is ambiguous. It could either mean that the entire file was read, and</span></span>
<span class="line" id="L2045">    <span class="tok-comment">/// it exactly fits the buffer, or it could mean the buffer was not big enough for the</span></span>
<span class="line" id="L2046">    <span class="tok-comment">/// entire file.</span></span>
<span class="line" id="L2047">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readFile</span>(self: Dir, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L2048">        <span class="tok-kw">var</span> file = <span class="tok-kw">try</span> self.openFile(file_path, .{});</span>
<span class="line" id="L2049">        <span class="tok-kw">defer</span> file.close();</span>
<span class="line" id="L2050"></span>
<span class="line" id="L2051">        <span class="tok-kw">const</span> end_index = <span class="tok-kw">try</span> file.readAll(buffer);</span>
<span class="line" id="L2052">        <span class="tok-kw">return</span> buffer[<span class="tok-number">0</span>..end_index];</span>
<span class="line" id="L2053">    }</span>
<span class="line" id="L2054"></span>
<span class="line" id="L2055">    <span class="tok-comment">/// On success, caller owns returned buffer.</span></span>
<span class="line" id="L2056">    <span class="tok-comment">/// If the file is larger than `max_bytes`, returns `error.FileTooBig`.</span></span>
<span class="line" id="L2057">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readFileAlloc</span>(self: Dir, allocator: mem.Allocator, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, max_bytes: <span class="tok-type">usize</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L2058">        <span class="tok-kw">return</span> self.readFileAllocOptions(allocator, file_path, max_bytes, <span class="tok-null">null</span>, <span class="tok-builtin">@alignOf</span>(<span class="tok-type">u8</span>), <span class="tok-null">null</span>);</span>
<span class="line" id="L2059">    }</span>
<span class="line" id="L2060"></span>
<span class="line" id="L2061">    <span class="tok-comment">/// On success, caller owns returned buffer.</span></span>
<span class="line" id="L2062">    <span class="tok-comment">/// If the file is larger than `max_bytes`, returns `error.FileTooBig`.</span></span>
<span class="line" id="L2063">    <span class="tok-comment">/// If `size_hint` is specified the initial buffer size is calculated using</span></span>
<span class="line" id="L2064">    <span class="tok-comment">/// that value, otherwise the effective file size is used instead.</span></span>
<span class="line" id="L2065">    <span class="tok-comment">/// Allows specifying alignment and a sentinel value.</span></span>
<span class="line" id="L2066">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readFileAllocOptions</span>(</span>
<span class="line" id="L2067">        self: Dir,</span>
<span class="line" id="L2068">        allocator: mem.Allocator,</span>
<span class="line" id="L2069">        file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2070">        max_bytes: <span class="tok-type">usize</span>,</span>
<span class="line" id="L2071">        size_hint: ?<span class="tok-type">usize</span>,</span>
<span class="line" id="L2072">        <span class="tok-kw">comptime</span> alignment: <span class="tok-type">u29</span>,</span>
<span class="line" id="L2073">        <span class="tok-kw">comptime</span> optional_sentinel: ?<span class="tok-type">u8</span>,</span>
<span class="line" id="L2074">    ) !(<span class="tok-kw">if</span> (optional_sentinel) |s| [:s]<span class="tok-kw">align</span>(alignment) <span class="tok-type">u8</span> <span class="tok-kw">else</span> []<span class="tok-kw">align</span>(alignment) <span class="tok-type">u8</span>) {</span>
<span class="line" id="L2075">        <span class="tok-kw">var</span> file = <span class="tok-kw">try</span> self.openFile(file_path, .{});</span>
<span class="line" id="L2076">        <span class="tok-kw">defer</span> file.close();</span>
<span class="line" id="L2077"></span>
<span class="line" id="L2078">        <span class="tok-comment">// If the file size doesn't fit a usize it'll be certainly greater than</span>
</span>
<span class="line" id="L2079">        <span class="tok-comment">// `max_bytes`</span>
</span>
<span class="line" id="L2080">        <span class="tok-kw">const</span> stat_size = size_hint <span class="tok-kw">orelse</span> math.cast(<span class="tok-type">usize</span>, <span class="tok-kw">try</span> file.getEndPos()) <span class="tok-kw">orelse</span></span>
<span class="line" id="L2081">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig;</span>
<span class="line" id="L2082"></span>
<span class="line" id="L2083">        <span class="tok-kw">return</span> file.readToEndAllocOptions(allocator, max_bytes, stat_size, alignment, optional_sentinel);</span>
<span class="line" id="L2084">    }</span>
<span class="line" id="L2085"></span>
<span class="line" id="L2086">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> DeleteTreeError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L2087">        InvalidHandle,</span>
<span class="line" id="L2088">        AccessDenied,</span>
<span class="line" id="L2089">        FileTooBig,</span>
<span class="line" id="L2090">        SymLinkLoop,</span>
<span class="line" id="L2091">        ProcessFdQuotaExceeded,</span>
<span class="line" id="L2092">        NameTooLong,</span>
<span class="line" id="L2093">        SystemFdQuotaExceeded,</span>
<span class="line" id="L2094">        NoDevice,</span>
<span class="line" id="L2095">        SystemResources,</span>
<span class="line" id="L2096">        ReadOnlyFileSystem,</span>
<span class="line" id="L2097">        FileSystem,</span>
<span class="line" id="L2098">        FileBusy,</span>
<span class="line" id="L2099">        DeviceBusy,</span>
<span class="line" id="L2100"></span>
<span class="line" id="L2101">        <span class="tok-comment">/// One of the path components was not a directory.</span></span>
<span class="line" id="L2102">        <span class="tok-comment">/// This error is unreachable if `sub_path` does not contain a path separator.</span></span>
<span class="line" id="L2103">        NotDir,</span>
<span class="line" id="L2104"></span>
<span class="line" id="L2105">        <span class="tok-comment">/// On Windows, file paths must be valid Unicode.</span></span>
<span class="line" id="L2106">        InvalidUtf8,</span>
<span class="line" id="L2107"></span>
<span class="line" id="L2108">        <span class="tok-comment">/// On Windows, file paths cannot contain these characters:</span></span>
<span class="line" id="L2109">        <span class="tok-comment">/// '/', '*', '?', '&quot;', '&lt;', '&gt;', '|'</span></span>
<span class="line" id="L2110">        BadPathName,</span>
<span class="line" id="L2111"></span>
<span class="line" id="L2112">        <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span></span>
<span class="line" id="L2113">        NetworkNotFound,</span>
<span class="line" id="L2114">    } || os.UnexpectedError;</span>
<span class="line" id="L2115"></span>
<span class="line" id="L2116">    <span class="tok-comment">/// Whether `full_path` describes a symlink, file, or directory, this function</span></span>
<span class="line" id="L2117">    <span class="tok-comment">/// removes it. If it cannot be removed because it is a non-empty directory,</span></span>
<span class="line" id="L2118">    <span class="tok-comment">/// this function recursively removes its entries and then tries again.</span></span>
<span class="line" id="L2119">    <span class="tok-comment">/// This operation is not atomic on most file systems.</span></span>
<span class="line" id="L2120">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteTree</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) DeleteTreeError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2121">        <span class="tok-kw">var</span> initial_iterable_dir = (<span class="tok-kw">try</span> self.deleteTreeOpenInitialSubpath(sub_path, .file)) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L2122"></span>
<span class="line" id="L2123">        <span class="tok-kw">const</span> StackItem = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2124">            name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2125">            parent_dir: Dir,</span>
<span class="line" id="L2126">            iter: IterableDir.Iterator,</span>
<span class="line" id="L2127">        };</span>
<span class="line" id="L2128"></span>
<span class="line" id="L2129">        <span class="tok-kw">var</span> stack = std.BoundedArray(StackItem, <span class="tok-number">16</span>){};</span>
<span class="line" id="L2130">        <span class="tok-kw">defer</span> {</span>
<span class="line" id="L2131">            <span class="tok-kw">for</span> (stack.slice()) |*item| {</span>
<span class="line" id="L2132">                item.iter.dir.close();</span>
<span class="line" id="L2133">            }</span>
<span class="line" id="L2134">        }</span>
<span class="line" id="L2135"></span>
<span class="line" id="L2136">        stack.appendAssumeCapacity(StackItem{</span>
<span class="line" id="L2137">            .name = sub_path,</span>
<span class="line" id="L2138">            .parent_dir = self,</span>
<span class="line" id="L2139">            .iter = initial_iterable_dir.iterateAssumeFirstIteration(),</span>
<span class="line" id="L2140">        });</span>
<span class="line" id="L2141"></span>
<span class="line" id="L2142">        process_stack: <span class="tok-kw">while</span> (stack.len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L2143">            <span class="tok-kw">var</span> top = &amp;(stack.slice()[stack.len - <span class="tok-number">1</span>]);</span>
<span class="line" id="L2144">            <span class="tok-kw">while</span> (<span class="tok-kw">try</span> top.iter.next()) |entry| {</span>
<span class="line" id="L2145">                <span class="tok-kw">var</span> treat_as_dir = entry.kind == .directory;</span>
<span class="line" id="L2146">                handle_entry: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L2147">                    <span class="tok-kw">if</span> (treat_as_dir) {</span>
<span class="line" id="L2148">                        <span class="tok-kw">if</span> (stack.ensureUnusedCapacity(<span class="tok-number">1</span>)) {</span>
<span class="line" id="L2149">                            <span class="tok-kw">var</span> iterable_dir = top.iter.dir.openIterableDir(entry.name, .{ .no_follow = <span class="tok-null">true</span> }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2150">                                <span class="tok-kw">error</span>.NotDir =&gt; {</span>
<span class="line" id="L2151">                                    treat_as_dir = <span class="tok-null">false</span>;</span>
<span class="line" id="L2152">                                    <span class="tok-kw">continue</span> :handle_entry;</span>
<span class="line" id="L2153">                                },</span>
<span class="line" id="L2154">                                <span class="tok-kw">error</span>.FileNotFound =&gt; {</span>
<span class="line" id="L2155">                                    <span class="tok-comment">// That's fine, we were trying to remove this directory anyway.</span>
</span>
<span class="line" id="L2156">                                    <span class="tok-kw">break</span> :handle_entry;</span>
<span class="line" id="L2157">                                },</span>
<span class="line" id="L2158"></span>
<span class="line" id="L2159">                                <span class="tok-kw">error</span>.InvalidHandle,</span>
<span class="line" id="L2160">                                <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L2161">                                <span class="tok-kw">error</span>.SymLinkLoop,</span>
<span class="line" id="L2162">                                <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,</span>
<span class="line" id="L2163">                                <span class="tok-kw">error</span>.NameTooLong,</span>
<span class="line" id="L2164">                                <span class="tok-kw">error</span>.SystemFdQuotaExceeded,</span>
<span class="line" id="L2165">                                <span class="tok-kw">error</span>.NoDevice,</span>
<span class="line" id="L2166">                                <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L2167">                                <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L2168">                                <span class="tok-kw">error</span>.InvalidUtf8,</span>
<span class="line" id="L2169">                                <span class="tok-kw">error</span>.BadPathName,</span>
<span class="line" id="L2170">                                <span class="tok-kw">error</span>.NetworkNotFound,</span>
<span class="line" id="L2171">                                <span class="tok-kw">error</span>.DeviceBusy,</span>
<span class="line" id="L2172">                                =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L2173">                            };</span>
<span class="line" id="L2174">                            stack.appendAssumeCapacity(StackItem{</span>
<span class="line" id="L2175">                                .name = entry.name,</span>
<span class="line" id="L2176">                                .parent_dir = top.iter.dir,</span>
<span class="line" id="L2177">                                .iter = iterable_dir.iterateAssumeFirstIteration(),</span>
<span class="line" id="L2178">                            });</span>
<span class="line" id="L2179">                            <span class="tok-kw">continue</span> :process_stack;</span>
<span class="line" id="L2180">                        } <span class="tok-kw">else</span> |_| {</span>
<span class="line" id="L2181">                            <span class="tok-kw">try</span> top.iter.dir.deleteTreeMinStackSizeWithKindHint(entry.name, entry.kind);</span>
<span class="line" id="L2182">                            <span class="tok-kw">break</span> :handle_entry;</span>
<span class="line" id="L2183">                        }</span>
<span class="line" id="L2184">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2185">                        <span class="tok-kw">if</span> (top.iter.dir.deleteFile(entry.name)) {</span>
<span class="line" id="L2186">                            <span class="tok-kw">break</span> :handle_entry;</span>
<span class="line" id="L2187">                        } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2188">                            <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">break</span> :handle_entry,</span>
<span class="line" id="L2189"></span>
<span class="line" id="L2190">                            <span class="tok-comment">// Impossible because we do not pass any path separators.</span>
</span>
<span class="line" id="L2191">                            <span class="tok-kw">error</span>.NotDir =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L2192"></span>
<span class="line" id="L2193">                            <span class="tok-kw">error</span>.IsDir =&gt; {</span>
<span class="line" id="L2194">                                treat_as_dir = <span class="tok-null">true</span>;</span>
<span class="line" id="L2195">                                <span class="tok-kw">continue</span> :handle_entry;</span>
<span class="line" id="L2196">                            },</span>
<span class="line" id="L2197"></span>
<span class="line" id="L2198">                            <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L2199">                            <span class="tok-kw">error</span>.InvalidUtf8,</span>
<span class="line" id="L2200">                            <span class="tok-kw">error</span>.SymLinkLoop,</span>
<span class="line" id="L2201">                            <span class="tok-kw">error</span>.NameTooLong,</span>
<span class="line" id="L2202">                            <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L2203">                            <span class="tok-kw">error</span>.ReadOnlyFileSystem,</span>
<span class="line" id="L2204">                            <span class="tok-kw">error</span>.FileSystem,</span>
<span class="line" id="L2205">                            <span class="tok-kw">error</span>.FileBusy,</span>
<span class="line" id="L2206">                            <span class="tok-kw">error</span>.BadPathName,</span>
<span class="line" id="L2207">                            <span class="tok-kw">error</span>.NetworkNotFound,</span>
<span class="line" id="L2208">                            <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L2209">                            =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L2210">                        }</span>
<span class="line" id="L2211">                    }</span>
<span class="line" id="L2212">                }</span>
<span class="line" id="L2213">            }</span>
<span class="line" id="L2214"></span>
<span class="line" id="L2215">            <span class="tok-comment">// On Windows, we can't delete until the dir's handle has been closed, so</span>
</span>
<span class="line" id="L2216">            <span class="tok-comment">// close it before we try to delete.</span>
</span>
<span class="line" id="L2217">            top.iter.dir.close();</span>
<span class="line" id="L2218"></span>
<span class="line" id="L2219">            <span class="tok-comment">// In order to avoid double-closing the directory when cleaning up</span>
</span>
<span class="line" id="L2220">            <span class="tok-comment">// the stack in the case of an error, we save the relevant portions and</span>
</span>
<span class="line" id="L2221">            <span class="tok-comment">// pop the value from the stack.</span>
</span>
<span class="line" id="L2222">            <span class="tok-kw">const</span> parent_dir = top.parent_dir;</span>
<span class="line" id="L2223">            <span class="tok-kw">const</span> name = top.name;</span>
<span class="line" id="L2224">            _ = stack.pop();</span>
<span class="line" id="L2225"></span>
<span class="line" id="L2226">            <span class="tok-kw">var</span> need_to_retry: <span class="tok-type">bool</span> = <span class="tok-null">false</span>;</span>
<span class="line" id="L2227">            parent_dir.deleteDir(name) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2228">                <span class="tok-kw">error</span>.FileNotFound =&gt; {},</span>
<span class="line" id="L2229">                <span class="tok-kw">error</span>.DirNotEmpty =&gt; need_to_retry = <span class="tok-null">true</span>,</span>
<span class="line" id="L2230">                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L2231">            };</span>
<span class="line" id="L2232"></span>
<span class="line" id="L2233">            <span class="tok-kw">if</span> (need_to_retry) {</span>
<span class="line" id="L2234">                <span class="tok-comment">// Since we closed the handle that the previous iterator used, we</span>
</span>
<span class="line" id="L2235">                <span class="tok-comment">// need to re-open the dir and re-create the iterator.</span>
</span>
<span class="line" id="L2236">                <span class="tok-kw">var</span> iterable_dir = iterable_dir: {</span>
<span class="line" id="L2237">                    <span class="tok-kw">var</span> treat_as_dir = <span class="tok-null">true</span>;</span>
<span class="line" id="L2238">                    handle_entry: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L2239">                        <span class="tok-kw">if</span> (treat_as_dir) {</span>
<span class="line" id="L2240">                            <span class="tok-kw">break</span> :iterable_dir parent_dir.openIterableDir(name, .{ .no_follow = <span class="tok-null">true</span> }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2241">                                <span class="tok-kw">error</span>.NotDir =&gt; {</span>
<span class="line" id="L2242">                                    treat_as_dir = <span class="tok-null">false</span>;</span>
<span class="line" id="L2243">                                    <span class="tok-kw">continue</span> :handle_entry;</span>
<span class="line" id="L2244">                                },</span>
<span class="line" id="L2245">                                <span class="tok-kw">error</span>.FileNotFound =&gt; {</span>
<span class="line" id="L2246">                                    <span class="tok-comment">// That's fine, we were trying to remove this directory anyway.</span>
</span>
<span class="line" id="L2247">                                    <span class="tok-kw">continue</span> :process_stack;</span>
<span class="line" id="L2248">                                },</span>
<span class="line" id="L2249"></span>
<span class="line" id="L2250">                                <span class="tok-kw">error</span>.InvalidHandle,</span>
<span class="line" id="L2251">                                <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L2252">                                <span class="tok-kw">error</span>.SymLinkLoop,</span>
<span class="line" id="L2253">                                <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,</span>
<span class="line" id="L2254">                                <span class="tok-kw">error</span>.NameTooLong,</span>
<span class="line" id="L2255">                                <span class="tok-kw">error</span>.SystemFdQuotaExceeded,</span>
<span class="line" id="L2256">                                <span class="tok-kw">error</span>.NoDevice,</span>
<span class="line" id="L2257">                                <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L2258">                                <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L2259">                                <span class="tok-kw">error</span>.InvalidUtf8,</span>
<span class="line" id="L2260">                                <span class="tok-kw">error</span>.BadPathName,</span>
<span class="line" id="L2261">                                <span class="tok-kw">error</span>.NetworkNotFound,</span>
<span class="line" id="L2262">                                <span class="tok-kw">error</span>.DeviceBusy,</span>
<span class="line" id="L2263">                                =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L2264">                            };</span>
<span class="line" id="L2265">                        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2266">                            <span class="tok-kw">if</span> (parent_dir.deleteFile(name)) {</span>
<span class="line" id="L2267">                                <span class="tok-kw">continue</span> :process_stack;</span>
<span class="line" id="L2268">                            } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2269">                                <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">continue</span> :process_stack,</span>
<span class="line" id="L2270"></span>
<span class="line" id="L2271">                                <span class="tok-comment">// Impossible because we do not pass any path separators.</span>
</span>
<span class="line" id="L2272">                                <span class="tok-kw">error</span>.NotDir =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L2273"></span>
<span class="line" id="L2274">                                <span class="tok-kw">error</span>.IsDir =&gt; {</span>
<span class="line" id="L2275">                                    treat_as_dir = <span class="tok-null">true</span>;</span>
<span class="line" id="L2276">                                    <span class="tok-kw">continue</span> :handle_entry;</span>
<span class="line" id="L2277">                                },</span>
<span class="line" id="L2278"></span>
<span class="line" id="L2279">                                <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L2280">                                <span class="tok-kw">error</span>.InvalidUtf8,</span>
<span class="line" id="L2281">                                <span class="tok-kw">error</span>.SymLinkLoop,</span>
<span class="line" id="L2282">                                <span class="tok-kw">error</span>.NameTooLong,</span>
<span class="line" id="L2283">                                <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L2284">                                <span class="tok-kw">error</span>.ReadOnlyFileSystem,</span>
<span class="line" id="L2285">                                <span class="tok-kw">error</span>.FileSystem,</span>
<span class="line" id="L2286">                                <span class="tok-kw">error</span>.FileBusy,</span>
<span class="line" id="L2287">                                <span class="tok-kw">error</span>.BadPathName,</span>
<span class="line" id="L2288">                                <span class="tok-kw">error</span>.NetworkNotFound,</span>
<span class="line" id="L2289">                                <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L2290">                                =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L2291">                            }</span>
<span class="line" id="L2292">                        }</span>
<span class="line" id="L2293">                    }</span>
<span class="line" id="L2294">                };</span>
<span class="line" id="L2295">                <span class="tok-comment">// We know there is room on the stack since we are just re-adding</span>
</span>
<span class="line" id="L2296">                <span class="tok-comment">// the StackItem that we previously popped.</span>
</span>
<span class="line" id="L2297">                stack.appendAssumeCapacity(StackItem{</span>
<span class="line" id="L2298">                    .name = name,</span>
<span class="line" id="L2299">                    .parent_dir = parent_dir,</span>
<span class="line" id="L2300">                    .iter = iterable_dir.iterateAssumeFirstIteration(),</span>
<span class="line" id="L2301">                });</span>
<span class="line" id="L2302">                <span class="tok-kw">continue</span> :process_stack;</span>
<span class="line" id="L2303">            }</span>
<span class="line" id="L2304">        }</span>
<span class="line" id="L2305">    }</span>
<span class="line" id="L2306"></span>
<span class="line" id="L2307">    <span class="tok-comment">/// Like `deleteTree`, but only keeps one `Iterator` active at a time to minimize the function's stack size.</span></span>
<span class="line" id="L2308">    <span class="tok-comment">/// This is slower than `deleteTree` but uses less stack space.</span></span>
<span class="line" id="L2309">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteTreeMinStackSize</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) DeleteTreeError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2310">        <span class="tok-kw">return</span> self.deleteTreeMinStackSizeWithKindHint(sub_path, .file);</span>
<span class="line" id="L2311">    }</span>
<span class="line" id="L2312"></span>
<span class="line" id="L2313">    <span class="tok-kw">fn</span> <span class="tok-fn">deleteTreeMinStackSizeWithKindHint</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, kind_hint: File.Kind) DeleteTreeError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2314">        start_over: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L2315">            <span class="tok-kw">var</span> iterable_dir = (<span class="tok-kw">try</span> self.deleteTreeOpenInitialSubpath(sub_path, kind_hint)) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L2316">            <span class="tok-kw">var</span> cleanup_dir_parent: ?IterableDir = <span class="tok-null">null</span>;</span>
<span class="line" id="L2317">            <span class="tok-kw">defer</span> <span class="tok-kw">if</span> (cleanup_dir_parent) |*d| d.close();</span>
<span class="line" id="L2318"></span>
<span class="line" id="L2319">            <span class="tok-kw">var</span> cleanup_dir = <span class="tok-null">true</span>;</span>
<span class="line" id="L2320">            <span class="tok-kw">defer</span> <span class="tok-kw">if</span> (cleanup_dir) iterable_dir.close();</span>
<span class="line" id="L2321"></span>
<span class="line" id="L2322">            <span class="tok-comment">// Valid use of MAX_PATH_BYTES because dir_name_buf will only</span>
</span>
<span class="line" id="L2323">            <span class="tok-comment">// ever store a single path component that was returned from the</span>
</span>
<span class="line" id="L2324">            <span class="tok-comment">// filesystem.</span>
</span>
<span class="line" id="L2325">            <span class="tok-kw">var</span> dir_name_buf: [MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L2326">            <span class="tok-kw">var</span> dir_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = sub_path;</span>
<span class="line" id="L2327"></span>
<span class="line" id="L2328">            <span class="tok-comment">// Here we must avoid recursion, in order to provide O(1) memory guarantee of this function.</span>
</span>
<span class="line" id="L2329">            <span class="tok-comment">// Go through each entry and if it is not a directory, delete it. If it is a directory,</span>
</span>
<span class="line" id="L2330">            <span class="tok-comment">// open it, and close the original directory. Repeat. Then start the entire operation over.</span>
</span>
<span class="line" id="L2331"></span>
<span class="line" id="L2332">            scan_dir: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L2333">                <span class="tok-kw">var</span> dir_it = iterable_dir.iterateAssumeFirstIteration();</span>
<span class="line" id="L2334">                dir_it: <span class="tok-kw">while</span> (<span class="tok-kw">try</span> dir_it.next()) |entry| {</span>
<span class="line" id="L2335">                    <span class="tok-kw">var</span> treat_as_dir = entry.kind == .directory;</span>
<span class="line" id="L2336">                    handle_entry: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L2337">                        <span class="tok-kw">if</span> (treat_as_dir) {</span>
<span class="line" id="L2338">                            <span class="tok-kw">const</span> new_dir = iterable_dir.dir.openIterableDir(entry.name, .{ .no_follow = <span class="tok-null">true</span> }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2339">                                <span class="tok-kw">error</span>.NotDir =&gt; {</span>
<span class="line" id="L2340">                                    treat_as_dir = <span class="tok-null">false</span>;</span>
<span class="line" id="L2341">                                    <span class="tok-kw">continue</span> :handle_entry;</span>
<span class="line" id="L2342">                                },</span>
<span class="line" id="L2343">                                <span class="tok-kw">error</span>.FileNotFound =&gt; {</span>
<span class="line" id="L2344">                                    <span class="tok-comment">// That's fine, we were trying to remove this directory anyway.</span>
</span>
<span class="line" id="L2345">                                    <span class="tok-kw">continue</span> :dir_it;</span>
<span class="line" id="L2346">                                },</span>
<span class="line" id="L2347"></span>
<span class="line" id="L2348">                                <span class="tok-kw">error</span>.InvalidHandle,</span>
<span class="line" id="L2349">                                <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L2350">                                <span class="tok-kw">error</span>.SymLinkLoop,</span>
<span class="line" id="L2351">                                <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,</span>
<span class="line" id="L2352">                                <span class="tok-kw">error</span>.NameTooLong,</span>
<span class="line" id="L2353">                                <span class="tok-kw">error</span>.SystemFdQuotaExceeded,</span>
<span class="line" id="L2354">                                <span class="tok-kw">error</span>.NoDevice,</span>
<span class="line" id="L2355">                                <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L2356">                                <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L2357">                                <span class="tok-kw">error</span>.InvalidUtf8,</span>
<span class="line" id="L2358">                                <span class="tok-kw">error</span>.BadPathName,</span>
<span class="line" id="L2359">                                <span class="tok-kw">error</span>.NetworkNotFound,</span>
<span class="line" id="L2360">                                <span class="tok-kw">error</span>.DeviceBusy,</span>
<span class="line" id="L2361">                                =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L2362">                            };</span>
<span class="line" id="L2363">                            <span class="tok-kw">if</span> (cleanup_dir_parent) |*d| d.close();</span>
<span class="line" id="L2364">                            cleanup_dir_parent = iterable_dir;</span>
<span class="line" id="L2365">                            iterable_dir = new_dir;</span>
<span class="line" id="L2366">                            <span class="tok-kw">const</span> result = dir_name_buf[<span class="tok-number">0</span>..entry.name.len];</span>
<span class="line" id="L2367">                            <span class="tok-builtin">@memcpy</span>(result, entry.name);</span>
<span class="line" id="L2368">                            dir_name = result;</span>
<span class="line" id="L2369">                            <span class="tok-kw">continue</span> :scan_dir;</span>
<span class="line" id="L2370">                        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2371">                            <span class="tok-kw">if</span> (iterable_dir.dir.deleteFile(entry.name)) {</span>
<span class="line" id="L2372">                                <span class="tok-kw">continue</span> :dir_it;</span>
<span class="line" id="L2373">                            } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2374">                                <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">continue</span> :dir_it,</span>
<span class="line" id="L2375"></span>
<span class="line" id="L2376">                                <span class="tok-comment">// Impossible because we do not pass any path separators.</span>
</span>
<span class="line" id="L2377">                                <span class="tok-kw">error</span>.NotDir =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L2378"></span>
<span class="line" id="L2379">                                <span class="tok-kw">error</span>.IsDir =&gt; {</span>
<span class="line" id="L2380">                                    treat_as_dir = <span class="tok-null">true</span>;</span>
<span class="line" id="L2381">                                    <span class="tok-kw">continue</span> :handle_entry;</span>
<span class="line" id="L2382">                                },</span>
<span class="line" id="L2383"></span>
<span class="line" id="L2384">                                <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L2385">                                <span class="tok-kw">error</span>.InvalidUtf8,</span>
<span class="line" id="L2386">                                <span class="tok-kw">error</span>.SymLinkLoop,</span>
<span class="line" id="L2387">                                <span class="tok-kw">error</span>.NameTooLong,</span>
<span class="line" id="L2388">                                <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L2389">                                <span class="tok-kw">error</span>.ReadOnlyFileSystem,</span>
<span class="line" id="L2390">                                <span class="tok-kw">error</span>.FileSystem,</span>
<span class="line" id="L2391">                                <span class="tok-kw">error</span>.FileBusy,</span>
<span class="line" id="L2392">                                <span class="tok-kw">error</span>.BadPathName,</span>
<span class="line" id="L2393">                                <span class="tok-kw">error</span>.NetworkNotFound,</span>
<span class="line" id="L2394">                                <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L2395">                                =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L2396">                            }</span>
<span class="line" id="L2397">                        }</span>
<span class="line" id="L2398">                    }</span>
<span class="line" id="L2399">                }</span>
<span class="line" id="L2400">                <span class="tok-comment">// Reached the end of the directory entries, which means we successfully deleted all of them.</span>
</span>
<span class="line" id="L2401">                <span class="tok-comment">// Now to remove the directory itself.</span>
</span>
<span class="line" id="L2402">                iterable_dir.close();</span>
<span class="line" id="L2403">                cleanup_dir = <span class="tok-null">false</span>;</span>
<span class="line" id="L2404"></span>
<span class="line" id="L2405">                <span class="tok-kw">if</span> (cleanup_dir_parent) |d| {</span>
<span class="line" id="L2406">                    d.dir.deleteDir(dir_name) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2407">                        <span class="tok-comment">// These two things can happen due to file system race conditions.</span>
</span>
<span class="line" id="L2408">                        <span class="tok-kw">error</span>.FileNotFound, <span class="tok-kw">error</span>.DirNotEmpty =&gt; <span class="tok-kw">continue</span> :start_over,</span>
<span class="line" id="L2409">                        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L2410">                    };</span>
<span class="line" id="L2411">                    <span class="tok-kw">continue</span> :start_over;</span>
<span class="line" id="L2412">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2413">                    self.deleteDir(sub_path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2414">                        <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">return</span>,</span>
<span class="line" id="L2415">                        <span class="tok-kw">error</span>.DirNotEmpty =&gt; <span class="tok-kw">continue</span> :start_over,</span>
<span class="line" id="L2416">                        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L2417">                    };</span>
<span class="line" id="L2418">                    <span class="tok-kw">return</span>;</span>
<span class="line" id="L2419">                }</span>
<span class="line" id="L2420">            }</span>
<span class="line" id="L2421">        }</span>
<span class="line" id="L2422">    }</span>
<span class="line" id="L2423"></span>
<span class="line" id="L2424">    <span class="tok-comment">/// On successful delete, returns null.</span></span>
<span class="line" id="L2425">    <span class="tok-kw">fn</span> <span class="tok-fn">deleteTreeOpenInitialSubpath</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, kind_hint: File.Kind) !?IterableDir {</span>
<span class="line" id="L2426">        <span class="tok-kw">return</span> iterable_dir: {</span>
<span class="line" id="L2427">            <span class="tok-comment">// Treat as a file by default</span>
</span>
<span class="line" id="L2428">            <span class="tok-kw">var</span> treat_as_dir = kind_hint == .directory;</span>
<span class="line" id="L2429"></span>
<span class="line" id="L2430">            handle_entry: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L2431">                <span class="tok-kw">if</span> (treat_as_dir) {</span>
<span class="line" id="L2432">                    <span class="tok-kw">break</span> :iterable_dir self.openIterableDir(sub_path, .{ .no_follow = <span class="tok-null">true</span> }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2433">                        <span class="tok-kw">error</span>.NotDir =&gt; {</span>
<span class="line" id="L2434">                            treat_as_dir = <span class="tok-null">false</span>;</span>
<span class="line" id="L2435">                            <span class="tok-kw">continue</span> :handle_entry;</span>
<span class="line" id="L2436">                        },</span>
<span class="line" id="L2437">                        <span class="tok-kw">error</span>.FileNotFound =&gt; {</span>
<span class="line" id="L2438">                            <span class="tok-comment">// That's fine, we were trying to remove this directory anyway.</span>
</span>
<span class="line" id="L2439">                            <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2440">                        },</span>
<span class="line" id="L2441"></span>
<span class="line" id="L2442">                        <span class="tok-kw">error</span>.InvalidHandle,</span>
<span class="line" id="L2443">                        <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L2444">                        <span class="tok-kw">error</span>.SymLinkLoop,</span>
<span class="line" id="L2445">                        <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,</span>
<span class="line" id="L2446">                        <span class="tok-kw">error</span>.NameTooLong,</span>
<span class="line" id="L2447">                        <span class="tok-kw">error</span>.SystemFdQuotaExceeded,</span>
<span class="line" id="L2448">                        <span class="tok-kw">error</span>.NoDevice,</span>
<span class="line" id="L2449">                        <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L2450">                        <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L2451">                        <span class="tok-kw">error</span>.InvalidUtf8,</span>
<span class="line" id="L2452">                        <span class="tok-kw">error</span>.BadPathName,</span>
<span class="line" id="L2453">                        <span class="tok-kw">error</span>.DeviceBusy,</span>
<span class="line" id="L2454">                        <span class="tok-kw">error</span>.NetworkNotFound,</span>
<span class="line" id="L2455">                        =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L2456">                    };</span>
<span class="line" id="L2457">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2458">                    <span class="tok-kw">if</span> (self.deleteFile(sub_path)) {</span>
<span class="line" id="L2459">                        <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2460">                    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2461">                        <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,</span>
<span class="line" id="L2462"></span>
<span class="line" id="L2463">                        <span class="tok-kw">error</span>.IsDir =&gt; {</span>
<span class="line" id="L2464">                            treat_as_dir = <span class="tok-null">true</span>;</span>
<span class="line" id="L2465">                            <span class="tok-kw">continue</span> :handle_entry;</span>
<span class="line" id="L2466">                        },</span>
<span class="line" id="L2467"></span>
<span class="line" id="L2468">                        <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L2469">                        <span class="tok-kw">error</span>.InvalidUtf8,</span>
<span class="line" id="L2470">                        <span class="tok-kw">error</span>.SymLinkLoop,</span>
<span class="line" id="L2471">                        <span class="tok-kw">error</span>.NameTooLong,</span>
<span class="line" id="L2472">                        <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L2473">                        <span class="tok-kw">error</span>.ReadOnlyFileSystem,</span>
<span class="line" id="L2474">                        <span class="tok-kw">error</span>.NotDir,</span>
<span class="line" id="L2475">                        <span class="tok-kw">error</span>.FileSystem,</span>
<span class="line" id="L2476">                        <span class="tok-kw">error</span>.FileBusy,</span>
<span class="line" id="L2477">                        <span class="tok-kw">error</span>.BadPathName,</span>
<span class="line" id="L2478">                        <span class="tok-kw">error</span>.NetworkNotFound,</span>
<span class="line" id="L2479">                        <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L2480">                        =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L2481">                    }</span>
<span class="line" id="L2482">                }</span>
<span class="line" id="L2483">            }</span>
<span class="line" id="L2484">        };</span>
<span class="line" id="L2485">    }</span>
<span class="line" id="L2486"></span>
<span class="line" id="L2487">    <span class="tok-comment">/// Writes content to the file system, creating a new file if it does not exist, truncating</span></span>
<span class="line" id="L2488">    <span class="tok-comment">/// if it already exists.</span></span>
<span class="line" id="L2489">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeFile</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2490">        <span class="tok-kw">var</span> file = <span class="tok-kw">try</span> self.createFile(sub_path, .{});</span>
<span class="line" id="L2491">        <span class="tok-kw">defer</span> file.close();</span>
<span class="line" id="L2492">        <span class="tok-kw">try</span> file.writeAll(data);</span>
<span class="line" id="L2493">    }</span>
<span class="line" id="L2494"></span>
<span class="line" id="L2495">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> AccessError = os.AccessError;</span>
<span class="line" id="L2496"></span>
<span class="line" id="L2497">    <span class="tok-comment">/// Test accessing `path`.</span></span>
<span class="line" id="L2498">    <span class="tok-comment">/// `path` is UTF-8-encoded.</span></span>
<span class="line" id="L2499">    <span class="tok-comment">/// Be careful of Time-Of-Check-Time-Of-Use race conditions when using this function.</span></span>
<span class="line" id="L2500">    <span class="tok-comment">/// For example, instead of testing if a file exists and then opening it, just</span></span>
<span class="line" id="L2501">    <span class="tok-comment">/// open it and handle the error for file not found.</span></span>
<span class="line" id="L2502">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">access</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: File.OpenFlags) AccessError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2503">        <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L2504">            <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> os.windows.sliceToPrefixedFileW(sub_path);</span>
<span class="line" id="L2505">            <span class="tok-kw">return</span> self.accessW(sub_path_w.span().ptr, flags);</span>
<span class="line" id="L2506">        }</span>
<span class="line" id="L2507">        <span class="tok-kw">const</span> path_c = <span class="tok-kw">try</span> os.toPosixPath(sub_path);</span>
<span class="line" id="L2508">        <span class="tok-kw">return</span> self.accessZ(&amp;path_c, flags);</span>
<span class="line" id="L2509">    }</span>
<span class="line" id="L2510"></span>
<span class="line" id="L2511">    <span class="tok-comment">/// Same as `access` except the path parameter is null-terminated.</span></span>
<span class="line" id="L2512">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accessZ</span>(self: Dir, sub_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: File.OpenFlags) AccessError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2513">        <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L2514">            <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> os.windows.cStrToPrefixedFileW(sub_path);</span>
<span class="line" id="L2515">            <span class="tok-kw">return</span> self.accessW(sub_path_w.span().ptr, flags);</span>
<span class="line" id="L2516">        }</span>
<span class="line" id="L2517">        <span class="tok-kw">const</span> os_mode = <span class="tok-kw">switch</span> (flags.mode) {</span>
<span class="line" id="L2518">            .read_only =&gt; <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, os.F_OK),</span>
<span class="line" id="L2519">            .write_only =&gt; <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, os.W_OK),</span>
<span class="line" id="L2520">            .read_write =&gt; <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, os.R_OK | os.W_OK),</span>
<span class="line" id="L2521">        };</span>
<span class="line" id="L2522">        <span class="tok-kw">const</span> result = <span class="tok-kw">if</span> (need_async_thread <span class="tok-kw">and</span> flags.intended_io_mode != .blocking)</span>
<span class="line" id="L2523">            std.event.Loop.instance.?.faccessatZ(self.fd, sub_path, os_mode, <span class="tok-number">0</span>)</span>
<span class="line" id="L2524">        <span class="tok-kw">else</span></span>
<span class="line" id="L2525">            os.faccessatZ(self.fd, sub_path, os_mode, <span class="tok-number">0</span>);</span>
<span class="line" id="L2526">        <span class="tok-kw">return</span> result;</span>
<span class="line" id="L2527">    }</span>
<span class="line" id="L2528"></span>
<span class="line" id="L2529">    <span class="tok-comment">/// Same as `access` except asserts the target OS is Windows and the path parameter is</span></span>
<span class="line" id="L2530">    <span class="tok-comment">/// * WTF-16 encoded</span></span>
<span class="line" id="L2531">    <span class="tok-comment">/// * null-terminated</span></span>
<span class="line" id="L2532">    <span class="tok-comment">/// * NtDll prefixed</span></span>
<span class="line" id="L2533">    <span class="tok-comment">/// TODO currently this ignores `flags`.</span></span>
<span class="line" id="L2534">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accessW</span>(self: Dir, sub_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: File.OpenFlags) AccessError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2535">        _ = flags;</span>
<span class="line" id="L2536">        <span class="tok-kw">return</span> os.faccessatW(self.fd, sub_path_w, <span class="tok-number">0</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L2537">    }</span>
<span class="line" id="L2538"></span>
<span class="line" id="L2539">    <span class="tok-comment">/// Check the file size, mtime, and mode of `source_path` and `dest_path`. If they are equal, does nothing.</span></span>
<span class="line" id="L2540">    <span class="tok-comment">/// Otherwise, atomically copies `source_path` to `dest_path`. The destination file gains the mtime,</span></span>
<span class="line" id="L2541">    <span class="tok-comment">/// atime, and mode of the source file so that the next call to `updateFile` will not need a copy.</span></span>
<span class="line" id="L2542">    <span class="tok-comment">/// Returns the previous status of the file before updating.</span></span>
<span class="line" id="L2543">    <span class="tok-comment">/// If any of the directories do not exist for dest_path, they are created.</span></span>
<span class="line" id="L2544">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">updateFile</span>(</span>
<span class="line" id="L2545">        source_dir: Dir,</span>
<span class="line" id="L2546">        source_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2547">        dest_dir: Dir,</span>
<span class="line" id="L2548">        dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2549">        options: CopyFileOptions,</span>
<span class="line" id="L2550">    ) !PrevStatus {</span>
<span class="line" id="L2551">        <span class="tok-kw">var</span> src_file = <span class="tok-kw">try</span> source_dir.openFile(source_path, .{});</span>
<span class="line" id="L2552">        <span class="tok-kw">defer</span> src_file.close();</span>
<span class="line" id="L2553"></span>
<span class="line" id="L2554">        <span class="tok-kw">const</span> src_stat = <span class="tok-kw">try</span> src_file.stat();</span>
<span class="line" id="L2555">        <span class="tok-kw">const</span> actual_mode = options.override_mode <span class="tok-kw">orelse</span> src_stat.mode;</span>
<span class="line" id="L2556">        check_dest_stat: {</span>
<span class="line" id="L2557">            <span class="tok-kw">const</span> dest_stat = blk: {</span>
<span class="line" id="L2558">                <span class="tok-kw">var</span> dest_file = dest_dir.openFile(dest_path, .{}) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2559">                    <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">break</span> :check_dest_stat,</span>
<span class="line" id="L2560">                    <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L2561">                };</span>
<span class="line" id="L2562">                <span class="tok-kw">defer</span> dest_file.close();</span>
<span class="line" id="L2563"></span>
<span class="line" id="L2564">                <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> dest_file.stat();</span>
<span class="line" id="L2565">            };</span>
<span class="line" id="L2566"></span>
<span class="line" id="L2567">            <span class="tok-kw">if</span> (src_stat.size == dest_stat.size <span class="tok-kw">and</span></span>
<span class="line" id="L2568">                src_stat.mtime == dest_stat.mtime <span class="tok-kw">and</span></span>
<span class="line" id="L2569">                actual_mode == dest_stat.mode)</span>
<span class="line" id="L2570">            {</span>
<span class="line" id="L2571">                <span class="tok-kw">return</span> PrevStatus.fresh;</span>
<span class="line" id="L2572">            }</span>
<span class="line" id="L2573">        }</span>
<span class="line" id="L2574"></span>
<span class="line" id="L2575">        <span class="tok-kw">if</span> (path.dirname(dest_path)) |dirname| {</span>
<span class="line" id="L2576">            <span class="tok-kw">try</span> dest_dir.makePath(dirname);</span>
<span class="line" id="L2577">        }</span>
<span class="line" id="L2578"></span>
<span class="line" id="L2579">        <span class="tok-kw">var</span> atomic_file = <span class="tok-kw">try</span> dest_dir.atomicFile(dest_path, .{ .mode = actual_mode });</span>
<span class="line" id="L2580">        <span class="tok-kw">defer</span> atomic_file.deinit();</span>
<span class="line" id="L2581"></span>
<span class="line" id="L2582">        <span class="tok-kw">try</span> atomic_file.file.writeFileAll(src_file, .{ .in_len = src_stat.size });</span>
<span class="line" id="L2583">        <span class="tok-kw">try</span> atomic_file.file.updateTimes(src_stat.atime, src_stat.mtime);</span>
<span class="line" id="L2584">        <span class="tok-kw">try</span> atomic_file.finish();</span>
<span class="line" id="L2585">        <span class="tok-kw">return</span> PrevStatus.stale;</span>
<span class="line" id="L2586">    }</span>
<span class="line" id="L2587"></span>
<span class="line" id="L2588">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> CopyFileError = File.OpenError || File.StatError || AtomicFile.InitError || CopyFileRawError || AtomicFile.FinishError;</span>
<span class="line" id="L2589"></span>
<span class="line" id="L2590">    <span class="tok-comment">/// Guaranteed to be atomic.</span></span>
<span class="line" id="L2591">    <span class="tok-comment">/// On Linux, until https://patchwork.kernel.org/patch/9636735/ is merged and readily available,</span></span>
<span class="line" id="L2592">    <span class="tok-comment">/// there is a possibility of power loss or application termination leaving temporary files present</span></span>
<span class="line" id="L2593">    <span class="tok-comment">/// in the same directory as dest_path.</span></span>
<span class="line" id="L2594">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copyFile</span>(source_dir: Dir, source_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, dest_dir: Dir, dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, options: CopyFileOptions) CopyFileError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2595">        <span class="tok-kw">var</span> in_file = <span class="tok-kw">try</span> source_dir.openFile(source_path, .{});</span>
<span class="line" id="L2596">        <span class="tok-kw">defer</span> in_file.close();</span>
<span class="line" id="L2597"></span>
<span class="line" id="L2598">        <span class="tok-kw">var</span> size: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L2599">        <span class="tok-kw">const</span> mode = options.override_mode <span class="tok-kw">orelse</span> blk: {</span>
<span class="line" id="L2600">            <span class="tok-kw">const</span> st = <span class="tok-kw">try</span> in_file.stat();</span>
<span class="line" id="L2601">            size = st.size;</span>
<span class="line" id="L2602">            <span class="tok-kw">break</span> :blk st.mode;</span>
<span class="line" id="L2603">        };</span>
<span class="line" id="L2604"></span>
<span class="line" id="L2605">        <span class="tok-kw">var</span> atomic_file = <span class="tok-kw">try</span> dest_dir.atomicFile(dest_path, .{ .mode = mode });</span>
<span class="line" id="L2606">        <span class="tok-kw">defer</span> atomic_file.deinit();</span>
<span class="line" id="L2607"></span>
<span class="line" id="L2608">        <span class="tok-kw">try</span> copy_file(in_file.handle, atomic_file.file.handle, size);</span>
<span class="line" id="L2609">        <span class="tok-kw">try</span> atomic_file.finish();</span>
<span class="line" id="L2610">    }</span>
<span class="line" id="L2611"></span>
<span class="line" id="L2612">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> AtomicFileOptions = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2613">        mode: File.Mode = File.default_mode,</span>
<span class="line" id="L2614">    };</span>
<span class="line" id="L2615"></span>
<span class="line" id="L2616">    <span class="tok-comment">/// Directly access the `.file` field, and then call `AtomicFile.finish`</span></span>
<span class="line" id="L2617">    <span class="tok-comment">/// to atomically replace `dest_path` with contents.</span></span>
<span class="line" id="L2618">    <span class="tok-comment">/// Always call `AtomicFile.deinit` to clean up, regardless of whether `AtomicFile.finish` succeeded.</span></span>
<span class="line" id="L2619">    <span class="tok-comment">/// `dest_path` must remain valid until `AtomicFile.deinit` is called.</span></span>
<span class="line" id="L2620">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">atomicFile</span>(self: Dir, dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, options: AtomicFileOptions) !AtomicFile {</span>
<span class="line" id="L2621">        <span class="tok-kw">if</span> (path.dirname(dest_path)) |dirname| {</span>
<span class="line" id="L2622">            <span class="tok-kw">const</span> dir = <span class="tok-kw">try</span> self.openDir(dirname, .{});</span>
<span class="line" id="L2623">            <span class="tok-kw">return</span> AtomicFile.init(path.basename(dest_path), options.mode, dir, <span class="tok-null">true</span>);</span>
<span class="line" id="L2624">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2625">            <span class="tok-kw">return</span> AtomicFile.init(dest_path, options.mode, self, <span class="tok-null">false</span>);</span>
<span class="line" id="L2626">        }</span>
<span class="line" id="L2627">    }</span>
<span class="line" id="L2628"></span>
<span class="line" id="L2629">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Stat = File.Stat;</span>
<span class="line" id="L2630">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> StatError = File.StatError;</span>
<span class="line" id="L2631"></span>
<span class="line" id="L2632">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stat</span>(self: Dir) StatError!Stat {</span>
<span class="line" id="L2633">        <span class="tok-kw">const</span> file: File = .{</span>
<span class="line" id="L2634">            .handle = self.fd,</span>
<span class="line" id="L2635">            .capable_io_mode = .blocking,</span>
<span class="line" id="L2636">        };</span>
<span class="line" id="L2637">        <span class="tok-kw">return</span> file.stat();</span>
<span class="line" id="L2638">    }</span>
<span class="line" id="L2639"></span>
<span class="line" id="L2640">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> StatFileError = File.OpenError || File.StatError || os.FStatAtError;</span>
<span class="line" id="L2641"></span>
<span class="line" id="L2642">    <span class="tok-comment">/// Returns metadata for a file inside the directory.</span></span>
<span class="line" id="L2643">    <span class="tok-comment">///</span></span>
<span class="line" id="L2644">    <span class="tok-comment">/// On Windows, this requires three syscalls. On other operating systems, it</span></span>
<span class="line" id="L2645">    <span class="tok-comment">/// only takes one.</span></span>
<span class="line" id="L2646">    <span class="tok-comment">///</span></span>
<span class="line" id="L2647">    <span class="tok-comment">/// Symlinks are followed.</span></span>
<span class="line" id="L2648">    <span class="tok-comment">///</span></span>
<span class="line" id="L2649">    <span class="tok-comment">/// `sub_path` may be absolute, in which case `self` is ignored.</span></span>
<span class="line" id="L2650">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">statFile</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) StatFileError!Stat {</span>
<span class="line" id="L2651">        <span class="tok-kw">switch</span> (builtin.os.tag) {</span>
<span class="line" id="L2652">            .windows =&gt; {</span>
<span class="line" id="L2653">                <span class="tok-kw">var</span> file = <span class="tok-kw">try</span> self.openFile(sub_path, .{});</span>
<span class="line" id="L2654">                <span class="tok-kw">defer</span> file.close();</span>
<span class="line" id="L2655">                <span class="tok-kw">return</span> file.stat();</span>
<span class="line" id="L2656">            },</span>
<span class="line" id="L2657">            .wasi =&gt; {</span>
<span class="line" id="L2658">                <span class="tok-kw">const</span> st = <span class="tok-kw">try</span> os.fstatatWasi(self.fd, sub_path, os.wasi.LOOKUP_SYMLINK_FOLLOW);</span>
<span class="line" id="L2659">                <span class="tok-kw">return</span> Stat.fromSystem(st);</span>
<span class="line" id="L2660">            },</span>
<span class="line" id="L2661">            <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L2662">                <span class="tok-kw">const</span> st = <span class="tok-kw">try</span> os.fstatat(self.fd, sub_path, <span class="tok-number">0</span>);</span>
<span class="line" id="L2663">                <span class="tok-kw">return</span> Stat.fromSystem(st);</span>
<span class="line" id="L2664">            },</span>
<span class="line" id="L2665">        }</span>
<span class="line" id="L2666">    }</span>
<span class="line" id="L2667"></span>
<span class="line" id="L2668">    <span class="tok-kw">const</span> Permissions = File.Permissions;</span>
<span class="line" id="L2669">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> SetPermissionsError = File.SetPermissionsError;</span>
<span class="line" id="L2670"></span>
<span class="line" id="L2671">    <span class="tok-comment">/// Sets permissions according to the provided `Permissions` struct.</span></span>
<span class="line" id="L2672">    <span class="tok-comment">/// This method is *NOT* available on WASI</span></span>
<span class="line" id="L2673">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setPermissions</span>(self: Dir, permissions: Permissions) SetPermissionsError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2674">        <span class="tok-kw">const</span> file: File = .{</span>
<span class="line" id="L2675">            .handle = self.fd,</span>
<span class="line" id="L2676">            .capable_io_mode = .blocking,</span>
<span class="line" id="L2677">        };</span>
<span class="line" id="L2678">        <span class="tok-kw">try</span> file.setPermissions(permissions);</span>
<span class="line" id="L2679">    }</span>
<span class="line" id="L2680"></span>
<span class="line" id="L2681">    <span class="tok-kw">const</span> Metadata = File.Metadata;</span>
<span class="line" id="L2682">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> MetadataError = File.MetadataError;</span>
<span class="line" id="L2683"></span>
<span class="line" id="L2684">    <span class="tok-comment">/// Returns a `Metadata` struct, representing the permissions on the directory</span></span>
<span class="line" id="L2685">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadata</span>(self: Dir) MetadataError!Metadata {</span>
<span class="line" id="L2686">        <span class="tok-kw">const</span> file: File = .{</span>
<span class="line" id="L2687">            .handle = self.fd,</span>
<span class="line" id="L2688">            .capable_io_mode = .blocking,</span>
<span class="line" id="L2689">        };</span>
<span class="line" id="L2690">        <span class="tok-kw">return</span> <span class="tok-kw">try</span> file.metadata();</span>
<span class="line" id="L2691">    }</span>
<span class="line" id="L2692">};</span>
<span class="line" id="L2693"></span>
<span class="line" id="L2694"><span class="tok-comment">/// Returns a handle to the current working directory. It is not opened with iteration capability.</span></span>
<span class="line" id="L2695"><span class="tok-comment">/// Closing the returned `Dir` is checked illegal behavior. Iterating over the result is illegal behavior.</span></span>
<span class="line" id="L2696"><span class="tok-comment">/// On POSIX targets, this function is comptime-callable.</span></span>
<span class="line" id="L2697"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cwd</span>() Dir {</span>
<span class="line" id="L2698">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L2699">        <span class="tok-kw">return</span> Dir{ .fd = os.windows.peb().ProcessParameters.CurrentDirectory.Handle };</span>
<span class="line" id="L2700">    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (builtin.os.tag == .wasi) {</span>
<span class="line" id="L2701">        <span class="tok-kw">return</span> std.options.wasiCwd();</span>
<span class="line" id="L2702">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2703">        <span class="tok-kw">return</span> Dir{ .fd = os.AT.FDCWD };</span>
<span class="line" id="L2704">    }</span>
<span class="line" id="L2705">}</span>
<span class="line" id="L2706"></span>
<span class="line" id="L2707"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">defaultWasiCwd</span>() Dir {</span>
<span class="line" id="L2708">    <span class="tok-comment">// Expect the first preopen to be current working directory.</span>
</span>
<span class="line" id="L2709">    <span class="tok-kw">return</span> .{ .fd = <span class="tok-number">3</span> };</span>
<span class="line" id="L2710">}</span>
<span class="line" id="L2711"></span>
<span class="line" id="L2712"><span class="tok-comment">/// Opens a directory at the given path. The directory is a system resource that remains</span></span>
<span class="line" id="L2713"><span class="tok-comment">/// open until `close` is called on the result.</span></span>
<span class="line" id="L2714"><span class="tok-comment">/// See `openDirAbsoluteZ` for a function that accepts a null-terminated path.</span></span>
<span class="line" id="L2715"><span class="tok-comment">///</span></span>
<span class="line" id="L2716"><span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span></span>
<span class="line" id="L2717"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDirAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: Dir.OpenDirOptions) File.OpenError!Dir {</span>
<span class="line" id="L2718">    assert(path.isAbsolute(absolute_path));</span>
<span class="line" id="L2719">    <span class="tok-kw">return</span> cwd().openDir(absolute_path, flags);</span>
<span class="line" id="L2720">}</span>
<span class="line" id="L2721"></span>
<span class="line" id="L2722"><span class="tok-comment">/// Same as `openDirAbsolute` but the path parameter is null-terminated.</span></span>
<span class="line" id="L2723"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDirAbsoluteZ</span>(absolute_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: Dir.OpenDirOptions) File.OpenError!Dir {</span>
<span class="line" id="L2724">    assert(path.isAbsoluteZ(absolute_path_c));</span>
<span class="line" id="L2725">    <span class="tok-kw">return</span> cwd().openDirZ(absolute_path_c, flags, <span class="tok-null">false</span>);</span>
<span class="line" id="L2726">}</span>
<span class="line" id="L2727"><span class="tok-comment">/// Same as `openDirAbsolute` but the path parameter is null-terminated.</span></span>
<span class="line" id="L2728"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDirAbsoluteW</span>(absolute_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: Dir.OpenDirOptions) File.OpenError!Dir {</span>
<span class="line" id="L2729">    assert(path.isAbsoluteWindowsW(absolute_path_c));</span>
<span class="line" id="L2730">    <span class="tok-kw">return</span> cwd().openDirW(absolute_path_c, flags, <span class="tok-null">false</span>);</span>
<span class="line" id="L2731">}</span>
<span class="line" id="L2732"></span>
<span class="line" id="L2733"><span class="tok-comment">/// Opens a directory at the given path. The directory is a system resource that remains</span></span>
<span class="line" id="L2734"><span class="tok-comment">/// open until `close` is called on the result.</span></span>
<span class="line" id="L2735"><span class="tok-comment">/// See `openIterableDirAbsoluteZ` for a function that accepts a null-terminated path.</span></span>
<span class="line" id="L2736"><span class="tok-comment">///</span></span>
<span class="line" id="L2737"><span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span></span>
<span class="line" id="L2738"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openIterableDirAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: Dir.OpenDirOptions) File.OpenError!IterableDir {</span>
<span class="line" id="L2739">    assert(path.isAbsolute(absolute_path));</span>
<span class="line" id="L2740">    <span class="tok-kw">return</span> cwd().openIterableDir(absolute_path, flags);</span>
<span class="line" id="L2741">}</span>
<span class="line" id="L2742"></span>
<span class="line" id="L2743"><span class="tok-comment">/// Same as `openIterableDirAbsolute` but the path parameter is null-terminated.</span></span>
<span class="line" id="L2744"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openIterableDirAbsoluteZ</span>(absolute_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: Dir.OpenDirOptions) File.OpenError!IterableDir {</span>
<span class="line" id="L2745">    assert(path.isAbsoluteZ(absolute_path_c));</span>
<span class="line" id="L2746">    <span class="tok-kw">return</span> IterableDir{ .dir = <span class="tok-kw">try</span> cwd().openDirZ(absolute_path_c, flags, <span class="tok-null">true</span>) };</span>
<span class="line" id="L2747">}</span>
<span class="line" id="L2748"><span class="tok-comment">/// Same as `openIterableDirAbsolute` but the path parameter is null-terminated.</span></span>
<span class="line" id="L2749"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openIterableDirAbsoluteW</span>(absolute_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: Dir.OpenDirOptions) File.OpenError!IterableDir {</span>
<span class="line" id="L2750">    assert(path.isAbsoluteWindowsW(absolute_path_c));</span>
<span class="line" id="L2751">    <span class="tok-kw">return</span> IterableDir{ .dir = <span class="tok-kw">try</span> cwd().openDirW(absolute_path_c, flags, <span class="tok-null">true</span>) };</span>
<span class="line" id="L2752">}</span>
<span class="line" id="L2753"></span>
<span class="line" id="L2754"><span class="tok-comment">/// Opens a file for reading or writing, without attempting to create a new file, based on an absolute path.</span></span>
<span class="line" id="L2755"><span class="tok-comment">/// Call `File.close` to release the resource.</span></span>
<span class="line" id="L2756"><span class="tok-comment">/// Asserts that the path is absolute. See `Dir.openFile` for a function that</span></span>
<span class="line" id="L2757"><span class="tok-comment">/// operates on both absolute and relative paths.</span></span>
<span class="line" id="L2758"><span class="tok-comment">/// Asserts that the path parameter has no null bytes. See `openFileAbsoluteZ` for a function</span></span>
<span class="line" id="L2759"><span class="tok-comment">/// that accepts a null-terminated path.</span></span>
<span class="line" id="L2760"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openFileAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: File.OpenFlags) File.OpenError!File {</span>
<span class="line" id="L2761">    assert(path.isAbsolute(absolute_path));</span>
<span class="line" id="L2762">    <span class="tok-kw">return</span> cwd().openFile(absolute_path, flags);</span>
<span class="line" id="L2763">}</span>
<span class="line" id="L2764"></span>
<span class="line" id="L2765"><span class="tok-comment">/// Same as `openFileAbsolute` but the path parameter is null-terminated.</span></span>
<span class="line" id="L2766"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openFileAbsoluteZ</span>(absolute_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: File.OpenFlags) File.OpenError!File {</span>
<span class="line" id="L2767">    assert(path.isAbsoluteZ(absolute_path_c));</span>
<span class="line" id="L2768">    <span class="tok-kw">return</span> cwd().openFileZ(absolute_path_c, flags);</span>
<span class="line" id="L2769">}</span>
<span class="line" id="L2770"></span>
<span class="line" id="L2771"><span class="tok-comment">/// Same as `openFileAbsolute` but the path parameter is WTF-16-encoded.</span></span>
<span class="line" id="L2772"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openFileAbsoluteW</span>(absolute_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: File.OpenFlags) File.OpenError!File {</span>
<span class="line" id="L2773">    assert(path.isAbsoluteWindowsWTF16(absolute_path_w));</span>
<span class="line" id="L2774">    <span class="tok-kw">return</span> cwd().openFileW(absolute_path_w, flags);</span>
<span class="line" id="L2775">}</span>
<span class="line" id="L2776"></span>
<span class="line" id="L2777"><span class="tok-comment">/// Test accessing `path`.</span></span>
<span class="line" id="L2778"><span class="tok-comment">/// `path` is UTF-8-encoded.</span></span>
<span class="line" id="L2779"><span class="tok-comment">/// Be careful of Time-Of-Check-Time-Of-Use race conditions when using this function.</span></span>
<span class="line" id="L2780"><span class="tok-comment">/// For example, instead of testing if a file exists and then opening it, just</span></span>
<span class="line" id="L2781"><span class="tok-comment">/// open it and handle the error for file not found.</span></span>
<span class="line" id="L2782"><span class="tok-comment">/// See `accessAbsoluteZ` for a function that accepts a null-terminated path.</span></span>
<span class="line" id="L2783"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accessAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: File.OpenFlags) Dir.AccessError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2784">    assert(path.isAbsolute(absolute_path));</span>
<span class="line" id="L2785">    <span class="tok-kw">try</span> cwd().access(absolute_path, flags);</span>
<span class="line" id="L2786">}</span>
<span class="line" id="L2787"><span class="tok-comment">/// Same as `accessAbsolute` but the path parameter is null-terminated.</span></span>
<span class="line" id="L2788"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accessAbsoluteZ</span>(absolute_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: File.OpenFlags) Dir.AccessError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2789">    assert(path.isAbsoluteZ(absolute_path));</span>
<span class="line" id="L2790">    <span class="tok-kw">try</span> cwd().accessZ(absolute_path, flags);</span>
<span class="line" id="L2791">}</span>
<span class="line" id="L2792"><span class="tok-comment">/// Same as `accessAbsolute` but the path parameter is WTF-16 encoded.</span></span>
<span class="line" id="L2793"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accessAbsoluteW</span>(absolute_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-number">16</span>, flags: File.OpenFlags) Dir.AccessError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2794">    assert(path.isAbsoluteWindowsW(absolute_path));</span>
<span class="line" id="L2795">    <span class="tok-kw">try</span> cwd().accessW(absolute_path, flags);</span>
<span class="line" id="L2796">}</span>
<span class="line" id="L2797"></span>
<span class="line" id="L2798"><span class="tok-comment">/// Creates, opens, or overwrites a file with write access, based on an absolute path.</span></span>
<span class="line" id="L2799"><span class="tok-comment">/// Call `File.close` to release the resource.</span></span>
<span class="line" id="L2800"><span class="tok-comment">/// Asserts that the path is absolute. See `Dir.createFile` for a function that</span></span>
<span class="line" id="L2801"><span class="tok-comment">/// operates on both absolute and relative paths.</span></span>
<span class="line" id="L2802"><span class="tok-comment">/// Asserts that the path parameter has no null bytes. See `createFileAbsoluteC` for a function</span></span>
<span class="line" id="L2803"><span class="tok-comment">/// that accepts a null-terminated path.</span></span>
<span class="line" id="L2804"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createFileAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: File.CreateFlags) File.OpenError!File {</span>
<span class="line" id="L2805">    assert(path.isAbsolute(absolute_path));</span>
<span class="line" id="L2806">    <span class="tok-kw">return</span> cwd().createFile(absolute_path, flags);</span>
<span class="line" id="L2807">}</span>
<span class="line" id="L2808"></span>
<span class="line" id="L2809"><span class="tok-comment">/// Same as `createFileAbsolute` but the path parameter is null-terminated.</span></span>
<span class="line" id="L2810"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createFileAbsoluteZ</span>(absolute_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: File.CreateFlags) File.OpenError!File {</span>
<span class="line" id="L2811">    assert(path.isAbsoluteZ(absolute_path_c));</span>
<span class="line" id="L2812">    <span class="tok-kw">return</span> cwd().createFileZ(absolute_path_c, flags);</span>
<span class="line" id="L2813">}</span>
<span class="line" id="L2814"></span>
<span class="line" id="L2815"><span class="tok-comment">/// Same as `createFileAbsolute` but the path parameter is WTF-16 encoded.</span></span>
<span class="line" id="L2816"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createFileAbsoluteW</span>(absolute_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: File.CreateFlags) File.OpenError!File {</span>
<span class="line" id="L2817">    assert(path.isAbsoluteWindowsW(absolute_path_w));</span>
<span class="line" id="L2818">    <span class="tok-kw">return</span> cwd().createFileW(absolute_path_w, flags);</span>
<span class="line" id="L2819">}</span>
<span class="line" id="L2820"></span>
<span class="line" id="L2821"><span class="tok-comment">/// Delete a file name and possibly the file it refers to, based on an absolute path.</span></span>
<span class="line" id="L2822"><span class="tok-comment">/// Asserts that the path is absolute. See `Dir.deleteFile` for a function that</span></span>
<span class="line" id="L2823"><span class="tok-comment">/// operates on both absolute and relative paths.</span></span>
<span class="line" id="L2824"><span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span></span>
<span class="line" id="L2825"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteFileAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) Dir.DeleteFileError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2826">    assert(path.isAbsolute(absolute_path));</span>
<span class="line" id="L2827">    <span class="tok-kw">return</span> cwd().deleteFile(absolute_path);</span>
<span class="line" id="L2828">}</span>
<span class="line" id="L2829"></span>
<span class="line" id="L2830"><span class="tok-comment">/// Same as `deleteFileAbsolute` except the parameter is null-terminated.</span></span>
<span class="line" id="L2831"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteFileAbsoluteZ</span>(absolute_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) Dir.DeleteFileError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2832">    assert(path.isAbsoluteZ(absolute_path_c));</span>
<span class="line" id="L2833">    <span class="tok-kw">return</span> cwd().deleteFileZ(absolute_path_c);</span>
<span class="line" id="L2834">}</span>
<span class="line" id="L2835"></span>
<span class="line" id="L2836"><span class="tok-comment">/// Same as `deleteFileAbsolute` except the parameter is WTF-16 encoded.</span></span>
<span class="line" id="L2837"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteFileAbsoluteW</span>(absolute_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) Dir.DeleteFileError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2838">    assert(path.isAbsoluteWindowsW(absolute_path_w));</span>
<span class="line" id="L2839">    <span class="tok-kw">return</span> cwd().deleteFileW(absolute_path_w);</span>
<span class="line" id="L2840">}</span>
<span class="line" id="L2841"></span>
<span class="line" id="L2842"><span class="tok-comment">/// Removes a symlink, file, or directory.</span></span>
<span class="line" id="L2843"><span class="tok-comment">/// This is equivalent to `Dir.deleteTree` with the base directory.</span></span>
<span class="line" id="L2844"><span class="tok-comment">/// Asserts that the path is absolute. See `Dir.deleteTree` for a function that</span></span>
<span class="line" id="L2845"><span class="tok-comment">/// operates on both absolute and relative paths.</span></span>
<span class="line" id="L2846"><span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span></span>
<span class="line" id="L2847"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteTreeAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2848">    assert(path.isAbsolute(absolute_path));</span>
<span class="line" id="L2849">    <span class="tok-kw">const</span> dirname = path.dirname(absolute_path) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>{</span>
<span class="line" id="L2850">        <span class="tok-comment">/// Attempt to remove the root file system path.</span></span>
<span class="line" id="L2851">        <span class="tok-comment">/// This error is unreachable if `absolute_path` is relative.</span></span>
<span class="line" id="L2852">        CannotDeleteRootDirectory,</span>
<span class="line" id="L2853">    }.CannotDeleteRootDirectory;</span>
<span class="line" id="L2854"></span>
<span class="line" id="L2855">    <span class="tok-kw">var</span> dir = <span class="tok-kw">try</span> cwd().openDir(dirname, .{});</span>
<span class="line" id="L2856">    <span class="tok-kw">defer</span> dir.close();</span>
<span class="line" id="L2857"></span>
<span class="line" id="L2858">    <span class="tok-kw">return</span> dir.deleteTree(path.basename(absolute_path));</span>
<span class="line" id="L2859">}</span>
<span class="line" id="L2860"></span>
<span class="line" id="L2861"><span class="tok-comment">/// Same as `Dir.readLink`, except it asserts the path is absolute.</span></span>
<span class="line" id="L2862"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLinkAbsolute</span>(pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: *[MAX_PATH_BYTES]<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L2863">    assert(path.isAbsolute(pathname));</span>
<span class="line" id="L2864">    <span class="tok-kw">return</span> os.readlink(pathname, buffer);</span>
<span class="line" id="L2865">}</span>
<span class="line" id="L2866"></span>
<span class="line" id="L2867"><span class="tok-comment">/// Windows-only. Same as `readlinkW`, except the path parameter is null-terminated, WTF16</span></span>
<span class="line" id="L2868"><span class="tok-comment">/// encoded.</span></span>
<span class="line" id="L2869"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readlinkAbsoluteW</span>(pathname_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, buffer: *[MAX_PATH_BYTES]<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L2870">    assert(path.isAbsoluteWindowsW(pathname_w));</span>
<span class="line" id="L2871">    <span class="tok-kw">return</span> os.readlinkW(pathname_w, buffer);</span>
<span class="line" id="L2872">}</span>
<span class="line" id="L2873"></span>
<span class="line" id="L2874"><span class="tok-comment">/// Same as `readLink`, except the path parameter is null-terminated.</span></span>
<span class="line" id="L2875"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLinkAbsoluteZ</span>(pathname_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: *[MAX_PATH_BYTES]<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L2876">    assert(path.isAbsoluteZ(pathname_c));</span>
<span class="line" id="L2877">    <span class="tok-kw">return</span> os.readlinkZ(pathname_c, buffer);</span>
<span class="line" id="L2878">}</span>
<span class="line" id="L2879"></span>
<span class="line" id="L2880"><span class="tok-comment">/// Use with `Dir.symLink` and `symLinkAbsolute` to specify whether the symlink</span></span>
<span class="line" id="L2881"><span class="tok-comment">/// will point to a file or a directory. This value is ignored on all hosts</span></span>
<span class="line" id="L2882"><span class="tok-comment">/// except Windows where creating symlinks to different resource types, requires</span></span>
<span class="line" id="L2883"><span class="tok-comment">/// different flags. By default, `symLinkAbsolute` is assumed to point to a file.</span></span>
<span class="line" id="L2884"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SymLinkFlags = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2885">    is_directory: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L2886">};</span>
<span class="line" id="L2887"></span>
<span class="line" id="L2888"><span class="tok-comment">/// Creates a symbolic link named `sym_link_path` which contains the string `target_path`.</span></span>
<span class="line" id="L2889"><span class="tok-comment">/// A symbolic link (also known as a soft link) may point to an existing file or to a nonexistent</span></span>
<span class="line" id="L2890"><span class="tok-comment">/// one; the latter case is known as a dangling link.</span></span>
<span class="line" id="L2891"><span class="tok-comment">/// If `sym_link_path` exists, it will not be overwritten.</span></span>
<span class="line" id="L2892"><span class="tok-comment">/// See also `symLinkAbsoluteZ` and `symLinkAbsoluteW`.</span></span>
<span class="line" id="L2893"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLinkAbsolute</span>(target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: SymLinkFlags) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2894">    assert(path.isAbsolute(target_path));</span>
<span class="line" id="L2895">    assert(path.isAbsolute(sym_link_path));</span>
<span class="line" id="L2896">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L2897">        <span class="tok-kw">const</span> target_path_w = <span class="tok-kw">try</span> os.windows.sliceToPrefixedFileW(target_path);</span>
<span class="line" id="L2898">        <span class="tok-kw">const</span> sym_link_path_w = <span class="tok-kw">try</span> os.windows.sliceToPrefixedFileW(sym_link_path);</span>
<span class="line" id="L2899">        <span class="tok-kw">return</span> os.windows.CreateSymbolicLink(<span class="tok-null">null</span>, sym_link_path_w.span(), target_path_w.span(), flags.is_directory);</span>
<span class="line" id="L2900">    }</span>
<span class="line" id="L2901">    <span class="tok-kw">return</span> os.symlink(target_path, sym_link_path);</span>
<span class="line" id="L2902">}</span>
<span class="line" id="L2903"></span>
<span class="line" id="L2904"><span class="tok-comment">/// Windows-only. Same as `symLinkAbsolute` except the parameters are null-terminated, WTF16 encoded.</span></span>
<span class="line" id="L2905"><span class="tok-comment">/// Note that this function will by default try creating a symbolic link to a file. If you would</span></span>
<span class="line" id="L2906"><span class="tok-comment">/// like to create a symbolic link to a directory, specify this with `SymLinkFlags{ .is_directory = true }`.</span></span>
<span class="line" id="L2907"><span class="tok-comment">/// See also `symLinkAbsolute`, `symLinkAbsoluteZ`.</span></span>
<span class="line" id="L2908"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLinkAbsoluteW</span>(target_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, sym_link_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: SymLinkFlags) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2909">    assert(path.isAbsoluteWindowsWTF16(target_path_w));</span>
<span class="line" id="L2910">    assert(path.isAbsoluteWindowsWTF16(sym_link_path_w));</span>
<span class="line" id="L2911">    <span class="tok-kw">return</span> os.windows.CreateSymbolicLink(<span class="tok-null">null</span>, sym_link_path_w, target_path_w, flags.is_directory);</span>
<span class="line" id="L2912">}</span>
<span class="line" id="L2913"></span>
<span class="line" id="L2914"><span class="tok-comment">/// Same as `symLinkAbsolute` except the parameters are null-terminated pointers.</span></span>
<span class="line" id="L2915"><span class="tok-comment">/// See also `symLinkAbsolute`.</span></span>
<span class="line" id="L2916"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLinkAbsoluteZ</span>(target_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, sym_link_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: SymLinkFlags) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2917">    assert(path.isAbsoluteZ(target_path_c));</span>
<span class="line" id="L2918">    assert(path.isAbsoluteZ(sym_link_path_c));</span>
<span class="line" id="L2919">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L2920">        <span class="tok-kw">const</span> target_path_w = <span class="tok-kw">try</span> os.windows.cStrToWin32PrefixedFileW(target_path_c);</span>
<span class="line" id="L2921">        <span class="tok-kw">const</span> sym_link_path_w = <span class="tok-kw">try</span> os.windows.cStrToWin32PrefixedFileW(sym_link_path_c);</span>
<span class="line" id="L2922">        <span class="tok-kw">return</span> os.windows.CreateSymbolicLink(sym_link_path_w.span(), target_path_w.span(), flags.is_directory);</span>
<span class="line" id="L2923">    }</span>
<span class="line" id="L2924">    <span class="tok-kw">return</span> os.symlinkZ(target_path_c, sym_link_path_c);</span>
<span class="line" id="L2925">}</span>
<span class="line" id="L2926"></span>
<span class="line" id="L2927"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> OpenSelfExeError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L2928">    SharingViolation,</span>
<span class="line" id="L2929">    PathAlreadyExists,</span>
<span class="line" id="L2930">    FileNotFound,</span>
<span class="line" id="L2931">    AccessDenied,</span>
<span class="line" id="L2932">    PipeBusy,</span>
<span class="line" id="L2933">    NameTooLong,</span>
<span class="line" id="L2934">    <span class="tok-comment">/// On Windows, file paths must be valid Unicode.</span></span>
<span class="line" id="L2935">    InvalidUtf8,</span>
<span class="line" id="L2936">    <span class="tok-comment">/// On Windows, file paths cannot contain these characters:</span></span>
<span class="line" id="L2937">    <span class="tok-comment">/// '/', '*', '?', '&quot;', '&lt;', '&gt;', '|'</span></span>
<span class="line" id="L2938">    BadPathName,</span>
<span class="line" id="L2939">    Unexpected,</span>
<span class="line" id="L2940">} || os.OpenError || SelfExePathError || os.FlockError;</span>
<span class="line" id="L2941"></span>
<span class="line" id="L2942"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openSelfExe</span>(flags: File.OpenFlags) OpenSelfExeError!File {</span>
<span class="line" id="L2943">    <span class="tok-kw">if</span> (builtin.os.tag == .linux) {</span>
<span class="line" id="L2944">        <span class="tok-kw">return</span> openFileAbsoluteZ(<span class="tok-str">&quot;/proc/self/exe&quot;</span>, flags);</span>
<span class="line" id="L2945">    }</span>
<span class="line" id="L2946">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L2947">        <span class="tok-kw">const</span> wide_slice = selfExePathW();</span>
<span class="line" id="L2948">        <span class="tok-kw">const</span> prefixed_path_w = <span class="tok-kw">try</span> os.windows.wToPrefixedFileW(wide_slice);</span>
<span class="line" id="L2949">        <span class="tok-kw">return</span> cwd().openFileW(prefixed_path_w.span(), flags);</span>
<span class="line" id="L2950">    }</span>
<span class="line" id="L2951">    <span class="tok-comment">// Use of MAX_PATH_BYTES here is valid as the resulting path is immediately</span>
</span>
<span class="line" id="L2952">    <span class="tok-comment">// opened with no modification.</span>
</span>
<span class="line" id="L2953">    <span class="tok-kw">var</span> buf: [MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L2954">    <span class="tok-kw">const</span> self_exe_path = <span class="tok-kw">try</span> selfExePath(&amp;buf);</span>
<span class="line" id="L2955">    buf[self_exe_path.len] = <span class="tok-number">0</span>;</span>
<span class="line" id="L2956">    <span class="tok-kw">return</span> openFileAbsoluteZ(buf[<span class="tok-number">0</span>..self_exe_path.len :<span class="tok-number">0</span>].ptr, flags);</span>
<span class="line" id="L2957">}</span>
<span class="line" id="L2958"></span>
<span class="line" id="L2959"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SelfExePathError = os.ReadLinkError || os.SysCtlError || os.RealPathError;</span>
<span class="line" id="L2960"></span>
<span class="line" id="L2961"><span class="tok-comment">/// `selfExePath` except allocates the result on the heap.</span></span>
<span class="line" id="L2962"><span class="tok-comment">/// Caller owns returned memory.</span></span>
<span class="line" id="L2963"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">selfExePathAlloc</span>(allocator: Allocator) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L2964">    <span class="tok-comment">// Use of MAX_PATH_BYTES here is justified as, at least on one tested Linux</span>
</span>
<span class="line" id="L2965">    <span class="tok-comment">// system, readlink will completely fail to return a result larger than</span>
</span>
<span class="line" id="L2966">    <span class="tok-comment">// PATH_MAX even if given a sufficiently large buffer. This makes it</span>
</span>
<span class="line" id="L2967">    <span class="tok-comment">// fundamentally impossible to get the selfExePath of a program running in</span>
</span>
<span class="line" id="L2968">    <span class="tok-comment">// a very deeply nested directory chain in this way.</span>
</span>
<span class="line" id="L2969">    <span class="tok-comment">// TODO(#4812): Investigate other systems and whether it is possible to get</span>
</span>
<span class="line" id="L2970">    <span class="tok-comment">// this path by trying larger and larger buffers until one succeeds.</span>
</span>
<span class="line" id="L2971">    <span class="tok-kw">var</span> buf: [MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L2972">    <span class="tok-kw">return</span> allocator.dupe(<span class="tok-type">u8</span>, <span class="tok-kw">try</span> selfExePath(&amp;buf));</span>
<span class="line" id="L2973">}</span>
<span class="line" id="L2974"></span>
<span class="line" id="L2975"><span class="tok-comment">/// Get the path to the current executable.</span></span>
<span class="line" id="L2976"><span class="tok-comment">/// If you only need the directory, use selfExeDirPath.</span></span>
<span class="line" id="L2977"><span class="tok-comment">/// If you only want an open file handle, use openSelfExe.</span></span>
<span class="line" id="L2978"><span class="tok-comment">/// This function may return an error if the current executable</span></span>
<span class="line" id="L2979"><span class="tok-comment">/// was deleted after spawning.</span></span>
<span class="line" id="L2980"><span class="tok-comment">/// Returned value is a slice of out_buffer.</span></span>
<span class="line" id="L2981"><span class="tok-comment">///</span></span>
<span class="line" id="L2982"><span class="tok-comment">/// On Linux, depends on procfs being mounted. If the currently executing binary has</span></span>
<span class="line" id="L2983"><span class="tok-comment">/// been deleted, the file path looks something like `/a/b/c/exe (deleted)`.</span></span>
<span class="line" id="L2984"><span class="tok-comment">/// TODO make the return type of this a null terminated pointer</span></span>
<span class="line" id="L2985"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">selfExePath</span>(out_buffer: []<span class="tok-type">u8</span>) SelfExePathError![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L2986">    <span class="tok-kw">if</span> (is_darwin) {</span>
<span class="line" id="L2987">        <span class="tok-comment">// Note that _NSGetExecutablePath() will return &quot;a path&quot; to</span>
</span>
<span class="line" id="L2988">        <span class="tok-comment">// the executable not a &quot;real path&quot; to the executable.</span>
</span>
<span class="line" id="L2989">        <span class="tok-kw">var</span> symlink_path_buf: [MAX_PATH_BYTES:<span class="tok-number">0</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L2990">        <span class="tok-kw">var</span> u32_len: <span class="tok-type">u32</span> = MAX_PATH_BYTES + <span class="tok-number">1</span>; <span class="tok-comment">// include the sentinel</span>
</span>
<span class="line" id="L2991">        <span class="tok-kw">const</span> rc = std.c._NSGetExecutablePath(&amp;symlink_path_buf, &amp;u32_len);</span>
<span class="line" id="L2992">        <span class="tok-kw">if</span> (rc != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;</span>
<span class="line" id="L2993"></span>
<span class="line" id="L2994">        <span class="tok-kw">var</span> real_path_buf: [MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L2995">        <span class="tok-kw">const</span> real_path = <span class="tok-kw">try</span> std.os.realpathZ(&amp;symlink_path_buf, &amp;real_path_buf);</span>
<span class="line" id="L2996">        <span class="tok-kw">if</span> (real_path.len &gt; out_buffer.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;</span>
<span class="line" id="L2997">        <span class="tok-kw">const</span> result = out_buffer[<span class="tok-number">0</span>..real_path.len];</span>
<span class="line" id="L2998">        <span class="tok-builtin">@memcpy</span>(result, real_path);</span>
<span class="line" id="L2999">        <span class="tok-kw">return</span> result;</span>
<span class="line" id="L3000">    }</span>
<span class="line" id="L3001">    <span class="tok-kw">switch</span> (builtin.os.tag) {</span>
<span class="line" id="L3002">        .linux =&gt; <span class="tok-kw">return</span> os.readlinkZ(<span class="tok-str">&quot;/proc/self/exe&quot;</span>, out_buffer),</span>
<span class="line" id="L3003">        .solaris =&gt; <span class="tok-kw">return</span> os.readlinkZ(<span class="tok-str">&quot;/proc/self/path/a.out&quot;</span>, out_buffer),</span>
<span class="line" id="L3004">        .freebsd, .dragonfly =&gt; {</span>
<span class="line" id="L3005">            <span class="tok-kw">var</span> mib = [<span class="tok-number">4</span>]<span class="tok-type">c_int</span>{ os.CTL.KERN, os.KERN.PROC, os.KERN.PROC_PATHNAME, -<span class="tok-number">1</span> };</span>
<span class="line" id="L3006">            <span class="tok-kw">var</span> out_len: <span class="tok-type">usize</span> = out_buffer.len;</span>
<span class="line" id="L3007">            <span class="tok-kw">try</span> os.sysctl(&amp;mib, out_buffer.ptr, &amp;out_len, <span class="tok-null">null</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3008">            <span class="tok-comment">// TODO could this slice from 0 to out_len instead?</span>
</span>
<span class="line" id="L3009">            <span class="tok-kw">return</span> mem.sliceTo(out_buffer, <span class="tok-number">0</span>);</span>
<span class="line" id="L3010">        },</span>
<span class="line" id="L3011">        .netbsd =&gt; {</span>
<span class="line" id="L3012">            <span class="tok-kw">var</span> mib = [<span class="tok-number">4</span>]<span class="tok-type">c_int</span>{ os.CTL.KERN, os.KERN.PROC_ARGS, -<span class="tok-number">1</span>, os.KERN.PROC_PATHNAME };</span>
<span class="line" id="L3013">            <span class="tok-kw">var</span> out_len: <span class="tok-type">usize</span> = out_buffer.len;</span>
<span class="line" id="L3014">            <span class="tok-kw">try</span> os.sysctl(&amp;mib, out_buffer.ptr, &amp;out_len, <span class="tok-null">null</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3015">            <span class="tok-comment">// TODO could this slice from 0 to out_len instead?</span>
</span>
<span class="line" id="L3016">            <span class="tok-kw">return</span> mem.sliceTo(out_buffer, <span class="tok-number">0</span>);</span>
<span class="line" id="L3017">        },</span>
<span class="line" id="L3018">        .openbsd, .haiku =&gt; {</span>
<span class="line" id="L3019">            <span class="tok-comment">// OpenBSD doesn't support getting the path of a running process, so try to guess it</span>
</span>
<span class="line" id="L3020">            <span class="tok-kw">if</span> (os.argv.len == <span class="tok-number">0</span>)</span>
<span class="line" id="L3021">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound;</span>
<span class="line" id="L3022"></span>
<span class="line" id="L3023">            <span class="tok-kw">const</span> argv0 = mem.span(os.argv[<span class="tok-number">0</span>]);</span>
<span class="line" id="L3024">            <span class="tok-kw">if</span> (mem.indexOf(<span class="tok-type">u8</span>, argv0, <span class="tok-str">&quot;/&quot;</span>) != <span class="tok-null">null</span>) {</span>
<span class="line" id="L3025">                <span class="tok-comment">// argv[0] is a path (relative or absolute): use realpath(3) directly</span>
</span>
<span class="line" id="L3026">                <span class="tok-kw">var</span> real_path_buf: [MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L3027">                <span class="tok-kw">const</span> real_path = <span class="tok-kw">try</span> os.realpathZ(os.argv[<span class="tok-number">0</span>], &amp;real_path_buf);</span>
<span class="line" id="L3028">                <span class="tok-kw">if</span> (real_path.len &gt; out_buffer.len)</span>
<span class="line" id="L3029">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;</span>
<span class="line" id="L3030">                <span class="tok-kw">const</span> result = out_buffer[<span class="tok-number">0</span>..real_path.len];</span>
<span class="line" id="L3031">                <span class="tok-builtin">@memcpy</span>(result, real_path);</span>
<span class="line" id="L3032">                <span class="tok-kw">return</span> result;</span>
<span class="line" id="L3033">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (argv0.len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L3034">                <span class="tok-comment">// argv[0] is not empty (and not a path): search it inside PATH</span>
</span>
<span class="line" id="L3035">                <span class="tok-kw">const</span> PATH = std.os.getenvZ(<span class="tok-str">&quot;PATH&quot;</span>) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound;</span>
<span class="line" id="L3036">                <span class="tok-kw">var</span> path_it = mem.tokenizeScalar(<span class="tok-type">u8</span>, PATH, path.delimiter);</span>
<span class="line" id="L3037">                <span class="tok-kw">while</span> (path_it.next()) |a_path| {</span>
<span class="line" id="L3038">                    <span class="tok-kw">var</span> resolved_path_buf: [MAX_PATH_BYTES - <span class="tok-number">1</span>:<span class="tok-number">0</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L3039">                    <span class="tok-kw">const</span> resolved_path = std.fmt.bufPrintZ(&amp;resolved_path_buf, <span class="tok-str">&quot;{s}/{s}&quot;</span>, .{</span>
<span class="line" id="L3040">                        a_path,</span>
<span class="line" id="L3041">                        os.argv[<span class="tok-number">0</span>],</span>
<span class="line" id="L3042">                    }) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L3043"></span>
<span class="line" id="L3044">                    <span class="tok-kw">var</span> real_path_buf: [MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L3045">                    <span class="tok-kw">if</span> (os.realpathZ(resolved_path, &amp;real_path_buf)) |real_path| {</span>
<span class="line" id="L3046">                        <span class="tok-comment">// found a file, and hope it is the right file</span>
</span>
<span class="line" id="L3047">                        <span class="tok-kw">if</span> (real_path.len &gt; out_buffer.len)</span>
<span class="line" id="L3048">                            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;</span>
<span class="line" id="L3049">                        <span class="tok-kw">const</span> result = out_buffer[<span class="tok-number">0</span>..real_path.len];</span>
<span class="line" id="L3050">                        <span class="tok-builtin">@memcpy</span>(result, real_path);</span>
<span class="line" id="L3051">                        <span class="tok-kw">return</span> result;</span>
<span class="line" id="L3052">                    } <span class="tok-kw">else</span> |_| <span class="tok-kw">continue</span>;</span>
<span class="line" id="L3053">                }</span>
<span class="line" id="L3054">            }</span>
<span class="line" id="L3055">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound;</span>
<span class="line" id="L3056">        },</span>
<span class="line" id="L3057">        .windows =&gt; {</span>
<span class="line" id="L3058">            <span class="tok-kw">const</span> utf16le_slice = selfExePathW();</span>
<span class="line" id="L3059">            <span class="tok-comment">// Trust that Windows gives us valid UTF-16LE.</span>
</span>
<span class="line" id="L3060">            <span class="tok-kw">const</span> end_index = std.unicode.utf16leToUtf8(out_buffer, utf16le_slice) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L3061">            <span class="tok-kw">return</span> out_buffer[<span class="tok-number">0</span>..end_index];</span>
<span class="line" id="L3062">        },</span>
<span class="line" id="L3063">        .wasi =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;std.fs.selfExePath not supported for WASI. Use std.fs.selfExePathAlloc instead.&quot;</span>),</span>
<span class="line" id="L3064">        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;std.fs.selfExePath not supported for this target&quot;</span>),</span>
<span class="line" id="L3065">    }</span>
<span class="line" id="L3066">}</span>
<span class="line" id="L3067"></span>
<span class="line" id="L3068"><span class="tok-comment">/// The result is UTF16LE-encoded.</span></span>
<span class="line" id="L3069"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">selfExePathW</span>() [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span> {</span>
<span class="line" id="L3070">    <span class="tok-kw">const</span> image_path_name = &amp;os.windows.peb().ProcessParameters.ImagePathName;</span>
<span class="line" id="L3071">    <span class="tok-kw">return</span> image_path_name.Buffer[<span class="tok-number">0</span> .. image_path_name.Length / <span class="tok-number">2</span> :<span class="tok-number">0</span>];</span>
<span class="line" id="L3072">}</span>
<span class="line" id="L3073"></span>
<span class="line" id="L3074"><span class="tok-comment">/// `selfExeDirPath` except allocates the result on the heap.</span></span>
<span class="line" id="L3075"><span class="tok-comment">/// Caller owns returned memory.</span></span>
<span class="line" id="L3076"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">selfExeDirPathAlloc</span>(allocator: Allocator) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L3077">    <span class="tok-comment">// Use of MAX_PATH_BYTES here is justified as, at least on one tested Linux</span>
</span>
<span class="line" id="L3078">    <span class="tok-comment">// system, readlink will completely fail to return a result larger than</span>
</span>
<span class="line" id="L3079">    <span class="tok-comment">// PATH_MAX even if given a sufficiently large buffer. This makes it</span>
</span>
<span class="line" id="L3080">    <span class="tok-comment">// fundamentally impossible to get the selfExeDirPath of a program running</span>
</span>
<span class="line" id="L3081">    <span class="tok-comment">// in a very deeply nested directory chain in this way.</span>
</span>
<span class="line" id="L3082">    <span class="tok-comment">// TODO(#4812): Investigate other systems and whether it is possible to get</span>
</span>
<span class="line" id="L3083">    <span class="tok-comment">// this path by trying larger and larger buffers until one succeeds.</span>
</span>
<span class="line" id="L3084">    <span class="tok-kw">var</span> buf: [MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L3085">    <span class="tok-kw">return</span> allocator.dupe(<span class="tok-type">u8</span>, <span class="tok-kw">try</span> selfExeDirPath(&amp;buf));</span>
<span class="line" id="L3086">}</span>
<span class="line" id="L3087"></span>
<span class="line" id="L3088"><span class="tok-comment">/// Get the directory path that contains the current executable.</span></span>
<span class="line" id="L3089"><span class="tok-comment">/// Returned value is a slice of out_buffer.</span></span>
<span class="line" id="L3090"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">selfExeDirPath</span>(out_buffer: []<span class="tok-type">u8</span>) SelfExePathError![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L3091">    <span class="tok-kw">const</span> self_exe_path = <span class="tok-kw">try</span> selfExePath(out_buffer);</span>
<span class="line" id="L3092">    <span class="tok-comment">// Assume that the OS APIs return absolute paths, and therefore dirname</span>
</span>
<span class="line" id="L3093">    <span class="tok-comment">// will not return null.</span>
</span>
<span class="line" id="L3094">    <span class="tok-kw">return</span> path.dirname(self_exe_path).?;</span>
<span class="line" id="L3095">}</span>
<span class="line" id="L3096"></span>
<span class="line" id="L3097"><span class="tok-comment">/// `realpath`, except caller must free the returned memory.</span></span>
<span class="line" id="L3098"><span class="tok-comment">/// See also `Dir.realpath`.</span></span>
<span class="line" id="L3099"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpathAlloc</span>(allocator: Allocator, pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L3100">    <span class="tok-comment">// Use of MAX_PATH_BYTES here is valid as the realpath function does not</span>
</span>
<span class="line" id="L3101">    <span class="tok-comment">// have a variant that takes an arbitrary-size buffer.</span>
</span>
<span class="line" id="L3102">    <span class="tok-comment">// TODO(#4812): Consider reimplementing realpath or using the POSIX.1-2008</span>
</span>
<span class="line" id="L3103">    <span class="tok-comment">// NULL out parameter (GNU's canonicalize_file_name) to handle overelong</span>
</span>
<span class="line" id="L3104">    <span class="tok-comment">// paths. musl supports passing NULL but restricts the output to PATH_MAX</span>
</span>
<span class="line" id="L3105">    <span class="tok-comment">// anyway.</span>
</span>
<span class="line" id="L3106">    <span class="tok-kw">var</span> buf: [MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L3107">    <span class="tok-kw">return</span> allocator.dupe(<span class="tok-type">u8</span>, <span class="tok-kw">try</span> os.realpath(pathname, &amp;buf));</span>
<span class="line" id="L3108">}</span>
<span class="line" id="L3109"></span>
<span class="line" id="L3110"><span class="tok-kw">const</span> CopyFileRawError = <span class="tok-kw">error</span>{SystemResources} || os.CopyFileRangeError || os.SendFileError;</span>
<span class="line" id="L3111"></span>
<span class="line" id="L3112"><span class="tok-comment">// Transfer all the data between two file descriptors in the most efficient way.</span>
</span>
<span class="line" id="L3113"><span class="tok-comment">// The copy starts at offset 0, the initial offsets are preserved.</span>
</span>
<span class="line" id="L3114"><span class="tok-comment">// No metadata is transferred over.</span>
</span>
<span class="line" id="L3115"><span class="tok-kw">fn</span> <span class="tok-fn">copy_file</span>(fd_in: os.fd_t, fd_out: os.fd_t, maybe_size: ?<span class="tok-type">u64</span>) CopyFileRawError!<span class="tok-type">void</span> {</span>
<span class="line" id="L3116">    <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> builtin.target.isDarwin()) {</span>
<span class="line" id="L3117">        <span class="tok-kw">const</span> rc = os.system.fcopyfile(fd_in, fd_out, <span class="tok-null">null</span>, os.system.COPYFILE_DATA);</span>
<span class="line" id="L3118">        <span class="tok-kw">switch</span> (os.errno(rc)) {</span>
<span class="line" id="L3119">            .SUCCESS =&gt; <span class="tok-kw">return</span>,</span>
<span class="line" id="L3120">            .INVAL =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L3121">            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L3122">            <span class="tok-comment">// The source file is not a directory, symbolic link, or regular file.</span>
</span>
<span class="line" id="L3123">            <span class="tok-comment">// Try with the fallback path before giving up.</span>
</span>
<span class="line" id="L3124">            .OPNOTSUPP =&gt; {},</span>
<span class="line" id="L3125">            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> os.unexpectedErrno(err),</span>
<span class="line" id="L3126">        }</span>
<span class="line" id="L3127">    }</span>
<span class="line" id="L3128"></span>
<span class="line" id="L3129">    <span class="tok-kw">if</span> (builtin.os.tag == .linux) {</span>
<span class="line" id="L3130">        <span class="tok-comment">// Try copy_file_range first as that works at the FS level and is the</span>
</span>
<span class="line" id="L3131">        <span class="tok-comment">// most efficient method (if available).</span>
</span>
<span class="line" id="L3132">        <span class="tok-kw">var</span> offset: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L3133">        cfr_loop: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L3134">            <span class="tok-comment">// The kernel checks the u64 value `offset+count` for overflow, use</span>
</span>
<span class="line" id="L3135">            <span class="tok-comment">// a 32 bit value so that the syscall won't return EINVAL except for</span>
</span>
<span class="line" id="L3136">            <span class="tok-comment">// impossibly large files (&gt; 2^64-1 - 2^32-1).</span>
</span>
<span class="line" id="L3137">            <span class="tok-kw">const</span> amt = <span class="tok-kw">try</span> os.copy_file_range(fd_in, offset, fd_out, offset, math.maxInt(<span class="tok-type">u32</span>), <span class="tok-number">0</span>);</span>
<span class="line" id="L3138">            <span class="tok-comment">// Terminate as soon as we have copied size bytes or no bytes</span>
</span>
<span class="line" id="L3139">            <span class="tok-kw">if</span> (maybe_size) |s| {</span>
<span class="line" id="L3140">                <span class="tok-kw">if</span> (s == amt) <span class="tok-kw">break</span> :cfr_loop;</span>
<span class="line" id="L3141">            }</span>
<span class="line" id="L3142">            <span class="tok-kw">if</span> (amt == <span class="tok-number">0</span>) <span class="tok-kw">break</span> :cfr_loop;</span>
<span class="line" id="L3143">            offset += amt;</span>
<span class="line" id="L3144">        }</span>
<span class="line" id="L3145">        <span class="tok-kw">return</span>;</span>
<span class="line" id="L3146">    }</span>
<span class="line" id="L3147"></span>
<span class="line" id="L3148">    <span class="tok-comment">// Sendfile is a zero-copy mechanism iff the OS supports it, otherwise the</span>
</span>
<span class="line" id="L3149">    <span class="tok-comment">// fallback code will copy the contents chunk by chunk.</span>
</span>
<span class="line" id="L3150">    <span class="tok-kw">const</span> empty_iovec = [<span class="tok-number">0</span>]os.iovec_const{};</span>
<span class="line" id="L3151">    <span class="tok-kw">var</span> offset: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L3152">    sendfile_loop: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L3153">        <span class="tok-kw">const</span> amt = <span class="tok-kw">try</span> os.sendfile(fd_out, fd_in, offset, <span class="tok-number">0</span>, &amp;empty_iovec, &amp;empty_iovec, <span class="tok-number">0</span>);</span>
<span class="line" id="L3154">        <span class="tok-comment">// Terminate as soon as we have copied size bytes or no bytes</span>
</span>
<span class="line" id="L3155">        <span class="tok-kw">if</span> (maybe_size) |s| {</span>
<span class="line" id="L3156">            <span class="tok-kw">if</span> (s == amt) <span class="tok-kw">break</span> :sendfile_loop;</span>
<span class="line" id="L3157">        }</span>
<span class="line" id="L3158">        <span class="tok-kw">if</span> (amt == <span class="tok-number">0</span>) <span class="tok-kw">break</span> :sendfile_loop;</span>
<span class="line" id="L3159">        offset += amt;</span>
<span class="line" id="L3160">    }</span>
<span class="line" id="L3161">}</span>
<span class="line" id="L3162"></span>
<span class="line" id="L3163"><span class="tok-kw">test</span> {</span>
<span class="line" id="L3164">    <span class="tok-kw">if</span> (builtin.os.tag != .wasi) {</span>
<span class="line" id="L3165">        _ = &amp;makeDirAbsolute;</span>
<span class="line" id="L3166">        _ = &amp;makeDirAbsoluteZ;</span>
<span class="line" id="L3167">        _ = &amp;copyFileAbsolute;</span>
<span class="line" id="L3168">        _ = &amp;updateFileAbsolute;</span>
<span class="line" id="L3169">    }</span>
<span class="line" id="L3170">    _ = &amp;Dir.copyFile;</span>
<span class="line" id="L3171">    _ = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fs/test.zig&quot;</span>);</span>
<span class="line" id="L3172">    _ = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fs/path.zig&quot;</span>);</span>
<span class="line" id="L3173">    _ = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fs/file.zig&quot;</span>);</span>
<span class="line" id="L3174">    _ = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fs/get_app_data_dir.zig&quot;</span>);</span>
<span class="line" id="L3175">    _ = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fs/watch.zig&quot;</span>);</span>
<span class="line" id="L3176">}</span>
<span class="line" id="L3177"></span>
</code></pre></body>
</html>