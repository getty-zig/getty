<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>fs.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg==">
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std.zig&quot;</span>);</span>
<span class="line" id="L2"><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);</span>
<span class="line" id="L3"><span class="tok-kw">const</span> root = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;root&quot;</span>);</span>
<span class="line" id="L4"><span class="tok-kw">const</span> os = std.os;</span>
<span class="line" id="L5"><span class="tok-kw">const</span> mem = std.mem;</span>
<span class="line" id="L6"><span class="tok-kw">const</span> base64 = std.base64;</span>
<span class="line" id="L7"><span class="tok-kw">const</span> crypto = std.crypto;</span>
<span class="line" id="L8"><span class="tok-kw">const</span> Allocator = std.mem.Allocator;</span>
<span class="line" id="L9"><span class="tok-kw">const</span> assert = std.debug.assert;</span>
<span class="line" id="L10"></span>
<span class="line" id="L11"><span class="tok-kw">const</span> is_darwin = builtin.os.tag.isDarwin();</span>
<span class="line" id="L12"></span>
<span class="line" id="L13"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> AtomicFile = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fs/AtomicFile.zig&quot;</span>);</span>
<span class="line" id="L14"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Dir = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fs/Dir.zig&quot;</span>);</span>
<span class="line" id="L15"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> File = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fs/File.zig&quot;</span>);</span>
<span class="line" id="L16"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> path = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fs/path.zig&quot;</span>);</span>
<span class="line" id="L17"></span>
<span class="line" id="L18"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> has_executable_bit = <span class="tok-kw">switch</span> (builtin.os.tag) {</span>
<span class="line" id="L19">    .windows, .wasi =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L20">    <span class="tok-kw">else</span> =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L21">};</span>
<span class="line" id="L22"></span>
<span class="line" id="L23"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> wasi = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fs/wasi.zig&quot;</span>);</span>
<span class="line" id="L24"></span>
<span class="line" id="L25"><span class="tok-comment">// TODO audit these APIs with respect to Dir and absolute paths</span>
</span>
<span class="line" id="L26"></span>
<span class="line" id="L27"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> realpath = os.realpath;</span>
<span class="line" id="L28"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> realpathZ = os.realpathZ;</span>
<span class="line" id="L29"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> realpathW = os.realpathW;</span>
<span class="line" id="L30"></span>
<span class="line" id="L31"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> getAppDataDir = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fs/get_app_data_dir.zig&quot;</span>).getAppDataDir;</span>
<span class="line" id="L32"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetAppDataDirError = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fs/get_app_data_dir.zig&quot;</span>).GetAppDataDirError;</span>
<span class="line" id="L33"></span>
<span class="line" id="L34"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Watch = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fs/watch.zig&quot;</span>).Watch;</span>
<span class="line" id="L35"></span>
<span class="line" id="L36"><span class="tok-comment">/// This represents the maximum size of a UTF-8 encoded file path that the</span></span>
<span class="line" id="L37"><span class="tok-comment">/// operating system will accept. Paths, including those returned from file</span></span>
<span class="line" id="L38"><span class="tok-comment">/// system operations, may be longer than this length, but such paths cannot</span></span>
<span class="line" id="L39"><span class="tok-comment">/// be successfully passed back in other file system operations. However,</span></span>
<span class="line" id="L40"><span class="tok-comment">/// all path components returned by file system operations are assumed to</span></span>
<span class="line" id="L41"><span class="tok-comment">/// fit into a UTF-8 encoded array of this length.</span></span>
<span class="line" id="L42"><span class="tok-comment">/// The byte count includes room for a null sentinel byte.</span></span>
<span class="line" id="L43"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> MAX_PATH_BYTES = <span class="tok-kw">switch</span> (builtin.os.tag) {</span>
<span class="line" id="L44">    .linux, .macos, .ios, .freebsd, .openbsd, .netbsd, .dragonfly, .haiku, .solaris, .illumos, .plan9 =&gt; os.PATH_MAX,</span>
<span class="line" id="L45">    <span class="tok-comment">// Each UTF-16LE character may be expanded to 3 UTF-8 bytes.</span>
</span>
<span class="line" id="L46">    <span class="tok-comment">// If it would require 4 UTF-8 bytes, then there would be a surrogate</span>
</span>
<span class="line" id="L47">    <span class="tok-comment">// pair in the UTF-16LE, and we (over)account 3 bytes for it that way.</span>
</span>
<span class="line" id="L48">    <span class="tok-comment">// +1 for the null byte at the end, which can be encoded in 1 byte.</span>
</span>
<span class="line" id="L49">    .windows =&gt; os.windows.PATH_MAX_WIDE * <span class="tok-number">3</span> + <span class="tok-number">1</span>,</span>
<span class="line" id="L50">    <span class="tok-comment">// TODO work out what a reasonable value we should use here</span>
</span>
<span class="line" id="L51">    .wasi =&gt; <span class="tok-number">4096</span>,</span>
<span class="line" id="L52">    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(root, <span class="tok-str">&quot;os&quot;</span>) <span class="tok-kw">and</span> <span class="tok-builtin">@hasDecl</span>(root.os, <span class="tok-str">&quot;PATH_MAX&quot;</span>))</span>
<span class="line" id="L53">        root.os.PATH_MAX</span>
<span class="line" id="L54">    <span class="tok-kw">else</span></span>
<span class="line" id="L55">        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;PATH_MAX not implemented for &quot;</span> ++ <span class="tok-builtin">@tagName</span>(builtin.os.tag)),</span>
<span class="line" id="L56">};</span>
<span class="line" id="L57"></span>
<span class="line" id="L58"><span class="tok-comment">/// This represents the maximum size of a UTF-8 encoded file name component that</span></span>
<span class="line" id="L59"><span class="tok-comment">/// the platform's common file systems support. File name components returned by file system</span></span>
<span class="line" id="L60"><span class="tok-comment">/// operations are likely to fit into a UTF-8 encoded array of this length, but</span></span>
<span class="line" id="L61"><span class="tok-comment">/// (depending on the platform) this assumption may not hold for every configuration.</span></span>
<span class="line" id="L62"><span class="tok-comment">/// The byte count does not include a null sentinel byte.</span></span>
<span class="line" id="L63"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> MAX_NAME_BYTES = <span class="tok-kw">switch</span> (builtin.os.tag) {</span>
<span class="line" id="L64">    .linux, .macos, .ios, .freebsd, .openbsd, .netbsd, .dragonfly, .solaris, .illumos =&gt; os.NAME_MAX,</span>
<span class="line" id="L65">    <span class="tok-comment">// Haiku's NAME_MAX includes the null terminator, so subtract one.</span>
</span>
<span class="line" id="L66">    .haiku =&gt; os.NAME_MAX - <span class="tok-number">1</span>,</span>
<span class="line" id="L67">    <span class="tok-comment">// Each UTF-16LE character may be expanded to 3 UTF-8 bytes.</span>
</span>
<span class="line" id="L68">    <span class="tok-comment">// If it would require 4 UTF-8 bytes, then there would be a surrogate</span>
</span>
<span class="line" id="L69">    <span class="tok-comment">// pair in the UTF-16LE, and we (over)account 3 bytes for it that way.</span>
</span>
<span class="line" id="L70">    .windows =&gt; os.windows.NAME_MAX * <span class="tok-number">3</span>,</span>
<span class="line" id="L71">    <span class="tok-comment">// For WASI, the MAX_NAME will depend on the host OS, so it needs to be</span>
</span>
<span class="line" id="L72">    <span class="tok-comment">// as large as the largest MAX_NAME_BYTES (Windows) in order to work on any host OS.</span>
</span>
<span class="line" id="L73">    <span class="tok-comment">// TODO determine if this is a reasonable approach</span>
</span>
<span class="line" id="L74">    .wasi =&gt; os.windows.NAME_MAX * <span class="tok-number">3</span>,</span>
<span class="line" id="L75">    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(root, <span class="tok-str">&quot;os&quot;</span>) <span class="tok-kw">and</span> <span class="tok-builtin">@hasDecl</span>(root.os, <span class="tok-str">&quot;NAME_MAX&quot;</span>))</span>
<span class="line" id="L76">        root.os.NAME_MAX</span>
<span class="line" id="L77">    <span class="tok-kw">else</span></span>
<span class="line" id="L78">        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;NAME_MAX not implemented for &quot;</span> ++ <span class="tok-builtin">@tagName</span>(builtin.os.tag)),</span>
<span class="line" id="L79">};</span>
<span class="line" id="L80"></span>
<span class="line" id="L81"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> base64_alphabet = <span class="tok-str">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_&quot;</span>.*;</span>
<span class="line" id="L82"></span>
<span class="line" id="L83"><span class="tok-comment">/// Base64 encoder, replacing the standard `+/` with `-_` so that it can be used in a file name on any filesystem.</span></span>
<span class="line" id="L84"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> base64_encoder = base64.Base64Encoder.init(base64_alphabet, <span class="tok-null">null</span>);</span>
<span class="line" id="L85"></span>
<span class="line" id="L86"><span class="tok-comment">/// Base64 decoder, replacing the standard `+/` with `-_` so that it can be used in a file name on any filesystem.</span></span>
<span class="line" id="L87"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> base64_decoder = base64.Base64Decoder.init(base64_alphabet, <span class="tok-null">null</span>);</span>
<span class="line" id="L88"></span>
<span class="line" id="L89"><span class="tok-comment">/// Whether or not async file system syscalls need a dedicated thread because the operating</span></span>
<span class="line" id="L90"><span class="tok-comment">/// system does not support non-blocking I/O on the file system.</span></span>
<span class="line" id="L91"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> need_async_thread = std.io.is_async <span class="tok-kw">and</span> <span class="tok-kw">switch</span> (builtin.os.tag) {</span>
<span class="line" id="L92">    .windows, .other =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L93">    <span class="tok-kw">else</span> =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L94">};</span>
<span class="line" id="L95"></span>
<span class="line" id="L96"><span class="tok-comment">/// TODO remove the allocator requirement from this API</span></span>
<span class="line" id="L97"><span class="tok-comment">/// TODO move to Dir</span></span>
<span class="line" id="L98"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">atomicSymLink</span>(allocator: Allocator, existing_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L99">    <span class="tok-kw">if</span> (cwd().symLink(existing_path, new_path, .{})) {</span>
<span class="line" id="L100">        <span class="tok-kw">return</span>;</span>
<span class="line" id="L101">    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L102">        <span class="tok-kw">error</span>.PathAlreadyExists =&gt; {},</span>
<span class="line" id="L103">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err, <span class="tok-comment">// TODO zig should know this set does not include PathAlreadyExists</span>
</span>
<span class="line" id="L104">    }</span>
<span class="line" id="L105"></span>
<span class="line" id="L106">    <span class="tok-kw">const</span> dirname = path.dirname(new_path) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;.&quot;</span>;</span>
<span class="line" id="L107"></span>
<span class="line" id="L108">    <span class="tok-kw">var</span> rand_buf: [AtomicFile.random_bytes_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L109">    <span class="tok-kw">const</span> tmp_path = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, dirname.len + <span class="tok-number">1</span> + base64_encoder.calcSize(rand_buf.len));</span>
<span class="line" id="L110">    <span class="tok-kw">defer</span> allocator.free(tmp_path);</span>
<span class="line" id="L111">    <span class="tok-builtin">@memcpy</span>(tmp_path[<span class="tok-number">0</span>..dirname.len], dirname);</span>
<span class="line" id="L112">    tmp_path[dirname.len] = path.sep;</span>
<span class="line" id="L113">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L114">        crypto.random.bytes(rand_buf[<span class="tok-number">0</span>..]);</span>
<span class="line" id="L115">        _ = base64_encoder.encode(tmp_path[dirname.len + <span class="tok-number">1</span> ..], &amp;rand_buf);</span>
<span class="line" id="L116"></span>
<span class="line" id="L117">        <span class="tok-kw">if</span> (cwd().symLink(existing_path, tmp_path, .{})) {</span>
<span class="line" id="L118">            <span class="tok-kw">return</span> cwd().rename(tmp_path, new_path);</span>
<span class="line" id="L119">        } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L120">            <span class="tok-kw">error</span>.PathAlreadyExists =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L121">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err, <span class="tok-comment">// TODO zig should know this set does not include PathAlreadyExists</span>
</span>
<span class="line" id="L122">        }</span>
<span class="line" id="L123">    }</span>
<span class="line" id="L124">}</span>
<span class="line" id="L125"></span>
<span class="line" id="L126"><span class="tok-comment">/// Same as `Dir.updateFile`, except asserts that both `source_path` and `dest_path`</span></span>
<span class="line" id="L127"><span class="tok-comment">/// are absolute. See `Dir.updateFile` for a function that operates on both</span></span>
<span class="line" id="L128"><span class="tok-comment">/// absolute and relative paths.</span></span>
<span class="line" id="L129"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">updateFileAbsolute</span>(</span>
<span class="line" id="L130">    source_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L131">    dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L132">    args: Dir.CopyFileOptions,</span>
<span class="line" id="L133">) !Dir.PrevStatus {</span>
<span class="line" id="L134">    assert(path.isAbsolute(source_path));</span>
<span class="line" id="L135">    assert(path.isAbsolute(dest_path));</span>
<span class="line" id="L136">    <span class="tok-kw">const</span> my_cwd = cwd();</span>
<span class="line" id="L137">    <span class="tok-kw">return</span> Dir.updateFile(my_cwd, source_path, my_cwd, dest_path, args);</span>
<span class="line" id="L138">}</span>
<span class="line" id="L139"></span>
<span class="line" id="L140"><span class="tok-comment">/// Same as `Dir.copyFile`, except asserts that both `source_path` and `dest_path`</span></span>
<span class="line" id="L141"><span class="tok-comment">/// are absolute. See `Dir.copyFile` for a function that operates on both</span></span>
<span class="line" id="L142"><span class="tok-comment">/// absolute and relative paths.</span></span>
<span class="line" id="L143"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copyFileAbsolute</span>(</span>
<span class="line" id="L144">    source_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L145">    dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L146">    args: Dir.CopyFileOptions,</span>
<span class="line" id="L147">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L148">    assert(path.isAbsolute(source_path));</span>
<span class="line" id="L149">    assert(path.isAbsolute(dest_path));</span>
<span class="line" id="L150">    <span class="tok-kw">const</span> my_cwd = cwd();</span>
<span class="line" id="L151">    <span class="tok-kw">return</span> Dir.copyFile(my_cwd, source_path, my_cwd, dest_path, args);</span>
<span class="line" id="L152">}</span>
<span class="line" id="L153"></span>
<span class="line" id="L154"><span class="tok-comment">/// Create a new directory, based on an absolute path.</span></span>
<span class="line" id="L155"><span class="tok-comment">/// Asserts that the path is absolute. See `Dir.makeDir` for a function that operates</span></span>
<span class="line" id="L156"><span class="tok-comment">/// on both absolute and relative paths.</span></span>
<span class="line" id="L157"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeDirAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L158">    assert(path.isAbsolute(absolute_path));</span>
<span class="line" id="L159">    <span class="tok-kw">return</span> os.mkdir(absolute_path, Dir.default_mode);</span>
<span class="line" id="L160">}</span>
<span class="line" id="L161"></span>
<span class="line" id="L162"><span class="tok-comment">/// Same as `makeDirAbsolute` except the parameter is a null-terminated UTF-8-encoded string.</span></span>
<span class="line" id="L163"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeDirAbsoluteZ</span>(absolute_path_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L164">    assert(path.isAbsoluteZ(absolute_path_z));</span>
<span class="line" id="L165">    <span class="tok-kw">return</span> os.mkdirZ(absolute_path_z, Dir.default_mode);</span>
<span class="line" id="L166">}</span>
<span class="line" id="L167"></span>
<span class="line" id="L168"><span class="tok-comment">/// Same as `makeDirAbsolute` except the parameter is a null-terminated WTF-16-encoded string.</span></span>
<span class="line" id="L169"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeDirAbsoluteW</span>(absolute_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L170">    assert(path.isAbsoluteWindowsW(absolute_path_w));</span>
<span class="line" id="L171">    <span class="tok-kw">return</span> os.mkdirW(absolute_path_w, Dir.default_mode);</span>
<span class="line" id="L172">}</span>
<span class="line" id="L173"></span>
<span class="line" id="L174"><span class="tok-comment">/// Same as `Dir.deleteDir` except the path is absolute.</span></span>
<span class="line" id="L175"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteDirAbsolute</span>(dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L176">    assert(path.isAbsolute(dir_path));</span>
<span class="line" id="L177">    <span class="tok-kw">return</span> os.rmdir(dir_path);</span>
<span class="line" id="L178">}</span>
<span class="line" id="L179"></span>
<span class="line" id="L180"><span class="tok-comment">/// Same as `deleteDirAbsolute` except the path parameter is null-terminated.</span></span>
<span class="line" id="L181"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteDirAbsoluteZ</span>(dir_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L182">    assert(path.isAbsoluteZ(dir_path));</span>
<span class="line" id="L183">    <span class="tok-kw">return</span> os.rmdirZ(dir_path);</span>
<span class="line" id="L184">}</span>
<span class="line" id="L185"></span>
<span class="line" id="L186"><span class="tok-comment">/// Same as `deleteDirAbsolute` except the path parameter is WTF-16 and target OS is assumed Windows.</span></span>
<span class="line" id="L187"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteDirAbsoluteW</span>(dir_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L188">    assert(path.isAbsoluteWindowsW(dir_path));</span>
<span class="line" id="L189">    <span class="tok-kw">return</span> os.rmdirW(dir_path);</span>
<span class="line" id="L190">}</span>
<span class="line" id="L191"></span>
<span class="line" id="L192"><span class="tok-comment">/// Same as `Dir.rename` except the paths are absolute.</span></span>
<span class="line" id="L193"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameAbsolute</span>(old_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L194">    assert(path.isAbsolute(old_path));</span>
<span class="line" id="L195">    assert(path.isAbsolute(new_path));</span>
<span class="line" id="L196">    <span class="tok-kw">return</span> os.rename(old_path, new_path);</span>
<span class="line" id="L197">}</span>
<span class="line" id="L198"></span>
<span class="line" id="L199"><span class="tok-comment">/// Same as `renameAbsolute` except the path parameters are null-terminated.</span></span>
<span class="line" id="L200"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameAbsoluteZ</span>(old_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L201">    assert(path.isAbsoluteZ(old_path));</span>
<span class="line" id="L202">    assert(path.isAbsoluteZ(new_path));</span>
<span class="line" id="L203">    <span class="tok-kw">return</span> os.renameZ(old_path, new_path);</span>
<span class="line" id="L204">}</span>
<span class="line" id="L205"></span>
<span class="line" id="L206"><span class="tok-comment">/// Same as `renameAbsolute` except the path parameters are WTF-16 and target OS is assumed Windows.</span></span>
<span class="line" id="L207"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameAbsoluteW</span>(old_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, new_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L208">    assert(path.isAbsoluteWindowsW(old_path));</span>
<span class="line" id="L209">    assert(path.isAbsoluteWindowsW(new_path));</span>
<span class="line" id="L210">    <span class="tok-kw">return</span> os.renameW(old_path, new_path);</span>
<span class="line" id="L211">}</span>
<span class="line" id="L212"></span>
<span class="line" id="L213"><span class="tok-comment">/// Same as `Dir.rename`, except `new_sub_path` is relative to `new_dir`</span></span>
<span class="line" id="L214"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rename</span>(old_dir: Dir, old_sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_dir: Dir, new_sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L215">    <span class="tok-kw">return</span> os.renameat(old_dir.fd, old_sub_path, new_dir.fd, new_sub_path);</span>
<span class="line" id="L216">}</span>
<span class="line" id="L217"></span>
<span class="line" id="L218"><span class="tok-comment">/// Same as `rename` except the parameters are null-terminated.</span></span>
<span class="line" id="L219"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameZ</span>(old_dir: Dir, old_sub_path_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_dir: Dir, new_sub_path_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L220">    <span class="tok-kw">return</span> os.renameatZ(old_dir.fd, old_sub_path_z, new_dir.fd, new_sub_path_z);</span>
<span class="line" id="L221">}</span>
<span class="line" id="L222"></span>
<span class="line" id="L223"><span class="tok-comment">/// Same as `rename` except the parameters are UTF16LE, NT prefixed.</span></span>
<span class="line" id="L224"><span class="tok-comment">/// This function is Windows-only.</span></span>
<span class="line" id="L225"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameW</span>(old_dir: Dir, old_sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, new_dir: Dir, new_sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L226">    <span class="tok-kw">return</span> os.renameatW(old_dir.fd, old_sub_path_w, new_dir.fd, new_sub_path_w);</span>
<span class="line" id="L227">}</span>
<span class="line" id="L228"></span>
<span class="line" id="L229"><span class="tok-comment">/// Returns a handle to the current working directory. It is not opened with iteration capability.</span></span>
<span class="line" id="L230"><span class="tok-comment">/// Closing the returned `Dir` is checked illegal behavior. Iterating over the result is illegal behavior.</span></span>
<span class="line" id="L231"><span class="tok-comment">/// On POSIX targets, this function is comptime-callable.</span></span>
<span class="line" id="L232"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cwd</span>() Dir {</span>
<span class="line" id="L233">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L234">        <span class="tok-kw">return</span> Dir{ .fd = os.windows.peb().ProcessParameters.CurrentDirectory.Handle };</span>
<span class="line" id="L235">    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (builtin.os.tag == .wasi) {</span>
<span class="line" id="L236">        <span class="tok-kw">return</span> std.options.wasiCwd();</span>
<span class="line" id="L237">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L238">        <span class="tok-kw">return</span> Dir{ .fd = os.AT.FDCWD };</span>
<span class="line" id="L239">    }</span>
<span class="line" id="L240">}</span>
<span class="line" id="L241"></span>
<span class="line" id="L242"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">defaultWasiCwd</span>() Dir {</span>
<span class="line" id="L243">    <span class="tok-comment">// Expect the first preopen to be current working directory.</span>
</span>
<span class="line" id="L244">    <span class="tok-kw">return</span> .{ .fd = <span class="tok-number">3</span> };</span>
<span class="line" id="L245">}</span>
<span class="line" id="L246"></span>
<span class="line" id="L247"><span class="tok-comment">/// Opens a directory at the given path. The directory is a system resource that remains</span></span>
<span class="line" id="L248"><span class="tok-comment">/// open until `close` is called on the result.</span></span>
<span class="line" id="L249"><span class="tok-comment">/// See `openDirAbsoluteZ` for a function that accepts a null-terminated path.</span></span>
<span class="line" id="L250"><span class="tok-comment">///</span></span>
<span class="line" id="L251"><span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span></span>
<span class="line" id="L252"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDirAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: Dir.OpenDirOptions) File.OpenError!Dir {</span>
<span class="line" id="L253">    assert(path.isAbsolute(absolute_path));</span>
<span class="line" id="L254">    <span class="tok-kw">return</span> cwd().openDir(absolute_path, flags);</span>
<span class="line" id="L255">}</span>
<span class="line" id="L256"></span>
<span class="line" id="L257"><span class="tok-comment">/// Same as `openDirAbsolute` but the path parameter is null-terminated.</span></span>
<span class="line" id="L258"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDirAbsoluteZ</span>(absolute_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: Dir.OpenDirOptions) File.OpenError!Dir {</span>
<span class="line" id="L259">    assert(path.isAbsoluteZ(absolute_path_c));</span>
<span class="line" id="L260">    <span class="tok-kw">return</span> cwd().openDirZ(absolute_path_c, flags);</span>
<span class="line" id="L261">}</span>
<span class="line" id="L262"><span class="tok-comment">/// Same as `openDirAbsolute` but the path parameter is null-terminated.</span></span>
<span class="line" id="L263"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDirAbsoluteW</span>(absolute_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: Dir.OpenDirOptions) File.OpenError!Dir {</span>
<span class="line" id="L264">    assert(path.isAbsoluteWindowsW(absolute_path_c));</span>
<span class="line" id="L265">    <span class="tok-kw">return</span> cwd().openDirW(absolute_path_c, flags);</span>
<span class="line" id="L266">}</span>
<span class="line" id="L267"></span>
<span class="line" id="L268"><span class="tok-comment">/// Opens a file for reading or writing, without attempting to create a new file, based on an absolute path.</span></span>
<span class="line" id="L269"><span class="tok-comment">/// Call `File.close` to release the resource.</span></span>
<span class="line" id="L270"><span class="tok-comment">/// Asserts that the path is absolute. See `Dir.openFile` for a function that</span></span>
<span class="line" id="L271"><span class="tok-comment">/// operates on both absolute and relative paths.</span></span>
<span class="line" id="L272"><span class="tok-comment">/// Asserts that the path parameter has no null bytes. See `openFileAbsoluteZ` for a function</span></span>
<span class="line" id="L273"><span class="tok-comment">/// that accepts a null-terminated path.</span></span>
<span class="line" id="L274"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openFileAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: File.OpenFlags) File.OpenError!File {</span>
<span class="line" id="L275">    assert(path.isAbsolute(absolute_path));</span>
<span class="line" id="L276">    <span class="tok-kw">return</span> cwd().openFile(absolute_path, flags);</span>
<span class="line" id="L277">}</span>
<span class="line" id="L278"></span>
<span class="line" id="L279"><span class="tok-comment">/// Same as `openFileAbsolute` but the path parameter is null-terminated.</span></span>
<span class="line" id="L280"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openFileAbsoluteZ</span>(absolute_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: File.OpenFlags) File.OpenError!File {</span>
<span class="line" id="L281">    assert(path.isAbsoluteZ(absolute_path_c));</span>
<span class="line" id="L282">    <span class="tok-kw">return</span> cwd().openFileZ(absolute_path_c, flags);</span>
<span class="line" id="L283">}</span>
<span class="line" id="L284"></span>
<span class="line" id="L285"><span class="tok-comment">/// Same as `openFileAbsolute` but the path parameter is WTF-16-encoded.</span></span>
<span class="line" id="L286"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openFileAbsoluteW</span>(absolute_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: File.OpenFlags) File.OpenError!File {</span>
<span class="line" id="L287">    assert(path.isAbsoluteWindowsWTF16(absolute_path_w));</span>
<span class="line" id="L288">    <span class="tok-kw">return</span> cwd().openFileW(absolute_path_w, flags);</span>
<span class="line" id="L289">}</span>
<span class="line" id="L290"></span>
<span class="line" id="L291"><span class="tok-comment">/// Test accessing `path`.</span></span>
<span class="line" id="L292"><span class="tok-comment">/// `path` is UTF-8-encoded.</span></span>
<span class="line" id="L293"><span class="tok-comment">/// Be careful of Time-Of-Check-Time-Of-Use race conditions when using this function.</span></span>
<span class="line" id="L294"><span class="tok-comment">/// For example, instead of testing if a file exists and then opening it, just</span></span>
<span class="line" id="L295"><span class="tok-comment">/// open it and handle the error for file not found.</span></span>
<span class="line" id="L296"><span class="tok-comment">/// See `accessAbsoluteZ` for a function that accepts a null-terminated path.</span></span>
<span class="line" id="L297"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accessAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: File.OpenFlags) Dir.AccessError!<span class="tok-type">void</span> {</span>
<span class="line" id="L298">    assert(path.isAbsolute(absolute_path));</span>
<span class="line" id="L299">    <span class="tok-kw">try</span> cwd().access(absolute_path, flags);</span>
<span class="line" id="L300">}</span>
<span class="line" id="L301"><span class="tok-comment">/// Same as `accessAbsolute` but the path parameter is null-terminated.</span></span>
<span class="line" id="L302"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accessAbsoluteZ</span>(absolute_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: File.OpenFlags) Dir.AccessError!<span class="tok-type">void</span> {</span>
<span class="line" id="L303">    assert(path.isAbsoluteZ(absolute_path));</span>
<span class="line" id="L304">    <span class="tok-kw">try</span> cwd().accessZ(absolute_path, flags);</span>
<span class="line" id="L305">}</span>
<span class="line" id="L306"><span class="tok-comment">/// Same as `accessAbsolute` but the path parameter is WTF-16 encoded.</span></span>
<span class="line" id="L307"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accessAbsoluteW</span>(absolute_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: File.OpenFlags) Dir.AccessError!<span class="tok-type">void</span> {</span>
<span class="line" id="L308">    assert(path.isAbsoluteWindowsW(absolute_path));</span>
<span class="line" id="L309">    <span class="tok-kw">try</span> cwd().accessW(absolute_path, flags);</span>
<span class="line" id="L310">}</span>
<span class="line" id="L311"></span>
<span class="line" id="L312"><span class="tok-comment">/// Creates, opens, or overwrites a file with write access, based on an absolute path.</span></span>
<span class="line" id="L313"><span class="tok-comment">/// Call `File.close` to release the resource.</span></span>
<span class="line" id="L314"><span class="tok-comment">/// Asserts that the path is absolute. See `Dir.createFile` for a function that</span></span>
<span class="line" id="L315"><span class="tok-comment">/// operates on both absolute and relative paths.</span></span>
<span class="line" id="L316"><span class="tok-comment">/// Asserts that the path parameter has no null bytes. See `createFileAbsoluteC` for a function</span></span>
<span class="line" id="L317"><span class="tok-comment">/// that accepts a null-terminated path.</span></span>
<span class="line" id="L318"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createFileAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: File.CreateFlags) File.OpenError!File {</span>
<span class="line" id="L319">    assert(path.isAbsolute(absolute_path));</span>
<span class="line" id="L320">    <span class="tok-kw">return</span> cwd().createFile(absolute_path, flags);</span>
<span class="line" id="L321">}</span>
<span class="line" id="L322"></span>
<span class="line" id="L323"><span class="tok-comment">/// Same as `createFileAbsolute` but the path parameter is null-terminated.</span></span>
<span class="line" id="L324"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createFileAbsoluteZ</span>(absolute_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: File.CreateFlags) File.OpenError!File {</span>
<span class="line" id="L325">    assert(path.isAbsoluteZ(absolute_path_c));</span>
<span class="line" id="L326">    <span class="tok-kw">return</span> cwd().createFileZ(absolute_path_c, flags);</span>
<span class="line" id="L327">}</span>
<span class="line" id="L328"></span>
<span class="line" id="L329"><span class="tok-comment">/// Same as `createFileAbsolute` but the path parameter is WTF-16 encoded.</span></span>
<span class="line" id="L330"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createFileAbsoluteW</span>(absolute_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: File.CreateFlags) File.OpenError!File {</span>
<span class="line" id="L331">    assert(path.isAbsoluteWindowsW(absolute_path_w));</span>
<span class="line" id="L332">    <span class="tok-kw">return</span> cwd().createFileW(absolute_path_w, flags);</span>
<span class="line" id="L333">}</span>
<span class="line" id="L334"></span>
<span class="line" id="L335"><span class="tok-comment">/// Delete a file name and possibly the file it refers to, based on an absolute path.</span></span>
<span class="line" id="L336"><span class="tok-comment">/// Asserts that the path is absolute. See `Dir.deleteFile` for a function that</span></span>
<span class="line" id="L337"><span class="tok-comment">/// operates on both absolute and relative paths.</span></span>
<span class="line" id="L338"><span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span></span>
<span class="line" id="L339"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteFileAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) Dir.DeleteFileError!<span class="tok-type">void</span> {</span>
<span class="line" id="L340">    assert(path.isAbsolute(absolute_path));</span>
<span class="line" id="L341">    <span class="tok-kw">return</span> cwd().deleteFile(absolute_path);</span>
<span class="line" id="L342">}</span>
<span class="line" id="L343"></span>
<span class="line" id="L344"><span class="tok-comment">/// Same as `deleteFileAbsolute` except the parameter is null-terminated.</span></span>
<span class="line" id="L345"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteFileAbsoluteZ</span>(absolute_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) Dir.DeleteFileError!<span class="tok-type">void</span> {</span>
<span class="line" id="L346">    assert(path.isAbsoluteZ(absolute_path_c));</span>
<span class="line" id="L347">    <span class="tok-kw">return</span> cwd().deleteFileZ(absolute_path_c);</span>
<span class="line" id="L348">}</span>
<span class="line" id="L349"></span>
<span class="line" id="L350"><span class="tok-comment">/// Same as `deleteFileAbsolute` except the parameter is WTF-16 encoded.</span></span>
<span class="line" id="L351"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteFileAbsoluteW</span>(absolute_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) Dir.DeleteFileError!<span class="tok-type">void</span> {</span>
<span class="line" id="L352">    assert(path.isAbsoluteWindowsW(absolute_path_w));</span>
<span class="line" id="L353">    <span class="tok-kw">return</span> cwd().deleteFileW(absolute_path_w);</span>
<span class="line" id="L354">}</span>
<span class="line" id="L355"></span>
<span class="line" id="L356"><span class="tok-comment">/// Removes a symlink, file, or directory.</span></span>
<span class="line" id="L357"><span class="tok-comment">/// This is equivalent to `Dir.deleteTree` with the base directory.</span></span>
<span class="line" id="L358"><span class="tok-comment">/// Asserts that the path is absolute. See `Dir.deleteTree` for a function that</span></span>
<span class="line" id="L359"><span class="tok-comment">/// operates on both absolute and relative paths.</span></span>
<span class="line" id="L360"><span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span></span>
<span class="line" id="L361"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteTreeAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L362">    assert(path.isAbsolute(absolute_path));</span>
<span class="line" id="L363">    <span class="tok-kw">const</span> dirname = path.dirname(absolute_path) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>{</span>
<span class="line" id="L364">        <span class="tok-comment">/// Attempt to remove the root file system path.</span></span>
<span class="line" id="L365">        <span class="tok-comment">/// This error is unreachable if `absolute_path` is relative.</span></span>
<span class="line" id="L366">        CannotDeleteRootDirectory,</span>
<span class="line" id="L367">    }.CannotDeleteRootDirectory;</span>
<span class="line" id="L368"></span>
<span class="line" id="L369">    <span class="tok-kw">var</span> dir = <span class="tok-kw">try</span> cwd().openDir(dirname, .{});</span>
<span class="line" id="L370">    <span class="tok-kw">defer</span> dir.close();</span>
<span class="line" id="L371"></span>
<span class="line" id="L372">    <span class="tok-kw">return</span> dir.deleteTree(path.basename(absolute_path));</span>
<span class="line" id="L373">}</span>
<span class="line" id="L374"></span>
<span class="line" id="L375"><span class="tok-comment">/// Same as `Dir.readLink`, except it asserts the path is absolute.</span></span>
<span class="line" id="L376"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLinkAbsolute</span>(pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: *[MAX_PATH_BYTES]<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L377">    assert(path.isAbsolute(pathname));</span>
<span class="line" id="L378">    <span class="tok-kw">return</span> os.readlink(pathname, buffer);</span>
<span class="line" id="L379">}</span>
<span class="line" id="L380"></span>
<span class="line" id="L381"><span class="tok-comment">/// Windows-only. Same as `readlinkW`, except the path parameter is null-terminated, WTF16</span></span>
<span class="line" id="L382"><span class="tok-comment">/// encoded.</span></span>
<span class="line" id="L383"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readlinkAbsoluteW</span>(pathname_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, buffer: *[MAX_PATH_BYTES]<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L384">    assert(path.isAbsoluteWindowsW(pathname_w));</span>
<span class="line" id="L385">    <span class="tok-kw">return</span> os.readlinkW(pathname_w, buffer);</span>
<span class="line" id="L386">}</span>
<span class="line" id="L387"></span>
<span class="line" id="L388"><span class="tok-comment">/// Same as `readLink`, except the path parameter is null-terminated.</span></span>
<span class="line" id="L389"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLinkAbsoluteZ</span>(pathname_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: *[MAX_PATH_BYTES]<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L390">    assert(path.isAbsoluteZ(pathname_c));</span>
<span class="line" id="L391">    <span class="tok-kw">return</span> os.readlinkZ(pathname_c, buffer);</span>
<span class="line" id="L392">}</span>
<span class="line" id="L393"></span>
<span class="line" id="L394"><span class="tok-comment">/// Creates a symbolic link named `sym_link_path` which contains the string `target_path`.</span></span>
<span class="line" id="L395"><span class="tok-comment">/// A symbolic link (also known as a soft link) may point to an existing file or to a nonexistent</span></span>
<span class="line" id="L396"><span class="tok-comment">/// one; the latter case is known as a dangling link.</span></span>
<span class="line" id="L397"><span class="tok-comment">/// If `sym_link_path` exists, it will not be overwritten.</span></span>
<span class="line" id="L398"><span class="tok-comment">/// See also `symLinkAbsoluteZ` and `symLinkAbsoluteW`.</span></span>
<span class="line" id="L399"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLinkAbsolute</span>(</span>
<span class="line" id="L400">    target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L401">    sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L402">    flags: Dir.SymLinkFlags,</span>
<span class="line" id="L403">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L404">    assert(path.isAbsolute(target_path));</span>
<span class="line" id="L405">    assert(path.isAbsolute(sym_link_path));</span>
<span class="line" id="L406">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L407">        <span class="tok-kw">const</span> target_path_w = <span class="tok-kw">try</span> os.windows.sliceToPrefixedFileW(<span class="tok-null">null</span>, target_path);</span>
<span class="line" id="L408">        <span class="tok-kw">const</span> sym_link_path_w = <span class="tok-kw">try</span> os.windows.sliceToPrefixedFileW(<span class="tok-null">null</span>, sym_link_path);</span>
<span class="line" id="L409">        <span class="tok-kw">return</span> os.windows.CreateSymbolicLink(<span class="tok-null">null</span>, sym_link_path_w.span(), target_path_w.span(), flags.is_directory);</span>
<span class="line" id="L410">    }</span>
<span class="line" id="L411">    <span class="tok-kw">return</span> os.symlink(target_path, sym_link_path);</span>
<span class="line" id="L412">}</span>
<span class="line" id="L413"></span>
<span class="line" id="L414"><span class="tok-comment">/// Windows-only. Same as `symLinkAbsolute` except the parameters are null-terminated, WTF16 encoded.</span></span>
<span class="line" id="L415"><span class="tok-comment">/// Note that this function will by default try creating a symbolic link to a file. If you would</span></span>
<span class="line" id="L416"><span class="tok-comment">/// like to create a symbolic link to a directory, specify this with `SymLinkFlags{ .is_directory = true }`.</span></span>
<span class="line" id="L417"><span class="tok-comment">/// See also `symLinkAbsolute`, `symLinkAbsoluteZ`.</span></span>
<span class="line" id="L418"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLinkAbsoluteW</span>(</span>
<span class="line" id="L419">    target_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>,</span>
<span class="line" id="L420">    sym_link_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>,</span>
<span class="line" id="L421">    flags: Dir.SymLinkFlags,</span>
<span class="line" id="L422">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L423">    assert(path.isAbsoluteWindowsWTF16(target_path_w));</span>
<span class="line" id="L424">    assert(path.isAbsoluteWindowsWTF16(sym_link_path_w));</span>
<span class="line" id="L425">    <span class="tok-kw">return</span> os.windows.CreateSymbolicLink(<span class="tok-null">null</span>, sym_link_path_w, target_path_w, flags.is_directory);</span>
<span class="line" id="L426">}</span>
<span class="line" id="L427"></span>
<span class="line" id="L428"><span class="tok-comment">/// Same as `symLinkAbsolute` except the parameters are null-terminated pointers.</span></span>
<span class="line" id="L429"><span class="tok-comment">/// See also `symLinkAbsolute`.</span></span>
<span class="line" id="L430"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLinkAbsoluteZ</span>(</span>
<span class="line" id="L431">    target_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L432">    sym_link_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L433">    flags: Dir.SymLinkFlags,</span>
<span class="line" id="L434">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L435">    assert(path.isAbsoluteZ(target_path_c));</span>
<span class="line" id="L436">    assert(path.isAbsoluteZ(sym_link_path_c));</span>
<span class="line" id="L437">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L438">        <span class="tok-kw">const</span> target_path_w = <span class="tok-kw">try</span> os.windows.cStrToWin32PrefixedFileW(target_path_c);</span>
<span class="line" id="L439">        <span class="tok-kw">const</span> sym_link_path_w = <span class="tok-kw">try</span> os.windows.cStrToWin32PrefixedFileW(sym_link_path_c);</span>
<span class="line" id="L440">        <span class="tok-kw">return</span> os.windows.CreateSymbolicLink(sym_link_path_w.span(), target_path_w.span(), flags.is_directory);</span>
<span class="line" id="L441">    }</span>
<span class="line" id="L442">    <span class="tok-kw">return</span> os.symlinkZ(target_path_c, sym_link_path_c);</span>
<span class="line" id="L443">}</span>
<span class="line" id="L444"></span>
<span class="line" id="L445"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> OpenSelfExeError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L446">    SharingViolation,</span>
<span class="line" id="L447">    PathAlreadyExists,</span>
<span class="line" id="L448">    FileNotFound,</span>
<span class="line" id="L449">    AccessDenied,</span>
<span class="line" id="L450">    PipeBusy,</span>
<span class="line" id="L451">    NameTooLong,</span>
<span class="line" id="L452">    <span class="tok-comment">/// On Windows, file paths must be valid Unicode.</span></span>
<span class="line" id="L453">    InvalidUtf8,</span>
<span class="line" id="L454">    <span class="tok-comment">/// On Windows, file paths cannot contain these characters:</span></span>
<span class="line" id="L455">    <span class="tok-comment">/// '/', '*', '?', '&quot;', '&lt;', '&gt;', '|'</span></span>
<span class="line" id="L456">    BadPathName,</span>
<span class="line" id="L457">    Unexpected,</span>
<span class="line" id="L458">} || os.OpenError || SelfExePathError || os.FlockError;</span>
<span class="line" id="L459"></span>
<span class="line" id="L460"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openSelfExe</span>(flags: File.OpenFlags) OpenSelfExeError!File {</span>
<span class="line" id="L461">    <span class="tok-kw">if</span> (builtin.os.tag == .linux) {</span>
<span class="line" id="L462">        <span class="tok-kw">return</span> openFileAbsoluteZ(<span class="tok-str">&quot;/proc/self/exe&quot;</span>, flags);</span>
<span class="line" id="L463">    }</span>
<span class="line" id="L464">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L465">        <span class="tok-comment">// If ImagePathName is a symlink, then it will contain the path of the symlink,</span>
</span>
<span class="line" id="L466">        <span class="tok-comment">// not the path that the symlink points to. However, because we are opening</span>
</span>
<span class="line" id="L467">        <span class="tok-comment">// the file, we can let the openFileW call follow the symlink for us.</span>
</span>
<span class="line" id="L468">        <span class="tok-kw">const</span> image_path_unicode_string = &amp;os.windows.peb().ProcessParameters.ImagePathName;</span>
<span class="line" id="L469">        <span class="tok-kw">const</span> image_path_name = image_path_unicode_string.Buffer[<span class="tok-number">0</span> .. image_path_unicode_string.Length / <span class="tok-number">2</span> :<span class="tok-number">0</span>];</span>
<span class="line" id="L470">        <span class="tok-kw">const</span> prefixed_path_w = <span class="tok-kw">try</span> os.windows.wToPrefixedFileW(<span class="tok-null">null</span>, image_path_name);</span>
<span class="line" id="L471">        <span class="tok-kw">return</span> cwd().openFileW(prefixed_path_w.span(), flags);</span>
<span class="line" id="L472">    }</span>
<span class="line" id="L473">    <span class="tok-comment">// Use of MAX_PATH_BYTES here is valid as the resulting path is immediately</span>
</span>
<span class="line" id="L474">    <span class="tok-comment">// opened with no modification.</span>
</span>
<span class="line" id="L475">    <span class="tok-kw">var</span> buf: [MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L476">    <span class="tok-kw">const</span> self_exe_path = <span class="tok-kw">try</span> selfExePath(&amp;buf);</span>
<span class="line" id="L477">    buf[self_exe_path.len] = <span class="tok-number">0</span>;</span>
<span class="line" id="L478">    <span class="tok-kw">return</span> openFileAbsoluteZ(buf[<span class="tok-number">0</span>..self_exe_path.len :<span class="tok-number">0</span>].ptr, flags);</span>
<span class="line" id="L479">}</span>
<span class="line" id="L480"></span>
<span class="line" id="L481"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SelfExePathError = os.ReadLinkError || os.SysCtlError || os.RealPathError;</span>
<span class="line" id="L482"></span>
<span class="line" id="L483"><span class="tok-comment">/// `selfExePath` except allocates the result on the heap.</span></span>
<span class="line" id="L484"><span class="tok-comment">/// Caller owns returned memory.</span></span>
<span class="line" id="L485"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">selfExePathAlloc</span>(allocator: Allocator) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L486">    <span class="tok-comment">// Use of MAX_PATH_BYTES here is justified as, at least on one tested Linux</span>
</span>
<span class="line" id="L487">    <span class="tok-comment">// system, readlink will completely fail to return a result larger than</span>
</span>
<span class="line" id="L488">    <span class="tok-comment">// PATH_MAX even if given a sufficiently large buffer. This makes it</span>
</span>
<span class="line" id="L489">    <span class="tok-comment">// fundamentally impossible to get the selfExePath of a program running in</span>
</span>
<span class="line" id="L490">    <span class="tok-comment">// a very deeply nested directory chain in this way.</span>
</span>
<span class="line" id="L491">    <span class="tok-comment">// TODO(#4812): Investigate other systems and whether it is possible to get</span>
</span>
<span class="line" id="L492">    <span class="tok-comment">// this path by trying larger and larger buffers until one succeeds.</span>
</span>
<span class="line" id="L493">    <span class="tok-kw">var</span> buf: [MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L494">    <span class="tok-kw">return</span> allocator.dupe(<span class="tok-type">u8</span>, <span class="tok-kw">try</span> selfExePath(&amp;buf));</span>
<span class="line" id="L495">}</span>
<span class="line" id="L496"></span>
<span class="line" id="L497"><span class="tok-comment">/// Get the path to the current executable. Follows symlinks.</span></span>
<span class="line" id="L498"><span class="tok-comment">/// If you only need the directory, use selfExeDirPath.</span></span>
<span class="line" id="L499"><span class="tok-comment">/// If you only want an open file handle, use openSelfExe.</span></span>
<span class="line" id="L500"><span class="tok-comment">/// This function may return an error if the current executable</span></span>
<span class="line" id="L501"><span class="tok-comment">/// was deleted after spawning.</span></span>
<span class="line" id="L502"><span class="tok-comment">/// Returned value is a slice of out_buffer.</span></span>
<span class="line" id="L503"><span class="tok-comment">///</span></span>
<span class="line" id="L504"><span class="tok-comment">/// On Linux, depends on procfs being mounted. If the currently executing binary has</span></span>
<span class="line" id="L505"><span class="tok-comment">/// been deleted, the file path looks something like `/a/b/c/exe (deleted)`.</span></span>
<span class="line" id="L506"><span class="tok-comment">/// TODO make the return type of this a null terminated pointer</span></span>
<span class="line" id="L507"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">selfExePath</span>(out_buffer: []<span class="tok-type">u8</span>) SelfExePathError![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L508">    <span class="tok-kw">if</span> (is_darwin) {</span>
<span class="line" id="L509">        <span class="tok-comment">// Note that _NSGetExecutablePath() will return &quot;a path&quot; to</span>
</span>
<span class="line" id="L510">        <span class="tok-comment">// the executable not a &quot;real path&quot; to the executable.</span>
</span>
<span class="line" id="L511">        <span class="tok-kw">var</span> symlink_path_buf: [MAX_PATH_BYTES:<span class="tok-number">0</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L512">        <span class="tok-kw">var</span> u32_len: <span class="tok-type">u32</span> = MAX_PATH_BYTES + <span class="tok-number">1</span>; <span class="tok-comment">// include the sentinel</span>
</span>
<span class="line" id="L513">        <span class="tok-kw">const</span> rc = std.c._NSGetExecutablePath(&amp;symlink_path_buf, &amp;u32_len);</span>
<span class="line" id="L514">        <span class="tok-kw">if</span> (rc != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;</span>
<span class="line" id="L515"></span>
<span class="line" id="L516">        <span class="tok-kw">var</span> real_path_buf: [MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L517">        <span class="tok-kw">const</span> real_path = <span class="tok-kw">try</span> std.os.realpathZ(&amp;symlink_path_buf, &amp;real_path_buf);</span>
<span class="line" id="L518">        <span class="tok-kw">if</span> (real_path.len &gt; out_buffer.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;</span>
<span class="line" id="L519">        <span class="tok-kw">const</span> result = out_buffer[<span class="tok-number">0</span>..real_path.len];</span>
<span class="line" id="L520">        <span class="tok-builtin">@memcpy</span>(result, real_path);</span>
<span class="line" id="L521">        <span class="tok-kw">return</span> result;</span>
<span class="line" id="L522">    }</span>
<span class="line" id="L523">    <span class="tok-kw">switch</span> (builtin.os.tag) {</span>
<span class="line" id="L524">        .linux =&gt; <span class="tok-kw">return</span> os.readlinkZ(<span class="tok-str">&quot;/proc/self/exe&quot;</span>, out_buffer),</span>
<span class="line" id="L525">        .solaris, .illumos =&gt; <span class="tok-kw">return</span> os.readlinkZ(<span class="tok-str">&quot;/proc/self/path/a.out&quot;</span>, out_buffer),</span>
<span class="line" id="L526">        .freebsd, .dragonfly =&gt; {</span>
<span class="line" id="L527">            <span class="tok-kw">var</span> mib = [<span class="tok-number">4</span>]<span class="tok-type">c_int</span>{ os.CTL.KERN, os.KERN.PROC, os.KERN.PROC_PATHNAME, -<span class="tok-number">1</span> };</span>
<span class="line" id="L528">            <span class="tok-kw">var</span> out_len: <span class="tok-type">usize</span> = out_buffer.len;</span>
<span class="line" id="L529">            <span class="tok-kw">try</span> os.sysctl(&amp;mib, out_buffer.ptr, &amp;out_len, <span class="tok-null">null</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L530">            <span class="tok-comment">// TODO could this slice from 0 to out_len instead?</span>
</span>
<span class="line" id="L531">            <span class="tok-kw">return</span> mem.sliceTo(out_buffer, <span class="tok-number">0</span>);</span>
<span class="line" id="L532">        },</span>
<span class="line" id="L533">        .netbsd =&gt; {</span>
<span class="line" id="L534">            <span class="tok-kw">var</span> mib = [<span class="tok-number">4</span>]<span class="tok-type">c_int</span>{ os.CTL.KERN, os.KERN.PROC_ARGS, -<span class="tok-number">1</span>, os.KERN.PROC_PATHNAME };</span>
<span class="line" id="L535">            <span class="tok-kw">var</span> out_len: <span class="tok-type">usize</span> = out_buffer.len;</span>
<span class="line" id="L536">            <span class="tok-kw">try</span> os.sysctl(&amp;mib, out_buffer.ptr, &amp;out_len, <span class="tok-null">null</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L537">            <span class="tok-comment">// TODO could this slice from 0 to out_len instead?</span>
</span>
<span class="line" id="L538">            <span class="tok-kw">return</span> mem.sliceTo(out_buffer, <span class="tok-number">0</span>);</span>
<span class="line" id="L539">        },</span>
<span class="line" id="L540">        .openbsd, .haiku =&gt; {</span>
<span class="line" id="L541">            <span class="tok-comment">// OpenBSD doesn't support getting the path of a running process, so try to guess it</span>
</span>
<span class="line" id="L542">            <span class="tok-kw">if</span> (os.argv.len == <span class="tok-number">0</span>)</span>
<span class="line" id="L543">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound;</span>
<span class="line" id="L544"></span>
<span class="line" id="L545">            <span class="tok-kw">const</span> argv0 = mem.span(os.argv[<span class="tok-number">0</span>]);</span>
<span class="line" id="L546">            <span class="tok-kw">if</span> (mem.indexOf(<span class="tok-type">u8</span>, argv0, <span class="tok-str">&quot;/&quot;</span>) != <span class="tok-null">null</span>) {</span>
<span class="line" id="L547">                <span class="tok-comment">// argv[0] is a path (relative or absolute): use realpath(3) directly</span>
</span>
<span class="line" id="L548">                <span class="tok-kw">var</span> real_path_buf: [MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L549">                <span class="tok-kw">const</span> real_path = <span class="tok-kw">try</span> os.realpathZ(os.argv[<span class="tok-number">0</span>], &amp;real_path_buf);</span>
<span class="line" id="L550">                <span class="tok-kw">if</span> (real_path.len &gt; out_buffer.len)</span>
<span class="line" id="L551">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;</span>
<span class="line" id="L552">                <span class="tok-kw">const</span> result = out_buffer[<span class="tok-number">0</span>..real_path.len];</span>
<span class="line" id="L553">                <span class="tok-builtin">@memcpy</span>(result, real_path);</span>
<span class="line" id="L554">                <span class="tok-kw">return</span> result;</span>
<span class="line" id="L555">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (argv0.len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L556">                <span class="tok-comment">// argv[0] is not empty (and not a path): search it inside PATH</span>
</span>
<span class="line" id="L557">                <span class="tok-kw">const</span> PATH = std.os.getenvZ(<span class="tok-str">&quot;PATH&quot;</span>) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound;</span>
<span class="line" id="L558">                <span class="tok-kw">var</span> path_it = mem.tokenizeScalar(<span class="tok-type">u8</span>, PATH, path.delimiter);</span>
<span class="line" id="L559">                <span class="tok-kw">while</span> (path_it.next()) |a_path| {</span>
<span class="line" id="L560">                    <span class="tok-kw">var</span> resolved_path_buf: [MAX_PATH_BYTES - <span class="tok-number">1</span>:<span class="tok-number">0</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L561">                    <span class="tok-kw">const</span> resolved_path = std.fmt.bufPrintZ(&amp;resolved_path_buf, <span class="tok-str">&quot;{s}/{s}&quot;</span>, .{</span>
<span class="line" id="L562">                        a_path,</span>
<span class="line" id="L563">                        os.argv[<span class="tok-number">0</span>],</span>
<span class="line" id="L564">                    }) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L565"></span>
<span class="line" id="L566">                    <span class="tok-kw">var</span> real_path_buf: [MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L567">                    <span class="tok-kw">if</span> (os.realpathZ(resolved_path, &amp;real_path_buf)) |real_path| {</span>
<span class="line" id="L568">                        <span class="tok-comment">// found a file, and hope it is the right file</span>
</span>
<span class="line" id="L569">                        <span class="tok-kw">if</span> (real_path.len &gt; out_buffer.len)</span>
<span class="line" id="L570">                            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;</span>
<span class="line" id="L571">                        <span class="tok-kw">const</span> result = out_buffer[<span class="tok-number">0</span>..real_path.len];</span>
<span class="line" id="L572">                        <span class="tok-builtin">@memcpy</span>(result, real_path);</span>
<span class="line" id="L573">                        <span class="tok-kw">return</span> result;</span>
<span class="line" id="L574">                    } <span class="tok-kw">else</span> |_| <span class="tok-kw">continue</span>;</span>
<span class="line" id="L575">                }</span>
<span class="line" id="L576">            }</span>
<span class="line" id="L577">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound;</span>
<span class="line" id="L578">        },</span>
<span class="line" id="L579">        .windows =&gt; {</span>
<span class="line" id="L580">            <span class="tok-kw">const</span> image_path_unicode_string = &amp;os.windows.peb().ProcessParameters.ImagePathName;</span>
<span class="line" id="L581">            <span class="tok-kw">const</span> image_path_name = image_path_unicode_string.Buffer[<span class="tok-number">0</span> .. image_path_unicode_string.Length / <span class="tok-number">2</span> :<span class="tok-number">0</span>];</span>
<span class="line" id="L582"></span>
<span class="line" id="L583">            <span class="tok-comment">// If ImagePathName is a symlink, then it will contain the path of the</span>
</span>
<span class="line" id="L584">            <span class="tok-comment">// symlink, not the path that the symlink points to. We want the path</span>
</span>
<span class="line" id="L585">            <span class="tok-comment">// that the symlink points to, though, so we need to get the realpath.</span>
</span>
<span class="line" id="L586">            <span class="tok-kw">const</span> pathname_w = <span class="tok-kw">try</span> os.windows.wToPrefixedFileW(<span class="tok-null">null</span>, image_path_name);</span>
<span class="line" id="L587">            <span class="tok-kw">return</span> std.fs.cwd().realpathW(pathname_w.span(), out_buffer);</span>
<span class="line" id="L588">        },</span>
<span class="line" id="L589">        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;std.fs.selfExePath not supported for this target&quot;</span>),</span>
<span class="line" id="L590">    }</span>
<span class="line" id="L591">}</span>
<span class="line" id="L592"></span>
<span class="line" id="L593"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> selfExePathW = <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;deprecated; use selfExePath instead&quot;</span>);</span>
<span class="line" id="L594"></span>
<span class="line" id="L595"><span class="tok-comment">/// `selfExeDirPath` except allocates the result on the heap.</span></span>
<span class="line" id="L596"><span class="tok-comment">/// Caller owns returned memory.</span></span>
<span class="line" id="L597"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">selfExeDirPathAlloc</span>(allocator: Allocator) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L598">    <span class="tok-comment">// Use of MAX_PATH_BYTES here is justified as, at least on one tested Linux</span>
</span>
<span class="line" id="L599">    <span class="tok-comment">// system, readlink will completely fail to return a result larger than</span>
</span>
<span class="line" id="L600">    <span class="tok-comment">// PATH_MAX even if given a sufficiently large buffer. This makes it</span>
</span>
<span class="line" id="L601">    <span class="tok-comment">// fundamentally impossible to get the selfExeDirPath of a program running</span>
</span>
<span class="line" id="L602">    <span class="tok-comment">// in a very deeply nested directory chain in this way.</span>
</span>
<span class="line" id="L603">    <span class="tok-comment">// TODO(#4812): Investigate other systems and whether it is possible to get</span>
</span>
<span class="line" id="L604">    <span class="tok-comment">// this path by trying larger and larger buffers until one succeeds.</span>
</span>
<span class="line" id="L605">    <span class="tok-kw">var</span> buf: [MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L606">    <span class="tok-kw">return</span> allocator.dupe(<span class="tok-type">u8</span>, <span class="tok-kw">try</span> selfExeDirPath(&amp;buf));</span>
<span class="line" id="L607">}</span>
<span class="line" id="L608"></span>
<span class="line" id="L609"><span class="tok-comment">/// Get the directory path that contains the current executable.</span></span>
<span class="line" id="L610"><span class="tok-comment">/// Returned value is a slice of out_buffer.</span></span>
<span class="line" id="L611"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">selfExeDirPath</span>(out_buffer: []<span class="tok-type">u8</span>) SelfExePathError![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L612">    <span class="tok-kw">const</span> self_exe_path = <span class="tok-kw">try</span> selfExePath(out_buffer);</span>
<span class="line" id="L613">    <span class="tok-comment">// Assume that the OS APIs return absolute paths, and therefore dirname</span>
</span>
<span class="line" id="L614">    <span class="tok-comment">// will not return null.</span>
</span>
<span class="line" id="L615">    <span class="tok-kw">return</span> path.dirname(self_exe_path).?;</span>
<span class="line" id="L616">}</span>
<span class="line" id="L617"></span>
<span class="line" id="L618"><span class="tok-comment">/// `realpath`, except caller must free the returned memory.</span></span>
<span class="line" id="L619"><span class="tok-comment">/// See also `Dir.realpath`.</span></span>
<span class="line" id="L620"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpathAlloc</span>(allocator: Allocator, pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L621">    <span class="tok-comment">// Use of MAX_PATH_BYTES here is valid as the realpath function does not</span>
</span>
<span class="line" id="L622">    <span class="tok-comment">// have a variant that takes an arbitrary-size buffer.</span>
</span>
<span class="line" id="L623">    <span class="tok-comment">// TODO(#4812): Consider reimplementing realpath or using the POSIX.1-2008</span>
</span>
<span class="line" id="L624">    <span class="tok-comment">// NULL out parameter (GNU's canonicalize_file_name) to handle overelong</span>
</span>
<span class="line" id="L625">    <span class="tok-comment">// paths. musl supports passing NULL but restricts the output to PATH_MAX</span>
</span>
<span class="line" id="L626">    <span class="tok-comment">// anyway.</span>
</span>
<span class="line" id="L627">    <span class="tok-kw">var</span> buf: [MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L628">    <span class="tok-kw">return</span> allocator.dupe(<span class="tok-type">u8</span>, <span class="tok-kw">try</span> os.realpath(pathname, &amp;buf));</span>
<span class="line" id="L629">}</span>
<span class="line" id="L630"></span>
<span class="line" id="L631"><span class="tok-kw">test</span> {</span>
<span class="line" id="L632">    <span class="tok-kw">if</span> (builtin.os.tag != .wasi) {</span>
<span class="line" id="L633">        _ = &amp;makeDirAbsolute;</span>
<span class="line" id="L634">        _ = &amp;makeDirAbsoluteZ;</span>
<span class="line" id="L635">        _ = &amp;copyFileAbsolute;</span>
<span class="line" id="L636">        _ = &amp;updateFileAbsolute;</span>
<span class="line" id="L637">    }</span>
<span class="line" id="L638">    _ = &amp;AtomicFile;</span>
<span class="line" id="L639">    _ = &amp;Dir;</span>
<span class="line" id="L640">    _ = &amp;File;</span>
<span class="line" id="L641">    _ = &amp;path;</span>
<span class="line" id="L642">    _ = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fs/test.zig&quot;</span>);</span>
<span class="line" id="L643">    _ = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fs/get_app_data_dir.zig&quot;</span>);</span>
<span class="line" id="L644">    _ = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fs/watch.zig&quot;</span>);</span>
<span class="line" id="L645">}</span>
<span class="line" id="L646"></span>
</code></pre></body>
</html>