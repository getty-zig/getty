<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>fs/Dir.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg==">
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1">fd: posix.fd_t,</span>
<span class="line" id="L2"></span>
<span class="line" id="L3"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> default_mode = <span class="tok-number">0o755</span>;</span>
<span class="line" id="L4"></span>
<span class="line" id="L5"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L6">    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L7">    kind: Kind,</span>
<span class="line" id="L8"></span>
<span class="line" id="L9">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Kind = File.Kind;</span>
<span class="line" id="L10">};</span>
<span class="line" id="L11"></span>
<span class="line" id="L12"><span class="tok-kw">const</span> IteratorError = <span class="tok-kw">error</span>{ AccessDenied, SystemResources } || posix.UnexpectedError;</span>
<span class="line" id="L13"></span>
<span class="line" id="L14"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <span class="tok-kw">switch</span> (builtin.os.tag) {</span>
<span class="line" id="L15">    .macos, .ios, .freebsd, .netbsd, .dragonfly, .openbsd, .solaris, .illumos =&gt; <span class="tok-kw">struct</span> {</span>
<span class="line" id="L16">        dir: Dir,</span>
<span class="line" id="L17">        seek: <span class="tok-type">i64</span>,</span>
<span class="line" id="L18">        buf: [<span class="tok-number">1024</span>]<span class="tok-type">u8</span>, <span class="tok-comment">// TODO align(@alignOf(posix.system.dirent)),</span>
</span>
<span class="line" id="L19">        index: <span class="tok-type">usize</span>,</span>
<span class="line" id="L20">        end_index: <span class="tok-type">usize</span>,</span>
<span class="line" id="L21">        first_iter: <span class="tok-type">bool</span>,</span>
<span class="line" id="L22"></span>
<span class="line" id="L23">        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L24"></span>
<span class="line" id="L25">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = IteratorError;</span>
<span class="line" id="L26"></span>
<span class="line" id="L27">        <span class="tok-comment">/// Memory such as file names referenced in this returned entry becomes invalid</span></span>
<span class="line" id="L28">        <span class="tok-comment">/// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.</span></span>
<span class="line" id="L29">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *Self) Error!?Entry {</span>
<span class="line" id="L30">            <span class="tok-kw">switch</span> (builtin.os.tag) {</span>
<span class="line" id="L31">                .macos, .ios =&gt; <span class="tok-kw">return</span> self.nextDarwin(),</span>
<span class="line" id="L32">                .freebsd, .netbsd, .dragonfly, .openbsd =&gt; <span class="tok-kw">return</span> self.nextBsd(),</span>
<span class="line" id="L33">                .solaris, .illumos =&gt; <span class="tok-kw">return</span> self.nextSolaris(),</span>
<span class="line" id="L34">                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unimplemented&quot;</span>),</span>
<span class="line" id="L35">            }</span>
<span class="line" id="L36">        }</span>
<span class="line" id="L37"></span>
<span class="line" id="L38">        <span class="tok-kw">fn</span> <span class="tok-fn">nextDarwin</span>(self: *Self) !?Entry {</span>
<span class="line" id="L39">            start_over: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L40">                <span class="tok-kw">if</span> (self.index &gt;= self.end_index) {</span>
<span class="line" id="L41">                    <span class="tok-kw">if</span> (self.first_iter) {</span>
<span class="line" id="L42">                        posix.lseek_SET(self.dir.fd, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>; <span class="tok-comment">// EBADF here likely means that the Dir was not opened with iteration permissions</span>
</span>
<span class="line" id="L43">                        self.first_iter = <span class="tok-null">false</span>;</span>
<span class="line" id="L44">                    }</span>
<span class="line" id="L45">                    <span class="tok-kw">const</span> rc = posix.system.__getdirentries64(</span>
<span class="line" id="L46">                        self.dir.fd,</span>
<span class="line" id="L47">                        &amp;self.buf,</span>
<span class="line" id="L48">                        self.buf.len,</span>
<span class="line" id="L49">                        &amp;self.seek,</span>
<span class="line" id="L50">                    );</span>
<span class="line" id="L51">                    <span class="tok-kw">if</span> (rc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L52">                    <span class="tok-kw">if</span> (rc &lt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L53">                        <span class="tok-kw">switch</span> (posix.errno(rc)) {</span>
<span class="line" id="L54">                            .BADF =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Dir is invalid or was opened without iteration ability</span>
</span>
<span class="line" id="L55">                            .FAULT =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L56">                            .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L57">                            .INVAL =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L58">                            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> posix.unexpectedErrno(err),</span>
<span class="line" id="L59">                        }</span>
<span class="line" id="L60">                    }</span>
<span class="line" id="L61">                    self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L62">                    self.end_index = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(rc));</span>
<span class="line" id="L63">                }</span>
<span class="line" id="L64">                <span class="tok-kw">const</span> darwin_entry = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) posix.system.dirent, <span class="tok-builtin">@ptrCast</span>(&amp;self.buf[self.index]));</span>
<span class="line" id="L65">                <span class="tok-kw">const</span> next_index = self.index + darwin_entry.reclen();</span>
<span class="line" id="L66">                self.index = next_index;</span>
<span class="line" id="L67"></span>
<span class="line" id="L68">                <span class="tok-kw">const</span> name = <span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;darwin_entry.d_name))[<span class="tok-number">0</span>..darwin_entry.d_namlen];</span>
<span class="line" id="L69"></span>
<span class="line" id="L70">                <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>) <span class="tok-kw">or</span> mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;..&quot;</span>) <span class="tok-kw">or</span> (darwin_entry.d_ino == <span class="tok-number">0</span>)) {</span>
<span class="line" id="L71">                    <span class="tok-kw">continue</span> :start_over;</span>
<span class="line" id="L72">                }</span>
<span class="line" id="L73"></span>
<span class="line" id="L74">                <span class="tok-kw">const</span> entry_kind: Entry.Kind = <span class="tok-kw">switch</span> (darwin_entry.d_type) {</span>
<span class="line" id="L75">                    posix.DT.BLK =&gt; .block_device,</span>
<span class="line" id="L76">                    posix.DT.CHR =&gt; .character_device,</span>
<span class="line" id="L77">                    posix.DT.DIR =&gt; .directory,</span>
<span class="line" id="L78">                    posix.DT.FIFO =&gt; .named_pipe,</span>
<span class="line" id="L79">                    posix.DT.LNK =&gt; .sym_link,</span>
<span class="line" id="L80">                    posix.DT.REG =&gt; .file,</span>
<span class="line" id="L81">                    posix.DT.SOCK =&gt; .unix_domain_socket,</span>
<span class="line" id="L82">                    posix.DT.WHT =&gt; .whiteout,</span>
<span class="line" id="L83">                    <span class="tok-kw">else</span> =&gt; .unknown,</span>
<span class="line" id="L84">                };</span>
<span class="line" id="L85">                <span class="tok-kw">return</span> Entry{</span>
<span class="line" id="L86">                    .name = name,</span>
<span class="line" id="L87">                    .kind = entry_kind,</span>
<span class="line" id="L88">                };</span>
<span class="line" id="L89">            }</span>
<span class="line" id="L90">        }</span>
<span class="line" id="L91"></span>
<span class="line" id="L92">        <span class="tok-kw">fn</span> <span class="tok-fn">nextSolaris</span>(self: *Self) !?Entry {</span>
<span class="line" id="L93">            start_over: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L94">                <span class="tok-kw">if</span> (self.index &gt;= self.end_index) {</span>
<span class="line" id="L95">                    <span class="tok-kw">if</span> (self.first_iter) {</span>
<span class="line" id="L96">                        posix.lseek_SET(self.dir.fd, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>; <span class="tok-comment">// EBADF here likely means that the Dir was not opened with iteration permissions</span>
</span>
<span class="line" id="L97">                        self.first_iter = <span class="tok-null">false</span>;</span>
<span class="line" id="L98">                    }</span>
<span class="line" id="L99">                    <span class="tok-kw">const</span> rc = posix.system.getdents(self.dir.fd, &amp;self.buf, self.buf.len);</span>
<span class="line" id="L100">                    <span class="tok-kw">switch</span> (posix.errno(rc)) {</span>
<span class="line" id="L101">                        .SUCCESS =&gt; {},</span>
<span class="line" id="L102">                        .BADF =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Dir is invalid or was opened without iteration ability</span>
</span>
<span class="line" id="L103">                        .FAULT =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L104">                        .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L105">                        .INVAL =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L106">                        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> posix.unexpectedErrno(err),</span>
<span class="line" id="L107">                    }</span>
<span class="line" id="L108">                    <span class="tok-kw">if</span> (rc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L109">                    self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L110">                    self.end_index = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(rc));</span>
<span class="line" id="L111">                }</span>
<span class="line" id="L112">                <span class="tok-kw">const</span> entry = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) posix.system.dirent, <span class="tok-builtin">@ptrCast</span>(&amp;self.buf[self.index]));</span>
<span class="line" id="L113">                <span class="tok-kw">const</span> next_index = self.index + entry.reclen();</span>
<span class="line" id="L114">                self.index = next_index;</span>
<span class="line" id="L115"></span>
<span class="line" id="L116">                <span class="tok-kw">const</span> name = mem.sliceTo(<span class="tok-builtin">@as</span>([*:<span class="tok-number">0</span>]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;entry.d_name)), <span class="tok-number">0</span>);</span>
<span class="line" id="L117">                <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>) <span class="tok-kw">or</span> mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;..&quot;</span>))</span>
<span class="line" id="L118">                    <span class="tok-kw">continue</span> :start_over;</span>
<span class="line" id="L119"></span>
<span class="line" id="L120">                <span class="tok-comment">// Solaris dirent doesn't expose d_type, so we have to call stat to get it.</span>
</span>
<span class="line" id="L121">                <span class="tok-kw">const</span> stat_info = posix.fstatat(</span>
<span class="line" id="L122">                    self.dir.fd,</span>
<span class="line" id="L123">                    name,</span>
<span class="line" id="L124">                    posix.AT.SYMLINK_NOFOLLOW,</span>
<span class="line" id="L125">                ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L126">                    <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L127">                    <span class="tok-kw">error</span>.SymLinkLoop =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L128">                    <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// lost the race</span>
</span>
<span class="line" id="L129">                    <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L130">                };</span>
<span class="line" id="L131">                <span class="tok-kw">const</span> entry_kind: Entry.Kind = <span class="tok-kw">switch</span> (stat_info.mode &amp; posix.S.IFMT) {</span>
<span class="line" id="L132">                    posix.S.IFIFO =&gt; .named_pipe,</span>
<span class="line" id="L133">                    posix.S.IFCHR =&gt; .character_device,</span>
<span class="line" id="L134">                    posix.S.IFDIR =&gt; .directory,</span>
<span class="line" id="L135">                    posix.S.IFBLK =&gt; .block_device,</span>
<span class="line" id="L136">                    posix.S.IFREG =&gt; .file,</span>
<span class="line" id="L137">                    posix.S.IFLNK =&gt; .sym_link,</span>
<span class="line" id="L138">                    posix.S.IFSOCK =&gt; .unix_domain_socket,</span>
<span class="line" id="L139">                    posix.S.IFDOOR =&gt; .door,</span>
<span class="line" id="L140">                    posix.S.IFPORT =&gt; .event_port,</span>
<span class="line" id="L141">                    <span class="tok-kw">else</span> =&gt; .unknown,</span>
<span class="line" id="L142">                };</span>
<span class="line" id="L143">                <span class="tok-kw">return</span> Entry{</span>
<span class="line" id="L144">                    .name = name,</span>
<span class="line" id="L145">                    .kind = entry_kind,</span>
<span class="line" id="L146">                };</span>
<span class="line" id="L147">            }</span>
<span class="line" id="L148">        }</span>
<span class="line" id="L149"></span>
<span class="line" id="L150">        <span class="tok-kw">fn</span> <span class="tok-fn">nextBsd</span>(self: *Self) !?Entry {</span>
<span class="line" id="L151">            start_over: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L152">                <span class="tok-kw">if</span> (self.index &gt;= self.end_index) {</span>
<span class="line" id="L153">                    <span class="tok-kw">if</span> (self.first_iter) {</span>
<span class="line" id="L154">                        posix.lseek_SET(self.dir.fd, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>; <span class="tok-comment">// EBADF here likely means that the Dir was not opened with iteration permissions</span>
</span>
<span class="line" id="L155">                        self.first_iter = <span class="tok-null">false</span>;</span>
<span class="line" id="L156">                    }</span>
<span class="line" id="L157">                    <span class="tok-kw">const</span> rc = <span class="tok-kw">if</span> (builtin.os.tag == .netbsd)</span>
<span class="line" id="L158">                        posix.system.__getdents30(self.dir.fd, &amp;self.buf, self.buf.len)</span>
<span class="line" id="L159">                    <span class="tok-kw">else</span></span>
<span class="line" id="L160">                        posix.system.getdents(self.dir.fd, &amp;self.buf, self.buf.len);</span>
<span class="line" id="L161">                    <span class="tok-kw">switch</span> (posix.errno(rc)) {</span>
<span class="line" id="L162">                        .SUCCESS =&gt; {},</span>
<span class="line" id="L163">                        .BADF =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Dir is invalid or was opened without iteration ability</span>
</span>
<span class="line" id="L164">                        .FAULT =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L165">                        .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L166">                        .INVAL =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L167">                        <span class="tok-comment">// Introduced in freebsd 13.2: directory unlinked but still open.</span>
</span>
<span class="line" id="L168">                        <span class="tok-comment">// To be consistent, iteration ends if the directory being iterated is deleted during iteration.</span>
</span>
<span class="line" id="L169">                        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,</span>
<span class="line" id="L170">                        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> posix.unexpectedErrno(err),</span>
<span class="line" id="L171">                    }</span>
<span class="line" id="L172">                    <span class="tok-kw">if</span> (rc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L173">                    self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L174">                    self.end_index = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(rc));</span>
<span class="line" id="L175">                }</span>
<span class="line" id="L176">                <span class="tok-kw">const</span> bsd_entry = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) posix.system.dirent, <span class="tok-builtin">@ptrCast</span>(&amp;self.buf[self.index]));</span>
<span class="line" id="L177">                <span class="tok-kw">const</span> next_index = self.index + bsd_entry.reclen();</span>
<span class="line" id="L178">                self.index = next_index;</span>
<span class="line" id="L179"></span>
<span class="line" id="L180">                <span class="tok-kw">const</span> name = <span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;bsd_entry.d_name))[<span class="tok-number">0</span>..bsd_entry.d_namlen];</span>
<span class="line" id="L181"></span>
<span class="line" id="L182">                <span class="tok-kw">const</span> skip_zero_fileno = <span class="tok-kw">switch</span> (builtin.os.tag) {</span>
<span class="line" id="L183">                    <span class="tok-comment">// d_fileno=0 is used to mark invalid entries or deleted files.</span>
</span>
<span class="line" id="L184">                    .openbsd, .netbsd =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L185">                    <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L186">                };</span>
<span class="line" id="L187">                <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>) <span class="tok-kw">or</span> mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;..&quot;</span>) <span class="tok-kw">or</span></span>
<span class="line" id="L188">                    (skip_zero_fileno <span class="tok-kw">and</span> bsd_entry.d_fileno == <span class="tok-number">0</span>))</span>
<span class="line" id="L189">                {</span>
<span class="line" id="L190">                    <span class="tok-kw">continue</span> :start_over;</span>
<span class="line" id="L191">                }</span>
<span class="line" id="L192"></span>
<span class="line" id="L193">                <span class="tok-kw">const</span> entry_kind: Entry.Kind = <span class="tok-kw">switch</span> (bsd_entry.d_type) {</span>
<span class="line" id="L194">                    posix.DT.BLK =&gt; .block_device,</span>
<span class="line" id="L195">                    posix.DT.CHR =&gt; .character_device,</span>
<span class="line" id="L196">                    posix.DT.DIR =&gt; .directory,</span>
<span class="line" id="L197">                    posix.DT.FIFO =&gt; .named_pipe,</span>
<span class="line" id="L198">                    posix.DT.LNK =&gt; .sym_link,</span>
<span class="line" id="L199">                    posix.DT.REG =&gt; .file,</span>
<span class="line" id="L200">                    posix.DT.SOCK =&gt; .unix_domain_socket,</span>
<span class="line" id="L201">                    posix.DT.WHT =&gt; .whiteout,</span>
<span class="line" id="L202">                    <span class="tok-kw">else</span> =&gt; .unknown,</span>
<span class="line" id="L203">                };</span>
<span class="line" id="L204">                <span class="tok-kw">return</span> Entry{</span>
<span class="line" id="L205">                    .name = name,</span>
<span class="line" id="L206">                    .kind = entry_kind,</span>
<span class="line" id="L207">                };</span>
<span class="line" id="L208">            }</span>
<span class="line" id="L209">        }</span>
<span class="line" id="L210"></span>
<span class="line" id="L211">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *Self) <span class="tok-type">void</span> {</span>
<span class="line" id="L212">            self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L213">            self.end_index = <span class="tok-number">0</span>;</span>
<span class="line" id="L214">            self.first_iter = <span class="tok-null">true</span>;</span>
<span class="line" id="L215">        }</span>
<span class="line" id="L216">    },</span>
<span class="line" id="L217">    .haiku =&gt; <span class="tok-kw">struct</span> {</span>
<span class="line" id="L218">        dir: Dir,</span>
<span class="line" id="L219">        buf: [<span class="tok-number">1024</span>]<span class="tok-type">u8</span>, <span class="tok-comment">// TODO align(@alignOf(posix.dirent64)),</span>
</span>
<span class="line" id="L220">        index: <span class="tok-type">usize</span>,</span>
<span class="line" id="L221">        end_index: <span class="tok-type">usize</span>,</span>
<span class="line" id="L222">        first_iter: <span class="tok-type">bool</span>,</span>
<span class="line" id="L223"></span>
<span class="line" id="L224">        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L225"></span>
<span class="line" id="L226">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = IteratorError;</span>
<span class="line" id="L227"></span>
<span class="line" id="L228">        <span class="tok-comment">/// Memory such as file names referenced in this returned entry becomes invalid</span></span>
<span class="line" id="L229">        <span class="tok-comment">/// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.</span></span>
<span class="line" id="L230">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *Self) Error!?Entry {</span>
<span class="line" id="L231">            start_over: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L232">                <span class="tok-comment">// TODO: find a better max</span>
</span>
<span class="line" id="L233">                <span class="tok-kw">const</span> HAIKU_MAX_COUNT = <span class="tok-number">10000</span>;</span>
<span class="line" id="L234">                <span class="tok-kw">if</span> (self.index &gt;= self.end_index) {</span>
<span class="line" id="L235">                    <span class="tok-kw">if</span> (self.first_iter) {</span>
<span class="line" id="L236">                        posix.lseek_SET(self.dir.fd, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>; <span class="tok-comment">// EBADF here likely means that the Dir was not opened with iteration permissions</span>
</span>
<span class="line" id="L237">                        self.first_iter = <span class="tok-null">false</span>;</span>
<span class="line" id="L238">                    }</span>
<span class="line" id="L239">                    <span class="tok-kw">const</span> rc = posix.system._kern_read_dir(</span>
<span class="line" id="L240">                        self.dir.fd,</span>
<span class="line" id="L241">                        &amp;self.buf,</span>
<span class="line" id="L242">                        self.buf.len,</span>
<span class="line" id="L243">                        HAIKU_MAX_COUNT,</span>
<span class="line" id="L244">                    );</span>
<span class="line" id="L245">                    <span class="tok-kw">if</span> (rc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L246">                    <span class="tok-kw">if</span> (rc &lt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L247">                        <span class="tok-kw">switch</span> (posix.errno(rc)) {</span>
<span class="line" id="L248">                            .BADF =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Dir is invalid or was opened without iteration ability</span>
</span>
<span class="line" id="L249">                            .FAULT =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L250">                            .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L251">                            .INVAL =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L252">                            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> posix.unexpectedErrno(err),</span>
<span class="line" id="L253">                        }</span>
<span class="line" id="L254">                    }</span>
<span class="line" id="L255">                    self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L256">                    self.end_index = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(rc));</span>
<span class="line" id="L257">                }</span>
<span class="line" id="L258">                <span class="tok-kw">const</span> haiku_entry = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) posix.system.dirent, <span class="tok-builtin">@ptrCast</span>(&amp;self.buf[self.index]));</span>
<span class="line" id="L259">                <span class="tok-kw">const</span> next_index = self.index + haiku_entry.reclen();</span>
<span class="line" id="L260">                self.index = next_index;</span>
<span class="line" id="L261">                <span class="tok-kw">const</span> name = mem.sliceTo(<span class="tok-builtin">@as</span>([*:<span class="tok-number">0</span>]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;haiku_entry.d_name)), <span class="tok-number">0</span>);</span>
<span class="line" id="L262"></span>
<span class="line" id="L263">                <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>) <span class="tok-kw">or</span> mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;..&quot;</span>) <span class="tok-kw">or</span> (haiku_entry.d_ino == <span class="tok-number">0</span>)) {</span>
<span class="line" id="L264">                    <span class="tok-kw">continue</span> :start_over;</span>
<span class="line" id="L265">                }</span>
<span class="line" id="L266"></span>
<span class="line" id="L267">                <span class="tok-kw">var</span> stat_info: posix.Stat = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L268">                <span class="tok-kw">const</span> rc = posix.system._kern_read_stat(</span>
<span class="line" id="L269">                    self.dir.fd,</span>
<span class="line" id="L270">                    &amp;haiku_entry.d_name,</span>
<span class="line" id="L271">                    <span class="tok-null">false</span>,</span>
<span class="line" id="L272">                    &amp;stat_info,</span>
<span class="line" id="L273">                    <span class="tok-number">0</span>,</span>
<span class="line" id="L274">                );</span>
<span class="line" id="L275">                <span class="tok-kw">if</span> (rc != <span class="tok-number">0</span>) {</span>
<span class="line" id="L276">                    <span class="tok-kw">switch</span> (posix.errno(rc)) {</span>
<span class="line" id="L277">                        .SUCCESS =&gt; {},</span>
<span class="line" id="L278">                        .BADF =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Dir is invalid or was opened without iteration ability</span>
</span>
<span class="line" id="L279">                        .FAULT =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L280">                        .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L281">                        .INVAL =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L282">                        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> posix.unexpectedErrno(err),</span>
<span class="line" id="L283">                    }</span>
<span class="line" id="L284">                }</span>
<span class="line" id="L285">                <span class="tok-kw">const</span> statmode = stat_info.mode &amp; posix.S.IFMT;</span>
<span class="line" id="L286"></span>
<span class="line" id="L287">                <span class="tok-kw">const</span> entry_kind: Entry.Kind = <span class="tok-kw">switch</span> (statmode) {</span>
<span class="line" id="L288">                    posix.S.IFDIR =&gt; .directory,</span>
<span class="line" id="L289">                    posix.S.IFBLK =&gt; .block_device,</span>
<span class="line" id="L290">                    posix.S.IFCHR =&gt; .character_device,</span>
<span class="line" id="L291">                    posix.S.IFLNK =&gt; .sym_link,</span>
<span class="line" id="L292">                    posix.S.IFREG =&gt; .file,</span>
<span class="line" id="L293">                    posix.S.IFIFO =&gt; .named_pipe,</span>
<span class="line" id="L294">                    <span class="tok-kw">else</span> =&gt; .unknown,</span>
<span class="line" id="L295">                };</span>
<span class="line" id="L296"></span>
<span class="line" id="L297">                <span class="tok-kw">return</span> Entry{</span>
<span class="line" id="L298">                    .name = name,</span>
<span class="line" id="L299">                    .kind = entry_kind,</span>
<span class="line" id="L300">                };</span>
<span class="line" id="L301">            }</span>
<span class="line" id="L302">        }</span>
<span class="line" id="L303"></span>
<span class="line" id="L304">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *Self) <span class="tok-type">void</span> {</span>
<span class="line" id="L305">            self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L306">            self.end_index = <span class="tok-number">0</span>;</span>
<span class="line" id="L307">            self.first_iter = <span class="tok-null">true</span>;</span>
<span class="line" id="L308">        }</span>
<span class="line" id="L309">    },</span>
<span class="line" id="L310">    .linux =&gt; <span class="tok-kw">struct</span> {</span>
<span class="line" id="L311">        dir: Dir,</span>
<span class="line" id="L312">        <span class="tok-comment">// The if guard is solely there to prevent compile errors from missing `linux.dirent64`</span>
</span>
<span class="line" id="L313">        <span class="tok-comment">// definition when compiling for other OSes. It doesn't do anything when compiling for Linux.</span>
</span>
<span class="line" id="L314">        buf: [<span class="tok-number">1024</span>]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-kw">if</span> (builtin.os.tag != .linux) <span class="tok-number">1</span> <span class="tok-kw">else</span> <span class="tok-builtin">@alignOf</span>(linux.dirent64)),</span>
<span class="line" id="L315">        index: <span class="tok-type">usize</span>,</span>
<span class="line" id="L316">        end_index: <span class="tok-type">usize</span>,</span>
<span class="line" id="L317">        first_iter: <span class="tok-type">bool</span>,</span>
<span class="line" id="L318"></span>
<span class="line" id="L319">        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L320">        <span class="tok-kw">const</span> linux = std.os.linux;</span>
<span class="line" id="L321"></span>
<span class="line" id="L322">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = IteratorError;</span>
<span class="line" id="L323"></span>
<span class="line" id="L324">        <span class="tok-comment">/// Memory such as file names referenced in this returned entry becomes invalid</span></span>
<span class="line" id="L325">        <span class="tok-comment">/// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.</span></span>
<span class="line" id="L326">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *Self) Error!?Entry {</span>
<span class="line" id="L327">            <span class="tok-kw">return</span> self.nextLinux() <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L328">                <span class="tok-comment">// To be consistent across platforms, iteration ends if the directory being iterated is deleted during iteration.</span>
</span>
<span class="line" id="L329">                <span class="tok-comment">// This matches the behavior of non-Linux UNIX platforms.</span>
</span>
<span class="line" id="L330">                <span class="tok-kw">error</span>.DirNotFound =&gt; <span class="tok-null">null</span>,</span>
<span class="line" id="L331">                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L332">            };</span>
<span class="line" id="L333">        }</span>
<span class="line" id="L334"></span>
<span class="line" id="L335">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ErrorLinux = <span class="tok-kw">error</span>{DirNotFound} || IteratorError;</span>
<span class="line" id="L336"></span>
<span class="line" id="L337">        <span class="tok-comment">/// Implementation of `next` that can return `error.DirNotFound` if the directory being</span></span>
<span class="line" id="L338">        <span class="tok-comment">/// iterated was deleted during iteration (this error is Linux specific).</span></span>
<span class="line" id="L339">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextLinux</span>(self: *Self) ErrorLinux!?Entry {</span>
<span class="line" id="L340">            start_over: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L341">                <span class="tok-kw">if</span> (self.index &gt;= self.end_index) {</span>
<span class="line" id="L342">                    <span class="tok-kw">if</span> (self.first_iter) {</span>
<span class="line" id="L343">                        posix.lseek_SET(self.dir.fd, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>; <span class="tok-comment">// EBADF here likely means that the Dir was not opened with iteration permissions</span>
</span>
<span class="line" id="L344">                        self.first_iter = <span class="tok-null">false</span>;</span>
<span class="line" id="L345">                    }</span>
<span class="line" id="L346">                    <span class="tok-kw">const</span> rc = linux.getdents64(self.dir.fd, &amp;self.buf, self.buf.len);</span>
<span class="line" id="L347">                    <span class="tok-kw">switch</span> (linux.getErrno(rc)) {</span>
<span class="line" id="L348">                        .SUCCESS =&gt; {},</span>
<span class="line" id="L349">                        .BADF =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Dir is invalid or was opened without iteration ability</span>
</span>
<span class="line" id="L350">                        .FAULT =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L351">                        .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L352">                        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DirNotFound, <span class="tok-comment">// The directory being iterated was deleted during iteration.</span>
</span>
<span class="line" id="L353">                        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected, <span class="tok-comment">// Linux may in some cases return EINVAL when reading /proc/$PID/net.</span>
</span>
<span class="line" id="L354">                        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied, <span class="tok-comment">// Do not have permission to iterate this directory.</span>
</span>
<span class="line" id="L355">                        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> posix.unexpectedErrno(err),</span>
<span class="line" id="L356">                    }</span>
<span class="line" id="L357">                    <span class="tok-kw">if</span> (rc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L358">                    self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L359">                    self.end_index = rc;</span>
<span class="line" id="L360">                }</span>
<span class="line" id="L361">                <span class="tok-kw">const</span> linux_entry = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) linux.dirent64, <span class="tok-builtin">@ptrCast</span>(&amp;self.buf[self.index]));</span>
<span class="line" id="L362">                <span class="tok-kw">const</span> next_index = self.index + linux_entry.reclen();</span>
<span class="line" id="L363">                self.index = next_index;</span>
<span class="line" id="L364"></span>
<span class="line" id="L365">                <span class="tok-kw">const</span> name = mem.sliceTo(<span class="tok-builtin">@as</span>([*:<span class="tok-number">0</span>]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;linux_entry.d_name)), <span class="tok-number">0</span>);</span>
<span class="line" id="L366"></span>
<span class="line" id="L367">                <span class="tok-comment">// skip . and .. entries</span>
</span>
<span class="line" id="L368">                <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>) <span class="tok-kw">or</span> mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;..&quot;</span>)) {</span>
<span class="line" id="L369">                    <span class="tok-kw">continue</span> :start_over;</span>
<span class="line" id="L370">                }</span>
<span class="line" id="L371"></span>
<span class="line" id="L372">                <span class="tok-kw">const</span> entry_kind: Entry.Kind = <span class="tok-kw">switch</span> (linux_entry.d_type) {</span>
<span class="line" id="L373">                    linux.DT.BLK =&gt; .block_device,</span>
<span class="line" id="L374">                    linux.DT.CHR =&gt; .character_device,</span>
<span class="line" id="L375">                    linux.DT.DIR =&gt; .directory,</span>
<span class="line" id="L376">                    linux.DT.FIFO =&gt; .named_pipe,</span>
<span class="line" id="L377">                    linux.DT.LNK =&gt; .sym_link,</span>
<span class="line" id="L378">                    linux.DT.REG =&gt; .file,</span>
<span class="line" id="L379">                    linux.DT.SOCK =&gt; .unix_domain_socket,</span>
<span class="line" id="L380">                    <span class="tok-kw">else</span> =&gt; .unknown,</span>
<span class="line" id="L381">                };</span>
<span class="line" id="L382">                <span class="tok-kw">return</span> Entry{</span>
<span class="line" id="L383">                    .name = name,</span>
<span class="line" id="L384">                    .kind = entry_kind,</span>
<span class="line" id="L385">                };</span>
<span class="line" id="L386">            }</span>
<span class="line" id="L387">        }</span>
<span class="line" id="L388"></span>
<span class="line" id="L389">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *Self) <span class="tok-type">void</span> {</span>
<span class="line" id="L390">            self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L391">            self.end_index = <span class="tok-number">0</span>;</span>
<span class="line" id="L392">            self.first_iter = <span class="tok-null">true</span>;</span>
<span class="line" id="L393">        }</span>
<span class="line" id="L394">    },</span>
<span class="line" id="L395">    .windows =&gt; <span class="tok-kw">struct</span> {</span>
<span class="line" id="L396">        dir: Dir,</span>
<span class="line" id="L397">        buf: [<span class="tok-number">1024</span>]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(std.os.windows.FILE_BOTH_DIR_INFORMATION)),</span>
<span class="line" id="L398">        index: <span class="tok-type">usize</span>,</span>
<span class="line" id="L399">        end_index: <span class="tok-type">usize</span>,</span>
<span class="line" id="L400">        first_iter: <span class="tok-type">bool</span>,</span>
<span class="line" id="L401">        name_data: [fs.MAX_NAME_BYTES]<span class="tok-type">u8</span>,</span>
<span class="line" id="L402"></span>
<span class="line" id="L403">        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L404"></span>
<span class="line" id="L405">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = IteratorError;</span>
<span class="line" id="L406"></span>
<span class="line" id="L407">        <span class="tok-comment">/// Memory such as file names referenced in this returned entry becomes invalid</span></span>
<span class="line" id="L408">        <span class="tok-comment">/// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.</span></span>
<span class="line" id="L409">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *Self) Error!?Entry {</span>
<span class="line" id="L410">            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L411">                <span class="tok-kw">const</span> w = std.os.windows;</span>
<span class="line" id="L412">                <span class="tok-kw">if</span> (self.index &gt;= self.end_index) {</span>
<span class="line" id="L413">                    <span class="tok-kw">var</span> io: w.IO_STATUS_BLOCK = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L414">                    <span class="tok-kw">const</span> rc = w.ntdll.NtQueryDirectoryFile(</span>
<span class="line" id="L415">                        self.dir.fd,</span>
<span class="line" id="L416">                        <span class="tok-null">null</span>,</span>
<span class="line" id="L417">                        <span class="tok-null">null</span>,</span>
<span class="line" id="L418">                        <span class="tok-null">null</span>,</span>
<span class="line" id="L419">                        &amp;io,</span>
<span class="line" id="L420">                        &amp;self.buf,</span>
<span class="line" id="L421">                        self.buf.len,</span>
<span class="line" id="L422">                        .FileBothDirectoryInformation,</span>
<span class="line" id="L423">                        w.FALSE,</span>
<span class="line" id="L424">                        <span class="tok-null">null</span>,</span>
<span class="line" id="L425">                        <span class="tok-kw">if</span> (self.first_iter) <span class="tok-builtin">@as</span>(w.BOOLEAN, w.TRUE) <span class="tok-kw">else</span> <span class="tok-builtin">@as</span>(w.BOOLEAN, w.FALSE),</span>
<span class="line" id="L426">                    );</span>
<span class="line" id="L427">                    self.first_iter = <span class="tok-null">false</span>;</span>
<span class="line" id="L428">                    <span class="tok-kw">if</span> (io.Information == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L429">                    self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L430">                    self.end_index = io.Information;</span>
<span class="line" id="L431">                    <span class="tok-kw">switch</span> (rc) {</span>
<span class="line" id="L432">                        .SUCCESS =&gt; {},</span>
<span class="line" id="L433">                        .ACCESS_DENIED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied, <span class="tok-comment">// Double-check that the Dir was opened with iteration ability</span>
</span>
<span class="line" id="L434"></span>
<span class="line" id="L435">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> w.unexpectedStatus(rc),</span>
<span class="line" id="L436">                    }</span>
<span class="line" id="L437">                }</span>
<span class="line" id="L438"></span>
<span class="line" id="L439">                <span class="tok-comment">// While the official api docs guarantee FILE_BOTH_DIR_INFORMATION to be aligned properly</span>
</span>
<span class="line" id="L440">                <span class="tok-comment">// this may not always be the case (e.g. due to faulty VM/Sandboxing tools)</span>
</span>
<span class="line" id="L441">                <span class="tok-kw">const</span> dir_info: *<span class="tok-kw">align</span>(<span class="tok-number">2</span>) w.FILE_BOTH_DIR_INFORMATION = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;self.buf[self.index]));</span>
<span class="line" id="L442">                <span class="tok-kw">if</span> (dir_info.NextEntryOffset != <span class="tok-number">0</span>) {</span>
<span class="line" id="L443">                    self.index += dir_info.NextEntryOffset;</span>
<span class="line" id="L444">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L445">                    self.index = self.buf.len;</span>
<span class="line" id="L446">                }</span>
<span class="line" id="L447"></span>
<span class="line" id="L448">                <span class="tok-kw">const</span> name_utf16le = <span class="tok-builtin">@as</span>([*]<span class="tok-type">u16</span>, <span class="tok-builtin">@ptrCast</span>(&amp;dir_info.FileName))[<span class="tok-number">0</span> .. dir_info.FileNameLength / <span class="tok-number">2</span>];</span>
<span class="line" id="L449"></span>
<span class="line" id="L450">                <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u16</span>, name_utf16le, &amp;[_]<span class="tok-type">u16</span>{<span class="tok-str">'.'</span>}) <span class="tok-kw">or</span> mem.eql(<span class="tok-type">u16</span>, name_utf16le, &amp;[_]<span class="tok-type">u16</span>{ <span class="tok-str">'.'</span>, <span class="tok-str">'.'</span> }))</span>
<span class="line" id="L451">                    <span class="tok-kw">continue</span>;</span>
<span class="line" id="L452">                <span class="tok-comment">// Trust that Windows gives us valid UTF-16LE</span>
</span>
<span class="line" id="L453">                <span class="tok-kw">const</span> name_utf8_len = std.unicode.utf16leToUtf8(self.name_data[<span class="tok-number">0</span>..], name_utf16le) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L454">                <span class="tok-kw">const</span> name_utf8 = self.name_data[<span class="tok-number">0</span>..name_utf8_len];</span>
<span class="line" id="L455">                <span class="tok-kw">const</span> kind: Entry.Kind = blk: {</span>
<span class="line" id="L456">                    <span class="tok-kw">const</span> attrs = dir_info.FileAttributes;</span>
<span class="line" id="L457">                    <span class="tok-kw">if</span> (attrs &amp; w.FILE_ATTRIBUTE_DIRECTORY != <span class="tok-number">0</span>) <span class="tok-kw">break</span> :blk .directory;</span>
<span class="line" id="L458">                    <span class="tok-kw">if</span> (attrs &amp; w.FILE_ATTRIBUTE_REPARSE_POINT != <span class="tok-number">0</span>) <span class="tok-kw">break</span> :blk .sym_link;</span>
<span class="line" id="L459">                    <span class="tok-kw">break</span> :blk .file;</span>
<span class="line" id="L460">                };</span>
<span class="line" id="L461">                <span class="tok-kw">return</span> Entry{</span>
<span class="line" id="L462">                    .name = name_utf8,</span>
<span class="line" id="L463">                    .kind = kind,</span>
<span class="line" id="L464">                };</span>
<span class="line" id="L465">            }</span>
<span class="line" id="L466">        }</span>
<span class="line" id="L467"></span>
<span class="line" id="L468">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *Self) <span class="tok-type">void</span> {</span>
<span class="line" id="L469">            self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L470">            self.end_index = <span class="tok-number">0</span>;</span>
<span class="line" id="L471">            self.first_iter = <span class="tok-null">true</span>;</span>
<span class="line" id="L472">        }</span>
<span class="line" id="L473">    },</span>
<span class="line" id="L474">    .wasi =&gt; <span class="tok-kw">struct</span> {</span>
<span class="line" id="L475">        dir: Dir,</span>
<span class="line" id="L476">        buf: [<span class="tok-number">1024</span>]<span class="tok-type">u8</span>, <span class="tok-comment">// TODO align(@alignOf(posix.wasi.dirent_t)),</span>
</span>
<span class="line" id="L477">        cookie: <span class="tok-type">u64</span>,</span>
<span class="line" id="L478">        index: <span class="tok-type">usize</span>,</span>
<span class="line" id="L479">        end_index: <span class="tok-type">usize</span>,</span>
<span class="line" id="L480"></span>
<span class="line" id="L481">        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L482"></span>
<span class="line" id="L483">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = IteratorError;</span>
<span class="line" id="L484"></span>
<span class="line" id="L485">        <span class="tok-comment">/// Memory such as file names referenced in this returned entry becomes invalid</span></span>
<span class="line" id="L486">        <span class="tok-comment">/// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.</span></span>
<span class="line" id="L487">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *Self) Error!?Entry {</span>
<span class="line" id="L488">            <span class="tok-kw">return</span> self.nextWasi() <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L489">                <span class="tok-comment">// To be consistent across platforms, iteration ends if the directory being iterated is deleted during iteration.</span>
</span>
<span class="line" id="L490">                <span class="tok-comment">// This matches the behavior of non-Linux UNIX platforms.</span>
</span>
<span class="line" id="L491">                <span class="tok-kw">error</span>.DirNotFound =&gt; <span class="tok-null">null</span>,</span>
<span class="line" id="L492">                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L493">            };</span>
<span class="line" id="L494">        }</span>
<span class="line" id="L495"></span>
<span class="line" id="L496">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ErrorWasi = <span class="tok-kw">error</span>{DirNotFound} || IteratorError;</span>
<span class="line" id="L497"></span>
<span class="line" id="L498">        <span class="tok-comment">/// Implementation of `next` that can return platform-dependent errors depending on the host platform.</span></span>
<span class="line" id="L499">        <span class="tok-comment">/// When the host platform is Linux, `error.DirNotFound` can be returned if the directory being</span></span>
<span class="line" id="L500">        <span class="tok-comment">/// iterated was deleted during iteration.</span></span>
<span class="line" id="L501">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextWasi</span>(self: *Self) ErrorWasi!?Entry {</span>
<span class="line" id="L502">            <span class="tok-comment">// We intentinally use fd_readdir even when linked with libc,</span>
</span>
<span class="line" id="L503">            <span class="tok-comment">// since its implementation is exactly the same as below,</span>
</span>
<span class="line" id="L504">            <span class="tok-comment">// and we avoid the code complexity here.</span>
</span>
<span class="line" id="L505">            <span class="tok-kw">const</span> w = std.os.wasi;</span>
<span class="line" id="L506">            start_over: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L507">                <span class="tok-comment">// According to the WASI spec, the last entry might be truncated,</span>
</span>
<span class="line" id="L508">                <span class="tok-comment">// so we need to check if the left buffer contains the whole dirent.</span>
</span>
<span class="line" id="L509">                <span class="tok-kw">if</span> (self.end_index - self.index &lt; <span class="tok-builtin">@sizeOf</span>(w.dirent_t)) {</span>
<span class="line" id="L510">                    <span class="tok-kw">var</span> bufused: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L511">                    <span class="tok-kw">switch</span> (w.fd_readdir(self.dir.fd, &amp;self.buf, self.buf.len, self.cookie, &amp;bufused)) {</span>
<span class="line" id="L512">                        .SUCCESS =&gt; {},</span>
<span class="line" id="L513">                        .BADF =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Dir is invalid or was opened without iteration ability</span>
</span>
<span class="line" id="L514">                        .FAULT =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L515">                        .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L516">                        .INVAL =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L517">                        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DirNotFound, <span class="tok-comment">// The directory being iterated was deleted during iteration.</span>
</span>
<span class="line" id="L518">                        .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L519">                        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> posix.unexpectedErrno(err),</span>
<span class="line" id="L520">                    }</span>
<span class="line" id="L521">                    <span class="tok-kw">if</span> (bufused == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L522">                    self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L523">                    self.end_index = bufused;</span>
<span class="line" id="L524">                }</span>
<span class="line" id="L525">                <span class="tok-kw">const</span> entry = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) w.dirent_t, <span class="tok-builtin">@ptrCast</span>(&amp;self.buf[self.index]));</span>
<span class="line" id="L526">                <span class="tok-kw">const</span> entry_size = <span class="tok-builtin">@sizeOf</span>(w.dirent_t);</span>
<span class="line" id="L527">                <span class="tok-kw">const</span> name_index = self.index + entry_size;</span>
<span class="line" id="L528">                <span class="tok-kw">if</span> (name_index + entry.d_namlen &gt; self.end_index) {</span>
<span class="line" id="L529">                    <span class="tok-comment">// This case, the name is truncated, so we need to call readdir to store the entire name.</span>
</span>
<span class="line" id="L530">                    self.end_index = self.index; <span class="tok-comment">// Force fd_readdir in the next loop.</span>
</span>
<span class="line" id="L531">                    <span class="tok-kw">continue</span> :start_over;</span>
<span class="line" id="L532">                }</span>
<span class="line" id="L533">                <span class="tok-kw">const</span> name = self.buf[name_index .. name_index + entry.d_namlen];</span>
<span class="line" id="L534"></span>
<span class="line" id="L535">                <span class="tok-kw">const</span> next_index = name_index + entry.d_namlen;</span>
<span class="line" id="L536">                self.index = next_index;</span>
<span class="line" id="L537">                self.cookie = entry.d_next;</span>
<span class="line" id="L538"></span>
<span class="line" id="L539">                <span class="tok-comment">// skip . and .. entries</span>
</span>
<span class="line" id="L540">                <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>) <span class="tok-kw">or</span> mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;..&quot;</span>)) {</span>
<span class="line" id="L541">                    <span class="tok-kw">continue</span> :start_over;</span>
<span class="line" id="L542">                }</span>
<span class="line" id="L543"></span>
<span class="line" id="L544">                <span class="tok-kw">const</span> entry_kind: Entry.Kind = <span class="tok-kw">switch</span> (entry.d_type) {</span>
<span class="line" id="L545">                    .BLOCK_DEVICE =&gt; .block_device,</span>
<span class="line" id="L546">                    .CHARACTER_DEVICE =&gt; .character_device,</span>
<span class="line" id="L547">                    .DIRECTORY =&gt; .directory,</span>
<span class="line" id="L548">                    .SYMBOLIC_LINK =&gt; .sym_link,</span>
<span class="line" id="L549">                    .REGULAR_FILE =&gt; .file,</span>
<span class="line" id="L550">                    .SOCKET_STREAM, .SOCKET_DGRAM =&gt; .unix_domain_socket,</span>
<span class="line" id="L551">                    <span class="tok-kw">else</span> =&gt; .unknown,</span>
<span class="line" id="L552">                };</span>
<span class="line" id="L553">                <span class="tok-kw">return</span> Entry{</span>
<span class="line" id="L554">                    .name = name,</span>
<span class="line" id="L555">                    .kind = entry_kind,</span>
<span class="line" id="L556">                };</span>
<span class="line" id="L557">            }</span>
<span class="line" id="L558">        }</span>
<span class="line" id="L559"></span>
<span class="line" id="L560">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *Self) <span class="tok-type">void</span> {</span>
<span class="line" id="L561">            self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L562">            self.end_index = <span class="tok-number">0</span>;</span>
<span class="line" id="L563">            self.cookie = std.os.wasi.DIRCOOKIE_START;</span>
<span class="line" id="L564">        }</span>
<span class="line" id="L565">    },</span>
<span class="line" id="L566">    <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unimplemented&quot;</span>),</span>
<span class="line" id="L567">};</span>
<span class="line" id="L568"></span>
<span class="line" id="L569"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterate</span>(self: Dir) Iterator {</span>
<span class="line" id="L570">    <span class="tok-kw">return</span> self.iterateImpl(<span class="tok-null">true</span>);</span>
<span class="line" id="L571">}</span>
<span class="line" id="L572"></span>
<span class="line" id="L573"><span class="tok-comment">/// Like `iterate`, but will not reset the directory cursor before the first</span></span>
<span class="line" id="L574"><span class="tok-comment">/// iteration. This should only be used in cases where it is known that the</span></span>
<span class="line" id="L575"><span class="tok-comment">/// `Dir` has not had its cursor modified yet (e.g. it was just opened).</span></span>
<span class="line" id="L576"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterateAssumeFirstIteration</span>(self: Dir) Iterator {</span>
<span class="line" id="L577">    <span class="tok-kw">return</span> self.iterateImpl(<span class="tok-null">false</span>);</span>
<span class="line" id="L578">}</span>
<span class="line" id="L579"></span>
<span class="line" id="L580"><span class="tok-kw">fn</span> <span class="tok-fn">iterateImpl</span>(self: Dir, first_iter_start_value: <span class="tok-type">bool</span>) Iterator {</span>
<span class="line" id="L581">    <span class="tok-kw">switch</span> (builtin.os.tag) {</span>
<span class="line" id="L582">        .macos,</span>
<span class="line" id="L583">        .ios,</span>
<span class="line" id="L584">        .freebsd,</span>
<span class="line" id="L585">        .netbsd,</span>
<span class="line" id="L586">        .dragonfly,</span>
<span class="line" id="L587">        .openbsd,</span>
<span class="line" id="L588">        .solaris,</span>
<span class="line" id="L589">        .illumos,</span>
<span class="line" id="L590">        =&gt; <span class="tok-kw">return</span> Iterator{</span>
<span class="line" id="L591">            .dir = self,</span>
<span class="line" id="L592">            .seek = <span class="tok-number">0</span>,</span>
<span class="line" id="L593">            .index = <span class="tok-number">0</span>,</span>
<span class="line" id="L594">            .end_index = <span class="tok-number">0</span>,</span>
<span class="line" id="L595">            .buf = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L596">            .first_iter = first_iter_start_value,</span>
<span class="line" id="L597">        },</span>
<span class="line" id="L598">        .linux, .haiku =&gt; <span class="tok-kw">return</span> Iterator{</span>
<span class="line" id="L599">            .dir = self,</span>
<span class="line" id="L600">            .index = <span class="tok-number">0</span>,</span>
<span class="line" id="L601">            .end_index = <span class="tok-number">0</span>,</span>
<span class="line" id="L602">            .buf = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L603">            .first_iter = first_iter_start_value,</span>
<span class="line" id="L604">        },</span>
<span class="line" id="L605">        .windows =&gt; <span class="tok-kw">return</span> Iterator{</span>
<span class="line" id="L606">            .dir = self,</span>
<span class="line" id="L607">            .index = <span class="tok-number">0</span>,</span>
<span class="line" id="L608">            .end_index = <span class="tok-number">0</span>,</span>
<span class="line" id="L609">            .first_iter = first_iter_start_value,</span>
<span class="line" id="L610">            .buf = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L611">            .name_data = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L612">        },</span>
<span class="line" id="L613">        .wasi =&gt; <span class="tok-kw">return</span> Iterator{</span>
<span class="line" id="L614">            .dir = self,</span>
<span class="line" id="L615">            .cookie = std.os.wasi.DIRCOOKIE_START,</span>
<span class="line" id="L616">            .index = <span class="tok-number">0</span>,</span>
<span class="line" id="L617">            .end_index = <span class="tok-number">0</span>,</span>
<span class="line" id="L618">            .buf = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L619">        },</span>
<span class="line" id="L620">        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unimplemented&quot;</span>),</span>
<span class="line" id="L621">    }</span>
<span class="line" id="L622">}</span>
<span class="line" id="L623"></span>
<span class="line" id="L624"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Walker = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L625">    stack: std.ArrayList(StackItem),</span>
<span class="line" id="L626">    name_buffer: std.ArrayList(<span class="tok-type">u8</span>),</span>
<span class="line" id="L627"></span>
<span class="line" id="L628">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> WalkerEntry = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L629">        <span class="tok-comment">/// The containing directory. This can be used to operate directly on `basename`</span></span>
<span class="line" id="L630">        <span class="tok-comment">/// rather than `path`, avoiding `error.NameTooLong` for deeply nested paths.</span></span>
<span class="line" id="L631">        <span class="tok-comment">/// The directory remains open until `next` or `deinit` is called.</span></span>
<span class="line" id="L632">        dir: Dir,</span>
<span class="line" id="L633">        basename: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L634">        path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L635">        kind: Dir.Entry.Kind,</span>
<span class="line" id="L636">    };</span>
<span class="line" id="L637"></span>
<span class="line" id="L638">    <span class="tok-kw">const</span> StackItem = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L639">        iter: Dir.Iterator,</span>
<span class="line" id="L640">        dirname_len: <span class="tok-type">usize</span>,</span>
<span class="line" id="L641">    };</span>
<span class="line" id="L642"></span>
<span class="line" id="L643">    <span class="tok-comment">/// After each call to this function, and on deinit(), the memory returned</span></span>
<span class="line" id="L644">    <span class="tok-comment">/// from this function becomes invalid. A copy must be made in order to keep</span></span>
<span class="line" id="L645">    <span class="tok-comment">/// a reference to the path.</span></span>
<span class="line" id="L646">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *Walker) !?WalkerEntry {</span>
<span class="line" id="L647">        <span class="tok-kw">while</span> (self.stack.items.len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L648">            <span class="tok-comment">// `top` and `containing` become invalid after appending to `self.stack`</span>
</span>
<span class="line" id="L649">            <span class="tok-kw">var</span> top = &amp;self.stack.items[self.stack.items.len - <span class="tok-number">1</span>];</span>
<span class="line" id="L650">            <span class="tok-kw">var</span> containing = top;</span>
<span class="line" id="L651">            <span class="tok-kw">var</span> dirname_len = top.dirname_len;</span>
<span class="line" id="L652">            <span class="tok-kw">if</span> (top.iter.next() <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L653">                <span class="tok-comment">// If we get an error, then we want the user to be able to continue</span>
</span>
<span class="line" id="L654">                <span class="tok-comment">// walking if they want, which means that we need to pop the directory</span>
</span>
<span class="line" id="L655">                <span class="tok-comment">// that errored from the stack. Otherwise, all future `next` calls would</span>
</span>
<span class="line" id="L656">                <span class="tok-comment">// likely just fail with the same error.</span>
</span>
<span class="line" id="L657">                <span class="tok-kw">var</span> item = self.stack.pop();</span>
<span class="line" id="L658">                <span class="tok-kw">if</span> (self.stack.items.len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L659">                    item.iter.dir.close();</span>
<span class="line" id="L660">                }</span>
<span class="line" id="L661">                <span class="tok-kw">return</span> err;</span>
<span class="line" id="L662">            }) |base| {</span>
<span class="line" id="L663">                self.name_buffer.shrinkRetainingCapacity(dirname_len);</span>
<span class="line" id="L664">                <span class="tok-kw">if</span> (self.name_buffer.items.len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L665">                    <span class="tok-kw">try</span> self.name_buffer.append(fs.path.sep);</span>
<span class="line" id="L666">                    dirname_len += <span class="tok-number">1</span>;</span>
<span class="line" id="L667">                }</span>
<span class="line" id="L668">                <span class="tok-kw">try</span> self.name_buffer.appendSlice(base.name);</span>
<span class="line" id="L669">                <span class="tok-kw">if</span> (base.kind == .directory) {</span>
<span class="line" id="L670">                    <span class="tok-kw">var</span> new_dir = top.iter.dir.openDir(base.name, .{ .iterate = <span class="tok-null">true</span> }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L671">                        <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// no path sep in base.name</span>
</span>
<span class="line" id="L672">                        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L673">                    };</span>
<span class="line" id="L674">                    {</span>
<span class="line" id="L675">                        <span class="tok-kw">errdefer</span> new_dir.close();</span>
<span class="line" id="L676">                        <span class="tok-kw">try</span> self.stack.append(StackItem{</span>
<span class="line" id="L677">                            .iter = new_dir.iterateAssumeFirstIteration(),</span>
<span class="line" id="L678">                            .dirname_len = self.name_buffer.items.len,</span>
<span class="line" id="L679">                        });</span>
<span class="line" id="L680">                        top = &amp;self.stack.items[self.stack.items.len - <span class="tok-number">1</span>];</span>
<span class="line" id="L681">                        containing = &amp;self.stack.items[self.stack.items.len - <span class="tok-number">2</span>];</span>
<span class="line" id="L682">                    }</span>
<span class="line" id="L683">                }</span>
<span class="line" id="L684">                <span class="tok-kw">return</span> WalkerEntry{</span>
<span class="line" id="L685">                    .dir = containing.iter.dir,</span>
<span class="line" id="L686">                    .basename = self.name_buffer.items[dirname_len..],</span>
<span class="line" id="L687">                    .path = self.name_buffer.items,</span>
<span class="line" id="L688">                    .kind = base.kind,</span>
<span class="line" id="L689">                };</span>
<span class="line" id="L690">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L691">                <span class="tok-kw">var</span> item = self.stack.pop();</span>
<span class="line" id="L692">                <span class="tok-kw">if</span> (self.stack.items.len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L693">                    item.iter.dir.close();</span>
<span class="line" id="L694">                }</span>
<span class="line" id="L695">            }</span>
<span class="line" id="L696">        }</span>
<span class="line" id="L697">        <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L698">    }</span>
<span class="line" id="L699"></span>
<span class="line" id="L700">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *Walker) <span class="tok-type">void</span> {</span>
<span class="line" id="L701">        <span class="tok-comment">// Close any remaining directories except the initial one (which is always at index 0)</span>
</span>
<span class="line" id="L702">        <span class="tok-kw">if</span> (self.stack.items.len &gt; <span class="tok-number">1</span>) {</span>
<span class="line" id="L703">            <span class="tok-kw">for</span> (self.stack.items[<span class="tok-number">1</span>..]) |*item| {</span>
<span class="line" id="L704">                item.iter.dir.close();</span>
<span class="line" id="L705">            }</span>
<span class="line" id="L706">        }</span>
<span class="line" id="L707">        self.stack.deinit();</span>
<span class="line" id="L708">        self.name_buffer.deinit();</span>
<span class="line" id="L709">    }</span>
<span class="line" id="L710">};</span>
<span class="line" id="L711"></span>
<span class="line" id="L712"><span class="tok-comment">/// Recursively iterates over a directory.</span></span>
<span class="line" id="L713"><span class="tok-comment">/// `self` must have been opened with `OpenDirOptions{.iterate = true}`.</span></span>
<span class="line" id="L714"><span class="tok-comment">/// Must call `Walker.deinit` when done.</span></span>
<span class="line" id="L715"><span class="tok-comment">/// The order of returned file system entries is undefined.</span></span>
<span class="line" id="L716"><span class="tok-comment">/// `self` will not be closed after walking it.</span></span>
<span class="line" id="L717"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">walk</span>(self: Dir, allocator: Allocator) !Walker {</span>
<span class="line" id="L718">    <span class="tok-kw">var</span> name_buffer = std.ArrayList(<span class="tok-type">u8</span>).init(allocator);</span>
<span class="line" id="L719">    <span class="tok-kw">errdefer</span> name_buffer.deinit();</span>
<span class="line" id="L720"></span>
<span class="line" id="L721">    <span class="tok-kw">var</span> stack = std.ArrayList(Walker.StackItem).init(allocator);</span>
<span class="line" id="L722">    <span class="tok-kw">errdefer</span> stack.deinit();</span>
<span class="line" id="L723"></span>
<span class="line" id="L724">    <span class="tok-kw">try</span> stack.append(Walker.StackItem{</span>
<span class="line" id="L725">        .iter = self.iterate(),</span>
<span class="line" id="L726">        .dirname_len = <span class="tok-number">0</span>,</span>
<span class="line" id="L727">    });</span>
<span class="line" id="L728"></span>
<span class="line" id="L729">    <span class="tok-kw">return</span> Walker{</span>
<span class="line" id="L730">        .stack = stack,</span>
<span class="line" id="L731">        .name_buffer = name_buffer,</span>
<span class="line" id="L732">    };</span>
<span class="line" id="L733">}</span>
<span class="line" id="L734"></span>
<span class="line" id="L735"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> OpenError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L736">    FileNotFound,</span>
<span class="line" id="L737">    NotDir,</span>
<span class="line" id="L738">    InvalidHandle,</span>
<span class="line" id="L739">    AccessDenied,</span>
<span class="line" id="L740">    SymLinkLoop,</span>
<span class="line" id="L741">    ProcessFdQuotaExceeded,</span>
<span class="line" id="L742">    NameTooLong,</span>
<span class="line" id="L743">    SystemFdQuotaExceeded,</span>
<span class="line" id="L744">    NoDevice,</span>
<span class="line" id="L745">    SystemResources,</span>
<span class="line" id="L746">    InvalidUtf8,</span>
<span class="line" id="L747">    BadPathName,</span>
<span class="line" id="L748">    DeviceBusy,</span>
<span class="line" id="L749">    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span></span>
<span class="line" id="L750">    NetworkNotFound,</span>
<span class="line" id="L751">} || posix.UnexpectedError;</span>
<span class="line" id="L752"></span>
<span class="line" id="L753"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">close</span>(self: *Dir) <span class="tok-type">void</span> {</span>
<span class="line" id="L754">    <span class="tok-kw">if</span> (fs.need_async_thread) {</span>
<span class="line" id="L755">        std.event.Loop.instance.?.close(self.fd);</span>
<span class="line" id="L756">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L757">        posix.close(self.fd);</span>
<span class="line" id="L758">    }</span>
<span class="line" id="L759">    self.* = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L760">}</span>
<span class="line" id="L761"></span>
<span class="line" id="L762"><span class="tok-comment">/// Opens a file for reading or writing, without attempting to create a new file.</span></span>
<span class="line" id="L763"><span class="tok-comment">/// To create a new file, see `createFile`.</span></span>
<span class="line" id="L764"><span class="tok-comment">/// Call `File.close` to release the resource.</span></span>
<span class="line" id="L765"><span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span></span>
<span class="line" id="L766"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openFile</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: File.OpenFlags) File.OpenError!File {</span>
<span class="line" id="L767">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L768">        <span class="tok-kw">const</span> path_w = <span class="tok-kw">try</span> std.os.windows.sliceToPrefixedFileW(self.fd, sub_path);</span>
<span class="line" id="L769">        <span class="tok-kw">return</span> self.openFileW(path_w.span(), flags);</span>
<span class="line" id="L770">    }</span>
<span class="line" id="L771">    <span class="tok-kw">if</span> (builtin.os.tag == .wasi <span class="tok-kw">and</span> !builtin.link_libc) {</span>
<span class="line" id="L772">        <span class="tok-kw">return</span> self.openFileWasi(sub_path, flags);</span>
<span class="line" id="L773">    }</span>
<span class="line" id="L774">    <span class="tok-kw">const</span> path_c = <span class="tok-kw">try</span> posix.toPosixPath(sub_path);</span>
<span class="line" id="L775">    <span class="tok-kw">return</span> self.openFileZ(&amp;path_c, flags);</span>
<span class="line" id="L776">}</span>
<span class="line" id="L777"></span>
<span class="line" id="L778"><span class="tok-comment">/// Same as `openFile` but WASI only.</span></span>
<span class="line" id="L779"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openFileWasi</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: File.OpenFlags) File.OpenError!File {</span>
<span class="line" id="L780">    <span class="tok-kw">const</span> w = std.os.wasi;</span>
<span class="line" id="L781">    <span class="tok-kw">var</span> fdflags: w.fdflags_t = <span class="tok-number">0x0</span>;</span>
<span class="line" id="L782">    <span class="tok-kw">var</span> base: w.rights_t = <span class="tok-number">0x0</span>;</span>
<span class="line" id="L783">    <span class="tok-kw">if</span> (flags.isRead()) {</span>
<span class="line" id="L784">        base |= w.RIGHT.FD_READ | w.RIGHT.FD_TELL | w.RIGHT.FD_SEEK | w.RIGHT.FD_FILESTAT_GET;</span>
<span class="line" id="L785">    }</span>
<span class="line" id="L786">    <span class="tok-kw">if</span> (flags.isWrite()) {</span>
<span class="line" id="L787">        fdflags |= w.FDFLAG.APPEND;</span>
<span class="line" id="L788">        base |= w.RIGHT.FD_WRITE |</span>
<span class="line" id="L789">            w.RIGHT.FD_TELL |</span>
<span class="line" id="L790">            w.RIGHT.FD_SEEK |</span>
<span class="line" id="L791">            w.RIGHT.FD_DATASYNC |</span>
<span class="line" id="L792">            w.RIGHT.FD_FDSTAT_SET_FLAGS |</span>
<span class="line" id="L793">            w.RIGHT.FD_SYNC |</span>
<span class="line" id="L794">            w.RIGHT.FD_ALLOCATE |</span>
<span class="line" id="L795">            w.RIGHT.FD_ADVISE |</span>
<span class="line" id="L796">            w.RIGHT.FD_FILESTAT_SET_TIMES |</span>
<span class="line" id="L797">            w.RIGHT.FD_FILESTAT_SET_SIZE;</span>
<span class="line" id="L798">    }</span>
<span class="line" id="L799">    <span class="tok-kw">const</span> fd = <span class="tok-kw">try</span> posix.openatWasi(self.fd, sub_path, <span class="tok-number">0x0</span>, <span class="tok-number">0x0</span>, fdflags, base, <span class="tok-number">0x0</span>);</span>
<span class="line" id="L800">    <span class="tok-kw">return</span> File{ .handle = fd };</span>
<span class="line" id="L801">}</span>
<span class="line" id="L802"></span>
<span class="line" id="L803"><span class="tok-comment">/// Same as `openFile` but the path parameter is null-terminated.</span></span>
<span class="line" id="L804"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openFileZ</span>(self: Dir, sub_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: File.OpenFlags) File.OpenError!File {</span>
<span class="line" id="L805">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L806">        <span class="tok-kw">const</span> path_w = <span class="tok-kw">try</span> std.os.windows.cStrToPrefixedFileW(self.fd, sub_path);</span>
<span class="line" id="L807">        <span class="tok-kw">return</span> self.openFileW(path_w.span(), flags);</span>
<span class="line" id="L808">    }</span>
<span class="line" id="L809"></span>
<span class="line" id="L810">    <span class="tok-kw">var</span> os_flags: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L811">    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(posix.O, <span class="tok-str">&quot;CLOEXEC&quot;</span>)) os_flags = posix.O.CLOEXEC;</span>
<span class="line" id="L812"></span>
<span class="line" id="L813">    <span class="tok-comment">// Use the O locking flags if the os supports them to acquire the lock</span>
</span>
<span class="line" id="L814">    <span class="tok-comment">// atomically.</span>
</span>
<span class="line" id="L815">    <span class="tok-kw">const</span> has_flock_open_flags = <span class="tok-builtin">@hasDecl</span>(posix.O, <span class="tok-str">&quot;EXLOCK&quot;</span>);</span>
<span class="line" id="L816">    <span class="tok-kw">if</span> (has_flock_open_flags) {</span>
<span class="line" id="L817">        <span class="tok-comment">// Note that the O.NONBLOCK flag is removed after the openat() call</span>
</span>
<span class="line" id="L818">        <span class="tok-comment">// is successful.</span>
</span>
<span class="line" id="L819">        <span class="tok-kw">const</span> nonblocking_lock_flag: <span class="tok-type">u32</span> = <span class="tok-kw">if</span> (flags.lock_nonblocking)</span>
<span class="line" id="L820">            posix.O.NONBLOCK</span>
<span class="line" id="L821">        <span class="tok-kw">else</span></span>
<span class="line" id="L822">            <span class="tok-number">0</span>;</span>
<span class="line" id="L823">        os_flags |= <span class="tok-kw">switch</span> (flags.lock) {</span>
<span class="line" id="L824">            .none =&gt; <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>),</span>
<span class="line" id="L825">            .shared =&gt; posix.O.SHLOCK | nonblocking_lock_flag,</span>
<span class="line" id="L826">            .exclusive =&gt; posix.O.EXLOCK | nonblocking_lock_flag,</span>
<span class="line" id="L827">        };</span>
<span class="line" id="L828">    }</span>
<span class="line" id="L829">    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(posix.O, <span class="tok-str">&quot;LARGEFILE&quot;</span>)) {</span>
<span class="line" id="L830">        os_flags |= posix.O.LARGEFILE;</span>
<span class="line" id="L831">    }</span>
<span class="line" id="L832">    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(posix.O, <span class="tok-str">&quot;NOCTTY&quot;</span>) <span class="tok-kw">and</span> !flags.allow_ctty) {</span>
<span class="line" id="L833">        os_flags |= posix.O.NOCTTY;</span>
<span class="line" id="L834">    }</span>
<span class="line" id="L835">    os_flags |= <span class="tok-kw">switch</span> (flags.mode) {</span>
<span class="line" id="L836">        .read_only =&gt; <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, posix.O.RDONLY),</span>
<span class="line" id="L837">        .write_only =&gt; <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, posix.O.WRONLY),</span>
<span class="line" id="L838">        .read_write =&gt; <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, posix.O.RDWR),</span>
<span class="line" id="L839">    };</span>
<span class="line" id="L840">    <span class="tok-kw">const</span> fd = <span class="tok-kw">if</span> (flags.intended_io_mode != .blocking)</span>
<span class="line" id="L841">        <span class="tok-kw">try</span> std.event.Loop.instance.?.openatZ(self.fd, sub_path, os_flags, <span class="tok-number">0</span>)</span>
<span class="line" id="L842">    <span class="tok-kw">else</span></span>
<span class="line" id="L843">        <span class="tok-kw">try</span> posix.openatZ(self.fd, sub_path, os_flags, <span class="tok-number">0</span>);</span>
<span class="line" id="L844">    <span class="tok-kw">errdefer</span> posix.close(fd);</span>
<span class="line" id="L845"></span>
<span class="line" id="L846">    <span class="tok-comment">// WASI doesn't have posix.flock so we intetinally check OS prior to the inner if block</span>
</span>
<span class="line" id="L847">    <span class="tok-comment">// since it is not compiltime-known and we need to avoid undefined symbol in Wasm.</span>
</span>
<span class="line" id="L848">    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(posix.system, <span class="tok-str">&quot;LOCK&quot;</span>) <span class="tok-kw">and</span> builtin.target.os.tag != .wasi) {</span>
<span class="line" id="L849">        <span class="tok-kw">if</span> (!has_flock_open_flags <span class="tok-kw">and</span> flags.lock != .none) {</span>
<span class="line" id="L850">            <span class="tok-comment">// TODO: integrate async I/O</span>
</span>
<span class="line" id="L851">            <span class="tok-kw">const</span> lock_nonblocking: <span class="tok-type">i32</span> = <span class="tok-kw">if</span> (flags.lock_nonblocking) posix.LOCK.NB <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L852">            <span class="tok-kw">try</span> posix.flock(fd, <span class="tok-kw">switch</span> (flags.lock) {</span>
<span class="line" id="L853">                .none =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L854">                .shared =&gt; posix.LOCK.SH | lock_nonblocking,</span>
<span class="line" id="L855">                .exclusive =&gt; posix.LOCK.EX | lock_nonblocking,</span>
<span class="line" id="L856">            });</span>
<span class="line" id="L857">        }</span>
<span class="line" id="L858">    }</span>
<span class="line" id="L859"></span>
<span class="line" id="L860">    <span class="tok-kw">if</span> (has_flock_open_flags <span class="tok-kw">and</span> flags.lock_nonblocking) {</span>
<span class="line" id="L861">        <span class="tok-kw">var</span> fl_flags = posix.fcntl(fd, posix.F.GETFL, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L862">            <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L863">            <span class="tok-kw">error</span>.Locked =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L864">            <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L865">            <span class="tok-kw">error</span>.DeadLock =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L866">            <span class="tok-kw">error</span>.LockedRegionLimitExceeded =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L867">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L868">        };</span>
<span class="line" id="L869">        fl_flags &amp;= ~<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, posix.O.NONBLOCK);</span>
<span class="line" id="L870">        _ = posix.fcntl(fd, posix.F.SETFL, fl_flags) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L871">            <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L872">            <span class="tok-kw">error</span>.Locked =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L873">            <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L874">            <span class="tok-kw">error</span>.DeadLock =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L875">            <span class="tok-kw">error</span>.LockedRegionLimitExceeded =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L876">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L877">        };</span>
<span class="line" id="L878">    }</span>
<span class="line" id="L879"></span>
<span class="line" id="L880">    <span class="tok-kw">return</span> File{</span>
<span class="line" id="L881">        .handle = fd,</span>
<span class="line" id="L882">        .capable_io_mode = .blocking,</span>
<span class="line" id="L883">        .intended_io_mode = flags.intended_io_mode,</span>
<span class="line" id="L884">    };</span>
<span class="line" id="L885">}</span>
<span class="line" id="L886"></span>
<span class="line" id="L887"><span class="tok-comment">/// Same as `openFile` but Windows-only and the path parameter is</span></span>
<span class="line" id="L888"><span class="tok-comment">/// [WTF-16](https://simonsapin.github.io/wtf-8/#potentially-ill-formed-utf-16) encoded.</span></span>
<span class="line" id="L889"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openFileW</span>(self: Dir, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: File.OpenFlags) File.OpenError!File {</span>
<span class="line" id="L890">    <span class="tok-kw">const</span> w = std.os.windows;</span>
<span class="line" id="L891">    <span class="tok-kw">const</span> file: File = .{</span>
<span class="line" id="L892">        .handle = <span class="tok-kw">try</span> w.OpenFile(sub_path_w, .{</span>
<span class="line" id="L893">            .dir = self.fd,</span>
<span class="line" id="L894">            .access_mask = w.SYNCHRONIZE |</span>
<span class="line" id="L895">                (<span class="tok-kw">if</span> (flags.isRead()) <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, w.GENERIC_READ) <span class="tok-kw">else</span> <span class="tok-number">0</span>) |</span>
<span class="line" id="L896">                (<span class="tok-kw">if</span> (flags.isWrite()) <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, w.GENERIC_WRITE) <span class="tok-kw">else</span> <span class="tok-number">0</span>),</span>
<span class="line" id="L897">            .creation = w.FILE_OPEN,</span>
<span class="line" id="L898">            .io_mode = flags.intended_io_mode,</span>
<span class="line" id="L899">        }),</span>
<span class="line" id="L900">        .capable_io_mode = std.io.default_mode,</span>
<span class="line" id="L901">        .intended_io_mode = flags.intended_io_mode,</span>
<span class="line" id="L902">    };</span>
<span class="line" id="L903">    <span class="tok-kw">errdefer</span> file.close();</span>
<span class="line" id="L904">    <span class="tok-kw">var</span> io: w.IO_STATUS_BLOCK = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L905">    <span class="tok-kw">const</span> range_off: w.LARGE_INTEGER = <span class="tok-number">0</span>;</span>
<span class="line" id="L906">    <span class="tok-kw">const</span> range_len: w.LARGE_INTEGER = <span class="tok-number">1</span>;</span>
<span class="line" id="L907">    <span class="tok-kw">const</span> exclusive = <span class="tok-kw">switch</span> (flags.lock) {</span>
<span class="line" id="L908">        .none =&gt; <span class="tok-kw">return</span> file,</span>
<span class="line" id="L909">        .shared =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L910">        .exclusive =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L911">    };</span>
<span class="line" id="L912">    <span class="tok-kw">try</span> w.LockFile(</span>
<span class="line" id="L913">        file.handle,</span>
<span class="line" id="L914">        <span class="tok-null">null</span>,</span>
<span class="line" id="L915">        <span class="tok-null">null</span>,</span>
<span class="line" id="L916">        <span class="tok-null">null</span>,</span>
<span class="line" id="L917">        &amp;io,</span>
<span class="line" id="L918">        &amp;range_off,</span>
<span class="line" id="L919">        &amp;range_len,</span>
<span class="line" id="L920">        <span class="tok-null">null</span>,</span>
<span class="line" id="L921">        <span class="tok-builtin">@intFromBool</span>(flags.lock_nonblocking),</span>
<span class="line" id="L922">        <span class="tok-builtin">@intFromBool</span>(exclusive),</span>
<span class="line" id="L923">    );</span>
<span class="line" id="L924">    <span class="tok-kw">return</span> file;</span>
<span class="line" id="L925">}</span>
<span class="line" id="L926"></span>
<span class="line" id="L927"><span class="tok-comment">/// Creates, opens, or overwrites a file with write access.</span></span>
<span class="line" id="L928"><span class="tok-comment">/// Call `File.close` on the result when done.</span></span>
<span class="line" id="L929"><span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span></span>
<span class="line" id="L930"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createFile</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: File.CreateFlags) File.OpenError!File {</span>
<span class="line" id="L931">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L932">        <span class="tok-kw">const</span> path_w = <span class="tok-kw">try</span> std.os.windows.sliceToPrefixedFileW(self.fd, sub_path);</span>
<span class="line" id="L933">        <span class="tok-kw">return</span> self.createFileW(path_w.span(), flags);</span>
<span class="line" id="L934">    }</span>
<span class="line" id="L935">    <span class="tok-kw">if</span> (builtin.os.tag == .wasi <span class="tok-kw">and</span> !builtin.link_libc) {</span>
<span class="line" id="L936">        <span class="tok-kw">return</span> self.createFileWasi(sub_path, flags);</span>
<span class="line" id="L937">    }</span>
<span class="line" id="L938">    <span class="tok-kw">const</span> path_c = <span class="tok-kw">try</span> posix.toPosixPath(sub_path);</span>
<span class="line" id="L939">    <span class="tok-kw">return</span> self.createFileZ(&amp;path_c, flags);</span>
<span class="line" id="L940">}</span>
<span class="line" id="L941"></span>
<span class="line" id="L942"><span class="tok-comment">/// Same as `createFile` but WASI only.</span></span>
<span class="line" id="L943"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createFileWasi</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: File.CreateFlags) File.OpenError!File {</span>
<span class="line" id="L944">    <span class="tok-kw">const</span> w = std.os.wasi;</span>
<span class="line" id="L945">    <span class="tok-kw">var</span> oflags = w.O.CREAT;</span>
<span class="line" id="L946">    <span class="tok-kw">var</span> base: w.rights_t = w.RIGHT.FD_WRITE |</span>
<span class="line" id="L947">        w.RIGHT.FD_DATASYNC |</span>
<span class="line" id="L948">        w.RIGHT.FD_SEEK |</span>
<span class="line" id="L949">        w.RIGHT.FD_TELL |</span>
<span class="line" id="L950">        w.RIGHT.FD_FDSTAT_SET_FLAGS |</span>
<span class="line" id="L951">        w.RIGHT.FD_SYNC |</span>
<span class="line" id="L952">        w.RIGHT.FD_ALLOCATE |</span>
<span class="line" id="L953">        w.RIGHT.FD_ADVISE |</span>
<span class="line" id="L954">        w.RIGHT.FD_FILESTAT_SET_TIMES |</span>
<span class="line" id="L955">        w.RIGHT.FD_FILESTAT_SET_SIZE |</span>
<span class="line" id="L956">        w.RIGHT.FD_FILESTAT_GET;</span>
<span class="line" id="L957">    <span class="tok-kw">if</span> (flags.read) {</span>
<span class="line" id="L958">        base |= w.RIGHT.FD_READ;</span>
<span class="line" id="L959">    }</span>
<span class="line" id="L960">    <span class="tok-kw">if</span> (flags.truncate) {</span>
<span class="line" id="L961">        oflags |= w.O.TRUNC;</span>
<span class="line" id="L962">    }</span>
<span class="line" id="L963">    <span class="tok-kw">if</span> (flags.exclusive) {</span>
<span class="line" id="L964">        oflags |= w.O.EXCL;</span>
<span class="line" id="L965">    }</span>
<span class="line" id="L966">    <span class="tok-kw">const</span> fd = <span class="tok-kw">try</span> posix.openatWasi(self.fd, sub_path, <span class="tok-number">0x0</span>, oflags, <span class="tok-number">0x0</span>, base, <span class="tok-number">0x0</span>);</span>
<span class="line" id="L967">    <span class="tok-kw">return</span> File{ .handle = fd };</span>
<span class="line" id="L968">}</span>
<span class="line" id="L969"></span>
<span class="line" id="L970"><span class="tok-comment">/// Same as `createFile` but the path parameter is null-terminated.</span></span>
<span class="line" id="L971"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createFileZ</span>(self: Dir, sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: File.CreateFlags) File.OpenError!File {</span>
<span class="line" id="L972">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L973">        <span class="tok-kw">const</span> path_w = <span class="tok-kw">try</span> std.os.windows.cStrToPrefixedFileW(self.fd, sub_path_c);</span>
<span class="line" id="L974">        <span class="tok-kw">return</span> self.createFileW(path_w.span(), flags);</span>
<span class="line" id="L975">    }</span>
<span class="line" id="L976"></span>
<span class="line" id="L977">    <span class="tok-comment">// Use the O locking flags if the os supports them to acquire the lock</span>
</span>
<span class="line" id="L978">    <span class="tok-comment">// atomically.</span>
</span>
<span class="line" id="L979">    <span class="tok-kw">const</span> has_flock_open_flags = <span class="tok-builtin">@hasDecl</span>(posix.O, <span class="tok-str">&quot;EXLOCK&quot;</span>);</span>
<span class="line" id="L980">    <span class="tok-comment">// Note that the O.NONBLOCK flag is removed after the openat() call</span>
</span>
<span class="line" id="L981">    <span class="tok-comment">// is successful.</span>
</span>
<span class="line" id="L982">    <span class="tok-kw">const</span> nonblocking_lock_flag: <span class="tok-type">u32</span> = <span class="tok-kw">if</span> (has_flock_open_flags <span class="tok-kw">and</span> flags.lock_nonblocking)</span>
<span class="line" id="L983">        posix.O.NONBLOCK</span>
<span class="line" id="L984">    <span class="tok-kw">else</span></span>
<span class="line" id="L985">        <span class="tok-number">0</span>;</span>
<span class="line" id="L986">    <span class="tok-kw">const</span> lock_flag: <span class="tok-type">u32</span> = <span class="tok-kw">if</span> (has_flock_open_flags) <span class="tok-kw">switch</span> (flags.lock) {</span>
<span class="line" id="L987">        .none =&gt; <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>),</span>
<span class="line" id="L988">        .shared =&gt; posix.O.SHLOCK | nonblocking_lock_flag,</span>
<span class="line" id="L989">        .exclusive =&gt; posix.O.EXLOCK | nonblocking_lock_flag,</span>
<span class="line" id="L990">    } <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L991"></span>
<span class="line" id="L992">    <span class="tok-kw">const</span> O_LARGEFILE = <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(posix.O, <span class="tok-str">&quot;LARGEFILE&quot;</span>)) posix.O.LARGEFILE <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L993">    <span class="tok-kw">const</span> os_flags = lock_flag | O_LARGEFILE | posix.O.CREAT | posix.O.CLOEXEC |</span>
<span class="line" id="L994">        (<span class="tok-kw">if</span> (flags.truncate) <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, posix.O.TRUNC) <span class="tok-kw">else</span> <span class="tok-number">0</span>) |</span>
<span class="line" id="L995">        (<span class="tok-kw">if</span> (flags.read) <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, posix.O.RDWR) <span class="tok-kw">else</span> posix.O.WRONLY) |</span>
<span class="line" id="L996">        (<span class="tok-kw">if</span> (flags.exclusive) <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, posix.O.EXCL) <span class="tok-kw">else</span> <span class="tok-number">0</span>);</span>
<span class="line" id="L997">    <span class="tok-kw">const</span> fd = <span class="tok-kw">if</span> (flags.intended_io_mode != .blocking)</span>
<span class="line" id="L998">        <span class="tok-kw">try</span> std.event.Loop.instance.?.openatZ(self.fd, sub_path_c, os_flags, flags.mode)</span>
<span class="line" id="L999">    <span class="tok-kw">else</span></span>
<span class="line" id="L1000">        <span class="tok-kw">try</span> posix.openatZ(self.fd, sub_path_c, os_flags, flags.mode);</span>
<span class="line" id="L1001">    <span class="tok-kw">errdefer</span> posix.close(fd);</span>
<span class="line" id="L1002"></span>
<span class="line" id="L1003">    <span class="tok-comment">// WASI doesn't have posix.flock so we intetinally check OS prior to the inner if block</span>
</span>
<span class="line" id="L1004">    <span class="tok-comment">// since it is not compiltime-known and we need to avoid undefined symbol in Wasm.</span>
</span>
<span class="line" id="L1005">    <span class="tok-kw">if</span> (builtin.target.os.tag != .wasi) {</span>
<span class="line" id="L1006">        <span class="tok-kw">if</span> (!has_flock_open_flags <span class="tok-kw">and</span> flags.lock != .none) {</span>
<span class="line" id="L1007">            <span class="tok-comment">// TODO: integrate async I/O</span>
</span>
<span class="line" id="L1008">            <span class="tok-kw">const</span> lock_nonblocking: <span class="tok-type">i32</span> = <span class="tok-kw">if</span> (flags.lock_nonblocking) posix.LOCK.NB <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L1009">            <span class="tok-kw">try</span> posix.flock(fd, <span class="tok-kw">switch</span> (flags.lock) {</span>
<span class="line" id="L1010">                .none =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1011">                .shared =&gt; posix.LOCK.SH | lock_nonblocking,</span>
<span class="line" id="L1012">                .exclusive =&gt; posix.LOCK.EX | lock_nonblocking,</span>
<span class="line" id="L1013">            });</span>
<span class="line" id="L1014">        }</span>
<span class="line" id="L1015">    }</span>
<span class="line" id="L1016"></span>
<span class="line" id="L1017">    <span class="tok-kw">if</span> (has_flock_open_flags <span class="tok-kw">and</span> flags.lock_nonblocking) {</span>
<span class="line" id="L1018">        <span class="tok-kw">var</span> fl_flags = posix.fcntl(fd, posix.F.GETFL, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1019">            <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1020">            <span class="tok-kw">error</span>.Locked =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1021">            <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1022">            <span class="tok-kw">error</span>.DeadLock =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1023">            <span class="tok-kw">error</span>.LockedRegionLimitExceeded =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1024">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1025">        };</span>
<span class="line" id="L1026">        fl_flags &amp;= ~<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, posix.O.NONBLOCK);</span>
<span class="line" id="L1027">        _ = posix.fcntl(fd, posix.F.SETFL, fl_flags) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1028">            <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1029">            <span class="tok-kw">error</span>.Locked =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1030">            <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1031">            <span class="tok-kw">error</span>.DeadLock =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1032">            <span class="tok-kw">error</span>.LockedRegionLimitExceeded =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1033">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1034">        };</span>
<span class="line" id="L1035">    }</span>
<span class="line" id="L1036"></span>
<span class="line" id="L1037">    <span class="tok-kw">return</span> File{</span>
<span class="line" id="L1038">        .handle = fd,</span>
<span class="line" id="L1039">        .capable_io_mode = .blocking,</span>
<span class="line" id="L1040">        .intended_io_mode = flags.intended_io_mode,</span>
<span class="line" id="L1041">    };</span>
<span class="line" id="L1042">}</span>
<span class="line" id="L1043"></span>
<span class="line" id="L1044"><span class="tok-comment">/// Same as `createFile` but Windows-only and the path parameter is</span></span>
<span class="line" id="L1045"><span class="tok-comment">/// [WTF-16](https://simonsapin.github.io/wtf-8/#potentially-ill-formed-utf-16) encoded.</span></span>
<span class="line" id="L1046"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createFileW</span>(self: Dir, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: File.CreateFlags) File.OpenError!File {</span>
<span class="line" id="L1047">    <span class="tok-kw">const</span> w = std.os.windows;</span>
<span class="line" id="L1048">    <span class="tok-kw">const</span> read_flag = <span class="tok-kw">if</span> (flags.read) <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, w.GENERIC_READ) <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L1049">    <span class="tok-kw">const</span> file: File = .{</span>
<span class="line" id="L1050">        .handle = <span class="tok-kw">try</span> w.OpenFile(sub_path_w, .{</span>
<span class="line" id="L1051">            .dir = self.fd,</span>
<span class="line" id="L1052">            .access_mask = w.SYNCHRONIZE | w.GENERIC_WRITE | read_flag,</span>
<span class="line" id="L1053">            .creation = <span class="tok-kw">if</span> (flags.exclusive)</span>
<span class="line" id="L1054">                <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, w.FILE_CREATE)</span>
<span class="line" id="L1055">            <span class="tok-kw">else</span> <span class="tok-kw">if</span> (flags.truncate)</span>
<span class="line" id="L1056">                <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, w.FILE_OVERWRITE_IF)</span>
<span class="line" id="L1057">            <span class="tok-kw">else</span></span>
<span class="line" id="L1058">                <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, w.FILE_OPEN_IF),</span>
<span class="line" id="L1059">            .io_mode = flags.intended_io_mode,</span>
<span class="line" id="L1060">        }),</span>
<span class="line" id="L1061">        .capable_io_mode = std.io.default_mode,</span>
<span class="line" id="L1062">        .intended_io_mode = flags.intended_io_mode,</span>
<span class="line" id="L1063">    };</span>
<span class="line" id="L1064">    <span class="tok-kw">errdefer</span> file.close();</span>
<span class="line" id="L1065">    <span class="tok-kw">var</span> io: w.IO_STATUS_BLOCK = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1066">    <span class="tok-kw">const</span> range_off: w.LARGE_INTEGER = <span class="tok-number">0</span>;</span>
<span class="line" id="L1067">    <span class="tok-kw">const</span> range_len: w.LARGE_INTEGER = <span class="tok-number">1</span>;</span>
<span class="line" id="L1068">    <span class="tok-kw">const</span> exclusive = <span class="tok-kw">switch</span> (flags.lock) {</span>
<span class="line" id="L1069">        .none =&gt; <span class="tok-kw">return</span> file,</span>
<span class="line" id="L1070">        .shared =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L1071">        .exclusive =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L1072">    };</span>
<span class="line" id="L1073">    <span class="tok-kw">try</span> w.LockFile(</span>
<span class="line" id="L1074">        file.handle,</span>
<span class="line" id="L1075">        <span class="tok-null">null</span>,</span>
<span class="line" id="L1076">        <span class="tok-null">null</span>,</span>
<span class="line" id="L1077">        <span class="tok-null">null</span>,</span>
<span class="line" id="L1078">        &amp;io,</span>
<span class="line" id="L1079">        &amp;range_off,</span>
<span class="line" id="L1080">        &amp;range_len,</span>
<span class="line" id="L1081">        <span class="tok-null">null</span>,</span>
<span class="line" id="L1082">        <span class="tok-builtin">@intFromBool</span>(flags.lock_nonblocking),</span>
<span class="line" id="L1083">        <span class="tok-builtin">@intFromBool</span>(exclusive),</span>
<span class="line" id="L1084">    );</span>
<span class="line" id="L1085">    <span class="tok-kw">return</span> file;</span>
<span class="line" id="L1086">}</span>
<span class="line" id="L1087"></span>
<span class="line" id="L1088"><span class="tok-comment">/// Creates a single directory with a relative or absolute path.</span></span>
<span class="line" id="L1089"><span class="tok-comment">/// To create multiple directories to make an entire path, see `makePath`.</span></span>
<span class="line" id="L1090"><span class="tok-comment">/// To operate on only absolute paths, see `makeDirAbsolute`.</span></span>
<span class="line" id="L1091"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeDir</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1092">    <span class="tok-kw">try</span> posix.mkdirat(self.fd, sub_path, default_mode);</span>
<span class="line" id="L1093">}</span>
<span class="line" id="L1094"></span>
<span class="line" id="L1095"><span class="tok-comment">/// Creates a single directory with a relative or absolute null-terminated UTF-8-encoded path.</span></span>
<span class="line" id="L1096"><span class="tok-comment">/// To create multiple directories to make an entire path, see `makePath`.</span></span>
<span class="line" id="L1097"><span class="tok-comment">/// To operate on only absolute paths, see `makeDirAbsoluteZ`.</span></span>
<span class="line" id="L1098"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeDirZ</span>(self: Dir, sub_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1099">    <span class="tok-kw">try</span> posix.mkdiratZ(self.fd, sub_path, default_mode);</span>
<span class="line" id="L1100">}</span>
<span class="line" id="L1101"></span>
<span class="line" id="L1102"><span class="tok-comment">/// Creates a single directory with a relative or absolute null-terminated WTF-16-encoded path.</span></span>
<span class="line" id="L1103"><span class="tok-comment">/// To create multiple directories to make an entire path, see `makePath`.</span></span>
<span class="line" id="L1104"><span class="tok-comment">/// To operate on only absolute paths, see `makeDirAbsoluteW`.</span></span>
<span class="line" id="L1105"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeDirW</span>(self: Dir, sub_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1106">    <span class="tok-kw">try</span> posix.mkdiratW(self.fd, sub_path, default_mode);</span>
<span class="line" id="L1107">}</span>
<span class="line" id="L1108"></span>
<span class="line" id="L1109"><span class="tok-comment">/// Calls makeDir iteratively to make an entire path</span></span>
<span class="line" id="L1110"><span class="tok-comment">/// (i.e. creating any parent directories that do not exist).</span></span>
<span class="line" id="L1111"><span class="tok-comment">/// Returns success if the path already exists and is a directory.</span></span>
<span class="line" id="L1112"><span class="tok-comment">/// This function is not atomic, and if it returns an error, the file system may</span></span>
<span class="line" id="L1113"><span class="tok-comment">/// have been modified regardless.</span></span>
<span class="line" id="L1114"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makePath</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1115">    <span class="tok-kw">var</span> it = <span class="tok-kw">try</span> fs.path.componentIterator(sub_path);</span>
<span class="line" id="L1116">    <span class="tok-kw">var</span> component = it.last() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L1117">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L1118">        self.makeDir(component.path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1119">            <span class="tok-kw">error</span>.PathAlreadyExists =&gt; {</span>
<span class="line" id="L1120">                <span class="tok-comment">// TODO stat the file and return an error if it's not a directory</span>
</span>
<span class="line" id="L1121">                <span class="tok-comment">// this is important because otherwise a dangling symlink</span>
</span>
<span class="line" id="L1122">                <span class="tok-comment">// could cause an infinite loop</span>
</span>
<span class="line" id="L1123">            },</span>
<span class="line" id="L1124">            <span class="tok-kw">error</span>.FileNotFound =&gt; |e| {</span>
<span class="line" id="L1125">                component = it.previous() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> e;</span>
<span class="line" id="L1126">                <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1127">            },</span>
<span class="line" id="L1128">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1129">        };</span>
<span class="line" id="L1130">        component = it.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L1131">    }</span>
<span class="line" id="L1132">}</span>
<span class="line" id="L1133"></span>
<span class="line" id="L1134"><span class="tok-comment">/// Calls makeOpenDirAccessMaskW iteratively to make an entire path</span></span>
<span class="line" id="L1135"><span class="tok-comment">/// (i.e. creating any parent directories that do not exist).</span></span>
<span class="line" id="L1136"><span class="tok-comment">/// Opens the dir if the path already exists and is a directory.</span></span>
<span class="line" id="L1137"><span class="tok-comment">/// This function is not atomic, and if it returns an error, the file system may</span></span>
<span class="line" id="L1138"><span class="tok-comment">/// have been modified regardless.</span></span>
<span class="line" id="L1139"><span class="tok-kw">fn</span> <span class="tok-fn">makeOpenPathAccessMaskW</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, access_mask: <span class="tok-type">u32</span>, no_follow: <span class="tok-type">bool</span>) OpenError!Dir {</span>
<span class="line" id="L1140">    <span class="tok-kw">const</span> w = std.os.windows;</span>
<span class="line" id="L1141">    <span class="tok-kw">var</span> it = <span class="tok-kw">try</span> fs.path.componentIterator(sub_path);</span>
<span class="line" id="L1142">    <span class="tok-comment">// If there are no components in the path, then create a dummy component with the full path.</span>
</span>
<span class="line" id="L1143">    <span class="tok-kw">var</span> component = it.last() <span class="tok-kw">orelse</span> fs.path.NativeUtf8ComponentIterator.Component{</span>
<span class="line" id="L1144">        .name = <span class="tok-str">&quot;&quot;</span>,</span>
<span class="line" id="L1145">        .path = sub_path,</span>
<span class="line" id="L1146">    };</span>
<span class="line" id="L1147"></span>
<span class="line" id="L1148">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L1149">        <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> w.sliceToPrefixedFileW(self.fd, component.path);</span>
<span class="line" id="L1150">        <span class="tok-kw">const</span> is_last = it.peekNext() == <span class="tok-null">null</span>;</span>
<span class="line" id="L1151">        <span class="tok-kw">var</span> result = self.makeOpenDirAccessMaskW(sub_path_w.span().ptr, access_mask, .{</span>
<span class="line" id="L1152">            .no_follow = no_follow,</span>
<span class="line" id="L1153">            .create_disposition = <span class="tok-kw">if</span> (is_last) w.FILE_OPEN_IF <span class="tok-kw">else</span> w.FILE_CREATE,</span>
<span class="line" id="L1154">        }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1155">            <span class="tok-kw">error</span>.FileNotFound =&gt; |e| {</span>
<span class="line" id="L1156">                component = it.previous() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> e;</span>
<span class="line" id="L1157">                <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1158">            },</span>
<span class="line" id="L1159">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1160">        };</span>
<span class="line" id="L1161"></span>
<span class="line" id="L1162">        component = it.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> result;</span>
<span class="line" id="L1163">        <span class="tok-comment">// Don't leak the intermediate file handles</span>
</span>
<span class="line" id="L1164">        result.close();</span>
<span class="line" id="L1165">    }</span>
<span class="line" id="L1166">}</span>
<span class="line" id="L1167"></span>
<span class="line" id="L1168"><span class="tok-comment">/// This function performs `makePath`, followed by `openDir`.</span></span>
<span class="line" id="L1169"><span class="tok-comment">/// If supported by the OS, this operation is atomic. It is not atomic on</span></span>
<span class="line" id="L1170"><span class="tok-comment">/// all operating systems.</span></span>
<span class="line" id="L1171"><span class="tok-comment">/// On Windows, this function performs `makeOpenPathAccessMaskW`.</span></span>
<span class="line" id="L1172"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeOpenPath</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, open_dir_options: OpenDirOptions) !Dir {</span>
<span class="line" id="L1173">    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (builtin.os.tag) {</span>
<span class="line" id="L1174">        .windows =&gt; {</span>
<span class="line" id="L1175">            <span class="tok-kw">const</span> w = std.os.windows;</span>
<span class="line" id="L1176">            <span class="tok-kw">const</span> base_flags = w.STANDARD_RIGHTS_READ | w.FILE_READ_ATTRIBUTES | w.FILE_READ_EA |</span>
<span class="line" id="L1177">                w.SYNCHRONIZE | w.FILE_TRAVERSE |</span>
<span class="line" id="L1178">                (<span class="tok-kw">if</span> (open_dir_options.iterate) w.FILE_LIST_DIRECTORY <span class="tok-kw">else</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>));</span>
<span class="line" id="L1179"></span>
<span class="line" id="L1180">            <span class="tok-kw">return</span> self.makeOpenPathAccessMaskW(sub_path, base_flags, open_dir_options.no_follow);</span>
<span class="line" id="L1181">        },</span>
<span class="line" id="L1182">        <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L1183">            <span class="tok-kw">return</span> self.openDir(sub_path, open_dir_options) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1184">                <span class="tok-kw">error</span>.FileNotFound =&gt; {</span>
<span class="line" id="L1185">                    <span class="tok-kw">try</span> self.makePath(sub_path);</span>
<span class="line" id="L1186">                    <span class="tok-kw">return</span> self.openDir(sub_path, open_dir_options);</span>
<span class="line" id="L1187">                },</span>
<span class="line" id="L1188">                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1189">            };</span>
<span class="line" id="L1190">        },</span>
<span class="line" id="L1191">    };</span>
<span class="line" id="L1192">}</span>
<span class="line" id="L1193"></span>
<span class="line" id="L1194"><span class="tok-comment">///  This function returns the canonicalized absolute pathname of</span></span>
<span class="line" id="L1195"><span class="tok-comment">/// `pathname` relative to this `Dir`. If `pathname` is absolute, ignores this</span></span>
<span class="line" id="L1196"><span class="tok-comment">/// `Dir` handle and returns the canonicalized absolute pathname of `pathname`</span></span>
<span class="line" id="L1197"><span class="tok-comment">/// argument.</span></span>
<span class="line" id="L1198"><span class="tok-comment">/// This function is not universally supported by all platforms.</span></span>
<span class="line" id="L1199"><span class="tok-comment">/// Currently supported hosts are: Linux, macOS, and Windows.</span></span>
<span class="line" id="L1200"><span class="tok-comment">/// See also `Dir.realpathZ`, `Dir.realpathW`, and `Dir.realpathAlloc`.</span></span>
<span class="line" id="L1201"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpath</span>(self: Dir, pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L1202">    <span class="tok-kw">if</span> (builtin.os.tag == .wasi) {</span>
<span class="line" id="L1203">        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;realpath is not available on WASI&quot;</span>);</span>
<span class="line" id="L1204">    }</span>
<span class="line" id="L1205">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L1206">        <span class="tok-kw">const</span> pathname_w = <span class="tok-kw">try</span> std.os.windows.sliceToPrefixedFileW(self.fd, pathname);</span>
<span class="line" id="L1207">        <span class="tok-kw">return</span> self.realpathW(pathname_w.span(), out_buffer);</span>
<span class="line" id="L1208">    }</span>
<span class="line" id="L1209">    <span class="tok-kw">const</span> pathname_c = <span class="tok-kw">try</span> posix.toPosixPath(pathname);</span>
<span class="line" id="L1210">    <span class="tok-kw">return</span> self.realpathZ(&amp;pathname_c, out_buffer);</span>
<span class="line" id="L1211">}</span>
<span class="line" id="L1212"></span>
<span class="line" id="L1213"><span class="tok-comment">/// Same as `Dir.realpath` except `pathname` is null-terminated.</span></span>
<span class="line" id="L1214"><span class="tok-comment">/// See also `Dir.realpath`, `realpathZ`.</span></span>
<span class="line" id="L1215"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpathZ</span>(self: Dir, pathname: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L1216">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L1217">        <span class="tok-kw">const</span> pathname_w = <span class="tok-kw">try</span> posix.windows.cStrToPrefixedFileW(self.fd, pathname);</span>
<span class="line" id="L1218">        <span class="tok-kw">return</span> self.realpathW(pathname_w.span(), out_buffer);</span>
<span class="line" id="L1219">    }</span>
<span class="line" id="L1220"></span>
<span class="line" id="L1221">    <span class="tok-kw">const</span> flags = <span class="tok-kw">if</span> (builtin.os.tag == .linux)</span>
<span class="line" id="L1222">        posix.O.PATH | posix.O.NONBLOCK | posix.O.CLOEXEC</span>
<span class="line" id="L1223">    <span class="tok-kw">else</span></span>
<span class="line" id="L1224">        posix.O.NONBLOCK | posix.O.CLOEXEC;</span>
<span class="line" id="L1225">    <span class="tok-kw">const</span> fd = posix.openatZ(self.fd, pathname, flags, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1226">        <span class="tok-kw">error</span>.FileLocksNotSupported =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1227">        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1228">    };</span>
<span class="line" id="L1229">    <span class="tok-kw">defer</span> posix.close(fd);</span>
<span class="line" id="L1230"></span>
<span class="line" id="L1231">    <span class="tok-comment">// Use of MAX_PATH_BYTES here is valid as the realpath function does not</span>
</span>
<span class="line" id="L1232">    <span class="tok-comment">// have a variant that takes an arbitrary-size buffer.</span>
</span>
<span class="line" id="L1233">    <span class="tok-comment">// TODO(#4812): Consider reimplementing realpath or using the POSIX.1-2008</span>
</span>
<span class="line" id="L1234">    <span class="tok-comment">// NULL out parameter (GNU's canonicalize_file_name) to handle overelong</span>
</span>
<span class="line" id="L1235">    <span class="tok-comment">// paths. musl supports passing NULL but restricts the output to PATH_MAX</span>
</span>
<span class="line" id="L1236">    <span class="tok-comment">// anyway.</span>
</span>
<span class="line" id="L1237">    <span class="tok-kw">var</span> buffer: [fs.MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1238">    <span class="tok-kw">const</span> out_path = <span class="tok-kw">try</span> posix.getFdPath(fd, &amp;buffer);</span>
<span class="line" id="L1239"></span>
<span class="line" id="L1240">    <span class="tok-kw">if</span> (out_path.len &gt; out_buffer.len) {</span>
<span class="line" id="L1241">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;</span>
<span class="line" id="L1242">    }</span>
<span class="line" id="L1243"></span>
<span class="line" id="L1244">    <span class="tok-kw">const</span> result = out_buffer[<span class="tok-number">0</span>..out_path.len];</span>
<span class="line" id="L1245">    <span class="tok-builtin">@memcpy</span>(result, out_path);</span>
<span class="line" id="L1246">    <span class="tok-kw">return</span> result;</span>
<span class="line" id="L1247">}</span>
<span class="line" id="L1248"></span>
<span class="line" id="L1249"><span class="tok-comment">/// Windows-only. Same as `Dir.realpath` except `pathname` is WTF16 encoded.</span></span>
<span class="line" id="L1250"><span class="tok-comment">/// See also `Dir.realpath`, `realpathW`.</span></span>
<span class="line" id="L1251"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpathW</span>(self: Dir, pathname: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, out_buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L1252">    <span class="tok-kw">const</span> w = std.os.windows;</span>
<span class="line" id="L1253"></span>
<span class="line" id="L1254">    <span class="tok-kw">const</span> access_mask = w.GENERIC_READ | w.SYNCHRONIZE;</span>
<span class="line" id="L1255">    <span class="tok-kw">const</span> share_access = w.FILE_SHARE_READ;</span>
<span class="line" id="L1256">    <span class="tok-kw">const</span> creation = w.FILE_OPEN;</span>
<span class="line" id="L1257">    <span class="tok-kw">const</span> h_file = blk: {</span>
<span class="line" id="L1258">        <span class="tok-kw">const</span> res = w.OpenFile(pathname, .{</span>
<span class="line" id="L1259">            .dir = self.fd,</span>
<span class="line" id="L1260">            .access_mask = access_mask,</span>
<span class="line" id="L1261">            .share_access = share_access,</span>
<span class="line" id="L1262">            .creation = creation,</span>
<span class="line" id="L1263">            .io_mode = .blocking,</span>
<span class="line" id="L1264">            .filter = .any,</span>
<span class="line" id="L1265">        }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1266">            <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1267">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1268">        };</span>
<span class="line" id="L1269">        <span class="tok-kw">break</span> :blk res;</span>
<span class="line" id="L1270">    };</span>
<span class="line" id="L1271">    <span class="tok-kw">defer</span> w.CloseHandle(h_file);</span>
<span class="line" id="L1272"></span>
<span class="line" id="L1273">    <span class="tok-comment">// Use of MAX_PATH_BYTES here is valid as the realpath function does not</span>
</span>
<span class="line" id="L1274">    <span class="tok-comment">// have a variant that takes an arbitrary-size buffer.</span>
</span>
<span class="line" id="L1275">    <span class="tok-comment">// TODO(#4812): Consider reimplementing realpath or using the POSIX.1-2008</span>
</span>
<span class="line" id="L1276">    <span class="tok-comment">// NULL out parameter (GNU's canonicalize_file_name) to handle overelong</span>
</span>
<span class="line" id="L1277">    <span class="tok-comment">// paths. musl supports passing NULL but restricts the output to PATH_MAX</span>
</span>
<span class="line" id="L1278">    <span class="tok-comment">// anyway.</span>
</span>
<span class="line" id="L1279">    <span class="tok-kw">var</span> buffer: [fs.MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1280">    <span class="tok-kw">const</span> out_path = <span class="tok-kw">try</span> posix.getFdPath(h_file, &amp;buffer);</span>
<span class="line" id="L1281"></span>
<span class="line" id="L1282">    <span class="tok-kw">if</span> (out_path.len &gt; out_buffer.len) {</span>
<span class="line" id="L1283">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;</span>
<span class="line" id="L1284">    }</span>
<span class="line" id="L1285"></span>
<span class="line" id="L1286">    <span class="tok-kw">const</span> result = out_buffer[<span class="tok-number">0</span>..out_path.len];</span>
<span class="line" id="L1287">    <span class="tok-builtin">@memcpy</span>(result, out_path);</span>
<span class="line" id="L1288">    <span class="tok-kw">return</span> result;</span>
<span class="line" id="L1289">}</span>
<span class="line" id="L1290"></span>
<span class="line" id="L1291"><span class="tok-comment">/// Same as `Dir.realpath` except caller must free the returned memory.</span></span>
<span class="line" id="L1292"><span class="tok-comment">/// See also `Dir.realpath`.</span></span>
<span class="line" id="L1293"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpathAlloc</span>(self: Dir, allocator: Allocator, pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L1294">    <span class="tok-comment">// Use of MAX_PATH_BYTES here is valid as the realpath function does not</span>
</span>
<span class="line" id="L1295">    <span class="tok-comment">// have a variant that takes an arbitrary-size buffer.</span>
</span>
<span class="line" id="L1296">    <span class="tok-comment">// TODO(#4812): Consider reimplementing realpath or using the POSIX.1-2008</span>
</span>
<span class="line" id="L1297">    <span class="tok-comment">// NULL out parameter (GNU's canonicalize_file_name) to handle overelong</span>
</span>
<span class="line" id="L1298">    <span class="tok-comment">// paths. musl supports passing NULL but restricts the output to PATH_MAX</span>
</span>
<span class="line" id="L1299">    <span class="tok-comment">// anyway.</span>
</span>
<span class="line" id="L1300">    <span class="tok-kw">var</span> buf: [fs.MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1301">    <span class="tok-kw">return</span> allocator.dupe(<span class="tok-type">u8</span>, <span class="tok-kw">try</span> self.realpath(pathname, buf[<span class="tok-number">0</span>..]));</span>
<span class="line" id="L1302">}</span>
<span class="line" id="L1303"></span>
<span class="line" id="L1304"><span class="tok-comment">/// Changes the current working directory to the open directory handle.</span></span>
<span class="line" id="L1305"><span class="tok-comment">/// This modifies global state and can have surprising effects in multi-</span></span>
<span class="line" id="L1306"><span class="tok-comment">/// threaded applications. Most applications and especially libraries should</span></span>
<span class="line" id="L1307"><span class="tok-comment">/// not call this function as a general rule, however it can have use cases</span></span>
<span class="line" id="L1308"><span class="tok-comment">/// in, for example, implementing a shell, or child process execution.</span></span>
<span class="line" id="L1309"><span class="tok-comment">/// Not all targets support this. For example, WASI does not have the concept</span></span>
<span class="line" id="L1310"><span class="tok-comment">/// of a current working directory.</span></span>
<span class="line" id="L1311"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setAsCwd</span>(self: Dir) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1312">    <span class="tok-kw">if</span> (builtin.os.tag == .wasi) {</span>
<span class="line" id="L1313">        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;changing cwd is not currently possible in WASI&quot;</span>);</span>
<span class="line" id="L1314">    }</span>
<span class="line" id="L1315">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L1316">        <span class="tok-kw">var</span> dir_path_buffer: [std.os.windows.PATH_MAX_WIDE]<span class="tok-type">u16</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1317">        <span class="tok-kw">const</span> dir_path = <span class="tok-kw">try</span> std.os.windows.GetFinalPathNameByHandle(self.fd, .{}, &amp;dir_path_buffer);</span>
<span class="line" id="L1318">        <span class="tok-kw">if</span> (builtin.link_libc) {</span>
<span class="line" id="L1319">            <span class="tok-kw">return</span> posix.chdirW(dir_path);</span>
<span class="line" id="L1320">        }</span>
<span class="line" id="L1321">        <span class="tok-kw">return</span> std.os.windows.SetCurrentDirectory(dir_path);</span>
<span class="line" id="L1322">    }</span>
<span class="line" id="L1323">    <span class="tok-kw">try</span> posix.fchdir(self.fd);</span>
<span class="line" id="L1324">}</span>
<span class="line" id="L1325"></span>
<span class="line" id="L1326"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> OpenDirOptions = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1327">    <span class="tok-comment">/// `true` means the opened directory can be used as the `Dir` parameter</span></span>
<span class="line" id="L1328">    <span class="tok-comment">/// for functions which operate based on an open directory handle. When `false`,</span></span>
<span class="line" id="L1329">    <span class="tok-comment">/// such operations are Illegal Behavior.</span></span>
<span class="line" id="L1330">    access_sub_paths: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,</span>
<span class="line" id="L1331"></span>
<span class="line" id="L1332">    <span class="tok-comment">/// `true` means the opened directory can be scanned for the files and sub-directories</span></span>
<span class="line" id="L1333">    <span class="tok-comment">/// of the result. It means the `iterate` function can be called.</span></span>
<span class="line" id="L1334">    iterate: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L1335"></span>
<span class="line" id="L1336">    <span class="tok-comment">/// `true` means it won't dereference the symlinks.</span></span>
<span class="line" id="L1337">    no_follow: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L1338">};</span>
<span class="line" id="L1339"></span>
<span class="line" id="L1340"><span class="tok-comment">/// Opens a directory at the given path. The directory is a system resource that remains</span></span>
<span class="line" id="L1341"><span class="tok-comment">/// open until `close` is called on the result.</span></span>
<span class="line" id="L1342"><span class="tok-comment">/// The directory cannot be iterated unless the `iterate` option is set to `true`.</span></span>
<span class="line" id="L1343"><span class="tok-comment">///</span></span>
<span class="line" id="L1344"><span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span></span>
<span class="line" id="L1345"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDir</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: OpenDirOptions) OpenError!Dir {</span>
<span class="line" id="L1346">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L1347">        <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> posix.windows.sliceToPrefixedFileW(self.fd, sub_path);</span>
<span class="line" id="L1348">        <span class="tok-kw">return</span> self.openDirW(sub_path_w.span().ptr, args);</span>
<span class="line" id="L1349">    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (builtin.os.tag == .wasi <span class="tok-kw">and</span> !builtin.link_libc) {</span>
<span class="line" id="L1350">        <span class="tok-kw">return</span> self.openDirWasi(sub_path, args);</span>
<span class="line" id="L1351">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1352">        <span class="tok-kw">const</span> sub_path_c = <span class="tok-kw">try</span> posix.toPosixPath(sub_path);</span>
<span class="line" id="L1353">        <span class="tok-kw">return</span> self.openDirZ(&amp;sub_path_c, args);</span>
<span class="line" id="L1354">    }</span>
<span class="line" id="L1355">}</span>
<span class="line" id="L1356"></span>
<span class="line" id="L1357"><span class="tok-comment">/// Same as `openDir` except only WASI.</span></span>
<span class="line" id="L1358"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDirWasi</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: OpenDirOptions) OpenError!Dir {</span>
<span class="line" id="L1359">    <span class="tok-kw">const</span> w = std.os.wasi;</span>
<span class="line" id="L1360">    <span class="tok-kw">var</span> base: w.rights_t = w.RIGHT.FD_FILESTAT_GET | w.RIGHT.FD_FDSTAT_SET_FLAGS | w.RIGHT.FD_FILESTAT_SET_TIMES;</span>
<span class="line" id="L1361">    <span class="tok-kw">if</span> (args.access_sub_paths) {</span>
<span class="line" id="L1362">        base |= w.RIGHT.FD_READDIR |</span>
<span class="line" id="L1363">            w.RIGHT.PATH_CREATE_DIRECTORY |</span>
<span class="line" id="L1364">            w.RIGHT.PATH_CREATE_FILE |</span>
<span class="line" id="L1365">            w.RIGHT.PATH_LINK_SOURCE |</span>
<span class="line" id="L1366">            w.RIGHT.PATH_LINK_TARGET |</span>
<span class="line" id="L1367">            w.RIGHT.PATH_OPEN |</span>
<span class="line" id="L1368">            w.RIGHT.PATH_READLINK |</span>
<span class="line" id="L1369">            w.RIGHT.PATH_RENAME_SOURCE |</span>
<span class="line" id="L1370">            w.RIGHT.PATH_RENAME_TARGET |</span>
<span class="line" id="L1371">            w.RIGHT.PATH_FILESTAT_GET |</span>
<span class="line" id="L1372">            w.RIGHT.PATH_FILESTAT_SET_SIZE |</span>
<span class="line" id="L1373">            w.RIGHT.PATH_FILESTAT_SET_TIMES |</span>
<span class="line" id="L1374">            w.RIGHT.PATH_SYMLINK |</span>
<span class="line" id="L1375">            w.RIGHT.PATH_REMOVE_DIRECTORY |</span>
<span class="line" id="L1376">            w.RIGHT.PATH_UNLINK_FILE;</span>
<span class="line" id="L1377">    }</span>
<span class="line" id="L1378">    <span class="tok-kw">const</span> symlink_flags: w.lookupflags_t = <span class="tok-kw">if</span> (args.no_follow) <span class="tok-number">0x0</span> <span class="tok-kw">else</span> w.LOOKUP_SYMLINK_FOLLOW;</span>
<span class="line" id="L1379">    <span class="tok-comment">// TODO do we really need all the rights here?</span>
</span>
<span class="line" id="L1380">    <span class="tok-kw">const</span> inheriting: w.rights_t = w.RIGHT.ALL ^ w.RIGHT.SOCK_SHUTDOWN;</span>
<span class="line" id="L1381"></span>
<span class="line" id="L1382">    <span class="tok-kw">const</span> result = posix.openatWasi(</span>
<span class="line" id="L1383">        self.fd,</span>
<span class="line" id="L1384">        sub_path,</span>
<span class="line" id="L1385">        symlink_flags,</span>
<span class="line" id="L1386">        w.O.DIRECTORY,</span>
<span class="line" id="L1387">        <span class="tok-number">0x0</span>,</span>
<span class="line" id="L1388">        base,</span>
<span class="line" id="L1389">        inheriting,</span>
<span class="line" id="L1390">    );</span>
<span class="line" id="L1391">    <span class="tok-kw">const</span> fd = result <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1392">        <span class="tok-kw">error</span>.FileTooBig =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// can't happen for directories</span>
</span>
<span class="line" id="L1393">        <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// we're providing O.DIRECTORY</span>
</span>
<span class="line" id="L1394">        <span class="tok-kw">error</span>.NoSpaceLeft =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// not providing O.CREAT</span>
</span>
<span class="line" id="L1395">        <span class="tok-kw">error</span>.PathAlreadyExists =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// not providing O.CREAT</span>
</span>
<span class="line" id="L1396">        <span class="tok-kw">error</span>.FileLocksNotSupported =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// locking folders is not supported</span>
</span>
<span class="line" id="L1397">        <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// can't happen for directories</span>
</span>
<span class="line" id="L1398">        <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// can't happen for directories</span>
</span>
<span class="line" id="L1399">        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1400">    };</span>
<span class="line" id="L1401">    <span class="tok-kw">return</span> Dir{ .fd = fd };</span>
<span class="line" id="L1402">}</span>
<span class="line" id="L1403"></span>
<span class="line" id="L1404"><span class="tok-comment">/// Same as `openDir` except the parameter is null-terminated.</span></span>
<span class="line" id="L1405"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDirZ</span>(self: Dir, sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: OpenDirOptions) OpenError!Dir {</span>
<span class="line" id="L1406">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L1407">        <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> std.os.windows.cStrToPrefixedFileW(self.fd, sub_path_c);</span>
<span class="line" id="L1408">        <span class="tok-kw">return</span> self.openDirW(sub_path_w.span().ptr, args);</span>
<span class="line" id="L1409">    }</span>
<span class="line" id="L1410">    <span class="tok-kw">const</span> symlink_flags: <span class="tok-type">u32</span> = <span class="tok-kw">if</span> (args.no_follow) posix.O.NOFOLLOW <span class="tok-kw">else</span> <span class="tok-number">0x0</span>;</span>
<span class="line" id="L1411">    <span class="tok-kw">if</span> (!args.iterate) {</span>
<span class="line" id="L1412">        <span class="tok-kw">const</span> O_PATH = <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(posix.O, <span class="tok-str">&quot;PATH&quot;</span>)) posix.O.PATH <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L1413">        <span class="tok-kw">return</span> self.openDirFlagsZ(sub_path_c, posix.O.DIRECTORY | posix.O.RDONLY | posix.O.CLOEXEC | O_PATH | symlink_flags);</span>
<span class="line" id="L1414">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1415">        <span class="tok-kw">return</span> self.openDirFlagsZ(sub_path_c, posix.O.DIRECTORY | posix.O.RDONLY | posix.O.CLOEXEC | symlink_flags);</span>
<span class="line" id="L1416">    }</span>
<span class="line" id="L1417">}</span>
<span class="line" id="L1418"></span>
<span class="line" id="L1419"><span class="tok-comment">/// Same as `openDir` except the path parameter is WTF-16 encoded, NT-prefixed.</span></span>
<span class="line" id="L1420"><span class="tok-comment">/// This function asserts the target OS is Windows.</span></span>
<span class="line" id="L1421"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDirW</span>(self: Dir, sub_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, args: OpenDirOptions) OpenError!Dir {</span>
<span class="line" id="L1422">    <span class="tok-kw">const</span> w = std.os.windows;</span>
<span class="line" id="L1423">    <span class="tok-comment">// TODO remove some of these flags if args.access_sub_paths is false</span>
</span>
<span class="line" id="L1424">    <span class="tok-kw">const</span> base_flags = w.STANDARD_RIGHTS_READ | w.FILE_READ_ATTRIBUTES | w.FILE_READ_EA |</span>
<span class="line" id="L1425">        w.SYNCHRONIZE | w.FILE_TRAVERSE;</span>
<span class="line" id="L1426">    <span class="tok-kw">const</span> flags: <span class="tok-type">u32</span> = <span class="tok-kw">if</span> (args.iterate) base_flags | w.FILE_LIST_DIRECTORY <span class="tok-kw">else</span> base_flags;</span>
<span class="line" id="L1427">    <span class="tok-kw">const</span> dir = <span class="tok-kw">try</span> self.makeOpenDirAccessMaskW(sub_path_w, flags, .{</span>
<span class="line" id="L1428">        .no_follow = args.no_follow,</span>
<span class="line" id="L1429">        .create_disposition = w.FILE_OPEN,</span>
<span class="line" id="L1430">    });</span>
<span class="line" id="L1431">    <span class="tok-kw">return</span> dir;</span>
<span class="line" id="L1432">}</span>
<span class="line" id="L1433"></span>
<span class="line" id="L1434"><span class="tok-comment">/// `flags` must contain `posix.O.DIRECTORY`.</span></span>
<span class="line" id="L1435"><span class="tok-kw">fn</span> <span class="tok-fn">openDirFlagsZ</span>(self: Dir, sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <span class="tok-type">u32</span>) OpenError!Dir {</span>
<span class="line" id="L1436">    <span class="tok-kw">const</span> result = <span class="tok-kw">if</span> (fs.need_async_thread)</span>
<span class="line" id="L1437">        std.event.Loop.instance.?.openatZ(self.fd, sub_path_c, flags, <span class="tok-number">0</span>)</span>
<span class="line" id="L1438">    <span class="tok-kw">else</span></span>
<span class="line" id="L1439">        posix.openatZ(self.fd, sub_path_c, flags, <span class="tok-number">0</span>);</span>
<span class="line" id="L1440">    <span class="tok-kw">const</span> fd = result <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1441">        <span class="tok-kw">error</span>.FileTooBig =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// can't happen for directories</span>
</span>
<span class="line" id="L1442">        <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// we're providing O.DIRECTORY</span>
</span>
<span class="line" id="L1443">        <span class="tok-kw">error</span>.NoSpaceLeft =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// not providing O.CREAT</span>
</span>
<span class="line" id="L1444">        <span class="tok-kw">error</span>.PathAlreadyExists =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// not providing O.CREAT</span>
</span>
<span class="line" id="L1445">        <span class="tok-kw">error</span>.FileLocksNotSupported =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// locking folders is not supported</span>
</span>
<span class="line" id="L1446">        <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// can't happen for directories</span>
</span>
<span class="line" id="L1447">        <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// can't happen for directories</span>
</span>
<span class="line" id="L1448">        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1449">    };</span>
<span class="line" id="L1450">    <span class="tok-kw">return</span> Dir{ .fd = fd };</span>
<span class="line" id="L1451">}</span>
<span class="line" id="L1452"></span>
<span class="line" id="L1453"><span class="tok-kw">const</span> MakeOpenDirAccessMaskWOptions = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1454">    no_follow: <span class="tok-type">bool</span>,</span>
<span class="line" id="L1455">    create_disposition: <span class="tok-type">u32</span>,</span>
<span class="line" id="L1456">};</span>
<span class="line" id="L1457"></span>
<span class="line" id="L1458"><span class="tok-kw">fn</span> <span class="tok-fn">makeOpenDirAccessMaskW</span>(self: Dir, sub_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, access_mask: <span class="tok-type">u32</span>, flags: MakeOpenDirAccessMaskWOptions) OpenError!Dir {</span>
<span class="line" id="L1459">    <span class="tok-kw">const</span> w = std.os.windows;</span>
<span class="line" id="L1460"></span>
<span class="line" id="L1461">    <span class="tok-kw">var</span> result = Dir{</span>
<span class="line" id="L1462">        .fd = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L1463">    };</span>
<span class="line" id="L1464"></span>
<span class="line" id="L1465">    <span class="tok-kw">const</span> path_len_bytes = <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intCast</span>(mem.sliceTo(sub_path_w, <span class="tok-number">0</span>).len * <span class="tok-number">2</span>));</span>
<span class="line" id="L1466">    <span class="tok-kw">var</span> nt_name = w.UNICODE_STRING{</span>
<span class="line" id="L1467">        .Length = path_len_bytes,</span>
<span class="line" id="L1468">        .MaximumLength = path_len_bytes,</span>
<span class="line" id="L1469">        .Buffer = <span class="tok-builtin">@constCast</span>(sub_path_w),</span>
<span class="line" id="L1470">    };</span>
<span class="line" id="L1471">    <span class="tok-kw">var</span> attr = w.OBJECT_ATTRIBUTES{</span>
<span class="line" id="L1472">        .Length = <span class="tok-builtin">@sizeOf</span>(w.OBJECT_ATTRIBUTES),</span>
<span class="line" id="L1473">        .RootDirectory = <span class="tok-kw">if</span> (fs.path.isAbsoluteWindowsW(sub_path_w)) <span class="tok-null">null</span> <span class="tok-kw">else</span> self.fd,</span>
<span class="line" id="L1474">        .Attributes = <span class="tok-number">0</span>, <span class="tok-comment">// Note we do not use OBJ_CASE_INSENSITIVE here.</span>
</span>
<span class="line" id="L1475">        .ObjectName = &amp;nt_name,</span>
<span class="line" id="L1476">        .SecurityDescriptor = <span class="tok-null">null</span>,</span>
<span class="line" id="L1477">        .SecurityQualityOfService = <span class="tok-null">null</span>,</span>
<span class="line" id="L1478">    };</span>
<span class="line" id="L1479">    <span class="tok-kw">const</span> open_reparse_point: w.DWORD = <span class="tok-kw">if</span> (flags.no_follow) w.FILE_OPEN_REPARSE_POINT <span class="tok-kw">else</span> <span class="tok-number">0x0</span>;</span>
<span class="line" id="L1480">    <span class="tok-kw">var</span> io: w.IO_STATUS_BLOCK = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1481">    <span class="tok-kw">const</span> rc = w.ntdll.NtCreateFile(</span>
<span class="line" id="L1482">        &amp;result.fd,</span>
<span class="line" id="L1483">        access_mask,</span>
<span class="line" id="L1484">        &amp;attr,</span>
<span class="line" id="L1485">        &amp;io,</span>
<span class="line" id="L1486">        <span class="tok-null">null</span>,</span>
<span class="line" id="L1487">        w.FILE_ATTRIBUTE_NORMAL,</span>
<span class="line" id="L1488">        w.FILE_SHARE_READ | w.FILE_SHARE_WRITE,</span>
<span class="line" id="L1489">        flags.create_disposition,</span>
<span class="line" id="L1490">        w.FILE_DIRECTORY_FILE | w.FILE_SYNCHRONOUS_IO_NONALERT | w.FILE_OPEN_FOR_BACKUP_INTENT | open_reparse_point,</span>
<span class="line" id="L1491">        <span class="tok-null">null</span>,</span>
<span class="line" id="L1492">        <span class="tok-number">0</span>,</span>
<span class="line" id="L1493">    );</span>
<span class="line" id="L1494"></span>
<span class="line" id="L1495">    <span class="tok-kw">switch</span> (rc) {</span>
<span class="line" id="L1496">        .SUCCESS =&gt; <span class="tok-kw">return</span> result,</span>
<span class="line" id="L1497">        .OBJECT_NAME_INVALID =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BadPathName,</span>
<span class="line" id="L1498">        .OBJECT_NAME_NOT_FOUND =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,</span>
<span class="line" id="L1499">        .OBJECT_PATH_NOT_FOUND =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,</span>
<span class="line" id="L1500">        .NOT_A_DIRECTORY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,</span>
<span class="line" id="L1501">        <span class="tok-comment">// This can happen if the directory has 'List folder contents' permission set to 'Deny'</span>
</span>
<span class="line" id="L1502">        <span class="tok-comment">// and the directory is trying to be opened for iteration.</span>
</span>
<span class="line" id="L1503">        .ACCESS_DENIED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L1504">        .INVALID_PARAMETER =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1505">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> w.unexpectedStatus(rc),</span>
<span class="line" id="L1506">    }</span>
<span class="line" id="L1507">}</span>
<span class="line" id="L1508"></span>
<span class="line" id="L1509"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DeleteFileError = posix.UnlinkError;</span>
<span class="line" id="L1510"></span>
<span class="line" id="L1511"><span class="tok-comment">/// Delete a file name and possibly the file it refers to, based on an open directory handle.</span></span>
<span class="line" id="L1512"><span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span></span>
<span class="line" id="L1513"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteFile</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) DeleteFileError!<span class="tok-type">void</span> {</span>
<span class="line" id="L1514">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L1515">        <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> std.os.windows.sliceToPrefixedFileW(self.fd, sub_path);</span>
<span class="line" id="L1516">        <span class="tok-kw">return</span> self.deleteFileW(sub_path_w.span());</span>
<span class="line" id="L1517">    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (builtin.os.tag == .wasi <span class="tok-kw">and</span> !builtin.link_libc) {</span>
<span class="line" id="L1518">        posix.unlinkat(self.fd, sub_path, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1519">            <span class="tok-kw">error</span>.DirNotEmpty =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// not passing AT.REMOVEDIR</span>
</span>
<span class="line" id="L1520">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1521">        };</span>
<span class="line" id="L1522">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1523">        <span class="tok-kw">const</span> sub_path_c = <span class="tok-kw">try</span> posix.toPosixPath(sub_path);</span>
<span class="line" id="L1524">        <span class="tok-kw">return</span> self.deleteFileZ(&amp;sub_path_c);</span>
<span class="line" id="L1525">    }</span>
<span class="line" id="L1526">}</span>
<span class="line" id="L1527"></span>
<span class="line" id="L1528"><span class="tok-comment">/// Same as `deleteFile` except the parameter is null-terminated.</span></span>
<span class="line" id="L1529"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteFileZ</span>(self: Dir, sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) DeleteFileError!<span class="tok-type">void</span> {</span>
<span class="line" id="L1530">    posix.unlinkatZ(self.fd, sub_path_c, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1531">        <span class="tok-kw">error</span>.DirNotEmpty =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// not passing AT.REMOVEDIR</span>
</span>
<span class="line" id="L1532">        <span class="tok-kw">error</span>.AccessDenied =&gt; |e| <span class="tok-kw">switch</span> (builtin.os.tag) {</span>
<span class="line" id="L1533">            <span class="tok-comment">// non-Linux POSIX systems return EPERM when trying to delete a directory, so</span>
</span>
<span class="line" id="L1534">            <span class="tok-comment">// we need to handle that case specifically and translate the error</span>
</span>
<span class="line" id="L1535">            .macos, .ios, .freebsd, .netbsd, .dragonfly, .openbsd, .solaris, .illumos =&gt; {</span>
<span class="line" id="L1536">                <span class="tok-comment">// Don't follow symlinks to match unlinkat (which acts on symlinks rather than follows them)</span>
</span>
<span class="line" id="L1537">                <span class="tok-kw">const</span> fstat = posix.fstatatZ(self.fd, sub_path_c, posix.AT.SYMLINK_NOFOLLOW) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> e;</span>
<span class="line" id="L1538">                <span class="tok-kw">const</span> is_dir = fstat.mode &amp; posix.S.IFMT == posix.S.IFDIR;</span>
<span class="line" id="L1539">                <span class="tok-kw">return</span> <span class="tok-kw">if</span> (is_dir) <span class="tok-kw">error</span>.IsDir <span class="tok-kw">else</span> e;</span>
<span class="line" id="L1540">            },</span>
<span class="line" id="L1541">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1542">        },</span>
<span class="line" id="L1543">        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1544">    };</span>
<span class="line" id="L1545">}</span>
<span class="line" id="L1546"></span>
<span class="line" id="L1547"><span class="tok-comment">/// Same as `deleteFile` except the parameter is WTF-16 encoded.</span></span>
<span class="line" id="L1548"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteFileW</span>(self: Dir, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>) DeleteFileError!<span class="tok-type">void</span> {</span>
<span class="line" id="L1549">    posix.unlinkatW(self.fd, sub_path_w, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1550">        <span class="tok-kw">error</span>.DirNotEmpty =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// not passing AT.REMOVEDIR</span>
</span>
<span class="line" id="L1551">        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1552">    };</span>
<span class="line" id="L1553">}</span>
<span class="line" id="L1554"></span>
<span class="line" id="L1555"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DeleteDirError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L1556">    DirNotEmpty,</span>
<span class="line" id="L1557">    FileNotFound,</span>
<span class="line" id="L1558">    AccessDenied,</span>
<span class="line" id="L1559">    FileBusy,</span>
<span class="line" id="L1560">    FileSystem,</span>
<span class="line" id="L1561">    SymLinkLoop,</span>
<span class="line" id="L1562">    NameTooLong,</span>
<span class="line" id="L1563">    NotDir,</span>
<span class="line" id="L1564">    SystemResources,</span>
<span class="line" id="L1565">    ReadOnlyFileSystem,</span>
<span class="line" id="L1566">    InvalidUtf8,</span>
<span class="line" id="L1567">    BadPathName,</span>
<span class="line" id="L1568">    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span></span>
<span class="line" id="L1569">    NetworkNotFound,</span>
<span class="line" id="L1570">    Unexpected,</span>
<span class="line" id="L1571">};</span>
<span class="line" id="L1572"></span>
<span class="line" id="L1573"><span class="tok-comment">/// Returns `error.DirNotEmpty` if the directory is not empty.</span></span>
<span class="line" id="L1574"><span class="tok-comment">/// To delete a directory recursively, see `deleteTree`.</span></span>
<span class="line" id="L1575"><span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span></span>
<span class="line" id="L1576"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteDir</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) DeleteDirError!<span class="tok-type">void</span> {</span>
<span class="line" id="L1577">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L1578">        <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> std.os.windows.sliceToPrefixedFileW(self.fd, sub_path);</span>
<span class="line" id="L1579">        <span class="tok-kw">return</span> self.deleteDirW(sub_path_w.span());</span>
<span class="line" id="L1580">    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (builtin.os.tag == .wasi <span class="tok-kw">and</span> !builtin.link_libc) {</span>
<span class="line" id="L1581">        posix.unlinkat(self.fd, sub_path, posix.AT.REMOVEDIR) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1582">            <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// not possible since we pass AT.REMOVEDIR</span>
</span>
<span class="line" id="L1583">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1584">        };</span>
<span class="line" id="L1585">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1586">        <span class="tok-kw">const</span> sub_path_c = <span class="tok-kw">try</span> posix.toPosixPath(sub_path);</span>
<span class="line" id="L1587">        <span class="tok-kw">return</span> self.deleteDirZ(&amp;sub_path_c);</span>
<span class="line" id="L1588">    }</span>
<span class="line" id="L1589">}</span>
<span class="line" id="L1590"></span>
<span class="line" id="L1591"><span class="tok-comment">/// Same as `deleteDir` except the parameter is null-terminated.</span></span>
<span class="line" id="L1592"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteDirZ</span>(self: Dir, sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) DeleteDirError!<span class="tok-type">void</span> {</span>
<span class="line" id="L1593">    posix.unlinkatZ(self.fd, sub_path_c, posix.AT.REMOVEDIR) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1594">        <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// not possible since we pass AT.REMOVEDIR</span>
</span>
<span class="line" id="L1595">        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1596">    };</span>
<span class="line" id="L1597">}</span>
<span class="line" id="L1598"></span>
<span class="line" id="L1599"><span class="tok-comment">/// Same as `deleteDir` except the parameter is UTF16LE, NT prefixed.</span></span>
<span class="line" id="L1600"><span class="tok-comment">/// This function is Windows-only.</span></span>
<span class="line" id="L1601"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteDirW</span>(self: Dir, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>) DeleteDirError!<span class="tok-type">void</span> {</span>
<span class="line" id="L1602">    posix.unlinkatW(self.fd, sub_path_w, posix.AT.REMOVEDIR) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1603">        <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// not possible since we pass AT.REMOVEDIR</span>
</span>
<span class="line" id="L1604">        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1605">    };</span>
<span class="line" id="L1606">}</span>
<span class="line" id="L1607"></span>
<span class="line" id="L1608"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> RenameError = posix.RenameError;</span>
<span class="line" id="L1609"></span>
<span class="line" id="L1610"><span class="tok-comment">/// Change the name or location of a file or directory.</span></span>
<span class="line" id="L1611"><span class="tok-comment">/// If new_sub_path already exists, it will be replaced.</span></span>
<span class="line" id="L1612"><span class="tok-comment">/// Renaming a file over an existing directory or a directory</span></span>
<span class="line" id="L1613"><span class="tok-comment">/// over an existing file will fail with `error.IsDir` or `error.NotDir`</span></span>
<span class="line" id="L1614"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rename</span>(self: Dir, old_sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) RenameError!<span class="tok-type">void</span> {</span>
<span class="line" id="L1615">    <span class="tok-kw">return</span> posix.renameat(self.fd, old_sub_path, self.fd, new_sub_path);</span>
<span class="line" id="L1616">}</span>
<span class="line" id="L1617"></span>
<span class="line" id="L1618"><span class="tok-comment">/// Same as `rename` except the parameters are null-terminated.</span></span>
<span class="line" id="L1619"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameZ</span>(self: Dir, old_sub_path_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_sub_path_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) RenameError!<span class="tok-type">void</span> {</span>
<span class="line" id="L1620">    <span class="tok-kw">return</span> posix.renameatZ(self.fd, old_sub_path_z, self.fd, new_sub_path_z);</span>
<span class="line" id="L1621">}</span>
<span class="line" id="L1622"></span>
<span class="line" id="L1623"><span class="tok-comment">/// Same as `rename` except the parameters are UTF16LE, NT prefixed.</span></span>
<span class="line" id="L1624"><span class="tok-comment">/// This function is Windows-only.</span></span>
<span class="line" id="L1625"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameW</span>(self: Dir, old_sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, new_sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>) RenameError!<span class="tok-type">void</span> {</span>
<span class="line" id="L1626">    <span class="tok-kw">return</span> posix.renameatW(self.fd, old_sub_path_w, self.fd, new_sub_path_w);</span>
<span class="line" id="L1627">}</span>
<span class="line" id="L1628"></span>
<span class="line" id="L1629"><span class="tok-comment">/// Use with `Dir.symLink` and `symLinkAbsolute` to specify whether the symlink</span></span>
<span class="line" id="L1630"><span class="tok-comment">/// will point to a file or a directory. This value is ignored on all hosts</span></span>
<span class="line" id="L1631"><span class="tok-comment">/// except Windows where creating symlinks to different resource types, requires</span></span>
<span class="line" id="L1632"><span class="tok-comment">/// different flags. By default, `symLinkAbsolute` is assumed to point to a file.</span></span>
<span class="line" id="L1633"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SymLinkFlags = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1634">    is_directory: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L1635">};</span>
<span class="line" id="L1636"></span>
<span class="line" id="L1637"><span class="tok-comment">/// Creates a symbolic link named `sym_link_path` which contains the string `target_path`.</span></span>
<span class="line" id="L1638"><span class="tok-comment">/// A symbolic link (also known as a soft link) may point to an existing file or to a nonexistent</span></span>
<span class="line" id="L1639"><span class="tok-comment">/// one; the latter case is known as a dangling link.</span></span>
<span class="line" id="L1640"><span class="tok-comment">/// If `sym_link_path` exists, it will not be overwritten.</span></span>
<span class="line" id="L1641"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLink</span>(</span>
<span class="line" id="L1642">    self: Dir,</span>
<span class="line" id="L1643">    target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1644">    sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1645">    flags: SymLinkFlags,</span>
<span class="line" id="L1646">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1647">    <span class="tok-kw">if</span> (builtin.os.tag == .wasi <span class="tok-kw">and</span> !builtin.link_libc) {</span>
<span class="line" id="L1648">        <span class="tok-kw">return</span> self.symLinkWasi(target_path, sym_link_path, flags);</span>
<span class="line" id="L1649">    }</span>
<span class="line" id="L1650">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L1651">        <span class="tok-comment">// Target path does not use sliceToPrefixedFileW because certain paths</span>
</span>
<span class="line" id="L1652">        <span class="tok-comment">// are handled differently when creating a symlink than they would be</span>
</span>
<span class="line" id="L1653">        <span class="tok-comment">// when converting to an NT namespaced path. CreateSymbolicLink in</span>
</span>
<span class="line" id="L1654">        <span class="tok-comment">// symLinkW will handle the necessary conversion.</span>
</span>
<span class="line" id="L1655">        <span class="tok-kw">var</span> target_path_w: std.os.windows.PathSpace = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1656">        target_path_w.len = <span class="tok-kw">try</span> std.unicode.utf8ToUtf16Le(&amp;target_path_w.data, target_path);</span>
<span class="line" id="L1657">        target_path_w.data[target_path_w.len] = <span class="tok-number">0</span>;</span>
<span class="line" id="L1658">        <span class="tok-kw">const</span> sym_link_path_w = <span class="tok-kw">try</span> std.os.windows.sliceToPrefixedFileW(self.fd, sym_link_path);</span>
<span class="line" id="L1659">        <span class="tok-kw">return</span> self.symLinkW(target_path_w.span(), sym_link_path_w.span(), flags);</span>
<span class="line" id="L1660">    }</span>
<span class="line" id="L1661">    <span class="tok-kw">const</span> target_path_c = <span class="tok-kw">try</span> posix.toPosixPath(target_path);</span>
<span class="line" id="L1662">    <span class="tok-kw">const</span> sym_link_path_c = <span class="tok-kw">try</span> posix.toPosixPath(sym_link_path);</span>
<span class="line" id="L1663">    <span class="tok-kw">return</span> self.symLinkZ(&amp;target_path_c, &amp;sym_link_path_c, flags);</span>
<span class="line" id="L1664">}</span>
<span class="line" id="L1665"></span>
<span class="line" id="L1666"><span class="tok-comment">/// WASI-only. Same as `symLink` except targeting WASI.</span></span>
<span class="line" id="L1667"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLinkWasi</span>(</span>
<span class="line" id="L1668">    self: Dir,</span>
<span class="line" id="L1669">    target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1670">    sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1671">    _: SymLinkFlags,</span>
<span class="line" id="L1672">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1673">    <span class="tok-kw">return</span> posix.symlinkat(target_path, self.fd, sym_link_path);</span>
<span class="line" id="L1674">}</span>
<span class="line" id="L1675"></span>
<span class="line" id="L1676"><span class="tok-comment">/// Same as `symLink`, except the pathname parameters are null-terminated.</span></span>
<span class="line" id="L1677"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLinkZ</span>(</span>
<span class="line" id="L1678">    self: Dir,</span>
<span class="line" id="L1679">    target_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1680">    sym_link_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1681">    flags: SymLinkFlags,</span>
<span class="line" id="L1682">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1683">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L1684">        <span class="tok-kw">const</span> target_path_w = <span class="tok-kw">try</span> std.os.windows.cStrToPrefixedFileW(self.fd, target_path_c);</span>
<span class="line" id="L1685">        <span class="tok-kw">const</span> sym_link_path_w = <span class="tok-kw">try</span> std.os.windows.cStrToPrefixedFileW(self.fd, sym_link_path_c);</span>
<span class="line" id="L1686">        <span class="tok-kw">return</span> self.symLinkW(target_path_w.span(), sym_link_path_w.span(), flags);</span>
<span class="line" id="L1687">    }</span>
<span class="line" id="L1688">    <span class="tok-kw">return</span> posix.symlinkatZ(target_path_c, self.fd, sym_link_path_c);</span>
<span class="line" id="L1689">}</span>
<span class="line" id="L1690"></span>
<span class="line" id="L1691"><span class="tok-comment">/// Windows-only. Same as `symLink` except the pathname parameters</span></span>
<span class="line" id="L1692"><span class="tok-comment">/// are null-terminated, WTF16 encoded.</span></span>
<span class="line" id="L1693"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLinkW</span>(</span>
<span class="line" id="L1694">    self: Dir,</span>
<span class="line" id="L1695">    <span class="tok-comment">/// WTF-16, does not need to be NT-prefixed. The NT-prefixing</span></span>
<span class="line" id="L1696">    <span class="tok-comment">/// of this path is handled by CreateSymbolicLink.</span></span>
<span class="line" id="L1697">    target_path_w: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>,</span>
<span class="line" id="L1698">    <span class="tok-comment">/// WTF-16, must be NT-prefixed or relative</span></span>
<span class="line" id="L1699">    sym_link_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>,</span>
<span class="line" id="L1700">    flags: SymLinkFlags,</span>
<span class="line" id="L1701">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1702">    <span class="tok-kw">return</span> std.os.windows.CreateSymbolicLink(self.fd, sym_link_path_w, target_path_w, flags.is_directory);</span>
<span class="line" id="L1703">}</span>
<span class="line" id="L1704"></span>
<span class="line" id="L1705"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ReadLinkError = posix.ReadLinkError;</span>
<span class="line" id="L1706"></span>
<span class="line" id="L1707"><span class="tok-comment">/// Read value of a symbolic link.</span></span>
<span class="line" id="L1708"><span class="tok-comment">/// The return value is a slice of `buffer`, from index `0`.</span></span>
<span class="line" id="L1709"><span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span></span>
<span class="line" id="L1710"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLink</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: []<span class="tok-type">u8</span>) ReadLinkError![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L1711">    <span class="tok-kw">if</span> (builtin.os.tag == .wasi <span class="tok-kw">and</span> !builtin.link_libc) {</span>
<span class="line" id="L1712">        <span class="tok-kw">return</span> self.readLinkWasi(sub_path, buffer);</span>
<span class="line" id="L1713">    }</span>
<span class="line" id="L1714">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L1715">        <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> std.os.windows.sliceToPrefixedFileW(self.fd, sub_path);</span>
<span class="line" id="L1716">        <span class="tok-kw">return</span> self.readLinkW(sub_path_w.span(), buffer);</span>
<span class="line" id="L1717">    }</span>
<span class="line" id="L1718">    <span class="tok-kw">const</span> sub_path_c = <span class="tok-kw">try</span> posix.toPosixPath(sub_path);</span>
<span class="line" id="L1719">    <span class="tok-kw">return</span> self.readLinkZ(&amp;sub_path_c, buffer);</span>
<span class="line" id="L1720">}</span>
<span class="line" id="L1721"></span>
<span class="line" id="L1722"><span class="tok-comment">/// WASI-only. Same as `readLink` except targeting WASI.</span></span>
<span class="line" id="L1723"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLinkWasi</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L1724">    <span class="tok-kw">return</span> posix.readlinkat(self.fd, sub_path, buffer);</span>
<span class="line" id="L1725">}</span>
<span class="line" id="L1726"></span>
<span class="line" id="L1727"><span class="tok-comment">/// Same as `readLink`, except the `pathname` parameter is null-terminated.</span></span>
<span class="line" id="L1728"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLinkZ</span>(self: Dir, sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L1729">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L1730">        <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> std.os.windows.cStrToPrefixedFileW(self.fd, sub_path_c);</span>
<span class="line" id="L1731">        <span class="tok-kw">return</span> self.readLinkW(sub_path_w.span(), buffer);</span>
<span class="line" id="L1732">    }</span>
<span class="line" id="L1733">    <span class="tok-kw">return</span> posix.readlinkatZ(self.fd, sub_path_c, buffer);</span>
<span class="line" id="L1734">}</span>
<span class="line" id="L1735"></span>
<span class="line" id="L1736"><span class="tok-comment">/// Windows-only. Same as `readLink` except the pathname parameter</span></span>
<span class="line" id="L1737"><span class="tok-comment">/// is null-terminated, WTF16 encoded.</span></span>
<span class="line" id="L1738"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLinkW</span>(self: Dir, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L1739">    <span class="tok-kw">return</span> std.os.windows.ReadLink(self.fd, sub_path_w, buffer);</span>
<span class="line" id="L1740">}</span>
<span class="line" id="L1741"></span>
<span class="line" id="L1742"><span class="tok-comment">/// Read all of file contents using a preallocated buffer.</span></span>
<span class="line" id="L1743"><span class="tok-comment">/// The returned slice has the same pointer as `buffer`. If the length matches `buffer.len`</span></span>
<span class="line" id="L1744"><span class="tok-comment">/// the situation is ambiguous. It could either mean that the entire file was read, and</span></span>
<span class="line" id="L1745"><span class="tok-comment">/// it exactly fits the buffer, or it could mean the buffer was not big enough for the</span></span>
<span class="line" id="L1746"><span class="tok-comment">/// entire file.</span></span>
<span class="line" id="L1747"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readFile</span>(self: Dir, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L1748">    <span class="tok-kw">var</span> file = <span class="tok-kw">try</span> self.openFile(file_path, .{});</span>
<span class="line" id="L1749">    <span class="tok-kw">defer</span> file.close();</span>
<span class="line" id="L1750"></span>
<span class="line" id="L1751">    <span class="tok-kw">const</span> end_index = <span class="tok-kw">try</span> file.readAll(buffer);</span>
<span class="line" id="L1752">    <span class="tok-kw">return</span> buffer[<span class="tok-number">0</span>..end_index];</span>
<span class="line" id="L1753">}</span>
<span class="line" id="L1754"></span>
<span class="line" id="L1755"><span class="tok-comment">/// On success, caller owns returned buffer.</span></span>
<span class="line" id="L1756"><span class="tok-comment">/// If the file is larger than `max_bytes`, returns `error.FileTooBig`.</span></span>
<span class="line" id="L1757"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readFileAlloc</span>(self: Dir, allocator: mem.Allocator, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, max_bytes: <span class="tok-type">usize</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L1758">    <span class="tok-kw">return</span> self.readFileAllocOptions(allocator, file_path, max_bytes, <span class="tok-null">null</span>, <span class="tok-builtin">@alignOf</span>(<span class="tok-type">u8</span>), <span class="tok-null">null</span>);</span>
<span class="line" id="L1759">}</span>
<span class="line" id="L1760"></span>
<span class="line" id="L1761"><span class="tok-comment">/// On success, caller owns returned buffer.</span></span>
<span class="line" id="L1762"><span class="tok-comment">/// If the file is larger than `max_bytes`, returns `error.FileTooBig`.</span></span>
<span class="line" id="L1763"><span class="tok-comment">/// If `size_hint` is specified the initial buffer size is calculated using</span></span>
<span class="line" id="L1764"><span class="tok-comment">/// that value, otherwise the effective file size is used instead.</span></span>
<span class="line" id="L1765"><span class="tok-comment">/// Allows specifying alignment and a sentinel value.</span></span>
<span class="line" id="L1766"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readFileAllocOptions</span>(</span>
<span class="line" id="L1767">    self: Dir,</span>
<span class="line" id="L1768">    allocator: mem.Allocator,</span>
<span class="line" id="L1769">    file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1770">    max_bytes: <span class="tok-type">usize</span>,</span>
<span class="line" id="L1771">    size_hint: ?<span class="tok-type">usize</span>,</span>
<span class="line" id="L1772">    <span class="tok-kw">comptime</span> alignment: <span class="tok-type">u29</span>,</span>
<span class="line" id="L1773">    <span class="tok-kw">comptime</span> optional_sentinel: ?<span class="tok-type">u8</span>,</span>
<span class="line" id="L1774">) !(<span class="tok-kw">if</span> (optional_sentinel) |s| [:s]<span class="tok-kw">align</span>(alignment) <span class="tok-type">u8</span> <span class="tok-kw">else</span> []<span class="tok-kw">align</span>(alignment) <span class="tok-type">u8</span>) {</span>
<span class="line" id="L1775">    <span class="tok-kw">var</span> file = <span class="tok-kw">try</span> self.openFile(file_path, .{});</span>
<span class="line" id="L1776">    <span class="tok-kw">defer</span> file.close();</span>
<span class="line" id="L1777"></span>
<span class="line" id="L1778">    <span class="tok-comment">// If the file size doesn't fit a usize it'll be certainly greater than</span>
</span>
<span class="line" id="L1779">    <span class="tok-comment">// `max_bytes`</span>
</span>
<span class="line" id="L1780">    <span class="tok-kw">const</span> stat_size = size_hint <span class="tok-kw">orelse</span> std.math.cast(<span class="tok-type">usize</span>, <span class="tok-kw">try</span> file.getEndPos()) <span class="tok-kw">orelse</span></span>
<span class="line" id="L1781">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig;</span>
<span class="line" id="L1782"></span>
<span class="line" id="L1783">    <span class="tok-kw">return</span> file.readToEndAllocOptions(allocator, max_bytes, stat_size, alignment, optional_sentinel);</span>
<span class="line" id="L1784">}</span>
<span class="line" id="L1785"></span>
<span class="line" id="L1786"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DeleteTreeError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L1787">    InvalidHandle,</span>
<span class="line" id="L1788">    AccessDenied,</span>
<span class="line" id="L1789">    FileTooBig,</span>
<span class="line" id="L1790">    SymLinkLoop,</span>
<span class="line" id="L1791">    ProcessFdQuotaExceeded,</span>
<span class="line" id="L1792">    NameTooLong,</span>
<span class="line" id="L1793">    SystemFdQuotaExceeded,</span>
<span class="line" id="L1794">    NoDevice,</span>
<span class="line" id="L1795">    SystemResources,</span>
<span class="line" id="L1796">    ReadOnlyFileSystem,</span>
<span class="line" id="L1797">    FileSystem,</span>
<span class="line" id="L1798">    FileBusy,</span>
<span class="line" id="L1799">    DeviceBusy,</span>
<span class="line" id="L1800"></span>
<span class="line" id="L1801">    <span class="tok-comment">/// One of the path components was not a directory.</span></span>
<span class="line" id="L1802">    <span class="tok-comment">/// This error is unreachable if `sub_path` does not contain a path separator.</span></span>
<span class="line" id="L1803">    NotDir,</span>
<span class="line" id="L1804"></span>
<span class="line" id="L1805">    <span class="tok-comment">/// On Windows, file paths must be valid Unicode.</span></span>
<span class="line" id="L1806">    InvalidUtf8,</span>
<span class="line" id="L1807"></span>
<span class="line" id="L1808">    <span class="tok-comment">/// On Windows, file paths cannot contain these characters:</span></span>
<span class="line" id="L1809">    <span class="tok-comment">/// '/', '*', '?', '&quot;', '&lt;', '&gt;', '|'</span></span>
<span class="line" id="L1810">    BadPathName,</span>
<span class="line" id="L1811"></span>
<span class="line" id="L1812">    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span></span>
<span class="line" id="L1813">    NetworkNotFound,</span>
<span class="line" id="L1814">} || posix.UnexpectedError;</span>
<span class="line" id="L1815"></span>
<span class="line" id="L1816"><span class="tok-comment">/// Whether `full_path` describes a symlink, file, or directory, this function</span></span>
<span class="line" id="L1817"><span class="tok-comment">/// removes it. If it cannot be removed because it is a non-empty directory,</span></span>
<span class="line" id="L1818"><span class="tok-comment">/// this function recursively removes its entries and then tries again.</span></span>
<span class="line" id="L1819"><span class="tok-comment">/// This operation is not atomic on most file systems.</span></span>
<span class="line" id="L1820"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteTree</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) DeleteTreeError!<span class="tok-type">void</span> {</span>
<span class="line" id="L1821">    <span class="tok-kw">var</span> initial_iterable_dir = (<span class="tok-kw">try</span> self.deleteTreeOpenInitialSubpath(sub_path, .file)) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L1822"></span>
<span class="line" id="L1823">    <span class="tok-kw">const</span> StackItem = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1824">        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1825">        parent_dir: Dir,</span>
<span class="line" id="L1826">        iter: Dir.Iterator,</span>
<span class="line" id="L1827"></span>
<span class="line" id="L1828">        <span class="tok-kw">fn</span> <span class="tok-fn">closeAll</span>(items: []<span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {</span>
<span class="line" id="L1829">            <span class="tok-kw">for</span> (items) |*item| item.iter.dir.close();</span>
<span class="line" id="L1830">        }</span>
<span class="line" id="L1831">    };</span>
<span class="line" id="L1832"></span>
<span class="line" id="L1833">    <span class="tok-kw">var</span> stack_buffer: [<span class="tok-number">16</span>]StackItem = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1834">    <span class="tok-kw">var</span> stack = std.ArrayListUnmanaged(StackItem).initBuffer(&amp;stack_buffer);</span>
<span class="line" id="L1835">    <span class="tok-kw">defer</span> StackItem.closeAll(stack.items);</span>
<span class="line" id="L1836"></span>
<span class="line" id="L1837">    stack.appendAssumeCapacity(.{</span>
<span class="line" id="L1838">        .name = sub_path,</span>
<span class="line" id="L1839">        .parent_dir = self,</span>
<span class="line" id="L1840">        .iter = initial_iterable_dir.iterateAssumeFirstIteration(),</span>
<span class="line" id="L1841">    });</span>
<span class="line" id="L1842"></span>
<span class="line" id="L1843">    process_stack: <span class="tok-kw">while</span> (stack.items.len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L1844">        <span class="tok-kw">var</span> top = &amp;stack.items[stack.items.len - <span class="tok-number">1</span>];</span>
<span class="line" id="L1845">        <span class="tok-kw">while</span> (<span class="tok-kw">try</span> top.iter.next()) |entry| {</span>
<span class="line" id="L1846">            <span class="tok-kw">var</span> treat_as_dir = entry.kind == .directory;</span>
<span class="line" id="L1847">            handle_entry: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L1848">                <span class="tok-kw">if</span> (treat_as_dir) {</span>
<span class="line" id="L1849">                    <span class="tok-kw">if</span> (stack.unusedCapacitySlice().len &gt;= <span class="tok-number">1</span>) {</span>
<span class="line" id="L1850">                        <span class="tok-kw">var</span> iterable_dir = top.iter.dir.openDir(entry.name, .{</span>
<span class="line" id="L1851">                            .no_follow = <span class="tok-null">true</span>,</span>
<span class="line" id="L1852">                            .iterate = <span class="tok-null">true</span>,</span>
<span class="line" id="L1853">                        }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1854">                            <span class="tok-kw">error</span>.NotDir =&gt; {</span>
<span class="line" id="L1855">                                treat_as_dir = <span class="tok-null">false</span>;</span>
<span class="line" id="L1856">                                <span class="tok-kw">continue</span> :handle_entry;</span>
<span class="line" id="L1857">                            },</span>
<span class="line" id="L1858">                            <span class="tok-kw">error</span>.FileNotFound =&gt; {</span>
<span class="line" id="L1859">                                <span class="tok-comment">// That's fine, we were trying to remove this directory anyway.</span>
</span>
<span class="line" id="L1860">                                <span class="tok-kw">break</span> :handle_entry;</span>
<span class="line" id="L1861">                            },</span>
<span class="line" id="L1862"></span>
<span class="line" id="L1863">                            <span class="tok-kw">error</span>.InvalidHandle,</span>
<span class="line" id="L1864">                            <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L1865">                            <span class="tok-kw">error</span>.SymLinkLoop,</span>
<span class="line" id="L1866">                            <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,</span>
<span class="line" id="L1867">                            <span class="tok-kw">error</span>.NameTooLong,</span>
<span class="line" id="L1868">                            <span class="tok-kw">error</span>.SystemFdQuotaExceeded,</span>
<span class="line" id="L1869">                            <span class="tok-kw">error</span>.NoDevice,</span>
<span class="line" id="L1870">                            <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L1871">                            <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L1872">                            <span class="tok-kw">error</span>.InvalidUtf8,</span>
<span class="line" id="L1873">                            <span class="tok-kw">error</span>.BadPathName,</span>
<span class="line" id="L1874">                            <span class="tok-kw">error</span>.NetworkNotFound,</span>
<span class="line" id="L1875">                            <span class="tok-kw">error</span>.DeviceBusy,</span>
<span class="line" id="L1876">                            =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1877">                        };</span>
<span class="line" id="L1878">                        stack.appendAssumeCapacity(.{</span>
<span class="line" id="L1879">                            .name = entry.name,</span>
<span class="line" id="L1880">                            .parent_dir = top.iter.dir,</span>
<span class="line" id="L1881">                            .iter = iterable_dir.iterateAssumeFirstIteration(),</span>
<span class="line" id="L1882">                        });</span>
<span class="line" id="L1883">                        <span class="tok-kw">continue</span> :process_stack;</span>
<span class="line" id="L1884">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1885">                        <span class="tok-kw">try</span> top.iter.dir.deleteTreeMinStackSizeWithKindHint(entry.name, entry.kind);</span>
<span class="line" id="L1886">                        <span class="tok-kw">break</span> :handle_entry;</span>
<span class="line" id="L1887">                    }</span>
<span class="line" id="L1888">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1889">                    <span class="tok-kw">if</span> (top.iter.dir.deleteFile(entry.name)) {</span>
<span class="line" id="L1890">                        <span class="tok-kw">break</span> :handle_entry;</span>
<span class="line" id="L1891">                    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1892">                        <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">break</span> :handle_entry,</span>
<span class="line" id="L1893"></span>
<span class="line" id="L1894">                        <span class="tok-comment">// Impossible because we do not pass any path separators.</span>
</span>
<span class="line" id="L1895">                        <span class="tok-kw">error</span>.NotDir =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1896"></span>
<span class="line" id="L1897">                        <span class="tok-kw">error</span>.IsDir =&gt; {</span>
<span class="line" id="L1898">                            treat_as_dir = <span class="tok-null">true</span>;</span>
<span class="line" id="L1899">                            <span class="tok-kw">continue</span> :handle_entry;</span>
<span class="line" id="L1900">                        },</span>
<span class="line" id="L1901"></span>
<span class="line" id="L1902">                        <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L1903">                        <span class="tok-kw">error</span>.InvalidUtf8,</span>
<span class="line" id="L1904">                        <span class="tok-kw">error</span>.SymLinkLoop,</span>
<span class="line" id="L1905">                        <span class="tok-kw">error</span>.NameTooLong,</span>
<span class="line" id="L1906">                        <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L1907">                        <span class="tok-kw">error</span>.ReadOnlyFileSystem,</span>
<span class="line" id="L1908">                        <span class="tok-kw">error</span>.FileSystem,</span>
<span class="line" id="L1909">                        <span class="tok-kw">error</span>.FileBusy,</span>
<span class="line" id="L1910">                        <span class="tok-kw">error</span>.BadPathName,</span>
<span class="line" id="L1911">                        <span class="tok-kw">error</span>.NetworkNotFound,</span>
<span class="line" id="L1912">                        <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L1913">                        =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1914">                    }</span>
<span class="line" id="L1915">                }</span>
<span class="line" id="L1916">            }</span>
<span class="line" id="L1917">        }</span>
<span class="line" id="L1918"></span>
<span class="line" id="L1919">        <span class="tok-comment">// On Windows, we can't delete until the dir's handle has been closed, so</span>
</span>
<span class="line" id="L1920">        <span class="tok-comment">// close it before we try to delete.</span>
</span>
<span class="line" id="L1921">        top.iter.dir.close();</span>
<span class="line" id="L1922"></span>
<span class="line" id="L1923">        <span class="tok-comment">// In order to avoid double-closing the directory when cleaning up</span>
</span>
<span class="line" id="L1924">        <span class="tok-comment">// the stack in the case of an error, we save the relevant portions and</span>
</span>
<span class="line" id="L1925">        <span class="tok-comment">// pop the value from the stack.</span>
</span>
<span class="line" id="L1926">        <span class="tok-kw">const</span> parent_dir = top.parent_dir;</span>
<span class="line" id="L1927">        <span class="tok-kw">const</span> name = top.name;</span>
<span class="line" id="L1928">        stack.items.len -= <span class="tok-number">1</span>;</span>
<span class="line" id="L1929"></span>
<span class="line" id="L1930">        <span class="tok-kw">var</span> need_to_retry: <span class="tok-type">bool</span> = <span class="tok-null">false</span>;</span>
<span class="line" id="L1931">        parent_dir.deleteDir(name) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1932">            <span class="tok-kw">error</span>.FileNotFound =&gt; {},</span>
<span class="line" id="L1933">            <span class="tok-kw">error</span>.DirNotEmpty =&gt; need_to_retry = <span class="tok-null">true</span>,</span>
<span class="line" id="L1934">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1935">        };</span>
<span class="line" id="L1936"></span>
<span class="line" id="L1937">        <span class="tok-kw">if</span> (need_to_retry) {</span>
<span class="line" id="L1938">            <span class="tok-comment">// Since we closed the handle that the previous iterator used, we</span>
</span>
<span class="line" id="L1939">            <span class="tok-comment">// need to re-open the dir and re-create the iterator.</span>
</span>
<span class="line" id="L1940">            <span class="tok-kw">var</span> iterable_dir = iterable_dir: {</span>
<span class="line" id="L1941">                <span class="tok-kw">var</span> treat_as_dir = <span class="tok-null">true</span>;</span>
<span class="line" id="L1942">                handle_entry: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L1943">                    <span class="tok-kw">if</span> (treat_as_dir) {</span>
<span class="line" id="L1944">                        <span class="tok-kw">break</span> :iterable_dir parent_dir.openDir(name, .{</span>
<span class="line" id="L1945">                            .no_follow = <span class="tok-null">true</span>,</span>
<span class="line" id="L1946">                            .iterate = <span class="tok-null">true</span>,</span>
<span class="line" id="L1947">                        }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1948">                            <span class="tok-kw">error</span>.NotDir =&gt; {</span>
<span class="line" id="L1949">                                treat_as_dir = <span class="tok-null">false</span>;</span>
<span class="line" id="L1950">                                <span class="tok-kw">continue</span> :handle_entry;</span>
<span class="line" id="L1951">                            },</span>
<span class="line" id="L1952">                            <span class="tok-kw">error</span>.FileNotFound =&gt; {</span>
<span class="line" id="L1953">                                <span class="tok-comment">// That's fine, we were trying to remove this directory anyway.</span>
</span>
<span class="line" id="L1954">                                <span class="tok-kw">continue</span> :process_stack;</span>
<span class="line" id="L1955">                            },</span>
<span class="line" id="L1956"></span>
<span class="line" id="L1957">                            <span class="tok-kw">error</span>.InvalidHandle,</span>
<span class="line" id="L1958">                            <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L1959">                            <span class="tok-kw">error</span>.SymLinkLoop,</span>
<span class="line" id="L1960">                            <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,</span>
<span class="line" id="L1961">                            <span class="tok-kw">error</span>.NameTooLong,</span>
<span class="line" id="L1962">                            <span class="tok-kw">error</span>.SystemFdQuotaExceeded,</span>
<span class="line" id="L1963">                            <span class="tok-kw">error</span>.NoDevice,</span>
<span class="line" id="L1964">                            <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L1965">                            <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L1966">                            <span class="tok-kw">error</span>.InvalidUtf8,</span>
<span class="line" id="L1967">                            <span class="tok-kw">error</span>.BadPathName,</span>
<span class="line" id="L1968">                            <span class="tok-kw">error</span>.NetworkNotFound,</span>
<span class="line" id="L1969">                            <span class="tok-kw">error</span>.DeviceBusy,</span>
<span class="line" id="L1970">                            =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1971">                        };</span>
<span class="line" id="L1972">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1973">                        <span class="tok-kw">if</span> (parent_dir.deleteFile(name)) {</span>
<span class="line" id="L1974">                            <span class="tok-kw">continue</span> :process_stack;</span>
<span class="line" id="L1975">                        } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1976">                            <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">continue</span> :process_stack,</span>
<span class="line" id="L1977"></span>
<span class="line" id="L1978">                            <span class="tok-comment">// Impossible because we do not pass any path separators.</span>
</span>
<span class="line" id="L1979">                            <span class="tok-kw">error</span>.NotDir =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1980"></span>
<span class="line" id="L1981">                            <span class="tok-kw">error</span>.IsDir =&gt; {</span>
<span class="line" id="L1982">                                treat_as_dir = <span class="tok-null">true</span>;</span>
<span class="line" id="L1983">                                <span class="tok-kw">continue</span> :handle_entry;</span>
<span class="line" id="L1984">                            },</span>
<span class="line" id="L1985"></span>
<span class="line" id="L1986">                            <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L1987">                            <span class="tok-kw">error</span>.InvalidUtf8,</span>
<span class="line" id="L1988">                            <span class="tok-kw">error</span>.SymLinkLoop,</span>
<span class="line" id="L1989">                            <span class="tok-kw">error</span>.NameTooLong,</span>
<span class="line" id="L1990">                            <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L1991">                            <span class="tok-kw">error</span>.ReadOnlyFileSystem,</span>
<span class="line" id="L1992">                            <span class="tok-kw">error</span>.FileSystem,</span>
<span class="line" id="L1993">                            <span class="tok-kw">error</span>.FileBusy,</span>
<span class="line" id="L1994">                            <span class="tok-kw">error</span>.BadPathName,</span>
<span class="line" id="L1995">                            <span class="tok-kw">error</span>.NetworkNotFound,</span>
<span class="line" id="L1996">                            <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L1997">                            =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1998">                        }</span>
<span class="line" id="L1999">                    }</span>
<span class="line" id="L2000">                }</span>
<span class="line" id="L2001">            };</span>
<span class="line" id="L2002">            <span class="tok-comment">// We know there is room on the stack since we are just re-adding</span>
</span>
<span class="line" id="L2003">            <span class="tok-comment">// the StackItem that we previously popped.</span>
</span>
<span class="line" id="L2004">            stack.appendAssumeCapacity(.{</span>
<span class="line" id="L2005">                .name = name,</span>
<span class="line" id="L2006">                .parent_dir = parent_dir,</span>
<span class="line" id="L2007">                .iter = iterable_dir.iterateAssumeFirstIteration(),</span>
<span class="line" id="L2008">            });</span>
<span class="line" id="L2009">            <span class="tok-kw">continue</span> :process_stack;</span>
<span class="line" id="L2010">        }</span>
<span class="line" id="L2011">    }</span>
<span class="line" id="L2012">}</span>
<span class="line" id="L2013"></span>
<span class="line" id="L2014"><span class="tok-comment">/// Like `deleteTree`, but only keeps one `Iterator` active at a time to minimize the function's stack size.</span></span>
<span class="line" id="L2015"><span class="tok-comment">/// This is slower than `deleteTree` but uses less stack space.</span></span>
<span class="line" id="L2016"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteTreeMinStackSize</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) DeleteTreeError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2017">    <span class="tok-kw">return</span> self.deleteTreeMinStackSizeWithKindHint(sub_path, .file);</span>
<span class="line" id="L2018">}</span>
<span class="line" id="L2019"></span>
<span class="line" id="L2020"><span class="tok-kw">fn</span> <span class="tok-fn">deleteTreeMinStackSizeWithKindHint</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, kind_hint: File.Kind) DeleteTreeError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2021">    start_over: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L2022">        <span class="tok-kw">var</span> dir = (<span class="tok-kw">try</span> self.deleteTreeOpenInitialSubpath(sub_path, kind_hint)) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L2023">        <span class="tok-kw">var</span> cleanup_dir_parent: ?Dir = <span class="tok-null">null</span>;</span>
<span class="line" id="L2024">        <span class="tok-kw">defer</span> <span class="tok-kw">if</span> (cleanup_dir_parent) |*d| d.close();</span>
<span class="line" id="L2025"></span>
<span class="line" id="L2026">        <span class="tok-kw">var</span> cleanup_dir = <span class="tok-null">true</span>;</span>
<span class="line" id="L2027">        <span class="tok-kw">defer</span> <span class="tok-kw">if</span> (cleanup_dir) dir.close();</span>
<span class="line" id="L2028"></span>
<span class="line" id="L2029">        <span class="tok-comment">// Valid use of MAX_PATH_BYTES because dir_name_buf will only</span>
</span>
<span class="line" id="L2030">        <span class="tok-comment">// ever store a single path component that was returned from the</span>
</span>
<span class="line" id="L2031">        <span class="tok-comment">// filesystem.</span>
</span>
<span class="line" id="L2032">        <span class="tok-kw">var</span> dir_name_buf: [fs.MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L2033">        <span class="tok-kw">var</span> dir_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = sub_path;</span>
<span class="line" id="L2034"></span>
<span class="line" id="L2035">        <span class="tok-comment">// Here we must avoid recursion, in order to provide O(1) memory guarantee of this function.</span>
</span>
<span class="line" id="L2036">        <span class="tok-comment">// Go through each entry and if it is not a directory, delete it. If it is a directory,</span>
</span>
<span class="line" id="L2037">        <span class="tok-comment">// open it, and close the original directory. Repeat. Then start the entire operation over.</span>
</span>
<span class="line" id="L2038"></span>
<span class="line" id="L2039">        scan_dir: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L2040">            <span class="tok-kw">var</span> dir_it = dir.iterateAssumeFirstIteration();</span>
<span class="line" id="L2041">            dir_it: <span class="tok-kw">while</span> (<span class="tok-kw">try</span> dir_it.next()) |entry| {</span>
<span class="line" id="L2042">                <span class="tok-kw">var</span> treat_as_dir = entry.kind == .directory;</span>
<span class="line" id="L2043">                handle_entry: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L2044">                    <span class="tok-kw">if</span> (treat_as_dir) {</span>
<span class="line" id="L2045">                        <span class="tok-kw">const</span> new_dir = dir.openDir(entry.name, .{</span>
<span class="line" id="L2046">                            .no_follow = <span class="tok-null">true</span>,</span>
<span class="line" id="L2047">                            .iterate = <span class="tok-null">true</span>,</span>
<span class="line" id="L2048">                        }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2049">                            <span class="tok-kw">error</span>.NotDir =&gt; {</span>
<span class="line" id="L2050">                                treat_as_dir = <span class="tok-null">false</span>;</span>
<span class="line" id="L2051">                                <span class="tok-kw">continue</span> :handle_entry;</span>
<span class="line" id="L2052">                            },</span>
<span class="line" id="L2053">                            <span class="tok-kw">error</span>.FileNotFound =&gt; {</span>
<span class="line" id="L2054">                                <span class="tok-comment">// That's fine, we were trying to remove this directory anyway.</span>
</span>
<span class="line" id="L2055">                                <span class="tok-kw">continue</span> :dir_it;</span>
<span class="line" id="L2056">                            },</span>
<span class="line" id="L2057"></span>
<span class="line" id="L2058">                            <span class="tok-kw">error</span>.InvalidHandle,</span>
<span class="line" id="L2059">                            <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L2060">                            <span class="tok-kw">error</span>.SymLinkLoop,</span>
<span class="line" id="L2061">                            <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,</span>
<span class="line" id="L2062">                            <span class="tok-kw">error</span>.NameTooLong,</span>
<span class="line" id="L2063">                            <span class="tok-kw">error</span>.SystemFdQuotaExceeded,</span>
<span class="line" id="L2064">                            <span class="tok-kw">error</span>.NoDevice,</span>
<span class="line" id="L2065">                            <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L2066">                            <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L2067">                            <span class="tok-kw">error</span>.InvalidUtf8,</span>
<span class="line" id="L2068">                            <span class="tok-kw">error</span>.BadPathName,</span>
<span class="line" id="L2069">                            <span class="tok-kw">error</span>.NetworkNotFound,</span>
<span class="line" id="L2070">                            <span class="tok-kw">error</span>.DeviceBusy,</span>
<span class="line" id="L2071">                            =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L2072">                        };</span>
<span class="line" id="L2073">                        <span class="tok-kw">if</span> (cleanup_dir_parent) |*d| d.close();</span>
<span class="line" id="L2074">                        cleanup_dir_parent = dir;</span>
<span class="line" id="L2075">                        dir = new_dir;</span>
<span class="line" id="L2076">                        <span class="tok-kw">const</span> result = dir_name_buf[<span class="tok-number">0</span>..entry.name.len];</span>
<span class="line" id="L2077">                        <span class="tok-builtin">@memcpy</span>(result, entry.name);</span>
<span class="line" id="L2078">                        dir_name = result;</span>
<span class="line" id="L2079">                        <span class="tok-kw">continue</span> :scan_dir;</span>
<span class="line" id="L2080">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2081">                        <span class="tok-kw">if</span> (dir.deleteFile(entry.name)) {</span>
<span class="line" id="L2082">                            <span class="tok-kw">continue</span> :dir_it;</span>
<span class="line" id="L2083">                        } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2084">                            <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">continue</span> :dir_it,</span>
<span class="line" id="L2085"></span>
<span class="line" id="L2086">                            <span class="tok-comment">// Impossible because we do not pass any path separators.</span>
</span>
<span class="line" id="L2087">                            <span class="tok-kw">error</span>.NotDir =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L2088"></span>
<span class="line" id="L2089">                            <span class="tok-kw">error</span>.IsDir =&gt; {</span>
<span class="line" id="L2090">                                treat_as_dir = <span class="tok-null">true</span>;</span>
<span class="line" id="L2091">                                <span class="tok-kw">continue</span> :handle_entry;</span>
<span class="line" id="L2092">                            },</span>
<span class="line" id="L2093"></span>
<span class="line" id="L2094">                            <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L2095">                            <span class="tok-kw">error</span>.InvalidUtf8,</span>
<span class="line" id="L2096">                            <span class="tok-kw">error</span>.SymLinkLoop,</span>
<span class="line" id="L2097">                            <span class="tok-kw">error</span>.NameTooLong,</span>
<span class="line" id="L2098">                            <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L2099">                            <span class="tok-kw">error</span>.ReadOnlyFileSystem,</span>
<span class="line" id="L2100">                            <span class="tok-kw">error</span>.FileSystem,</span>
<span class="line" id="L2101">                            <span class="tok-kw">error</span>.FileBusy,</span>
<span class="line" id="L2102">                            <span class="tok-kw">error</span>.BadPathName,</span>
<span class="line" id="L2103">                            <span class="tok-kw">error</span>.NetworkNotFound,</span>
<span class="line" id="L2104">                            <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L2105">                            =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L2106">                        }</span>
<span class="line" id="L2107">                    }</span>
<span class="line" id="L2108">                }</span>
<span class="line" id="L2109">            }</span>
<span class="line" id="L2110">            <span class="tok-comment">// Reached the end of the directory entries, which means we successfully deleted all of them.</span>
</span>
<span class="line" id="L2111">            <span class="tok-comment">// Now to remove the directory itself.</span>
</span>
<span class="line" id="L2112">            dir.close();</span>
<span class="line" id="L2113">            cleanup_dir = <span class="tok-null">false</span>;</span>
<span class="line" id="L2114"></span>
<span class="line" id="L2115">            <span class="tok-kw">if</span> (cleanup_dir_parent) |d| {</span>
<span class="line" id="L2116">                d.deleteDir(dir_name) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2117">                    <span class="tok-comment">// These two things can happen due to file system race conditions.</span>
</span>
<span class="line" id="L2118">                    <span class="tok-kw">error</span>.FileNotFound, <span class="tok-kw">error</span>.DirNotEmpty =&gt; <span class="tok-kw">continue</span> :start_over,</span>
<span class="line" id="L2119">                    <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L2120">                };</span>
<span class="line" id="L2121">                <span class="tok-kw">continue</span> :start_over;</span>
<span class="line" id="L2122">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2123">                self.deleteDir(sub_path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2124">                    <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">return</span>,</span>
<span class="line" id="L2125">                    <span class="tok-kw">error</span>.DirNotEmpty =&gt; <span class="tok-kw">continue</span> :start_over,</span>
<span class="line" id="L2126">                    <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L2127">                };</span>
<span class="line" id="L2128">                <span class="tok-kw">return</span>;</span>
<span class="line" id="L2129">            }</span>
<span class="line" id="L2130">        }</span>
<span class="line" id="L2131">    }</span>
<span class="line" id="L2132">}</span>
<span class="line" id="L2133"></span>
<span class="line" id="L2134"><span class="tok-comment">/// On successful delete, returns null.</span></span>
<span class="line" id="L2135"><span class="tok-kw">fn</span> <span class="tok-fn">deleteTreeOpenInitialSubpath</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, kind_hint: File.Kind) !?Dir {</span>
<span class="line" id="L2136">    <span class="tok-kw">return</span> iterable_dir: {</span>
<span class="line" id="L2137">        <span class="tok-comment">// Treat as a file by default</span>
</span>
<span class="line" id="L2138">        <span class="tok-kw">var</span> treat_as_dir = kind_hint == .directory;</span>
<span class="line" id="L2139"></span>
<span class="line" id="L2140">        handle_entry: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L2141">            <span class="tok-kw">if</span> (treat_as_dir) {</span>
<span class="line" id="L2142">                <span class="tok-kw">break</span> :iterable_dir self.openDir(sub_path, .{</span>
<span class="line" id="L2143">                    .no_follow = <span class="tok-null">true</span>,</span>
<span class="line" id="L2144">                    .iterate = <span class="tok-null">true</span>,</span>
<span class="line" id="L2145">                }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2146">                    <span class="tok-kw">error</span>.NotDir =&gt; {</span>
<span class="line" id="L2147">                        treat_as_dir = <span class="tok-null">false</span>;</span>
<span class="line" id="L2148">                        <span class="tok-kw">continue</span> :handle_entry;</span>
<span class="line" id="L2149">                    },</span>
<span class="line" id="L2150">                    <span class="tok-kw">error</span>.FileNotFound =&gt; {</span>
<span class="line" id="L2151">                        <span class="tok-comment">// That's fine, we were trying to remove this directory anyway.</span>
</span>
<span class="line" id="L2152">                        <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2153">                    },</span>
<span class="line" id="L2154"></span>
<span class="line" id="L2155">                    <span class="tok-kw">error</span>.InvalidHandle,</span>
<span class="line" id="L2156">                    <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L2157">                    <span class="tok-kw">error</span>.SymLinkLoop,</span>
<span class="line" id="L2158">                    <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,</span>
<span class="line" id="L2159">                    <span class="tok-kw">error</span>.NameTooLong,</span>
<span class="line" id="L2160">                    <span class="tok-kw">error</span>.SystemFdQuotaExceeded,</span>
<span class="line" id="L2161">                    <span class="tok-kw">error</span>.NoDevice,</span>
<span class="line" id="L2162">                    <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L2163">                    <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L2164">                    <span class="tok-kw">error</span>.InvalidUtf8,</span>
<span class="line" id="L2165">                    <span class="tok-kw">error</span>.BadPathName,</span>
<span class="line" id="L2166">                    <span class="tok-kw">error</span>.DeviceBusy,</span>
<span class="line" id="L2167">                    <span class="tok-kw">error</span>.NetworkNotFound,</span>
<span class="line" id="L2168">                    =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L2169">                };</span>
<span class="line" id="L2170">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2171">                <span class="tok-kw">if</span> (self.deleteFile(sub_path)) {</span>
<span class="line" id="L2172">                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2173">                } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2174">                    <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,</span>
<span class="line" id="L2175"></span>
<span class="line" id="L2176">                    <span class="tok-kw">error</span>.IsDir =&gt; {</span>
<span class="line" id="L2177">                        treat_as_dir = <span class="tok-null">true</span>;</span>
<span class="line" id="L2178">                        <span class="tok-kw">continue</span> :handle_entry;</span>
<span class="line" id="L2179">                    },</span>
<span class="line" id="L2180"></span>
<span class="line" id="L2181">                    <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L2182">                    <span class="tok-kw">error</span>.InvalidUtf8,</span>
<span class="line" id="L2183">                    <span class="tok-kw">error</span>.SymLinkLoop,</span>
<span class="line" id="L2184">                    <span class="tok-kw">error</span>.NameTooLong,</span>
<span class="line" id="L2185">                    <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L2186">                    <span class="tok-kw">error</span>.ReadOnlyFileSystem,</span>
<span class="line" id="L2187">                    <span class="tok-kw">error</span>.NotDir,</span>
<span class="line" id="L2188">                    <span class="tok-kw">error</span>.FileSystem,</span>
<span class="line" id="L2189">                    <span class="tok-kw">error</span>.FileBusy,</span>
<span class="line" id="L2190">                    <span class="tok-kw">error</span>.BadPathName,</span>
<span class="line" id="L2191">                    <span class="tok-kw">error</span>.NetworkNotFound,</span>
<span class="line" id="L2192">                    <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L2193">                    =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L2194">                }</span>
<span class="line" id="L2195">            }</span>
<span class="line" id="L2196">        }</span>
<span class="line" id="L2197">    };</span>
<span class="line" id="L2198">}</span>
<span class="line" id="L2199"></span>
<span class="line" id="L2200"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> WriteFileError = File.WriteError || File.OpenError;</span>
<span class="line" id="L2201"></span>
<span class="line" id="L2202"><span class="tok-comment">/// Deprecated: use `writeFile2`.</span></span>
<span class="line" id="L2203"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeFile</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) WriteFileError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2204">    <span class="tok-kw">return</span> writeFile2(self, .{</span>
<span class="line" id="L2205">        .sub_path = sub_path,</span>
<span class="line" id="L2206">        .data = data,</span>
<span class="line" id="L2207">        .flags = .{},</span>
<span class="line" id="L2208">    });</span>
<span class="line" id="L2209">}</span>
<span class="line" id="L2210"></span>
<span class="line" id="L2211"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> WriteFileOptions = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2212">    sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2213">    data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2214">    flags: File.CreateFlags = .{},</span>
<span class="line" id="L2215">};</span>
<span class="line" id="L2216"></span>
<span class="line" id="L2217"><span class="tok-comment">/// Writes content to the file system, using the file creation flags provided.</span></span>
<span class="line" id="L2218"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeFile2</span>(self: Dir, options: WriteFileOptions) WriteFileError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2219">    <span class="tok-kw">var</span> file = <span class="tok-kw">try</span> self.createFile(options.sub_path, options.flags);</span>
<span class="line" id="L2220">    <span class="tok-kw">defer</span> file.close();</span>
<span class="line" id="L2221">    <span class="tok-kw">try</span> file.writeAll(options.data);</span>
<span class="line" id="L2222">}</span>
<span class="line" id="L2223"></span>
<span class="line" id="L2224"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> AccessError = posix.AccessError;</span>
<span class="line" id="L2225"></span>
<span class="line" id="L2226"><span class="tok-comment">/// Test accessing `path`.</span></span>
<span class="line" id="L2227"><span class="tok-comment">/// `path` is UTF-8-encoded.</span></span>
<span class="line" id="L2228"><span class="tok-comment">/// Be careful of Time-Of-Check-Time-Of-Use race conditions when using this function.</span></span>
<span class="line" id="L2229"><span class="tok-comment">/// For example, instead of testing if a file exists and then opening it, just</span></span>
<span class="line" id="L2230"><span class="tok-comment">/// open it and handle the error for file not found.</span></span>
<span class="line" id="L2231"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">access</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: File.OpenFlags) AccessError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2232">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L2233">        <span class="tok-kw">const</span> sub_path_w = std.os.windows.sliceToPrefixedFileW(self.fd, sub_path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2234">            <span class="tok-kw">error</span>.AccessDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,</span>
<span class="line" id="L2235">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L2236">        };</span>
<span class="line" id="L2237">        <span class="tok-kw">return</span> self.accessW(sub_path_w.span().ptr, flags);</span>
<span class="line" id="L2238">    }</span>
<span class="line" id="L2239">    <span class="tok-kw">const</span> path_c = <span class="tok-kw">try</span> posix.toPosixPath(sub_path);</span>
<span class="line" id="L2240">    <span class="tok-kw">return</span> self.accessZ(&amp;path_c, flags);</span>
<span class="line" id="L2241">}</span>
<span class="line" id="L2242"></span>
<span class="line" id="L2243"><span class="tok-comment">/// Same as `access` except the path parameter is null-terminated.</span></span>
<span class="line" id="L2244"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accessZ</span>(self: Dir, sub_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: File.OpenFlags) AccessError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2245">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L2246">        <span class="tok-kw">const</span> sub_path_w = std.os.windows.cStrToPrefixedFileW(self.fd, sub_path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2247">            <span class="tok-kw">error</span>.AccessDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,</span>
<span class="line" id="L2248">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L2249">        };</span>
<span class="line" id="L2250">        <span class="tok-kw">return</span> self.accessW(sub_path_w.span().ptr, flags);</span>
<span class="line" id="L2251">    }</span>
<span class="line" id="L2252">    <span class="tok-kw">const</span> os_mode = <span class="tok-kw">switch</span> (flags.mode) {</span>
<span class="line" id="L2253">        .read_only =&gt; <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, posix.F_OK),</span>
<span class="line" id="L2254">        .write_only =&gt; <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, posix.W_OK),</span>
<span class="line" id="L2255">        .read_write =&gt; <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, posix.R_OK | posix.W_OK),</span>
<span class="line" id="L2256">    };</span>
<span class="line" id="L2257">    <span class="tok-kw">const</span> result = <span class="tok-kw">if</span> (fs.need_async_thread <span class="tok-kw">and</span> flags.intended_io_mode != .blocking)</span>
<span class="line" id="L2258">        std.event.Loop.instance.?.faccessatZ(self.fd, sub_path, os_mode, <span class="tok-number">0</span>)</span>
<span class="line" id="L2259">    <span class="tok-kw">else</span></span>
<span class="line" id="L2260">        posix.faccessatZ(self.fd, sub_path, os_mode, <span class="tok-number">0</span>);</span>
<span class="line" id="L2261">    <span class="tok-kw">return</span> result;</span>
<span class="line" id="L2262">}</span>
<span class="line" id="L2263"></span>
<span class="line" id="L2264"><span class="tok-comment">/// Same as `access` except asserts the target OS is Windows and the path parameter is</span></span>
<span class="line" id="L2265"><span class="tok-comment">/// * WTF-16 encoded</span></span>
<span class="line" id="L2266"><span class="tok-comment">/// * null-terminated</span></span>
<span class="line" id="L2267"><span class="tok-comment">/// * NtDll prefixed</span></span>
<span class="line" id="L2268"><span class="tok-comment">/// TODO currently this ignores `flags`.</span></span>
<span class="line" id="L2269"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accessW</span>(self: Dir, sub_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: File.OpenFlags) AccessError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2270">    _ = flags;</span>
<span class="line" id="L2271">    <span class="tok-kw">return</span> posix.faccessatW(self.fd, sub_path_w, <span class="tok-number">0</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L2272">}</span>
<span class="line" id="L2273"></span>
<span class="line" id="L2274"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CopyFileOptions = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2275">    <span class="tok-comment">/// When this is `null` the mode is copied from the source file.</span></span>
<span class="line" id="L2276">    override_mode: ?File.Mode = <span class="tok-null">null</span>,</span>
<span class="line" id="L2277">};</span>
<span class="line" id="L2278"></span>
<span class="line" id="L2279"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> PrevStatus = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L2280">    stale,</span>
<span class="line" id="L2281">    fresh,</span>
<span class="line" id="L2282">};</span>
<span class="line" id="L2283"></span>
<span class="line" id="L2284"><span class="tok-comment">/// Check the file size, mtime, and mode of `source_path` and `dest_path`. If they are equal, does nothing.</span></span>
<span class="line" id="L2285"><span class="tok-comment">/// Otherwise, atomically copies `source_path` to `dest_path`. The destination file gains the mtime,</span></span>
<span class="line" id="L2286"><span class="tok-comment">/// atime, and mode of the source file so that the next call to `updateFile` will not need a copy.</span></span>
<span class="line" id="L2287"><span class="tok-comment">/// Returns the previous status of the file before updating.</span></span>
<span class="line" id="L2288"><span class="tok-comment">/// If any of the directories do not exist for dest_path, they are created.</span></span>
<span class="line" id="L2289"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">updateFile</span>(</span>
<span class="line" id="L2290">    source_dir: Dir,</span>
<span class="line" id="L2291">    source_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2292">    dest_dir: Dir,</span>
<span class="line" id="L2293">    dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2294">    options: CopyFileOptions,</span>
<span class="line" id="L2295">) !PrevStatus {</span>
<span class="line" id="L2296">    <span class="tok-kw">var</span> src_file = <span class="tok-kw">try</span> source_dir.openFile(source_path, .{});</span>
<span class="line" id="L2297">    <span class="tok-kw">defer</span> src_file.close();</span>
<span class="line" id="L2298"></span>
<span class="line" id="L2299">    <span class="tok-kw">const</span> src_stat = <span class="tok-kw">try</span> src_file.stat();</span>
<span class="line" id="L2300">    <span class="tok-kw">const</span> actual_mode = options.override_mode <span class="tok-kw">orelse</span> src_stat.mode;</span>
<span class="line" id="L2301">    check_dest_stat: {</span>
<span class="line" id="L2302">        <span class="tok-kw">const</span> dest_stat = blk: {</span>
<span class="line" id="L2303">            <span class="tok-kw">var</span> dest_file = dest_dir.openFile(dest_path, .{}) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2304">                <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">break</span> :check_dest_stat,</span>
<span class="line" id="L2305">                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L2306">            };</span>
<span class="line" id="L2307">            <span class="tok-kw">defer</span> dest_file.close();</span>
<span class="line" id="L2308"></span>
<span class="line" id="L2309">            <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> dest_file.stat();</span>
<span class="line" id="L2310">        };</span>
<span class="line" id="L2311"></span>
<span class="line" id="L2312">        <span class="tok-kw">if</span> (src_stat.size == dest_stat.size <span class="tok-kw">and</span></span>
<span class="line" id="L2313">            src_stat.mtime == dest_stat.mtime <span class="tok-kw">and</span></span>
<span class="line" id="L2314">            actual_mode == dest_stat.mode)</span>
<span class="line" id="L2315">        {</span>
<span class="line" id="L2316">            <span class="tok-kw">return</span> PrevStatus.fresh;</span>
<span class="line" id="L2317">        }</span>
<span class="line" id="L2318">    }</span>
<span class="line" id="L2319"></span>
<span class="line" id="L2320">    <span class="tok-kw">if</span> (fs.path.dirname(dest_path)) |dirname| {</span>
<span class="line" id="L2321">        <span class="tok-kw">try</span> dest_dir.makePath(dirname);</span>
<span class="line" id="L2322">    }</span>
<span class="line" id="L2323"></span>
<span class="line" id="L2324">    <span class="tok-kw">var</span> atomic_file = <span class="tok-kw">try</span> dest_dir.atomicFile(dest_path, .{ .mode = actual_mode });</span>
<span class="line" id="L2325">    <span class="tok-kw">defer</span> atomic_file.deinit();</span>
<span class="line" id="L2326"></span>
<span class="line" id="L2327">    <span class="tok-kw">try</span> atomic_file.file.writeFileAll(src_file, .{ .in_len = src_stat.size });</span>
<span class="line" id="L2328">    <span class="tok-kw">try</span> atomic_file.file.updateTimes(src_stat.atime, src_stat.mtime);</span>
<span class="line" id="L2329">    <span class="tok-kw">try</span> atomic_file.finish();</span>
<span class="line" id="L2330">    <span class="tok-kw">return</span> PrevStatus.stale;</span>
<span class="line" id="L2331">}</span>
<span class="line" id="L2332"></span>
<span class="line" id="L2333"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CopyFileError = File.OpenError || File.StatError ||</span>
<span class="line" id="L2334">    AtomicFile.InitError || CopyFileRawError || AtomicFile.FinishError;</span>
<span class="line" id="L2335"></span>
<span class="line" id="L2336"><span class="tok-comment">/// Guaranteed to be atomic.</span></span>
<span class="line" id="L2337"><span class="tok-comment">/// On Linux, until https://patchwork.kernel.org/patch/9636735/ is merged and readily available,</span></span>
<span class="line" id="L2338"><span class="tok-comment">/// there is a possibility of power loss or application termination leaving temporary files present</span></span>
<span class="line" id="L2339"><span class="tok-comment">/// in the same directory as dest_path.</span></span>
<span class="line" id="L2340"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copyFile</span>(</span>
<span class="line" id="L2341">    source_dir: Dir,</span>
<span class="line" id="L2342">    source_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2343">    dest_dir: Dir,</span>
<span class="line" id="L2344">    dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2345">    options: CopyFileOptions,</span>
<span class="line" id="L2346">) CopyFileError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2347">    <span class="tok-kw">var</span> in_file = <span class="tok-kw">try</span> source_dir.openFile(source_path, .{});</span>
<span class="line" id="L2348">    <span class="tok-kw">defer</span> in_file.close();</span>
<span class="line" id="L2349"></span>
<span class="line" id="L2350">    <span class="tok-kw">var</span> size: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L2351">    <span class="tok-kw">const</span> mode = options.override_mode <span class="tok-kw">orelse</span> blk: {</span>
<span class="line" id="L2352">        <span class="tok-kw">const</span> st = <span class="tok-kw">try</span> in_file.stat();</span>
<span class="line" id="L2353">        size = st.size;</span>
<span class="line" id="L2354">        <span class="tok-kw">break</span> :blk st.mode;</span>
<span class="line" id="L2355">    };</span>
<span class="line" id="L2356"></span>
<span class="line" id="L2357">    <span class="tok-kw">var</span> atomic_file = <span class="tok-kw">try</span> dest_dir.atomicFile(dest_path, .{ .mode = mode });</span>
<span class="line" id="L2358">    <span class="tok-kw">defer</span> atomic_file.deinit();</span>
<span class="line" id="L2359"></span>
<span class="line" id="L2360">    <span class="tok-kw">try</span> copy_file(in_file.handle, atomic_file.file.handle, size);</span>
<span class="line" id="L2361">    <span class="tok-kw">try</span> atomic_file.finish();</span>
<span class="line" id="L2362">}</span>
<span class="line" id="L2363"></span>
<span class="line" id="L2364"><span class="tok-kw">const</span> CopyFileRawError = <span class="tok-kw">error</span>{SystemResources} || posix.CopyFileRangeError || posix.SendFileError;</span>
<span class="line" id="L2365"></span>
<span class="line" id="L2366"><span class="tok-comment">// Transfer all the data between two file descriptors in the most efficient way.</span>
</span>
<span class="line" id="L2367"><span class="tok-comment">// The copy starts at offset 0, the initial offsets are preserved.</span>
</span>
<span class="line" id="L2368"><span class="tok-comment">// No metadata is transferred over.</span>
</span>
<span class="line" id="L2369"><span class="tok-kw">fn</span> <span class="tok-fn">copy_file</span>(fd_in: posix.fd_t, fd_out: posix.fd_t, maybe_size: ?<span class="tok-type">u64</span>) CopyFileRawError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2370">    <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> builtin.target.isDarwin()) {</span>
<span class="line" id="L2371">        <span class="tok-kw">const</span> rc = posix.system.fcopyfile(fd_in, fd_out, <span class="tok-null">null</span>, posix.system.COPYFILE_DATA);</span>
<span class="line" id="L2372">        <span class="tok-kw">switch</span> (posix.errno(rc)) {</span>
<span class="line" id="L2373">            .SUCCESS =&gt; <span class="tok-kw">return</span>,</span>
<span class="line" id="L2374">            .INVAL =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L2375">            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L2376">            <span class="tok-comment">// The source file is not a directory, symbolic link, or regular file.</span>
</span>
<span class="line" id="L2377">            <span class="tok-comment">// Try with the fallback path before giving up.</span>
</span>
<span class="line" id="L2378">            .OPNOTSUPP =&gt; {},</span>
<span class="line" id="L2379">            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> posix.unexpectedErrno(err),</span>
<span class="line" id="L2380">        }</span>
<span class="line" id="L2381">    }</span>
<span class="line" id="L2382"></span>
<span class="line" id="L2383">    <span class="tok-kw">if</span> (builtin.os.tag == .linux) {</span>
<span class="line" id="L2384">        <span class="tok-comment">// Try copy_file_range first as that works at the FS level and is the</span>
</span>
<span class="line" id="L2385">        <span class="tok-comment">// most efficient method (if available).</span>
</span>
<span class="line" id="L2386">        <span class="tok-kw">var</span> offset: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2387">        cfr_loop: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L2388">            <span class="tok-comment">// The kernel checks the u64 value `offset+count` for overflow, use</span>
</span>
<span class="line" id="L2389">            <span class="tok-comment">// a 32 bit value so that the syscall won't return EINVAL except for</span>
</span>
<span class="line" id="L2390">            <span class="tok-comment">// impossibly large files (&gt; 2^64-1 - 2^32-1).</span>
</span>
<span class="line" id="L2391">            <span class="tok-kw">const</span> amt = <span class="tok-kw">try</span> posix.copy_file_range(fd_in, offset, fd_out, offset, std.math.maxInt(<span class="tok-type">u32</span>), <span class="tok-number">0</span>);</span>
<span class="line" id="L2392">            <span class="tok-comment">// Terminate as soon as we have copied size bytes or no bytes</span>
</span>
<span class="line" id="L2393">            <span class="tok-kw">if</span> (maybe_size) |s| {</span>
<span class="line" id="L2394">                <span class="tok-kw">if</span> (s == amt) <span class="tok-kw">break</span> :cfr_loop;</span>
<span class="line" id="L2395">            }</span>
<span class="line" id="L2396">            <span class="tok-kw">if</span> (amt == <span class="tok-number">0</span>) <span class="tok-kw">break</span> :cfr_loop;</span>
<span class="line" id="L2397">            offset += amt;</span>
<span class="line" id="L2398">        }</span>
<span class="line" id="L2399">        <span class="tok-kw">return</span>;</span>
<span class="line" id="L2400">    }</span>
<span class="line" id="L2401"></span>
<span class="line" id="L2402">    <span class="tok-comment">// Sendfile is a zero-copy mechanism iff the OS supports it, otherwise the</span>
</span>
<span class="line" id="L2403">    <span class="tok-comment">// fallback code will copy the contents chunk by chunk.</span>
</span>
<span class="line" id="L2404">    <span class="tok-kw">const</span> empty_iovec = [<span class="tok-number">0</span>]posix.iovec_const{};</span>
<span class="line" id="L2405">    <span class="tok-kw">var</span> offset: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2406">    sendfile_loop: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L2407">        <span class="tok-kw">const</span> amt = <span class="tok-kw">try</span> posix.sendfile(fd_out, fd_in, offset, <span class="tok-number">0</span>, &amp;empty_iovec, &amp;empty_iovec, <span class="tok-number">0</span>);</span>
<span class="line" id="L2408">        <span class="tok-comment">// Terminate as soon as we have copied size bytes or no bytes</span>
</span>
<span class="line" id="L2409">        <span class="tok-kw">if</span> (maybe_size) |s| {</span>
<span class="line" id="L2410">            <span class="tok-kw">if</span> (s == amt) <span class="tok-kw">break</span> :sendfile_loop;</span>
<span class="line" id="L2411">        }</span>
<span class="line" id="L2412">        <span class="tok-kw">if</span> (amt == <span class="tok-number">0</span>) <span class="tok-kw">break</span> :sendfile_loop;</span>
<span class="line" id="L2413">        offset += amt;</span>
<span class="line" id="L2414">    }</span>
<span class="line" id="L2415">}</span>
<span class="line" id="L2416"></span>
<span class="line" id="L2417"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> AtomicFileOptions = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2418">    mode: File.Mode = File.default_mode,</span>
<span class="line" id="L2419">};</span>
<span class="line" id="L2420"></span>
<span class="line" id="L2421"><span class="tok-comment">/// Directly access the `.file` field, and then call `AtomicFile.finish`</span></span>
<span class="line" id="L2422"><span class="tok-comment">/// to atomically replace `dest_path` with contents.</span></span>
<span class="line" id="L2423"><span class="tok-comment">/// Always call `AtomicFile.deinit` to clean up, regardless of whether `AtomicFile.finish` succeeded.</span></span>
<span class="line" id="L2424"><span class="tok-comment">/// `dest_path` must remain valid until `AtomicFile.deinit` is called.</span></span>
<span class="line" id="L2425"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">atomicFile</span>(self: Dir, dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, options: AtomicFileOptions) !AtomicFile {</span>
<span class="line" id="L2426">    <span class="tok-kw">if</span> (fs.path.dirname(dest_path)) |dirname| {</span>
<span class="line" id="L2427">        <span class="tok-kw">const</span> dir = <span class="tok-kw">try</span> self.openDir(dirname, .{});</span>
<span class="line" id="L2428">        <span class="tok-kw">return</span> AtomicFile.init(fs.path.basename(dest_path), options.mode, dir, <span class="tok-null">true</span>);</span>
<span class="line" id="L2429">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2430">        <span class="tok-kw">return</span> AtomicFile.init(dest_path, options.mode, self, <span class="tok-null">false</span>);</span>
<span class="line" id="L2431">    }</span>
<span class="line" id="L2432">}</span>
<span class="line" id="L2433"></span>
<span class="line" id="L2434"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Stat = File.Stat;</span>
<span class="line" id="L2435"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> StatError = File.StatError;</span>
<span class="line" id="L2436"></span>
<span class="line" id="L2437"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stat</span>(self: Dir) StatError!Stat {</span>
<span class="line" id="L2438">    <span class="tok-kw">const</span> file: File = .{</span>
<span class="line" id="L2439">        .handle = self.fd,</span>
<span class="line" id="L2440">        .capable_io_mode = .blocking,</span>
<span class="line" id="L2441">    };</span>
<span class="line" id="L2442">    <span class="tok-kw">return</span> file.stat();</span>
<span class="line" id="L2443">}</span>
<span class="line" id="L2444"></span>
<span class="line" id="L2445"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> StatFileError = File.OpenError || File.StatError || posix.FStatAtError;</span>
<span class="line" id="L2446"></span>
<span class="line" id="L2447"><span class="tok-comment">/// Returns metadata for a file inside the directory.</span></span>
<span class="line" id="L2448"><span class="tok-comment">///</span></span>
<span class="line" id="L2449"><span class="tok-comment">/// On Windows, this requires three syscalls. On other operating systems, it</span></span>
<span class="line" id="L2450"><span class="tok-comment">/// only takes one.</span></span>
<span class="line" id="L2451"><span class="tok-comment">///</span></span>
<span class="line" id="L2452"><span class="tok-comment">/// Symlinks are followed.</span></span>
<span class="line" id="L2453"><span class="tok-comment">///</span></span>
<span class="line" id="L2454"><span class="tok-comment">/// `sub_path` may be absolute, in which case `self` is ignored.</span></span>
<span class="line" id="L2455"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">statFile</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) StatFileError!Stat {</span>
<span class="line" id="L2456">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L2457">        <span class="tok-kw">var</span> file = <span class="tok-kw">try</span> self.openFile(sub_path, .{});</span>
<span class="line" id="L2458">        <span class="tok-kw">defer</span> file.close();</span>
<span class="line" id="L2459">        <span class="tok-kw">return</span> file.stat();</span>
<span class="line" id="L2460">    }</span>
<span class="line" id="L2461">    <span class="tok-kw">if</span> (builtin.os.tag == .wasi <span class="tok-kw">and</span> !builtin.link_libc) {</span>
<span class="line" id="L2462">        <span class="tok-kw">const</span> st = <span class="tok-kw">try</span> posix.fstatatWasi(self.fd, sub_path, posix.wasi.LOOKUP_SYMLINK_FOLLOW);</span>
<span class="line" id="L2463">        <span class="tok-kw">return</span> Stat.fromSystem(st);</span>
<span class="line" id="L2464">    }</span>
<span class="line" id="L2465">    <span class="tok-kw">const</span> st = <span class="tok-kw">try</span> posix.fstatat(self.fd, sub_path, <span class="tok-number">0</span>);</span>
<span class="line" id="L2466">    <span class="tok-kw">return</span> Stat.fromSystem(st);</span>
<span class="line" id="L2467">}</span>
<span class="line" id="L2468"></span>
<span class="line" id="L2469"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ChmodError = File.ChmodError;</span>
<span class="line" id="L2470"></span>
<span class="line" id="L2471"><span class="tok-comment">/// Changes the mode of the directory.</span></span>
<span class="line" id="L2472"><span class="tok-comment">/// The process must have the correct privileges in order to do this</span></span>
<span class="line" id="L2473"><span class="tok-comment">/// successfully, or must have the effective user ID matching the owner</span></span>
<span class="line" id="L2474"><span class="tok-comment">/// of the directory. Additionally, the directory must have been opened</span></span>
<span class="line" id="L2475"><span class="tok-comment">/// with `OpenDirOptions{ .iterate = true }`.</span></span>
<span class="line" id="L2476"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chmod</span>(self: Dir, new_mode: File.Mode) ChmodError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2477">    <span class="tok-kw">const</span> file: File = .{</span>
<span class="line" id="L2478">        .handle = self.fd,</span>
<span class="line" id="L2479">        .capable_io_mode = .blocking,</span>
<span class="line" id="L2480">    };</span>
<span class="line" id="L2481">    <span class="tok-kw">try</span> file.chmod(new_mode);</span>
<span class="line" id="L2482">}</span>
<span class="line" id="L2483"></span>
<span class="line" id="L2484"><span class="tok-comment">/// Changes the owner and group of the directory.</span></span>
<span class="line" id="L2485"><span class="tok-comment">/// The process must have the correct privileges in order to do this</span></span>
<span class="line" id="L2486"><span class="tok-comment">/// successfully. The group may be changed by the owner of the directory to</span></span>
<span class="line" id="L2487"><span class="tok-comment">/// any group of which the owner is a member. Additionally, the directory</span></span>
<span class="line" id="L2488"><span class="tok-comment">/// must have been opened with `OpenDirOptions{ .iterate = true }`. If the</span></span>
<span class="line" id="L2489"><span class="tok-comment">/// owner or group is specified as `null`, the ID is not changed.</span></span>
<span class="line" id="L2490"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chown</span>(self: Dir, owner: ?File.Uid, group: ?File.Gid) ChownError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2491">    <span class="tok-kw">const</span> file: File = .{</span>
<span class="line" id="L2492">        .handle = self.fd,</span>
<span class="line" id="L2493">        .capable_io_mode = .blocking,</span>
<span class="line" id="L2494">    };</span>
<span class="line" id="L2495">    <span class="tok-kw">try</span> file.chown(owner, group);</span>
<span class="line" id="L2496">}</span>
<span class="line" id="L2497"></span>
<span class="line" id="L2498"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ChownError = File.ChownError;</span>
<span class="line" id="L2499"></span>
<span class="line" id="L2500"><span class="tok-kw">const</span> Permissions = File.Permissions;</span>
<span class="line" id="L2501"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SetPermissionsError = File.SetPermissionsError;</span>
<span class="line" id="L2502"></span>
<span class="line" id="L2503"><span class="tok-comment">/// Sets permissions according to the provided `Permissions` struct.</span></span>
<span class="line" id="L2504"><span class="tok-comment">/// This method is *NOT* available on WASI</span></span>
<span class="line" id="L2505"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setPermissions</span>(self: Dir, permissions: Permissions) SetPermissionsError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2506">    <span class="tok-kw">const</span> file: File = .{</span>
<span class="line" id="L2507">        .handle = self.fd,</span>
<span class="line" id="L2508">        .capable_io_mode = .blocking,</span>
<span class="line" id="L2509">    };</span>
<span class="line" id="L2510">    <span class="tok-kw">try</span> file.setPermissions(permissions);</span>
<span class="line" id="L2511">}</span>
<span class="line" id="L2512"></span>
<span class="line" id="L2513"><span class="tok-kw">const</span> Metadata = File.Metadata;</span>
<span class="line" id="L2514"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> MetadataError = File.MetadataError;</span>
<span class="line" id="L2515"></span>
<span class="line" id="L2516"><span class="tok-comment">/// Returns a `Metadata` struct, representing the permissions on the directory</span></span>
<span class="line" id="L2517"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadata</span>(self: Dir) MetadataError!Metadata {</span>
<span class="line" id="L2518">    <span class="tok-kw">const</span> file: File = .{</span>
<span class="line" id="L2519">        .handle = self.fd,</span>
<span class="line" id="L2520">        .capable_io_mode = .blocking,</span>
<span class="line" id="L2521">    };</span>
<span class="line" id="L2522">    <span class="tok-kw">return</span> <span class="tok-kw">try</span> file.metadata();</span>
<span class="line" id="L2523">}</span>
<span class="line" id="L2524"></span>
<span class="line" id="L2525"><span class="tok-kw">const</span> Dir = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L2526"><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);</span>
<span class="line" id="L2527"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;../std.zig&quot;</span>);</span>
<span class="line" id="L2528"><span class="tok-kw">const</span> File = std.fs.File;</span>
<span class="line" id="L2529"><span class="tok-kw">const</span> AtomicFile = std.fs.AtomicFile;</span>
<span class="line" id="L2530"><span class="tok-comment">// https://github.com/ziglang/zig/issues/5019</span>
</span>
<span class="line" id="L2531"><span class="tok-kw">const</span> posix = std.os;</span>
<span class="line" id="L2532"><span class="tok-kw">const</span> mem = std.mem;</span>
<span class="line" id="L2533"><span class="tok-kw">const</span> fs = std.fs;</span>
<span class="line" id="L2534"><span class="tok-kw">const</span> Allocator = std.mem.Allocator;</span>
<span class="line" id="L2535"></span>
</code></pre></body>
</html>