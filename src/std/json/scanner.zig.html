<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>json/scanner.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAPNJREFUeNpi/P//PwMlgOXHUjly9E0G4hwgZmQiQZMqEK8H4v9QzUEgQSaoADK+zhH9iAGL+C0gDoAaNg9mGLoLfgA1awK9hS9gzgJxA9RQBmQDrgMxJzRMGKE4HYj/Ial5A8QmQLwCJoBsgBYW2+TR1ChDaWt4LOBxKsi/VUh8XiD+gq4IVyzwQAMJBoKwacZlAB8Qf0bi96IZhtOAe1D6LpqaEiz6rmEzQAeIzwGxCJpieFqApo/vQKyJboAaEBsAsSEupwI1MwKjGBTVHOhegMX5UajYRqiBjMgYmj400cVh0XgTiKdC0zhJgJHS7AwQYABm9EAdCKrEfAAAAABJRU5ErkJggg=="/>
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-comment">// Notes on standards compliance: https://datatracker.ietf.org/doc/html/rfc8259</span>
</span>
<span class="line" id="L2"><span class="tok-comment">// * RFC 8259 requires JSON documents be valid UTF-8,</span>
</span>
<span class="line" id="L3"><span class="tok-comment">//   but makes an allowance for systems that are &quot;part of a closed ecosystem&quot;.</span>
</span>
<span class="line" id="L4"><span class="tok-comment">//   I have no idea what that's supposed to mean in the context of a standard specification.</span>
</span>
<span class="line" id="L5"><span class="tok-comment">//   This implementation requires inputs to be valid UTF-8.</span>
</span>
<span class="line" id="L6"><span class="tok-comment">// * RFC 8259 contradicts itself regarding whether lowercase is allowed in \u hex digits,</span>
</span>
<span class="line" id="L7"><span class="tok-comment">//   but this is probably a bug in the spec, and it's clear that lowercase is meant to be allowed.</span>
</span>
<span class="line" id="L8"><span class="tok-comment">//   (RFC 5234 defines HEXDIG to only allow uppercase.)</span>
</span>
<span class="line" id="L9"><span class="tok-comment">// * When RFC 8259 refers to a &quot;character&quot;, I assume they really mean a &quot;Unicode scalar value&quot;.</span>
</span>
<span class="line" id="L10"><span class="tok-comment">//   See http://www.unicode.org/glossary/#unicode_scalar_value .</span>
</span>
<span class="line" id="L11"><span class="tok-comment">// * RFC 8259 doesn't explicitly disallow unpaired surrogate halves in \u escape sequences,</span>
</span>
<span class="line" id="L12"><span class="tok-comment">//   but vaguely implies that \u escapes are for encoding Unicode &quot;characters&quot; (i.e. Unicode scalar values?),</span>
</span>
<span class="line" id="L13"><span class="tok-comment">//   which would mean that unpaired surrogate halves are forbidden.</span>
</span>
<span class="line" id="L14"><span class="tok-comment">//   By contrast ECMA-404 (a competing(/compatible?) JSON standard, which JavaScript's JSON.parse() conforms to)</span>
</span>
<span class="line" id="L15"><span class="tok-comment">//   explicitly allows unpaired surrogate halves.</span>
</span>
<span class="line" id="L16"><span class="tok-comment">//   This implementation forbids unpaired surrogate halves in \u sequences.</span>
</span>
<span class="line" id="L17"><span class="tok-comment">//   If a high surrogate half appears in a \u sequence,</span>
</span>
<span class="line" id="L18"><span class="tok-comment">//   then a low surrogate half must immediately follow in \u notation.</span>
</span>
<span class="line" id="L19"><span class="tok-comment">// * RFC 8259 allows implementations to &quot;accept non-JSON forms or extensions&quot;.</span>
</span>
<span class="line" id="L20"><span class="tok-comment">//   This implementation does not accept any of that.</span>
</span>
<span class="line" id="L21"><span class="tok-comment">// * RFC 8259 allows implementations to put limits on &quot;the size of texts&quot;,</span>
</span>
<span class="line" id="L22"><span class="tok-comment">//   &quot;the maximum depth of nesting&quot;, &quot;the range and precision of numbers&quot;,</span>
</span>
<span class="line" id="L23"><span class="tok-comment">//   and &quot;the length and character contents of strings&quot;.</span>
</span>
<span class="line" id="L24"><span class="tok-comment">//   This low-level implementation does not limit these,</span>
</span>
<span class="line" id="L25"><span class="tok-comment">//   except where noted above, and except that nesting depth requires memory allocation.</span>
</span>
<span class="line" id="L26"><span class="tok-comment">//   Note that this low-level API does not interpret numbers numerically,</span>
</span>
<span class="line" id="L27"><span class="tok-comment">//   but simply emits their source form for some higher level code to make sense of.</span>
</span>
<span class="line" id="L28"><span class="tok-comment">// * This low-level implementation allows duplicate object keys,</span>
</span>
<span class="line" id="L29"><span class="tok-comment">//   and key/value pairs are emitted in the order they appear in the input.</span>
</span>
<span class="line" id="L30"></span>
<span class="line" id="L31"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);</span>
<span class="line" id="L32"></span>
<span class="line" id="L33"><span class="tok-kw">const</span> Allocator = std.mem.Allocator;</span>
<span class="line" id="L34"><span class="tok-kw">const</span> ArrayList = std.ArrayList;</span>
<span class="line" id="L35"><span class="tok-kw">const</span> assert = std.debug.assert;</span>
<span class="line" id="L36"></span>
<span class="line" id="L37"><span class="tok-comment">/// Scan the input and check for malformed JSON.</span></span>
<span class="line" id="L38"><span class="tok-comment">/// On `SyntaxError` or `UnexpectedEndOfInput`, returns `false`.</span></span>
<span class="line" id="L39"><span class="tok-comment">/// Returns any errors from the allocator as-is, which is unlikely,</span></span>
<span class="line" id="L40"><span class="tok-comment">/// but can be caused by extreme nesting depth in the input.</span></span>
<span class="line" id="L41"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">validate</span>(allocator: Allocator, s: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) Allocator.Error!<span class="tok-type">bool</span> {</span>
<span class="line" id="L42">    <span class="tok-kw">var</span> scanner = Scanner.initCompleteInput(allocator, s);</span>
<span class="line" id="L43">    <span class="tok-kw">defer</span> scanner.deinit();</span>
<span class="line" id="L44"></span>
<span class="line" id="L45">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L46">        <span class="tok-kw">const</span> token = scanner.next() <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L47">            <span class="tok-kw">error</span>.SyntaxError, <span class="tok-kw">error</span>.UnexpectedEndOfInput =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,</span>
<span class="line" id="L48">            <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,</span>
<span class="line" id="L49">            <span class="tok-kw">error</span>.BufferUnderrun =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L50">        };</span>
<span class="line" id="L51">        <span class="tok-kw">if</span> (token == .end_of_document) <span class="tok-kw">break</span>;</span>
<span class="line" id="L52">    }</span>
<span class="line" id="L53"></span>
<span class="line" id="L54">    <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L55">}</span>
<span class="line" id="L56"></span>
<span class="line" id="L57"><span class="tok-comment">/// The parsing errors are divided into two categories:</span></span>
<span class="line" id="L58"><span class="tok-comment">///  * `SyntaxError` is for clearly malformed JSON documents,</span></span>
<span class="line" id="L59"><span class="tok-comment">///    such as giving an input document that isn't JSON at all.</span></span>
<span class="line" id="L60"><span class="tok-comment">///  * `UnexpectedEndOfInput` is for signaling that everything's been</span></span>
<span class="line" id="L61"><span class="tok-comment">///    valid so far, but the input appears to be truncated for some reason.</span></span>
<span class="line" id="L62"><span class="tok-comment">/// Note that a completely empty (or whitespace-only) input will give `UnexpectedEndOfInput`.</span></span>
<span class="line" id="L63"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <span class="tok-kw">error</span>{ SyntaxError, UnexpectedEndOfInput };</span>
<span class="line" id="L64"></span>
<span class="line" id="L65"><span class="tok-comment">/// Calls `std.json.Reader` with `std.json.default_buffer_size`.</span></span>
<span class="line" id="L66"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reader</span>(allocator: Allocator, io_reader: <span class="tok-kw">anytype</span>) Reader(default_buffer_size, <span class="tok-builtin">@TypeOf</span>(io_reader)) {</span>
<span class="line" id="L67">    <span class="tok-kw">return</span> Reader(default_buffer_size, <span class="tok-builtin">@TypeOf</span>(io_reader)).init(allocator, io_reader);</span>
<span class="line" id="L68">}</span>
<span class="line" id="L69"><span class="tok-comment">/// Used by `json.reader`.</span></span>
<span class="line" id="L70"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> default_buffer_size = <span class="tok-number">0x1000</span>;</span>
<span class="line" id="L71"></span>
<span class="line" id="L72"><span class="tok-comment">/// The tokens emitted by `std.json.Scanner` and `std.json.Reader` `.next*()` functions follow this grammar:</span></span>
<span class="line" id="L73"><span class="tok-comment">/// ```</span></span>
<span class="line" id="L74"><span class="tok-comment">///  &lt;document&gt; = &lt;value&gt; .end_of_document</span></span>
<span class="line" id="L75"><span class="tok-comment">///  &lt;value&gt; =</span></span>
<span class="line" id="L76"><span class="tok-comment">///    | &lt;object&gt;</span></span>
<span class="line" id="L77"><span class="tok-comment">///    | &lt;array&gt;</span></span>
<span class="line" id="L78"><span class="tok-comment">///    | &lt;number&gt;</span></span>
<span class="line" id="L79"><span class="tok-comment">///    | &lt;string&gt;</span></span>
<span class="line" id="L80"><span class="tok-comment">///    | .true</span></span>
<span class="line" id="L81"><span class="tok-comment">///    | .false</span></span>
<span class="line" id="L82"><span class="tok-comment">///    | .null</span></span>
<span class="line" id="L83"><span class="tok-comment">///  &lt;object&gt; = .object_begin ( &lt;string&gt; &lt;value&gt; )* .object_end</span></span>
<span class="line" id="L84"><span class="tok-comment">///  &lt;array&gt; = .array_begin ( &lt;value&gt; )* .array_end</span></span>
<span class="line" id="L85"><span class="tok-comment">///  &lt;number&gt; = &lt;It depends. See below.&gt;</span></span>
<span class="line" id="L86"><span class="tok-comment">///  &lt;string&gt; = &lt;It depends. See below.&gt;</span></span>
<span class="line" id="L87"><span class="tok-comment">/// ```</span></span>
<span class="line" id="L88"><span class="tok-comment">///</span></span>
<span class="line" id="L89"><span class="tok-comment">/// What you get for `&lt;number&gt;` and `&lt;string&gt;` values depends on which `next*()` method you call:</span></span>
<span class="line" id="L90"><span class="tok-comment">///</span></span>
<span class="line" id="L91"><span class="tok-comment">/// ```</span></span>
<span class="line" id="L92"><span class="tok-comment">/// next():</span></span>
<span class="line" id="L93"><span class="tok-comment">///  &lt;number&gt; = ( .partial_number )* .number</span></span>
<span class="line" id="L94"><span class="tok-comment">///  &lt;string&gt; = ( &lt;partial_string&gt; )* .string</span></span>
<span class="line" id="L95"><span class="tok-comment">///  &lt;partial_string&gt; =</span></span>
<span class="line" id="L96"><span class="tok-comment">///    | .partial_string</span></span>
<span class="line" id="L97"><span class="tok-comment">///    | .partial_string_escaped_1</span></span>
<span class="line" id="L98"><span class="tok-comment">///    | .partial_string_escaped_2</span></span>
<span class="line" id="L99"><span class="tok-comment">///    | .partial_string_escaped_3</span></span>
<span class="line" id="L100"><span class="tok-comment">///    | .partial_string_escaped_4</span></span>
<span class="line" id="L101"><span class="tok-comment">///</span></span>
<span class="line" id="L102"><span class="tok-comment">/// nextAlloc*(..., .alloc_always):</span></span>
<span class="line" id="L103"><span class="tok-comment">///  &lt;number&gt; = .allocated_number</span></span>
<span class="line" id="L104"><span class="tok-comment">///  &lt;string&gt; = .allocated_string</span></span>
<span class="line" id="L105"><span class="tok-comment">///</span></span>
<span class="line" id="L106"><span class="tok-comment">/// nextAlloc*(..., .alloc_if_needed):</span></span>
<span class="line" id="L107"><span class="tok-comment">///  &lt;number&gt; =</span></span>
<span class="line" id="L108"><span class="tok-comment">///    | .number</span></span>
<span class="line" id="L109"><span class="tok-comment">///    | .allocated_number</span></span>
<span class="line" id="L110"><span class="tok-comment">///  &lt;string&gt; =</span></span>
<span class="line" id="L111"><span class="tok-comment">///    | .string</span></span>
<span class="line" id="L112"><span class="tok-comment">///    | .allocated_string</span></span>
<span class="line" id="L113"><span class="tok-comment">/// ```</span></span>
<span class="line" id="L114"><span class="tok-comment">///</span></span>
<span class="line" id="L115"><span class="tok-comment">/// For all tokens with a `[]const u8`, `[]u8`, or `[n]u8` payload, the payload represents the content of the value.</span></span>
<span class="line" id="L116"><span class="tok-comment">/// For number values, this is the representation of the number exactly as it appears in the input.</span></span>
<span class="line" id="L117"><span class="tok-comment">/// For strings, this is the content of the string after resolving escape sequences.</span></span>
<span class="line" id="L118"><span class="tok-comment">///</span></span>
<span class="line" id="L119"><span class="tok-comment">/// For `.allocated_number` and `.allocated_string`, the `[]u8` payloads are allocations made with the given allocator.</span></span>
<span class="line" id="L120"><span class="tok-comment">/// You are responsible for managing that memory. `json.Reader.deinit()` does *not* free those allocations.</span></span>
<span class="line" id="L121"><span class="tok-comment">///</span></span>
<span class="line" id="L122"><span class="tok-comment">/// The `.partial_*` tokens indicate that a value spans multiple input buffers or that a string contains escape sequences.</span></span>
<span class="line" id="L123"><span class="tok-comment">/// To get a complete value in memory, you need to concatenate the values yourself.</span></span>
<span class="line" id="L124"><span class="tok-comment">/// Calling `nextAlloc*()` does this for you, and returns an `.allocated_*` token with the result.</span></span>
<span class="line" id="L125"><span class="tok-comment">///</span></span>
<span class="line" id="L126"><span class="tok-comment">/// For tokens with a `[]const u8` payload, the payload is a slice into the current input buffer.</span></span>
<span class="line" id="L127"><span class="tok-comment">/// The memory may become undefined during the next call to `json.Scanner.feedInput()`</span></span>
<span class="line" id="L128"><span class="tok-comment">/// or any `json.Reader` method whose return error set includes `json.Error`.</span></span>
<span class="line" id="L129"><span class="tok-comment">/// To keep the value persistently, it recommended to make a copy or to use `.alloc_always`,</span></span>
<span class="line" id="L130"><span class="tok-comment">/// which makes a copy for you.</span></span>
<span class="line" id="L131"><span class="tok-comment">///</span></span>
<span class="line" id="L132"><span class="tok-comment">/// Note that `.number` and `.string` tokens that follow `.partial_*` tokens may have `0` length to indicate that</span></span>
<span class="line" id="L133"><span class="tok-comment">/// the previously partial value is completed with no additional bytes.</span></span>
<span class="line" id="L134"><span class="tok-comment">/// (This can happen when the break between input buffers happens to land on the exact end of a value. E.g. `&quot;[1234&quot;`, `&quot;]&quot;`.)</span></span>
<span class="line" id="L135"><span class="tok-comment">/// `.partial_*` tokens never have `0` length.</span></span>
<span class="line" id="L136"><span class="tok-comment">///</span></span>
<span class="line" id="L137"><span class="tok-comment">/// The recommended strategy for using the different `next*()` methods is something like this:</span></span>
<span class="line" id="L138"><span class="tok-comment">///</span></span>
<span class="line" id="L139"><span class="tok-comment">/// When you're expecting an object key, use `.alloc_if_needed`.</span></span>
<span class="line" id="L140"><span class="tok-comment">/// You often don't need a copy of the key string to persist; you might just check which field it is.</span></span>
<span class="line" id="L141"><span class="tok-comment">/// In the case that the key happens to require an allocation, free it immediately after checking it.</span></span>
<span class="line" id="L142"><span class="tok-comment">///</span></span>
<span class="line" id="L143"><span class="tok-comment">/// When you're expecting a meaningful string value (such as on the right of a `:`),</span></span>
<span class="line" id="L144"><span class="tok-comment">/// use `.alloc_always` in order to keep the value valid throughout parsing the rest of the document.</span></span>
<span class="line" id="L145"><span class="tok-comment">///</span></span>
<span class="line" id="L146"><span class="tok-comment">/// When you're expecting a number value, use `.alloc_if_needed`.</span></span>
<span class="line" id="L147"><span class="tok-comment">/// You're probably going to be parsing the string representation of the number into a numeric representation,</span></span>
<span class="line" id="L148"><span class="tok-comment">/// so you need the complete string representation only temporarily.</span></span>
<span class="line" id="L149"><span class="tok-comment">///</span></span>
<span class="line" id="L150"><span class="tok-comment">/// When you're skipping an unrecognized value, use `skipValue()`.</span></span>
<span class="line" id="L151"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Token = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L152">    object_begin,</span>
<span class="line" id="L153">    object_end,</span>
<span class="line" id="L154">    array_begin,</span>
<span class="line" id="L155">    array_end,</span>
<span class="line" id="L156"></span>
<span class="line" id="L157">    <span class="tok-null">true</span>,</span>
<span class="line" id="L158">    <span class="tok-null">false</span>,</span>
<span class="line" id="L159">    <span class="tok-null">null</span>,</span>
<span class="line" id="L160"></span>
<span class="line" id="L161">    number: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L162">    partial_number: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L163">    allocated_number: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L164"></span>
<span class="line" id="L165">    string: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L166">    partial_string: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L167">    partial_string_escaped_1: [<span class="tok-number">1</span>]<span class="tok-type">u8</span>,</span>
<span class="line" id="L168">    partial_string_escaped_2: [<span class="tok-number">2</span>]<span class="tok-type">u8</span>,</span>
<span class="line" id="L169">    partial_string_escaped_3: [<span class="tok-number">3</span>]<span class="tok-type">u8</span>,</span>
<span class="line" id="L170">    partial_string_escaped_4: [<span class="tok-number">4</span>]<span class="tok-type">u8</span>,</span>
<span class="line" id="L171">    allocated_string: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L172"></span>
<span class="line" id="L173">    end_of_document,</span>
<span class="line" id="L174">};</span>
<span class="line" id="L175"></span>
<span class="line" id="L176"><span class="tok-comment">/// This is only used in `peekNextTokenType()` and gives a categorization based on the first byte of the next token that will be emitted from a `next*()` call.</span></span>
<span class="line" id="L177"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> TokenType = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L178">    object_begin,</span>
<span class="line" id="L179">    object_end,</span>
<span class="line" id="L180">    array_begin,</span>
<span class="line" id="L181">    array_end,</span>
<span class="line" id="L182">    <span class="tok-null">true</span>,</span>
<span class="line" id="L183">    <span class="tok-null">false</span>,</span>
<span class="line" id="L184">    <span class="tok-null">null</span>,</span>
<span class="line" id="L185">    number,</span>
<span class="line" id="L186">    string,</span>
<span class="line" id="L187">    end_of_document,</span>
<span class="line" id="L188">};</span>
<span class="line" id="L189"></span>
<span class="line" id="L190"><span class="tok-comment">/// To enable diagnostics, declare `var diagnostics = Diagnostics{};` then call `source.enableDiagnostics(&amp;diagnostics);`</span></span>
<span class="line" id="L191"><span class="tok-comment">/// where `source` is either a `std.json.Reader` or a `std.json.Scanner` that has just been initialized.</span></span>
<span class="line" id="L192"><span class="tok-comment">/// At any time, notably just after an error, call `getLine()`, `getColumn()`, and/or `getByteOffset()`</span></span>
<span class="line" id="L193"><span class="tok-comment">/// to get meaningful information from this.</span></span>
<span class="line" id="L194"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Diagnostics = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L195">    line_number: <span class="tok-type">u64</span> = <span class="tok-number">1</span>,</span>
<span class="line" id="L196">    line_start_cursor: <span class="tok-type">usize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, -<span class="tok-number">1</span>)), <span class="tok-comment">// Start just &quot;before&quot; the input buffer to get a 1-based column for line 1.</span>
</span>
<span class="line" id="L197">    total_bytes_before_current_input: <span class="tok-type">u64</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L198">    cursor_pointer: *<span class="tok-kw">const</span> <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L199"></span>
<span class="line" id="L200">    <span class="tok-comment">/// Starts at 1.</span></span>
<span class="line" id="L201">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLine</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) <span class="tok-type">u64</span> {</span>
<span class="line" id="L202">        <span class="tok-kw">return</span> self.line_number;</span>
<span class="line" id="L203">    }</span>
<span class="line" id="L204">    <span class="tok-comment">/// Starts at 1.</span></span>
<span class="line" id="L205">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getColumn</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) <span class="tok-type">u64</span> {</span>
<span class="line" id="L206">        <span class="tok-kw">return</span> self.cursor_pointer.* -% self.line_start_cursor;</span>
<span class="line" id="L207">    }</span>
<span class="line" id="L208">    <span class="tok-comment">/// Starts at 0. Measures the byte offset since the start of the input.</span></span>
<span class="line" id="L209">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getByteOffset</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) <span class="tok-type">u64</span> {</span>
<span class="line" id="L210">        <span class="tok-kw">return</span> self.total_bytes_before_current_input + self.cursor_pointer.*;</span>
<span class="line" id="L211">    }</span>
<span class="line" id="L212">};</span>
<span class="line" id="L213"></span>
<span class="line" id="L214"><span class="tok-comment">/// See the documentation for `std.json.Token`.</span></span>
<span class="line" id="L215"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> AllocWhen = <span class="tok-kw">enum</span> { alloc_if_needed, alloc_always };</span>
<span class="line" id="L216"></span>
<span class="line" id="L217"><span class="tok-comment">/// For security, the maximum size allocated to store a single string or number value is limited to 4MiB by default.</span></span>
<span class="line" id="L218"><span class="tok-comment">/// This limit can be specified by calling `nextAllocMax()` instead of `nextAlloc()`.</span></span>
<span class="line" id="L219"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> default_max_value_len = <span class="tok-number">4</span> * <span class="tok-number">1024</span> * <span class="tok-number">1024</span>;</span>
<span class="line" id="L220"></span>
<span class="line" id="L221"><span class="tok-comment">/// Connects a `std.io.Reader` to a `std.json.Scanner`.</span></span>
<span class="line" id="L222"><span class="tok-comment">/// All `next*()` methods here handle `error.BufferUnderrun` from `std.json.Scanner`, and then read from the reader.</span></span>
<span class="line" id="L223"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Reader</span>(<span class="tok-kw">comptime</span> buffer_size: <span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> ReaderType: <span class="tok-type">type</span>) <span class="tok-type">type</span> {</span>
<span class="line" id="L224">    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L225">        scanner: Scanner,</span>
<span class="line" id="L226">        reader: ReaderType,</span>
<span class="line" id="L227"></span>
<span class="line" id="L228">        buffer: [buffer_size]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L229"></span>
<span class="line" id="L230">        <span class="tok-comment">/// The allocator is only used to track `[]` and `{}` nesting levels.</span></span>
<span class="line" id="L231">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: Allocator, io_reader: ReaderType) <span class="tok-builtin">@This</span>() {</span>
<span class="line" id="L232">            <span class="tok-kw">return</span> .{</span>
<span class="line" id="L233">                .scanner = Scanner.initStreaming(allocator),</span>
<span class="line" id="L234">                .reader = io_reader,</span>
<span class="line" id="L235">            };</span>
<span class="line" id="L236">        }</span>
<span class="line" id="L237">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {</span>
<span class="line" id="L238">            self.scanner.deinit();</span>
<span class="line" id="L239">            self.* = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L240">        }</span>
<span class="line" id="L241"></span>
<span class="line" id="L242">        <span class="tok-comment">/// Calls `std.json.Scanner.enableDiagnostics`.</span></span>
<span class="line" id="L243">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">enableDiagnostics</span>(self: *<span class="tok-builtin">@This</span>(), diagnostics: *Diagnostics) <span class="tok-type">void</span> {</span>
<span class="line" id="L244">            self.scanner.enableDiagnostics(diagnostics);</span>
<span class="line" id="L245">        }</span>
<span class="line" id="L246"></span>
<span class="line" id="L247">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> NextError = ReaderType.Error || Error || Allocator.Error;</span>
<span class="line" id="L248">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> SkipError = NextError;</span>
<span class="line" id="L249">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> AllocError = NextError || <span class="tok-kw">error</span>{ValueTooLong};</span>
<span class="line" id="L250">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> PeekError = ReaderType.Error || Error;</span>
<span class="line" id="L251"></span>
<span class="line" id="L252">        <span class="tok-comment">/// Equivalent to `nextAllocMax(allocator, when, default_max_value_len);`</span></span>
<span class="line" id="L253">        <span class="tok-comment">/// See also `std.json.Token` for documentation of `nextAlloc*()` function behavior.</span></span>
<span class="line" id="L254">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextAlloc</span>(self: *<span class="tok-builtin">@This</span>(), allocator: Allocator, when: AllocWhen) AllocError!Token {</span>
<span class="line" id="L255">            <span class="tok-kw">return</span> self.nextAllocMax(allocator, when, default_max_value_len);</span>
<span class="line" id="L256">        }</span>
<span class="line" id="L257">        <span class="tok-comment">/// See also `std.json.Token` for documentation of `nextAlloc*()` function behavior.</span></span>
<span class="line" id="L258">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextAllocMax</span>(self: *<span class="tok-builtin">@This</span>(), allocator: Allocator, when: AllocWhen, max_value_len: <span class="tok-type">usize</span>) AllocError!Token {</span>
<span class="line" id="L259">            <span class="tok-kw">const</span> token_type = <span class="tok-kw">try</span> self.peekNextTokenType();</span>
<span class="line" id="L260">            <span class="tok-kw">switch</span> (token_type) {</span>
<span class="line" id="L261">                .number, .string =&gt; {</span>
<span class="line" id="L262">                    <span class="tok-kw">var</span> value_list = ArrayList(<span class="tok-type">u8</span>).init(allocator);</span>
<span class="line" id="L263">                    <span class="tok-kw">errdefer</span> {</span>
<span class="line" id="L264">                        value_list.deinit();</span>
<span class="line" id="L265">                    }</span>
<span class="line" id="L266">                    <span class="tok-kw">if</span> (<span class="tok-kw">try</span> self.allocNextIntoArrayListMax(&amp;value_list, when, max_value_len)) |slice| {</span>
<span class="line" id="L267">                        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (token_type == .number)</span>
<span class="line" id="L268">                            Token{ .number = slice }</span>
<span class="line" id="L269">                        <span class="tok-kw">else</span></span>
<span class="line" id="L270">                            Token{ .string = slice };</span>
<span class="line" id="L271">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L272">                        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (token_type == .number)</span>
<span class="line" id="L273">                            Token{ .allocated_number = <span class="tok-kw">try</span> value_list.toOwnedSlice() }</span>
<span class="line" id="L274">                        <span class="tok-kw">else</span></span>
<span class="line" id="L275">                            Token{ .allocated_string = <span class="tok-kw">try</span> value_list.toOwnedSlice() };</span>
<span class="line" id="L276">                    }</span>
<span class="line" id="L277">                },</span>
<span class="line" id="L278"></span>
<span class="line" id="L279">                <span class="tok-comment">// Simple tokens never alloc.</span>
</span>
<span class="line" id="L280">                .object_begin,</span>
<span class="line" id="L281">                .object_end,</span>
<span class="line" id="L282">                .array_begin,</span>
<span class="line" id="L283">                .array_end,</span>
<span class="line" id="L284">                .<span class="tok-null">true</span>,</span>
<span class="line" id="L285">                .<span class="tok-null">false</span>,</span>
<span class="line" id="L286">                .<span class="tok-null">null</span>,</span>
<span class="line" id="L287">                .end_of_document,</span>
<span class="line" id="L288">                =&gt; <span class="tok-kw">return</span> <span class="tok-kw">try</span> self.next(),</span>
<span class="line" id="L289">            }</span>
<span class="line" id="L290">        }</span>
<span class="line" id="L291"></span>
<span class="line" id="L292">        <span class="tok-comment">/// Equivalent to `allocNextIntoArrayListMax(value_list, when, default_max_value_len);`</span></span>
<span class="line" id="L293">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocNextIntoArrayList</span>(self: *<span class="tok-builtin">@This</span>(), value_list: *ArrayList(<span class="tok-type">u8</span>), when: AllocWhen) AllocError!?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L294">            <span class="tok-kw">return</span> self.allocNextIntoArrayListMax(value_list, when, default_max_value_len);</span>
<span class="line" id="L295">        }</span>
<span class="line" id="L296">        <span class="tok-comment">/// Calls `std.json.Scanner.allocNextIntoArrayListMax` and handles `error.BufferUnderrun`.</span></span>
<span class="line" id="L297">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocNextIntoArrayListMax</span>(self: *<span class="tok-builtin">@This</span>(), value_list: *ArrayList(<span class="tok-type">u8</span>), when: AllocWhen, max_value_len: <span class="tok-type">usize</span>) AllocError!?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L298">            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L299">                <span class="tok-kw">return</span> self.scanner.allocNextIntoArrayListMax(value_list, when, max_value_len) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L300">                    <span class="tok-kw">error</span>.BufferUnderrun =&gt; {</span>
<span class="line" id="L301">                        <span class="tok-kw">try</span> self.refillBuffer();</span>
<span class="line" id="L302">                        <span class="tok-kw">continue</span>;</span>
<span class="line" id="L303">                    },</span>
<span class="line" id="L304">                    <span class="tok-kw">else</span> =&gt; |other_err| <span class="tok-kw">return</span> other_err,</span>
<span class="line" id="L305">                };</span>
<span class="line" id="L306">            }</span>
<span class="line" id="L307">        }</span>
<span class="line" id="L308"></span>
<span class="line" id="L309">        <span class="tok-comment">/// Like `std.json.Scanner.skipValue`, but handles `error.BufferUnderrun`.</span></span>
<span class="line" id="L310">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">skipValue</span>(self: *<span class="tok-builtin">@This</span>()) SkipError!<span class="tok-type">void</span> {</span>
<span class="line" id="L311">            <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.peekNextTokenType()) {</span>
<span class="line" id="L312">                .object_begin, .array_begin =&gt; {</span>
<span class="line" id="L313">                    <span class="tok-kw">try</span> self.skipUntilStackHeight(self.stackHeight());</span>
<span class="line" id="L314">                },</span>
<span class="line" id="L315">                .number, .string =&gt; {</span>
<span class="line" id="L316">                    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L317">                        <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.next()) {</span>
<span class="line" id="L318">                            .partial_number,</span>
<span class="line" id="L319">                            .partial_string,</span>
<span class="line" id="L320">                            .partial_string_escaped_1,</span>
<span class="line" id="L321">                            .partial_string_escaped_2,</span>
<span class="line" id="L322">                            .partial_string_escaped_3,</span>
<span class="line" id="L323">                            .partial_string_escaped_4,</span>
<span class="line" id="L324">                            =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L325"></span>
<span class="line" id="L326">                            .number, .string =&gt; <span class="tok-kw">break</span>,</span>
<span class="line" id="L327"></span>
<span class="line" id="L328">                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L329">                        }</span>
<span class="line" id="L330">                    }</span>
<span class="line" id="L331">                },</span>
<span class="line" id="L332">                .<span class="tok-null">true</span>, .<span class="tok-null">false</span>, .<span class="tok-null">null</span> =&gt; {</span>
<span class="line" id="L333">                    _ = <span class="tok-kw">try</span> self.next();</span>
<span class="line" id="L334">                },</span>
<span class="line" id="L335"></span>
<span class="line" id="L336">                .object_end, .array_end, .end_of_document =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Attempt to skip a non-value token.</span>
</span>
<span class="line" id="L337">            }</span>
<span class="line" id="L338">        }</span>
<span class="line" id="L339">        <span class="tok-comment">/// Like `std.json.Scanner.skipUntilStackHeight()` but handles `error.BufferUnderrun`.</span></span>
<span class="line" id="L340">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">skipUntilStackHeight</span>(self: *<span class="tok-builtin">@This</span>(), terminal_stack_height: <span class="tok-type">u32</span>) NextError!<span class="tok-type">void</span> {</span>
<span class="line" id="L341">            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L342">                <span class="tok-kw">return</span> self.scanner.skipUntilStackHeight(terminal_stack_height) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L343">                    <span class="tok-kw">error</span>.BufferUnderrun =&gt; {</span>
<span class="line" id="L344">                        <span class="tok-kw">try</span> self.refillBuffer();</span>
<span class="line" id="L345">                        <span class="tok-kw">continue</span>;</span>
<span class="line" id="L346">                    },</span>
<span class="line" id="L347">                    <span class="tok-kw">else</span> =&gt; |other_err| <span class="tok-kw">return</span> other_err,</span>
<span class="line" id="L348">                };</span>
<span class="line" id="L349">            }</span>
<span class="line" id="L350">        }</span>
<span class="line" id="L351"></span>
<span class="line" id="L352">        <span class="tok-comment">/// Calls `std.json.Scanner.stackHeight`.</span></span>
<span class="line" id="L353">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stackHeight</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) <span class="tok-type">u32</span> {</span>
<span class="line" id="L354">            <span class="tok-kw">return</span> self.scanner.stackHeight();</span>
<span class="line" id="L355">        }</span>
<span class="line" id="L356">        <span class="tok-comment">/// Calls `std.json.Scanner.ensureTotalStackCapacity`.</span></span>
<span class="line" id="L357">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalStackCapacity</span>(self: *<span class="tok-builtin">@This</span>(), height: <span class="tok-type">u32</span>) Allocator.Error!<span class="tok-type">void</span> {</span>
<span class="line" id="L358">            <span class="tok-kw">try</span> self.scanner.ensureTotalStackCapacity(height);</span>
<span class="line" id="L359">        }</span>
<span class="line" id="L360"></span>
<span class="line" id="L361">        <span class="tok-comment">/// See `std.json.Token` for documentation of this function.</span></span>
<span class="line" id="L362">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<span class="tok-builtin">@This</span>()) NextError!Token {</span>
<span class="line" id="L363">            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L364">                <span class="tok-kw">return</span> self.scanner.next() <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L365">                    <span class="tok-kw">error</span>.BufferUnderrun =&gt; {</span>
<span class="line" id="L366">                        <span class="tok-kw">try</span> self.refillBuffer();</span>
<span class="line" id="L367">                        <span class="tok-kw">continue</span>;</span>
<span class="line" id="L368">                    },</span>
<span class="line" id="L369">                    <span class="tok-kw">else</span> =&gt; |other_err| <span class="tok-kw">return</span> other_err,</span>
<span class="line" id="L370">                };</span>
<span class="line" id="L371">            }</span>
<span class="line" id="L372">        }</span>
<span class="line" id="L373"></span>
<span class="line" id="L374">        <span class="tok-comment">/// See `std.json.Scanner.peekNextTokenType()`.</span></span>
<span class="line" id="L375">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peekNextTokenType</span>(self: *<span class="tok-builtin">@This</span>()) PeekError!TokenType {</span>
<span class="line" id="L376">            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L377">                <span class="tok-kw">return</span> self.scanner.peekNextTokenType() <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L378">                    <span class="tok-kw">error</span>.BufferUnderrun =&gt; {</span>
<span class="line" id="L379">                        <span class="tok-kw">try</span> self.refillBuffer();</span>
<span class="line" id="L380">                        <span class="tok-kw">continue</span>;</span>
<span class="line" id="L381">                    },</span>
<span class="line" id="L382">                    <span class="tok-kw">else</span> =&gt; |other_err| <span class="tok-kw">return</span> other_err,</span>
<span class="line" id="L383">                };</span>
<span class="line" id="L384">            }</span>
<span class="line" id="L385">        }</span>
<span class="line" id="L386"></span>
<span class="line" id="L387">        <span class="tok-kw">fn</span> <span class="tok-fn">refillBuffer</span>(self: *<span class="tok-builtin">@This</span>()) ReaderType.Error!<span class="tok-type">void</span> {</span>
<span class="line" id="L388">            <span class="tok-kw">const</span> input = self.buffer[<span class="tok-number">0</span>..<span class="tok-kw">try</span> self.reader.read(self.buffer[<span class="tok-number">0</span>..])];</span>
<span class="line" id="L389">            <span class="tok-kw">if</span> (input.len &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L390">                self.scanner.feedInput(input);</span>
<span class="line" id="L391">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L392">                self.scanner.endInput();</span>
<span class="line" id="L393">            }</span>
<span class="line" id="L394">        }</span>
<span class="line" id="L395">    };</span>
<span class="line" id="L396">}</span>
<span class="line" id="L397"></span>
<span class="line" id="L398"><span class="tok-comment">/// The lowest level parsing API in this package;</span></span>
<span class="line" id="L399"><span class="tok-comment">/// supports streaming input with a low memory footprint.</span></span>
<span class="line" id="L400"><span class="tok-comment">/// The memory requirement is `O(d)` where d is the nesting depth of `[]` or `{}` containers in the input.</span></span>
<span class="line" id="L401"><span class="tok-comment">/// Specifically `d/8` bytes are required for this purpose,</span></span>
<span class="line" id="L402"><span class="tok-comment">/// with some extra buffer according to the implementation of `std.ArrayList`.</span></span>
<span class="line" id="L403"><span class="tok-comment">///</span></span>
<span class="line" id="L404"><span class="tok-comment">/// This scanner can emit partial tokens; see `std.json.Token`.</span></span>
<span class="line" id="L405"><span class="tok-comment">/// The input to this class is a sequence of input buffers that you must supply one at a time.</span></span>
<span class="line" id="L406"><span class="tok-comment">/// Call `feedInput()` with the first buffer, then call `next()` repeatedly until `error.BufferUnderrun` is returned.</span></span>
<span class="line" id="L407"><span class="tok-comment">/// Then call `feedInput()` again and so forth.</span></span>
<span class="line" id="L408"><span class="tok-comment">/// Call `endInput()` when the last input buffer has been given to `feedInput()`, either immediately after calling `feedInput()`,</span></span>
<span class="line" id="L409"><span class="tok-comment">/// or when `error.BufferUnderrun` requests more data and there is no more.</span></span>
<span class="line" id="L410"><span class="tok-comment">/// Be sure to call `next()` after calling `endInput()` until `Token.end_of_document` has been returned.</span></span>
<span class="line" id="L411"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Scanner = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L412">    state: State = .value,</span>
<span class="line" id="L413">    string_is_object_key: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L414">    stack: BitStack,</span>
<span class="line" id="L415">    value_start: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L416">    unicode_code_point: <span class="tok-type">u21</span> = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L417"></span>
<span class="line" id="L418">    input: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;&quot;</span>,</span>
<span class="line" id="L419">    cursor: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L420">    is_end_of_input: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L421">    diagnostics: ?*Diagnostics = <span class="tok-null">null</span>,</span>
<span class="line" id="L422"></span>
<span class="line" id="L423">    <span class="tok-comment">/// The allocator is only used to track `[]` and `{}` nesting levels.</span></span>
<span class="line" id="L424">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initStreaming</span>(allocator: Allocator) <span class="tok-builtin">@This</span>() {</span>
<span class="line" id="L425">        <span class="tok-kw">return</span> .{</span>
<span class="line" id="L426">            .stack = BitStack.init(allocator),</span>
<span class="line" id="L427">        };</span>
<span class="line" id="L428">    }</span>
<span class="line" id="L429">    <span class="tok-comment">/// Use this if your input is a single slice.</span></span>
<span class="line" id="L430">    <span class="tok-comment">/// This is effectively equivalent to:</span></span>
<span class="line" id="L431">    <span class="tok-comment">/// ```</span></span>
<span class="line" id="L432">    <span class="tok-comment">/// initStreaming(allocator);</span></span>
<span class="line" id="L433">    <span class="tok-comment">/// feedInput(complete_input);</span></span>
<span class="line" id="L434">    <span class="tok-comment">/// endInput();</span></span>
<span class="line" id="L435">    <span class="tok-comment">/// ```</span></span>
<span class="line" id="L436">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initCompleteInput</span>(allocator: Allocator, complete_input: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-builtin">@This</span>() {</span>
<span class="line" id="L437">        <span class="tok-kw">return</span> .{</span>
<span class="line" id="L438">            .stack = BitStack.init(allocator),</span>
<span class="line" id="L439">            .input = complete_input,</span>
<span class="line" id="L440">            .is_end_of_input = <span class="tok-null">true</span>,</span>
<span class="line" id="L441">        };</span>
<span class="line" id="L442">    }</span>
<span class="line" id="L443">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {</span>
<span class="line" id="L444">        self.stack.deinit();</span>
<span class="line" id="L445">        self.* = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L446">    }</span>
<span class="line" id="L447"></span>
<span class="line" id="L448">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">enableDiagnostics</span>(self: *<span class="tok-builtin">@This</span>(), diagnostics: *Diagnostics) <span class="tok-type">void</span> {</span>
<span class="line" id="L449">        diagnostics.cursor_pointer = &amp;self.cursor;</span>
<span class="line" id="L450">        self.diagnostics = diagnostics;</span>
<span class="line" id="L451">    }</span>
<span class="line" id="L452"></span>
<span class="line" id="L453">    <span class="tok-comment">/// Call this whenever you get `error.BufferUnderrun` from `next()`.</span></span>
<span class="line" id="L454">    <span class="tok-comment">/// When there is no more input to provide, call `endInput()`.</span></span>
<span class="line" id="L455">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">feedInput</span>(self: *<span class="tok-builtin">@This</span>(), input: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L456">        assert(self.cursor == self.input.len); <span class="tok-comment">// Not done with the last input slice.</span>
</span>
<span class="line" id="L457">        <span class="tok-kw">if</span> (self.diagnostics) |diag| {</span>
<span class="line" id="L458">            diag.total_bytes_before_current_input += self.input.len;</span>
<span class="line" id="L459">            <span class="tok-comment">// This usually goes &quot;negative&quot; to measure how far before the beginning</span>
</span>
<span class="line" id="L460">            <span class="tok-comment">// of the new buffer the current line started.</span>
</span>
<span class="line" id="L461">            diag.line_start_cursor -%= self.cursor;</span>
<span class="line" id="L462">        }</span>
<span class="line" id="L463">        self.input = input;</span>
<span class="line" id="L464">        self.cursor = <span class="tok-number">0</span>;</span>
<span class="line" id="L465">        self.value_start = <span class="tok-number">0</span>;</span>
<span class="line" id="L466">    }</span>
<span class="line" id="L467">    <span class="tok-comment">/// Call this when you will no longer call `feedInput()` anymore.</span></span>
<span class="line" id="L468">    <span class="tok-comment">/// This can be called either immediately after the last `feedInput()`,</span></span>
<span class="line" id="L469">    <span class="tok-comment">/// or at any time afterward, such as when getting `error.BufferUnderrun` from `next()`.</span></span>
<span class="line" id="L470">    <span class="tok-comment">/// Don't forget to call `next*()` after `endInput()` until you get `.end_of_document`.</span></span>
<span class="line" id="L471">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">endInput</span>(self: *<span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {</span>
<span class="line" id="L472">        self.is_end_of_input = <span class="tok-null">true</span>;</span>
<span class="line" id="L473">    }</span>
<span class="line" id="L474"></span>
<span class="line" id="L475">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> NextError = Error || Allocator.Error || <span class="tok-kw">error</span>{BufferUnderrun};</span>
<span class="line" id="L476">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> AllocError = Error || Allocator.Error || <span class="tok-kw">error</span>{ValueTooLong};</span>
<span class="line" id="L477">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> PeekError = Error || <span class="tok-kw">error</span>{BufferUnderrun};</span>
<span class="line" id="L478">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> SkipError = Error || Allocator.Error;</span>
<span class="line" id="L479">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> AllocIntoArrayListError = AllocError || <span class="tok-kw">error</span>{BufferUnderrun};</span>
<span class="line" id="L480"></span>
<span class="line" id="L481">    <span class="tok-comment">/// Equivalent to `nextAllocMax(allocator, when, default_max_value_len);`</span></span>
<span class="line" id="L482">    <span class="tok-comment">/// This function is only available after `endInput()` (or `initCompleteInput()`) has been called.</span></span>
<span class="line" id="L483">    <span class="tok-comment">/// See also `std.json.Token` for documentation of `nextAlloc*()` function behavior.</span></span>
<span class="line" id="L484">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextAlloc</span>(self: *<span class="tok-builtin">@This</span>(), allocator: Allocator, when: AllocWhen) AllocError!Token {</span>
<span class="line" id="L485">        <span class="tok-kw">return</span> self.nextAllocMax(allocator, when, default_max_value_len);</span>
<span class="line" id="L486">    }</span>
<span class="line" id="L487"></span>
<span class="line" id="L488">    <span class="tok-comment">/// This function is only available after `endInput()` (or `initCompleteInput()`) has been called.</span></span>
<span class="line" id="L489">    <span class="tok-comment">/// See also `std.json.Token` for documentation of `nextAlloc*()` function behavior.</span></span>
<span class="line" id="L490">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextAllocMax</span>(self: *<span class="tok-builtin">@This</span>(), allocator: Allocator, when: AllocWhen, max_value_len: <span class="tok-type">usize</span>) AllocError!Token {</span>
<span class="line" id="L491">        assert(self.is_end_of_input); <span class="tok-comment">// This function is not available in streaming mode.</span>
</span>
<span class="line" id="L492">        <span class="tok-kw">const</span> token_type = self.peekNextTokenType() <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {</span>
<span class="line" id="L493">            <span class="tok-kw">error</span>.BufferUnderrun =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L494">            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> err,</span>
<span class="line" id="L495">        };</span>
<span class="line" id="L496">        <span class="tok-kw">switch</span> (token_type) {</span>
<span class="line" id="L497">            .number, .string =&gt; {</span>
<span class="line" id="L498">                <span class="tok-kw">var</span> value_list = ArrayList(<span class="tok-type">u8</span>).init(allocator);</span>
<span class="line" id="L499">                <span class="tok-kw">errdefer</span> {</span>
<span class="line" id="L500">                    value_list.deinit();</span>
<span class="line" id="L501">                }</span>
<span class="line" id="L502">                <span class="tok-kw">if</span> (self.allocNextIntoArrayListMax(&amp;value_list, when, max_value_len) <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {</span>
<span class="line" id="L503">                    <span class="tok-kw">error</span>.BufferUnderrun =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L504">                    <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> err,</span>
<span class="line" id="L505">                }) |slice| {</span>
<span class="line" id="L506">                    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (token_type == .number)</span>
<span class="line" id="L507">                        Token{ .number = slice }</span>
<span class="line" id="L508">                    <span class="tok-kw">else</span></span>
<span class="line" id="L509">                        Token{ .string = slice };</span>
<span class="line" id="L510">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L511">                    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (token_type == .number)</span>
<span class="line" id="L512">                        Token{ .allocated_number = <span class="tok-kw">try</span> value_list.toOwnedSlice() }</span>
<span class="line" id="L513">                    <span class="tok-kw">else</span></span>
<span class="line" id="L514">                        Token{ .allocated_string = <span class="tok-kw">try</span> value_list.toOwnedSlice() };</span>
<span class="line" id="L515">                }</span>
<span class="line" id="L516">            },</span>
<span class="line" id="L517"></span>
<span class="line" id="L518">            <span class="tok-comment">// Simple tokens never alloc.</span>
</span>
<span class="line" id="L519">            .object_begin,</span>
<span class="line" id="L520">            .object_end,</span>
<span class="line" id="L521">            .array_begin,</span>
<span class="line" id="L522">            .array_end,</span>
<span class="line" id="L523">            .<span class="tok-null">true</span>,</span>
<span class="line" id="L524">            .<span class="tok-null">false</span>,</span>
<span class="line" id="L525">            .<span class="tok-null">null</span>,</span>
<span class="line" id="L526">            .end_of_document,</span>
<span class="line" id="L527">            =&gt; <span class="tok-kw">return</span> self.next() <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {</span>
<span class="line" id="L528">                <span class="tok-kw">error</span>.BufferUnderrun =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L529">                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> err,</span>
<span class="line" id="L530">            },</span>
<span class="line" id="L531">        }</span>
<span class="line" id="L532">    }</span>
<span class="line" id="L533"></span>
<span class="line" id="L534">    <span class="tok-comment">/// Equivalent to `allocNextIntoArrayListMax(value_list, when, default_max_value_len);`</span></span>
<span class="line" id="L535">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocNextIntoArrayList</span>(self: *<span class="tok-builtin">@This</span>(), value_list: *ArrayList(<span class="tok-type">u8</span>), when: AllocWhen) AllocIntoArrayListError!?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L536">        <span class="tok-kw">return</span> self.allocNextIntoArrayListMax(value_list, when, default_max_value_len);</span>
<span class="line" id="L537">    }</span>
<span class="line" id="L538">    <span class="tok-comment">/// The next token type must be either `.number` or `.string`. See `peekNextTokenType()`.</span></span>
<span class="line" id="L539">    <span class="tok-comment">/// When allocation is not necessary with `.alloc_if_needed`,</span></span>
<span class="line" id="L540">    <span class="tok-comment">/// this method returns the content slice from the input buffer, and `value_list` is not touched.</span></span>
<span class="line" id="L541">    <span class="tok-comment">/// When allocation is necessary or with `.alloc_always`, this method concatenates partial tokens into the given `value_list`,</span></span>
<span class="line" id="L542">    <span class="tok-comment">/// and returns `null` once the final `.number` or `.string` token has been written into it.</span></span>
<span class="line" id="L543">    <span class="tok-comment">/// In case of an `error.BufferUnderrun`, partial values will be left in the given value_list.</span></span>
<span class="line" id="L544">    <span class="tok-comment">/// The given `value_list` is never reset by this method, so an `error.BufferUnderrun` situation</span></span>
<span class="line" id="L545">    <span class="tok-comment">/// can be resumed by passing the same array list in again.</span></span>
<span class="line" id="L546">    <span class="tok-comment">/// This method does not indicate whether the token content being returned is for a `.number` or `.string` token type;</span></span>
<span class="line" id="L547">    <span class="tok-comment">/// the caller of this method is expected to know which type of token is being processed.</span></span>
<span class="line" id="L548">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocNextIntoArrayListMax</span>(self: *<span class="tok-builtin">@This</span>(), value_list: *ArrayList(<span class="tok-type">u8</span>), when: AllocWhen, max_value_len: <span class="tok-type">usize</span>) AllocIntoArrayListError!?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L549">        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L550">            <span class="tok-kw">const</span> token = <span class="tok-kw">try</span> self.next();</span>
<span class="line" id="L551">            <span class="tok-kw">switch</span> (token) {</span>
<span class="line" id="L552">                <span class="tok-comment">// Accumulate partial values.</span>
</span>
<span class="line" id="L553">                .partial_number, .partial_string =&gt; |slice| {</span>
<span class="line" id="L554">                    <span class="tok-kw">try</span> appendSlice(value_list, slice, max_value_len);</span>
<span class="line" id="L555">                },</span>
<span class="line" id="L556">                .partial_string_escaped_1 =&gt; |buf| {</span>
<span class="line" id="L557">                    <span class="tok-kw">try</span> appendSlice(value_list, buf[<span class="tok-number">0</span>..], max_value_len);</span>
<span class="line" id="L558">                },</span>
<span class="line" id="L559">                .partial_string_escaped_2 =&gt; |buf| {</span>
<span class="line" id="L560">                    <span class="tok-kw">try</span> appendSlice(value_list, buf[<span class="tok-number">0</span>..], max_value_len);</span>
<span class="line" id="L561">                },</span>
<span class="line" id="L562">                .partial_string_escaped_3 =&gt; |buf| {</span>
<span class="line" id="L563">                    <span class="tok-kw">try</span> appendSlice(value_list, buf[<span class="tok-number">0</span>..], max_value_len);</span>
<span class="line" id="L564">                },</span>
<span class="line" id="L565">                .partial_string_escaped_4 =&gt; |buf| {</span>
<span class="line" id="L566">                    <span class="tok-kw">try</span> appendSlice(value_list, buf[<span class="tok-number">0</span>..], max_value_len);</span>
<span class="line" id="L567">                },</span>
<span class="line" id="L568"></span>
<span class="line" id="L569">                <span class="tok-comment">// Return complete values.</span>
</span>
<span class="line" id="L570">                .number =&gt; |slice| {</span>
<span class="line" id="L571">                    <span class="tok-kw">if</span> (when == .alloc_if_needed <span class="tok-kw">and</span> value_list.items.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L572">                        <span class="tok-comment">// No alloc necessary.</span>
</span>
<span class="line" id="L573">                        <span class="tok-kw">return</span> slice;</span>
<span class="line" id="L574">                    }</span>
<span class="line" id="L575">                    <span class="tok-kw">try</span> appendSlice(value_list, slice, max_value_len);</span>
<span class="line" id="L576">                    <span class="tok-comment">// The token is complete.</span>
</span>
<span class="line" id="L577">                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L578">                },</span>
<span class="line" id="L579">                .string =&gt; |slice| {</span>
<span class="line" id="L580">                    <span class="tok-kw">if</span> (when == .alloc_if_needed <span class="tok-kw">and</span> value_list.items.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L581">                        <span class="tok-comment">// No alloc necessary.</span>
</span>
<span class="line" id="L582">                        <span class="tok-kw">return</span> slice;</span>
<span class="line" id="L583">                    }</span>
<span class="line" id="L584">                    <span class="tok-kw">try</span> appendSlice(value_list, slice, max_value_len);</span>
<span class="line" id="L585">                    <span class="tok-comment">// The token is complete.</span>
</span>
<span class="line" id="L586">                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L587">                },</span>
<span class="line" id="L588"></span>
<span class="line" id="L589">                .object_begin,</span>
<span class="line" id="L590">                .object_end,</span>
<span class="line" id="L591">                .array_begin,</span>
<span class="line" id="L592">                .array_end,</span>
<span class="line" id="L593">                .<span class="tok-null">true</span>,</span>
<span class="line" id="L594">                .<span class="tok-null">false</span>,</span>
<span class="line" id="L595">                .<span class="tok-null">null</span>,</span>
<span class="line" id="L596">                .end_of_document,</span>
<span class="line" id="L597">                =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Only .number and .string token types are allowed here. Check peekNextTokenType() before calling this.</span>
</span>
<span class="line" id="L598"></span>
<span class="line" id="L599">                .allocated_number, .allocated_string =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L600">            }</span>
<span class="line" id="L601">        }</span>
<span class="line" id="L602">    }</span>
<span class="line" id="L603"></span>
<span class="line" id="L604">    <span class="tok-comment">/// This function is only available after `endInput()` (or `initCompleteInput()`) has been called.</span></span>
<span class="line" id="L605">    <span class="tok-comment">/// If the next token type is `.object_begin` or `.array_begin`,</span></span>
<span class="line" id="L606">    <span class="tok-comment">/// this function calls `next()` repeatedly until the corresponding `.object_end` or `.array_end` is found.</span></span>
<span class="line" id="L607">    <span class="tok-comment">/// If the next token type is `.number` or `.string`,</span></span>
<span class="line" id="L608">    <span class="tok-comment">/// this function calls `next()` repeatedly until the (non `.partial_*`) `.number` or `.string` token is found.</span></span>
<span class="line" id="L609">    <span class="tok-comment">/// If the next token type is `.true`, `.false`, or `.null`, this function calls `next()` once.</span></span>
<span class="line" id="L610">    <span class="tok-comment">/// The next token type must not be `.object_end`, `.array_end`, or `.end_of_document`;</span></span>
<span class="line" id="L611">    <span class="tok-comment">/// see `peekNextTokenType()`.</span></span>
<span class="line" id="L612">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">skipValue</span>(self: *<span class="tok-builtin">@This</span>()) SkipError!<span class="tok-type">void</span> {</span>
<span class="line" id="L613">        assert(self.is_end_of_input); <span class="tok-comment">// This function is not available in streaming mode.</span>
</span>
<span class="line" id="L614">        <span class="tok-kw">switch</span> (self.peekNextTokenType() <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {</span>
<span class="line" id="L615">            <span class="tok-kw">error</span>.BufferUnderrun =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L616">            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> err,</span>
<span class="line" id="L617">        }) {</span>
<span class="line" id="L618">            .object_begin, .array_begin =&gt; {</span>
<span class="line" id="L619">                self.skipUntilStackHeight(self.stackHeight()) <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {</span>
<span class="line" id="L620">                    <span class="tok-kw">error</span>.BufferUnderrun =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L621">                    <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> err,</span>
<span class="line" id="L622">                };</span>
<span class="line" id="L623">            },</span>
<span class="line" id="L624">            .number, .string =&gt; {</span>
<span class="line" id="L625">                <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L626">                    <span class="tok-kw">switch</span> (self.next() <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {</span>
<span class="line" id="L627">                        <span class="tok-kw">error</span>.BufferUnderrun =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L628">                        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> err,</span>
<span class="line" id="L629">                    }) {</span>
<span class="line" id="L630">                        .partial_number,</span>
<span class="line" id="L631">                        .partial_string,</span>
<span class="line" id="L632">                        .partial_string_escaped_1,</span>
<span class="line" id="L633">                        .partial_string_escaped_2,</span>
<span class="line" id="L634">                        .partial_string_escaped_3,</span>
<span class="line" id="L635">                        .partial_string_escaped_4,</span>
<span class="line" id="L636">                        =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L637"></span>
<span class="line" id="L638">                        .number, .string =&gt; <span class="tok-kw">break</span>,</span>
<span class="line" id="L639"></span>
<span class="line" id="L640">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L641">                    }</span>
<span class="line" id="L642">                }</span>
<span class="line" id="L643">            },</span>
<span class="line" id="L644">            .<span class="tok-null">true</span>, .<span class="tok-null">false</span>, .<span class="tok-null">null</span> =&gt; {</span>
<span class="line" id="L645">                _ = self.next() <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {</span>
<span class="line" id="L646">                    <span class="tok-kw">error</span>.BufferUnderrun =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L647">                    <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> err,</span>
<span class="line" id="L648">                };</span>
<span class="line" id="L649">            },</span>
<span class="line" id="L650"></span>
<span class="line" id="L651">            .object_end, .array_end, .end_of_document =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Attempt to skip a non-value token.</span>
</span>
<span class="line" id="L652">        }</span>
<span class="line" id="L653">    }</span>
<span class="line" id="L654"></span>
<span class="line" id="L655">    <span class="tok-comment">/// Skip tokens until an `.object_end` or `.array_end` token results in a `stackHeight()` equal the given stack height.</span></span>
<span class="line" id="L656">    <span class="tok-comment">/// Unlike `skipValue()`, this function is available in streaming mode.</span></span>
<span class="line" id="L657">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">skipUntilStackHeight</span>(self: *<span class="tok-builtin">@This</span>(), terminal_stack_height: <span class="tok-type">u32</span>) NextError!<span class="tok-type">void</span> {</span>
<span class="line" id="L658">        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L659">            <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.next()) {</span>
<span class="line" id="L660">                .object_end, .array_end =&gt; {</span>
<span class="line" id="L661">                    <span class="tok-kw">if</span> (self.stackHeight() == terminal_stack_height) <span class="tok-kw">break</span>;</span>
<span class="line" id="L662">                },</span>
<span class="line" id="L663">                .end_of_document =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L664">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L665">            }</span>
<span class="line" id="L666">        }</span>
<span class="line" id="L667">    }</span>
<span class="line" id="L668"></span>
<span class="line" id="L669">    <span class="tok-comment">/// The depth of `{}` or `[]` nesting levels at the current position.</span></span>
<span class="line" id="L670">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stackHeight</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) <span class="tok-type">u32</span> {</span>
<span class="line" id="L671">        <span class="tok-kw">return</span> self.stack.bit_len;</span>
<span class="line" id="L672">    }</span>
<span class="line" id="L673"></span>
<span class="line" id="L674">    <span class="tok-comment">/// Pre allocate memory to hold the given number of nesting levels.</span></span>
<span class="line" id="L675">    <span class="tok-comment">/// `stackHeight()` up to the given number will not cause allocations.</span></span>
<span class="line" id="L676">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalStackCapacity</span>(self: *<span class="tok-builtin">@This</span>(), height: <span class="tok-type">u32</span>) Allocator.Error!<span class="tok-type">void</span> {</span>
<span class="line" id="L677">        <span class="tok-kw">try</span> self.stack.ensureTotalCapacity(height);</span>
<span class="line" id="L678">    }</span>
<span class="line" id="L679"></span>
<span class="line" id="L680">    <span class="tok-comment">/// See `std.json.Token` for documentation of this function.</span></span>
<span class="line" id="L681">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<span class="tok-builtin">@This</span>()) NextError!Token {</span>
<span class="line" id="L682">        state_loop: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L683">            <span class="tok-kw">switch</span> (self.state) {</span>
<span class="line" id="L684">                .value =&gt; {</span>
<span class="line" id="L685">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.skipWhitespaceExpectByte()) {</span>
<span class="line" id="L686">                        <span class="tok-comment">// Object, Array</span>
</span>
<span class="line" id="L687">                        <span class="tok-str">'{'</span> =&gt; {</span>
<span class="line" id="L688">                            <span class="tok-kw">try</span> self.stack.push(OBJECT_MODE);</span>
<span class="line" id="L689">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L690">                            self.state = .object_start;</span>
<span class="line" id="L691">                            <span class="tok-kw">return</span> .object_begin;</span>
<span class="line" id="L692">                        },</span>
<span class="line" id="L693">                        <span class="tok-str">'['</span> =&gt; {</span>
<span class="line" id="L694">                            <span class="tok-kw">try</span> self.stack.push(ARRAY_MODE);</span>
<span class="line" id="L695">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L696">                            self.state = .array_start;</span>
<span class="line" id="L697">                            <span class="tok-kw">return</span> .array_begin;</span>
<span class="line" id="L698">                        },</span>
<span class="line" id="L699"></span>
<span class="line" id="L700">                        <span class="tok-comment">// String</span>
</span>
<span class="line" id="L701">                        <span class="tok-str">'&quot;'</span> =&gt; {</span>
<span class="line" id="L702">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L703">                            self.value_start = self.cursor;</span>
<span class="line" id="L704">                            self.state = .string;</span>
<span class="line" id="L705">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L706">                        },</span>
<span class="line" id="L707"></span>
<span class="line" id="L708">                        <span class="tok-comment">// Number</span>
</span>
<span class="line" id="L709">                        <span class="tok-str">'1'</span>...<span class="tok-str">'9'</span> =&gt; {</span>
<span class="line" id="L710">                            self.value_start = self.cursor;</span>
<span class="line" id="L711">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L712">                            self.state = .number_int;</span>
<span class="line" id="L713">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L714">                        },</span>
<span class="line" id="L715">                        <span class="tok-str">'0'</span> =&gt; {</span>
<span class="line" id="L716">                            self.value_start = self.cursor;</span>
<span class="line" id="L717">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L718">                            self.state = .number_leading_zero;</span>
<span class="line" id="L719">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L720">                        },</span>
<span class="line" id="L721">                        <span class="tok-str">'-'</span> =&gt; {</span>
<span class="line" id="L722">                            self.value_start = self.cursor;</span>
<span class="line" id="L723">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L724">                            self.state = .number_minus;</span>
<span class="line" id="L725">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L726">                        },</span>
<span class="line" id="L727"></span>
<span class="line" id="L728">                        <span class="tok-comment">// literal values</span>
</span>
<span class="line" id="L729">                        <span class="tok-str">'t'</span> =&gt; {</span>
<span class="line" id="L730">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L731">                            self.state = .literal_t;</span>
<span class="line" id="L732">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L733">                        },</span>
<span class="line" id="L734">                        <span class="tok-str">'f'</span> =&gt; {</span>
<span class="line" id="L735">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L736">                            self.state = .literal_f;</span>
<span class="line" id="L737">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L738">                        },</span>
<span class="line" id="L739">                        <span class="tok-str">'n'</span> =&gt; {</span>
<span class="line" id="L740">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L741">                            self.state = .literal_n;</span>
<span class="line" id="L742">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L743">                        },</span>
<span class="line" id="L744"></span>
<span class="line" id="L745">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L746">                    }</span>
<span class="line" id="L747">                },</span>
<span class="line" id="L748"></span>
<span class="line" id="L749">                .post_value =&gt; {</span>
<span class="line" id="L750">                    <span class="tok-kw">if</span> (<span class="tok-kw">try</span> self.skipWhitespaceCheckEnd()) <span class="tok-kw">return</span> .end_of_document;</span>
<span class="line" id="L751"></span>
<span class="line" id="L752">                    <span class="tok-kw">const</span> c = self.input[self.cursor];</span>
<span class="line" id="L753">                    <span class="tok-kw">if</span> (self.string_is_object_key) {</span>
<span class="line" id="L754">                        self.string_is_object_key = <span class="tok-null">false</span>;</span>
<span class="line" id="L755">                        <span class="tok-kw">switch</span> (c) {</span>
<span class="line" id="L756">                            <span class="tok-str">':'</span> =&gt; {</span>
<span class="line" id="L757">                                self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L758">                                self.state = .value;</span>
<span class="line" id="L759">                                <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L760">                            },</span>
<span class="line" id="L761">                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L762">                        }</span>
<span class="line" id="L763">                    }</span>
<span class="line" id="L764"></span>
<span class="line" id="L765">                    <span class="tok-kw">switch</span> (c) {</span>
<span class="line" id="L766">                        <span class="tok-str">'}'</span> =&gt; {</span>
<span class="line" id="L767">                            <span class="tok-kw">if</span> (self.stack.pop() != OBJECT_MODE) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError;</span>
<span class="line" id="L768">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L769">                            <span class="tok-comment">// stay in .post_value state.</span>
</span>
<span class="line" id="L770">                            <span class="tok-kw">return</span> .object_end;</span>
<span class="line" id="L771">                        },</span>
<span class="line" id="L772">                        <span class="tok-str">']'</span> =&gt; {</span>
<span class="line" id="L773">                            <span class="tok-kw">if</span> (self.stack.pop() != ARRAY_MODE) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError;</span>
<span class="line" id="L774">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L775">                            <span class="tok-comment">// stay in .post_value state.</span>
</span>
<span class="line" id="L776">                            <span class="tok-kw">return</span> .array_end;</span>
<span class="line" id="L777">                        },</span>
<span class="line" id="L778">                        <span class="tok-str">','</span> =&gt; {</span>
<span class="line" id="L779">                            <span class="tok-kw">switch</span> (self.stack.peek()) {</span>
<span class="line" id="L780">                                OBJECT_MODE =&gt; {</span>
<span class="line" id="L781">                                    self.state = .object_post_comma;</span>
<span class="line" id="L782">                                },</span>
<span class="line" id="L783">                                ARRAY_MODE =&gt; {</span>
<span class="line" id="L784">                                    self.state = .value;</span>
<span class="line" id="L785">                                },</span>
<span class="line" id="L786">                            }</span>
<span class="line" id="L787">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L788">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L789">                        },</span>
<span class="line" id="L790">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L791">                    }</span>
<span class="line" id="L792">                },</span>
<span class="line" id="L793"></span>
<span class="line" id="L794">                .object_start =&gt; {</span>
<span class="line" id="L795">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.skipWhitespaceExpectByte()) {</span>
<span class="line" id="L796">                        <span class="tok-str">'&quot;'</span> =&gt; {</span>
<span class="line" id="L797">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L798">                            self.value_start = self.cursor;</span>
<span class="line" id="L799">                            self.state = .string;</span>
<span class="line" id="L800">                            self.string_is_object_key = <span class="tok-null">true</span>;</span>
<span class="line" id="L801">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L802">                        },</span>
<span class="line" id="L803">                        <span class="tok-str">'}'</span> =&gt; {</span>
<span class="line" id="L804">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L805">                            _ = self.stack.pop();</span>
<span class="line" id="L806">                            self.state = .post_value;</span>
<span class="line" id="L807">                            <span class="tok-kw">return</span> .object_end;</span>
<span class="line" id="L808">                        },</span>
<span class="line" id="L809">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L810">                    }</span>
<span class="line" id="L811">                },</span>
<span class="line" id="L812">                .object_post_comma =&gt; {</span>
<span class="line" id="L813">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.skipWhitespaceExpectByte()) {</span>
<span class="line" id="L814">                        <span class="tok-str">'&quot;'</span> =&gt; {</span>
<span class="line" id="L815">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L816">                            self.value_start = self.cursor;</span>
<span class="line" id="L817">                            self.state = .string;</span>
<span class="line" id="L818">                            self.string_is_object_key = <span class="tok-null">true</span>;</span>
<span class="line" id="L819">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L820">                        },</span>
<span class="line" id="L821">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L822">                    }</span>
<span class="line" id="L823">                },</span>
<span class="line" id="L824"></span>
<span class="line" id="L825">                .array_start =&gt; {</span>
<span class="line" id="L826">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.skipWhitespaceExpectByte()) {</span>
<span class="line" id="L827">                        <span class="tok-str">']'</span> =&gt; {</span>
<span class="line" id="L828">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L829">                            _ = self.stack.pop();</span>
<span class="line" id="L830">                            self.state = .post_value;</span>
<span class="line" id="L831">                            <span class="tok-kw">return</span> .array_end;</span>
<span class="line" id="L832">                        },</span>
<span class="line" id="L833">                        <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L834">                            self.state = .value;</span>
<span class="line" id="L835">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L836">                        },</span>
<span class="line" id="L837">                    }</span>
<span class="line" id="L838">                },</span>
<span class="line" id="L839"></span>
<span class="line" id="L840">                .number_minus =&gt; {</span>
<span class="line" id="L841">                    <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInNumber(<span class="tok-null">false</span>);</span>
<span class="line" id="L842">                    <span class="tok-kw">switch</span> (self.input[self.cursor]) {</span>
<span class="line" id="L843">                        <span class="tok-str">'0'</span> =&gt; {</span>
<span class="line" id="L844">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L845">                            self.state = .number_leading_zero;</span>
<span class="line" id="L846">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L847">                        },</span>
<span class="line" id="L848">                        <span class="tok-str">'1'</span>...<span class="tok-str">'9'</span> =&gt; {</span>
<span class="line" id="L849">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L850">                            self.state = .number_int;</span>
<span class="line" id="L851">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L852">                        },</span>
<span class="line" id="L853">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L854">                    }</span>
<span class="line" id="L855">                },</span>
<span class="line" id="L856">                .number_leading_zero =&gt; {</span>
<span class="line" id="L857">                    <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInNumber(<span class="tok-null">true</span>);</span>
<span class="line" id="L858">                    <span class="tok-kw">switch</span> (self.input[self.cursor]) {</span>
<span class="line" id="L859">                        <span class="tok-str">'.'</span> =&gt; {</span>
<span class="line" id="L860">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L861">                            self.state = .number_post_dot;</span>
<span class="line" id="L862">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L863">                        },</span>
<span class="line" id="L864">                        <span class="tok-str">'e'</span>, <span class="tok-str">'E'</span> =&gt; {</span>
<span class="line" id="L865">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L866">                            self.state = .number_post_e;</span>
<span class="line" id="L867">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L868">                        },</span>
<span class="line" id="L869">                        <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L870">                            self.state = .post_value;</span>
<span class="line" id="L871">                            <span class="tok-kw">return</span> Token{ .number = self.takeValueSlice() };</span>
<span class="line" id="L872">                        },</span>
<span class="line" id="L873">                    }</span>
<span class="line" id="L874">                },</span>
<span class="line" id="L875">                .number_int =&gt; {</span>
<span class="line" id="L876">                    <span class="tok-kw">while</span> (self.cursor &lt; self.input.len) : (self.cursor += <span class="tok-number">1</span>) {</span>
<span class="line" id="L877">                        <span class="tok-kw">switch</span> (self.input[self.cursor]) {</span>
<span class="line" id="L878">                            <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L879">                            <span class="tok-str">'.'</span> =&gt; {</span>
<span class="line" id="L880">                                self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L881">                                self.state = .number_post_dot;</span>
<span class="line" id="L882">                                <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L883">                            },</span>
<span class="line" id="L884">                            <span class="tok-str">'e'</span>, <span class="tok-str">'E'</span> =&gt; {</span>
<span class="line" id="L885">                                self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L886">                                self.state = .number_post_e;</span>
<span class="line" id="L887">                                <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L888">                            },</span>
<span class="line" id="L889">                            <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L890">                                self.state = .post_value;</span>
<span class="line" id="L891">                                <span class="tok-kw">return</span> Token{ .number = self.takeValueSlice() };</span>
<span class="line" id="L892">                            },</span>
<span class="line" id="L893">                        }</span>
<span class="line" id="L894">                    }</span>
<span class="line" id="L895">                    <span class="tok-kw">return</span> self.endOfBufferInNumber(<span class="tok-null">true</span>);</span>
<span class="line" id="L896">                },</span>
<span class="line" id="L897">                .number_post_dot =&gt; {</span>
<span class="line" id="L898">                    <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInNumber(<span class="tok-null">false</span>);</span>
<span class="line" id="L899">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L900">                        <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {</span>
<span class="line" id="L901">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L902">                            self.state = .number_frac;</span>
<span class="line" id="L903">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L904">                        },</span>
<span class="line" id="L905">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L906">                    }</span>
<span class="line" id="L907">                },</span>
<span class="line" id="L908">                .number_frac =&gt; {</span>
<span class="line" id="L909">                    <span class="tok-kw">while</span> (self.cursor &lt; self.input.len) : (self.cursor += <span class="tok-number">1</span>) {</span>
<span class="line" id="L910">                        <span class="tok-kw">switch</span> (self.input[self.cursor]) {</span>
<span class="line" id="L911">                            <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L912">                            <span class="tok-str">'e'</span>, <span class="tok-str">'E'</span> =&gt; {</span>
<span class="line" id="L913">                                self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L914">                                self.state = .number_post_e;</span>
<span class="line" id="L915">                                <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L916">                            },</span>
<span class="line" id="L917">                            <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L918">                                self.state = .post_value;</span>
<span class="line" id="L919">                                <span class="tok-kw">return</span> Token{ .number = self.takeValueSlice() };</span>
<span class="line" id="L920">                            },</span>
<span class="line" id="L921">                        }</span>
<span class="line" id="L922">                    }</span>
<span class="line" id="L923">                    <span class="tok-kw">return</span> self.endOfBufferInNumber(<span class="tok-null">true</span>);</span>
<span class="line" id="L924">                },</span>
<span class="line" id="L925">                .number_post_e =&gt; {</span>
<span class="line" id="L926">                    <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInNumber(<span class="tok-null">false</span>);</span>
<span class="line" id="L927">                    <span class="tok-kw">switch</span> (self.input[self.cursor]) {</span>
<span class="line" id="L928">                        <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {</span>
<span class="line" id="L929">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L930">                            self.state = .number_exp;</span>
<span class="line" id="L931">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L932">                        },</span>
<span class="line" id="L933">                        <span class="tok-str">'+'</span>, <span class="tok-str">'-'</span> =&gt; {</span>
<span class="line" id="L934">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L935">                            self.state = .number_post_e_sign;</span>
<span class="line" id="L936">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L937">                        },</span>
<span class="line" id="L938">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L939">                    }</span>
<span class="line" id="L940">                },</span>
<span class="line" id="L941">                .number_post_e_sign =&gt; {</span>
<span class="line" id="L942">                    <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInNumber(<span class="tok-null">false</span>);</span>
<span class="line" id="L943">                    <span class="tok-kw">switch</span> (self.input[self.cursor]) {</span>
<span class="line" id="L944">                        <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {</span>
<span class="line" id="L945">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L946">                            self.state = .number_exp;</span>
<span class="line" id="L947">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L948">                        },</span>
<span class="line" id="L949">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L950">                    }</span>
<span class="line" id="L951">                },</span>
<span class="line" id="L952">                .number_exp =&gt; {</span>
<span class="line" id="L953">                    <span class="tok-kw">while</span> (self.cursor &lt; self.input.len) : (self.cursor += <span class="tok-number">1</span>) {</span>
<span class="line" id="L954">                        <span class="tok-kw">switch</span> (self.input[self.cursor]) {</span>
<span class="line" id="L955">                            <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L956">                            <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L957">                                self.state = .post_value;</span>
<span class="line" id="L958">                                <span class="tok-kw">return</span> Token{ .number = self.takeValueSlice() };</span>
<span class="line" id="L959">                            },</span>
<span class="line" id="L960">                        }</span>
<span class="line" id="L961">                    }</span>
<span class="line" id="L962">                    <span class="tok-kw">return</span> self.endOfBufferInNumber(<span class="tok-null">true</span>);</span>
<span class="line" id="L963">                },</span>
<span class="line" id="L964"></span>
<span class="line" id="L965">                .string =&gt; {</span>
<span class="line" id="L966">                    <span class="tok-kw">while</span> (self.cursor &lt; self.input.len) : (self.cursor += <span class="tok-number">1</span>) {</span>
<span class="line" id="L967">                        <span class="tok-kw">switch</span> (self.input[self.cursor]) {</span>
<span class="line" id="L968">                            <span class="tok-number">0</span>...<span class="tok-number">0x1f</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError, <span class="tok-comment">// Bare ASCII control code in string.</span>
</span>
<span class="line" id="L969"></span>
<span class="line" id="L970">                            <span class="tok-comment">// ASCII plain text.</span>
</span>
<span class="line" id="L971">                            <span class="tok-number">0x20</span>...(<span class="tok-str">'&quot;'</span> - <span class="tok-number">1</span>), (<span class="tok-str">'&quot;'</span> + <span class="tok-number">1</span>)...(<span class="tok-str">'\\'</span> - <span class="tok-number">1</span>), (<span class="tok-str">'\\'</span> + <span class="tok-number">1</span>)...<span class="tok-number">0x7F</span> =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L972"></span>
<span class="line" id="L973">                            <span class="tok-comment">// Special characters.</span>
</span>
<span class="line" id="L974">                            <span class="tok-str">'&quot;'</span> =&gt; {</span>
<span class="line" id="L975">                                <span class="tok-kw">const</span> result = Token{ .string = self.takeValueSlice() };</span>
<span class="line" id="L976">                                self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L977">                                self.state = .post_value;</span>
<span class="line" id="L978">                                <span class="tok-kw">return</span> result;</span>
<span class="line" id="L979">                            },</span>
<span class="line" id="L980">                            <span class="tok-str">'\\'</span> =&gt; {</span>
<span class="line" id="L981">                                <span class="tok-kw">const</span> slice = self.takeValueSlice();</span>
<span class="line" id="L982">                                self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L983">                                self.state = .string_backslash;</span>
<span class="line" id="L984">                                <span class="tok-kw">if</span> (slice.len &gt; <span class="tok-number">0</span>) <span class="tok-kw">return</span> Token{ .partial_string = slice };</span>
<span class="line" id="L985">                                <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L986">                            },</span>
<span class="line" id="L987"></span>
<span class="line" id="L988">                            <span class="tok-comment">// UTF-8 validation.</span>
</span>
<span class="line" id="L989">                            <span class="tok-comment">// See http://unicode.org/mail-arch/unicode-ml/y2003-m02/att-0467/01-The_Algorithm_to_Valide_an_UTF-8_String</span>
</span>
<span class="line" id="L990">                            <span class="tok-number">0xC2</span>...<span class="tok-number">0xDF</span> =&gt; {</span>
<span class="line" id="L991">                                self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L992">                                self.state = .string_utf8_last_byte;</span>
<span class="line" id="L993">                                <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L994">                            },</span>
<span class="line" id="L995">                            <span class="tok-number">0xE0</span> =&gt; {</span>
<span class="line" id="L996">                                self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L997">                                self.state = .string_utf8_second_to_last_byte_guard_against_overlong;</span>
<span class="line" id="L998">                                <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L999">                            },</span>
<span class="line" id="L1000">                            <span class="tok-number">0xE1</span>...<span class="tok-number">0xEC</span>, <span class="tok-number">0xEE</span>...<span class="tok-number">0xEF</span> =&gt; {</span>
<span class="line" id="L1001">                                self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1002">                                self.state = .string_utf8_second_to_last_byte;</span>
<span class="line" id="L1003">                                <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1004">                            },</span>
<span class="line" id="L1005">                            <span class="tok-number">0xED</span> =&gt; {</span>
<span class="line" id="L1006">                                self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1007">                                self.state = .string_utf8_second_to_last_byte_guard_against_surrogate_half;</span>
<span class="line" id="L1008">                                <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1009">                            },</span>
<span class="line" id="L1010">                            <span class="tok-number">0xF0</span> =&gt; {</span>
<span class="line" id="L1011">                                self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1012">                                self.state = .string_utf8_third_to_last_byte_guard_against_overlong;</span>
<span class="line" id="L1013">                                <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1014">                            },</span>
<span class="line" id="L1015">                            <span class="tok-number">0xF1</span>...<span class="tok-number">0xF3</span> =&gt; {</span>
<span class="line" id="L1016">                                self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1017">                                self.state = .string_utf8_third_to_last_byte;</span>
<span class="line" id="L1018">                                <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1019">                            },</span>
<span class="line" id="L1020">                            <span class="tok-number">0xF4</span> =&gt; {</span>
<span class="line" id="L1021">                                self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1022">                                self.state = .string_utf8_third_to_last_byte_guard_against_too_large;</span>
<span class="line" id="L1023">                                <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1024">                            },</span>
<span class="line" id="L1025">                            <span class="tok-number">0x80</span>...<span class="tok-number">0xC1</span>, <span class="tok-number">0xF5</span>...<span class="tok-number">0xFF</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError, <span class="tok-comment">// Invalid UTF-8.</span>
</span>
<span class="line" id="L1026">                        }</span>
<span class="line" id="L1027">                    }</span>
<span class="line" id="L1028">                    <span class="tok-kw">if</span> (self.is_end_of_input) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedEndOfInput;</span>
<span class="line" id="L1029">                    <span class="tok-kw">const</span> slice = self.takeValueSlice();</span>
<span class="line" id="L1030">                    <span class="tok-kw">if</span> (slice.len &gt; <span class="tok-number">0</span>) <span class="tok-kw">return</span> Token{ .partial_string = slice };</span>
<span class="line" id="L1031">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BufferUnderrun;</span>
<span class="line" id="L1032">                },</span>
<span class="line" id="L1033">                .string_backslash =&gt; {</span>
<span class="line" id="L1034">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1035">                        <span class="tok-str">'&quot;'</span>, <span class="tok-str">'\\'</span>, <span class="tok-str">'/'</span> =&gt; {</span>
<span class="line" id="L1036">                            <span class="tok-comment">// Since these characters now represent themselves literally,</span>
</span>
<span class="line" id="L1037">                            <span class="tok-comment">// we can simply begin the next plaintext slice here.</span>
</span>
<span class="line" id="L1038">                            self.value_start = self.cursor;</span>
<span class="line" id="L1039">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1040">                            self.state = .string;</span>
<span class="line" id="L1041">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1042">                        },</span>
<span class="line" id="L1043">                        <span class="tok-str">'b'</span> =&gt; {</span>
<span class="line" id="L1044">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1045">                            self.value_start = self.cursor;</span>
<span class="line" id="L1046">                            self.state = .string;</span>
<span class="line" id="L1047">                            <span class="tok-kw">return</span> Token{ .partial_string_escaped_1 = [_]<span class="tok-type">u8</span>{<span class="tok-number">0x08</span>} };</span>
<span class="line" id="L1048">                        },</span>
<span class="line" id="L1049">                        <span class="tok-str">'f'</span> =&gt; {</span>
<span class="line" id="L1050">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1051">                            self.value_start = self.cursor;</span>
<span class="line" id="L1052">                            self.state = .string;</span>
<span class="line" id="L1053">                            <span class="tok-kw">return</span> Token{ .partial_string_escaped_1 = [_]<span class="tok-type">u8</span>{<span class="tok-number">0x0c</span>} };</span>
<span class="line" id="L1054">                        },</span>
<span class="line" id="L1055">                        <span class="tok-str">'n'</span> =&gt; {</span>
<span class="line" id="L1056">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1057">                            self.value_start = self.cursor;</span>
<span class="line" id="L1058">                            self.state = .string;</span>
<span class="line" id="L1059">                            <span class="tok-kw">return</span> Token{ .partial_string_escaped_1 = [_]<span class="tok-type">u8</span>{<span class="tok-str">'\n'</span>} };</span>
<span class="line" id="L1060">                        },</span>
<span class="line" id="L1061">                        <span class="tok-str">'r'</span> =&gt; {</span>
<span class="line" id="L1062">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1063">                            self.value_start = self.cursor;</span>
<span class="line" id="L1064">                            self.state = .string;</span>
<span class="line" id="L1065">                            <span class="tok-kw">return</span> Token{ .partial_string_escaped_1 = [_]<span class="tok-type">u8</span>{<span class="tok-str">'\r'</span>} };</span>
<span class="line" id="L1066">                        },</span>
<span class="line" id="L1067">                        <span class="tok-str">'t'</span> =&gt; {</span>
<span class="line" id="L1068">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1069">                            self.value_start = self.cursor;</span>
<span class="line" id="L1070">                            self.state = .string;</span>
<span class="line" id="L1071">                            <span class="tok-kw">return</span> Token{ .partial_string_escaped_1 = [_]<span class="tok-type">u8</span>{<span class="tok-str">'\t'</span>} };</span>
<span class="line" id="L1072">                        },</span>
<span class="line" id="L1073">                        <span class="tok-str">'u'</span> =&gt; {</span>
<span class="line" id="L1074">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1075">                            self.state = .string_backslash_u;</span>
<span class="line" id="L1076">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1077">                        },</span>
<span class="line" id="L1078">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1079">                    }</span>
<span class="line" id="L1080">                },</span>
<span class="line" id="L1081">                .string_backslash_u =&gt; {</span>
<span class="line" id="L1082">                    <span class="tok-kw">const</span> c = <span class="tok-kw">try</span> self.expectByte();</span>
<span class="line" id="L1083">                    <span class="tok-kw">switch</span> (c) {</span>
<span class="line" id="L1084">                        <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {</span>
<span class="line" id="L1085">                            self.unicode_code_point = <span class="tok-builtin">@as</span>(<span class="tok-type">u21</span>, c - <span class="tok-str">'0'</span>) &lt;&lt; <span class="tok-number">12</span>;</span>
<span class="line" id="L1086">                        },</span>
<span class="line" id="L1087">                        <span class="tok-str">'A'</span>...<span class="tok-str">'F'</span> =&gt; {</span>
<span class="line" id="L1088">                            self.unicode_code_point = <span class="tok-builtin">@as</span>(<span class="tok-type">u21</span>, c - <span class="tok-str">'A'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">12</span>;</span>
<span class="line" id="L1089">                        },</span>
<span class="line" id="L1090">                        <span class="tok-str">'a'</span>...<span class="tok-str">'f'</span> =&gt; {</span>
<span class="line" id="L1091">                            self.unicode_code_point = <span class="tok-builtin">@as</span>(<span class="tok-type">u21</span>, c - <span class="tok-str">'a'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">12</span>;</span>
<span class="line" id="L1092">                        },</span>
<span class="line" id="L1093">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1094">                    }</span>
<span class="line" id="L1095">                    self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1096">                    self.state = .string_backslash_u_1;</span>
<span class="line" id="L1097">                    <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1098">                },</span>
<span class="line" id="L1099">                .string_backslash_u_1 =&gt; {</span>
<span class="line" id="L1100">                    <span class="tok-kw">const</span> c = <span class="tok-kw">try</span> self.expectByte();</span>
<span class="line" id="L1101">                    <span class="tok-kw">switch</span> (c) {</span>
<span class="line" id="L1102">                        <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {</span>
<span class="line" id="L1103">                            self.unicode_code_point |= <span class="tok-builtin">@as</span>(<span class="tok-type">u21</span>, c - <span class="tok-str">'0'</span>) &lt;&lt; <span class="tok-number">8</span>;</span>
<span class="line" id="L1104">                        },</span>
<span class="line" id="L1105">                        <span class="tok-str">'A'</span>...<span class="tok-str">'F'</span> =&gt; {</span>
<span class="line" id="L1106">                            self.unicode_code_point |= <span class="tok-builtin">@as</span>(<span class="tok-type">u21</span>, c - <span class="tok-str">'A'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">8</span>;</span>
<span class="line" id="L1107">                        },</span>
<span class="line" id="L1108">                        <span class="tok-str">'a'</span>...<span class="tok-str">'f'</span> =&gt; {</span>
<span class="line" id="L1109">                            self.unicode_code_point |= <span class="tok-builtin">@as</span>(<span class="tok-type">u21</span>, c - <span class="tok-str">'a'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">8</span>;</span>
<span class="line" id="L1110">                        },</span>
<span class="line" id="L1111">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1112">                    }</span>
<span class="line" id="L1113">                    self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1114">                    self.state = .string_backslash_u_2;</span>
<span class="line" id="L1115">                    <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1116">                },</span>
<span class="line" id="L1117">                .string_backslash_u_2 =&gt; {</span>
<span class="line" id="L1118">                    <span class="tok-kw">const</span> c = <span class="tok-kw">try</span> self.expectByte();</span>
<span class="line" id="L1119">                    <span class="tok-kw">switch</span> (c) {</span>
<span class="line" id="L1120">                        <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {</span>
<span class="line" id="L1121">                            self.unicode_code_point |= <span class="tok-builtin">@as</span>(<span class="tok-type">u21</span>, c - <span class="tok-str">'0'</span>) &lt;&lt; <span class="tok-number">4</span>;</span>
<span class="line" id="L1122">                        },</span>
<span class="line" id="L1123">                        <span class="tok-str">'A'</span>...<span class="tok-str">'F'</span> =&gt; {</span>
<span class="line" id="L1124">                            self.unicode_code_point |= <span class="tok-builtin">@as</span>(<span class="tok-type">u21</span>, c - <span class="tok-str">'A'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">4</span>;</span>
<span class="line" id="L1125">                        },</span>
<span class="line" id="L1126">                        <span class="tok-str">'a'</span>...<span class="tok-str">'f'</span> =&gt; {</span>
<span class="line" id="L1127">                            self.unicode_code_point |= <span class="tok-builtin">@as</span>(<span class="tok-type">u21</span>, c - <span class="tok-str">'a'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">4</span>;</span>
<span class="line" id="L1128">                        },</span>
<span class="line" id="L1129">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1130">                    }</span>
<span class="line" id="L1131">                    self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1132">                    self.state = .string_backslash_u_3;</span>
<span class="line" id="L1133">                    <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1134">                },</span>
<span class="line" id="L1135">                .string_backslash_u_3 =&gt; {</span>
<span class="line" id="L1136">                    <span class="tok-kw">const</span> c = <span class="tok-kw">try</span> self.expectByte();</span>
<span class="line" id="L1137">                    <span class="tok-kw">switch</span> (c) {</span>
<span class="line" id="L1138">                        <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {</span>
<span class="line" id="L1139">                            self.unicode_code_point |= c - <span class="tok-str">'0'</span>;</span>
<span class="line" id="L1140">                        },</span>
<span class="line" id="L1141">                        <span class="tok-str">'A'</span>...<span class="tok-str">'F'</span> =&gt; {</span>
<span class="line" id="L1142">                            self.unicode_code_point |= c - <span class="tok-str">'A'</span> + <span class="tok-number">10</span>;</span>
<span class="line" id="L1143">                        },</span>
<span class="line" id="L1144">                        <span class="tok-str">'a'</span>...<span class="tok-str">'f'</span> =&gt; {</span>
<span class="line" id="L1145">                            self.unicode_code_point |= c - <span class="tok-str">'a'</span> + <span class="tok-number">10</span>;</span>
<span class="line" id="L1146">                        },</span>
<span class="line" id="L1147">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1148">                    }</span>
<span class="line" id="L1149">                    self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1150">                    <span class="tok-kw">switch</span> (self.unicode_code_point) {</span>
<span class="line" id="L1151">                        <span class="tok-number">0xD800</span>...<span class="tok-number">0xDBFF</span> =&gt; {</span>
<span class="line" id="L1152">                            <span class="tok-comment">// High surrogate half.</span>
</span>
<span class="line" id="L1153">                            self.unicode_code_point = <span class="tok-number">0x10000</span> | (self.unicode_code_point &lt;&lt; <span class="tok-number">10</span>);</span>
<span class="line" id="L1154">                            self.state = .string_surrogate_half;</span>
<span class="line" id="L1155">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1156">                        },</span>
<span class="line" id="L1157">                        <span class="tok-number">0xDC00</span>...<span class="tok-number">0xDFFF</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError, <span class="tok-comment">// Unexpected low surrogate half.</span>
</span>
<span class="line" id="L1158">                        <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L1159">                            <span class="tok-comment">// Code point from a single UTF-16 code unit.</span>
</span>
<span class="line" id="L1160">                            self.value_start = self.cursor;</span>
<span class="line" id="L1161">                            self.state = .string;</span>
<span class="line" id="L1162">                            <span class="tok-kw">return</span> self.partialStringCodepoint();</span>
<span class="line" id="L1163">                        },</span>
<span class="line" id="L1164">                    }</span>
<span class="line" id="L1165">                },</span>
<span class="line" id="L1166">                .string_surrogate_half =&gt; {</span>
<span class="line" id="L1167">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1168">                        <span class="tok-str">'\\'</span> =&gt; {</span>
<span class="line" id="L1169">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1170">                            self.state = .string_surrogate_half_backslash;</span>
<span class="line" id="L1171">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1172">                        },</span>
<span class="line" id="L1173">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError, <span class="tok-comment">// Expected low surrogate half.</span>
</span>
<span class="line" id="L1174">                    }</span>
<span class="line" id="L1175">                },</span>
<span class="line" id="L1176">                .string_surrogate_half_backslash =&gt; {</span>
<span class="line" id="L1177">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1178">                        <span class="tok-str">'u'</span> =&gt; {</span>
<span class="line" id="L1179">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1180">                            self.state = .string_surrogate_half_backslash_u;</span>
<span class="line" id="L1181">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1182">                        },</span>
<span class="line" id="L1183">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError, <span class="tok-comment">// Expected low surrogate half.</span>
</span>
<span class="line" id="L1184">                    }</span>
<span class="line" id="L1185">                },</span>
<span class="line" id="L1186">                .string_surrogate_half_backslash_u =&gt; {</span>
<span class="line" id="L1187">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1188">                        <span class="tok-str">'D'</span>, <span class="tok-str">'d'</span> =&gt; {</span>
<span class="line" id="L1189">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1190">                            self.state = .string_surrogate_half_backslash_u_1;</span>
<span class="line" id="L1191">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1192">                        },</span>
<span class="line" id="L1193">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError, <span class="tok-comment">// Expected low surrogate half.</span>
</span>
<span class="line" id="L1194">                    }</span>
<span class="line" id="L1195">                },</span>
<span class="line" id="L1196">                .string_surrogate_half_backslash_u_1 =&gt; {</span>
<span class="line" id="L1197">                    <span class="tok-kw">const</span> c = <span class="tok-kw">try</span> self.expectByte();</span>
<span class="line" id="L1198">                    <span class="tok-kw">switch</span> (c) {</span>
<span class="line" id="L1199">                        <span class="tok-str">'C'</span>...<span class="tok-str">'F'</span> =&gt; {</span>
<span class="line" id="L1200">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1201">                            self.unicode_code_point |= <span class="tok-builtin">@as</span>(<span class="tok-type">u21</span>, c - <span class="tok-str">'C'</span>) &lt;&lt; <span class="tok-number">8</span>;</span>
<span class="line" id="L1202">                            self.state = .string_surrogate_half_backslash_u_2;</span>
<span class="line" id="L1203">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1204">                        },</span>
<span class="line" id="L1205">                        <span class="tok-str">'c'</span>...<span class="tok-str">'f'</span> =&gt; {</span>
<span class="line" id="L1206">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1207">                            self.unicode_code_point |= <span class="tok-builtin">@as</span>(<span class="tok-type">u21</span>, c - <span class="tok-str">'c'</span>) &lt;&lt; <span class="tok-number">8</span>;</span>
<span class="line" id="L1208">                            self.state = .string_surrogate_half_backslash_u_2;</span>
<span class="line" id="L1209">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1210">                        },</span>
<span class="line" id="L1211">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError, <span class="tok-comment">// Expected low surrogate half.</span>
</span>
<span class="line" id="L1212">                    }</span>
<span class="line" id="L1213">                },</span>
<span class="line" id="L1214">                .string_surrogate_half_backslash_u_2 =&gt; {</span>
<span class="line" id="L1215">                    <span class="tok-kw">const</span> c = <span class="tok-kw">try</span> self.expectByte();</span>
<span class="line" id="L1216">                    <span class="tok-kw">switch</span> (c) {</span>
<span class="line" id="L1217">                        <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {</span>
<span class="line" id="L1218">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1219">                            self.unicode_code_point |= <span class="tok-builtin">@as</span>(<span class="tok-type">u21</span>, c - <span class="tok-str">'0'</span>) &lt;&lt; <span class="tok-number">4</span>;</span>
<span class="line" id="L1220">                            self.state = .string_surrogate_half_backslash_u_3;</span>
<span class="line" id="L1221">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1222">                        },</span>
<span class="line" id="L1223">                        <span class="tok-str">'A'</span>...<span class="tok-str">'F'</span> =&gt; {</span>
<span class="line" id="L1224">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1225">                            self.unicode_code_point |= <span class="tok-builtin">@as</span>(<span class="tok-type">u21</span>, c - <span class="tok-str">'A'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">4</span>;</span>
<span class="line" id="L1226">                            self.state = .string_surrogate_half_backslash_u_3;</span>
<span class="line" id="L1227">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1228">                        },</span>
<span class="line" id="L1229">                        <span class="tok-str">'a'</span>...<span class="tok-str">'f'</span> =&gt; {</span>
<span class="line" id="L1230">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1231">                            self.unicode_code_point |= <span class="tok-builtin">@as</span>(<span class="tok-type">u21</span>, c - <span class="tok-str">'a'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">4</span>;</span>
<span class="line" id="L1232">                            self.state = .string_surrogate_half_backslash_u_3;</span>
<span class="line" id="L1233">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1234">                        },</span>
<span class="line" id="L1235">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1236">                    }</span>
<span class="line" id="L1237">                },</span>
<span class="line" id="L1238">                .string_surrogate_half_backslash_u_3 =&gt; {</span>
<span class="line" id="L1239">                    <span class="tok-kw">const</span> c = <span class="tok-kw">try</span> self.expectByte();</span>
<span class="line" id="L1240">                    <span class="tok-kw">switch</span> (c) {</span>
<span class="line" id="L1241">                        <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {</span>
<span class="line" id="L1242">                            self.unicode_code_point |= c - <span class="tok-str">'0'</span>;</span>
<span class="line" id="L1243">                        },</span>
<span class="line" id="L1244">                        <span class="tok-str">'A'</span>...<span class="tok-str">'F'</span> =&gt; {</span>
<span class="line" id="L1245">                            self.unicode_code_point |= c - <span class="tok-str">'A'</span> + <span class="tok-number">10</span>;</span>
<span class="line" id="L1246">                        },</span>
<span class="line" id="L1247">                        <span class="tok-str">'a'</span>...<span class="tok-str">'f'</span> =&gt; {</span>
<span class="line" id="L1248">                            self.unicode_code_point |= c - <span class="tok-str">'a'</span> + <span class="tok-number">10</span>;</span>
<span class="line" id="L1249">                        },</span>
<span class="line" id="L1250">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1251">                    }</span>
<span class="line" id="L1252">                    self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1253">                    self.value_start = self.cursor;</span>
<span class="line" id="L1254">                    self.state = .string;</span>
<span class="line" id="L1255">                    <span class="tok-kw">return</span> self.partialStringCodepoint();</span>
<span class="line" id="L1256">                },</span>
<span class="line" id="L1257"></span>
<span class="line" id="L1258">                .string_utf8_last_byte =&gt; {</span>
<span class="line" id="L1259">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1260">                        <span class="tok-number">0x80</span>...<span class="tok-number">0xBF</span> =&gt; {</span>
<span class="line" id="L1261">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1262">                            self.state = .string;</span>
<span class="line" id="L1263">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1264">                        },</span>
<span class="line" id="L1265">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError, <span class="tok-comment">// Invalid UTF-8.</span>
</span>
<span class="line" id="L1266">                    }</span>
<span class="line" id="L1267">                },</span>
<span class="line" id="L1268">                .string_utf8_second_to_last_byte =&gt; {</span>
<span class="line" id="L1269">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1270">                        <span class="tok-number">0x80</span>...<span class="tok-number">0xBF</span> =&gt; {</span>
<span class="line" id="L1271">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1272">                            self.state = .string_utf8_last_byte;</span>
<span class="line" id="L1273">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1274">                        },</span>
<span class="line" id="L1275">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError, <span class="tok-comment">// Invalid UTF-8.</span>
</span>
<span class="line" id="L1276">                    }</span>
<span class="line" id="L1277">                },</span>
<span class="line" id="L1278">                .string_utf8_second_to_last_byte_guard_against_overlong =&gt; {</span>
<span class="line" id="L1279">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1280">                        <span class="tok-number">0xA0</span>...<span class="tok-number">0xBF</span> =&gt; {</span>
<span class="line" id="L1281">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1282">                            self.state = .string_utf8_last_byte;</span>
<span class="line" id="L1283">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1284">                        },</span>
<span class="line" id="L1285">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError, <span class="tok-comment">// Invalid UTF-8.</span>
</span>
<span class="line" id="L1286">                    }</span>
<span class="line" id="L1287">                },</span>
<span class="line" id="L1288">                .string_utf8_second_to_last_byte_guard_against_surrogate_half =&gt; {</span>
<span class="line" id="L1289">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1290">                        <span class="tok-number">0x80</span>...<span class="tok-number">0x9F</span> =&gt; {</span>
<span class="line" id="L1291">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1292">                            self.state = .string_utf8_last_byte;</span>
<span class="line" id="L1293">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1294">                        },</span>
<span class="line" id="L1295">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError, <span class="tok-comment">// Invalid UTF-8.</span>
</span>
<span class="line" id="L1296">                    }</span>
<span class="line" id="L1297">                },</span>
<span class="line" id="L1298">                .string_utf8_third_to_last_byte =&gt; {</span>
<span class="line" id="L1299">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1300">                        <span class="tok-number">0x80</span>...<span class="tok-number">0xBF</span> =&gt; {</span>
<span class="line" id="L1301">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1302">                            self.state = .string_utf8_second_to_last_byte;</span>
<span class="line" id="L1303">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1304">                        },</span>
<span class="line" id="L1305">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError, <span class="tok-comment">// Invalid UTF-8.</span>
</span>
<span class="line" id="L1306">                    }</span>
<span class="line" id="L1307">                },</span>
<span class="line" id="L1308">                .string_utf8_third_to_last_byte_guard_against_overlong =&gt; {</span>
<span class="line" id="L1309">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1310">                        <span class="tok-number">0x90</span>...<span class="tok-number">0xBF</span> =&gt; {</span>
<span class="line" id="L1311">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1312">                            self.state = .string_utf8_second_to_last_byte;</span>
<span class="line" id="L1313">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1314">                        },</span>
<span class="line" id="L1315">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError, <span class="tok-comment">// Invalid UTF-8.</span>
</span>
<span class="line" id="L1316">                    }</span>
<span class="line" id="L1317">                },</span>
<span class="line" id="L1318">                .string_utf8_third_to_last_byte_guard_against_too_large =&gt; {</span>
<span class="line" id="L1319">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1320">                        <span class="tok-number">0x80</span>...<span class="tok-number">0x8F</span> =&gt; {</span>
<span class="line" id="L1321">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1322">                            self.state = .string_utf8_second_to_last_byte;</span>
<span class="line" id="L1323">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1324">                        },</span>
<span class="line" id="L1325">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError, <span class="tok-comment">// Invalid UTF-8.</span>
</span>
<span class="line" id="L1326">                    }</span>
<span class="line" id="L1327">                },</span>
<span class="line" id="L1328"></span>
<span class="line" id="L1329">                .literal_t =&gt; {</span>
<span class="line" id="L1330">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1331">                        <span class="tok-str">'r'</span> =&gt; {</span>
<span class="line" id="L1332">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1333">                            self.state = .literal_tr;</span>
<span class="line" id="L1334">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1335">                        },</span>
<span class="line" id="L1336">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1337">                    }</span>
<span class="line" id="L1338">                },</span>
<span class="line" id="L1339">                .literal_tr =&gt; {</span>
<span class="line" id="L1340">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1341">                        <span class="tok-str">'u'</span> =&gt; {</span>
<span class="line" id="L1342">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1343">                            self.state = .literal_tru;</span>
<span class="line" id="L1344">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1345">                        },</span>
<span class="line" id="L1346">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1347">                    }</span>
<span class="line" id="L1348">                },</span>
<span class="line" id="L1349">                .literal_tru =&gt; {</span>
<span class="line" id="L1350">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1351">                        <span class="tok-str">'e'</span> =&gt; {</span>
<span class="line" id="L1352">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1353">                            self.state = .post_value;</span>
<span class="line" id="L1354">                            <span class="tok-kw">return</span> .<span class="tok-null">true</span>;</span>
<span class="line" id="L1355">                        },</span>
<span class="line" id="L1356">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1357">                    }</span>
<span class="line" id="L1358">                },</span>
<span class="line" id="L1359">                .literal_f =&gt; {</span>
<span class="line" id="L1360">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1361">                        <span class="tok-str">'a'</span> =&gt; {</span>
<span class="line" id="L1362">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1363">                            self.state = .literal_fa;</span>
<span class="line" id="L1364">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1365">                        },</span>
<span class="line" id="L1366">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1367">                    }</span>
<span class="line" id="L1368">                },</span>
<span class="line" id="L1369">                .literal_fa =&gt; {</span>
<span class="line" id="L1370">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1371">                        <span class="tok-str">'l'</span> =&gt; {</span>
<span class="line" id="L1372">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1373">                            self.state = .literal_fal;</span>
<span class="line" id="L1374">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1375">                        },</span>
<span class="line" id="L1376">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1377">                    }</span>
<span class="line" id="L1378">                },</span>
<span class="line" id="L1379">                .literal_fal =&gt; {</span>
<span class="line" id="L1380">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1381">                        <span class="tok-str">'s'</span> =&gt; {</span>
<span class="line" id="L1382">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1383">                            self.state = .literal_fals;</span>
<span class="line" id="L1384">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1385">                        },</span>
<span class="line" id="L1386">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1387">                    }</span>
<span class="line" id="L1388">                },</span>
<span class="line" id="L1389">                .literal_fals =&gt; {</span>
<span class="line" id="L1390">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1391">                        <span class="tok-str">'e'</span> =&gt; {</span>
<span class="line" id="L1392">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1393">                            self.state = .post_value;</span>
<span class="line" id="L1394">                            <span class="tok-kw">return</span> .<span class="tok-null">false</span>;</span>
<span class="line" id="L1395">                        },</span>
<span class="line" id="L1396">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1397">                    }</span>
<span class="line" id="L1398">                },</span>
<span class="line" id="L1399">                .literal_n =&gt; {</span>
<span class="line" id="L1400">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1401">                        <span class="tok-str">'u'</span> =&gt; {</span>
<span class="line" id="L1402">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1403">                            self.state = .literal_nu;</span>
<span class="line" id="L1404">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1405">                        },</span>
<span class="line" id="L1406">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1407">                    }</span>
<span class="line" id="L1408">                },</span>
<span class="line" id="L1409">                .literal_nu =&gt; {</span>
<span class="line" id="L1410">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1411">                        <span class="tok-str">'l'</span> =&gt; {</span>
<span class="line" id="L1412">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1413">                            self.state = .literal_nul;</span>
<span class="line" id="L1414">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1415">                        },</span>
<span class="line" id="L1416">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1417">                    }</span>
<span class="line" id="L1418">                },</span>
<span class="line" id="L1419">                .literal_nul =&gt; {</span>
<span class="line" id="L1420">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1421">                        <span class="tok-str">'l'</span> =&gt; {</span>
<span class="line" id="L1422">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1423">                            self.state = .post_value;</span>
<span class="line" id="L1424">                            <span class="tok-kw">return</span> .<span class="tok-null">null</span>;</span>
<span class="line" id="L1425">                        },</span>
<span class="line" id="L1426">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1427">                    }</span>
<span class="line" id="L1428">                },</span>
<span class="line" id="L1429">            }</span>
<span class="line" id="L1430">            <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L1431">        }</span>
<span class="line" id="L1432">    }</span>
<span class="line" id="L1433"></span>
<span class="line" id="L1434">    <span class="tok-comment">/// Seeks ahead in the input until the first byte of the next token (or the end of the input)</span></span>
<span class="line" id="L1435">    <span class="tok-comment">/// determines which type of token will be returned from the next `next*()` call.</span></span>
<span class="line" id="L1436">    <span class="tok-comment">/// This function is idempotent, only advancing past commas, colons, and inter-token whitespace.</span></span>
<span class="line" id="L1437">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peekNextTokenType</span>(self: *<span class="tok-builtin">@This</span>()) PeekError!TokenType {</span>
<span class="line" id="L1438">        state_loop: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L1439">            <span class="tok-kw">switch</span> (self.state) {</span>
<span class="line" id="L1440">                .value =&gt; {</span>
<span class="line" id="L1441">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.skipWhitespaceExpectByte()) {</span>
<span class="line" id="L1442">                        <span class="tok-str">'{'</span> =&gt; <span class="tok-kw">return</span> .object_begin,</span>
<span class="line" id="L1443">                        <span class="tok-str">'['</span> =&gt; <span class="tok-kw">return</span> .array_begin,</span>
<span class="line" id="L1444">                        <span class="tok-str">'&quot;'</span> =&gt; <span class="tok-kw">return</span> .string,</span>
<span class="line" id="L1445">                        <span class="tok-str">'-'</span>, <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; <span class="tok-kw">return</span> .number,</span>
<span class="line" id="L1446">                        <span class="tok-str">'t'</span> =&gt; <span class="tok-kw">return</span> .<span class="tok-null">true</span>,</span>
<span class="line" id="L1447">                        <span class="tok-str">'f'</span> =&gt; <span class="tok-kw">return</span> .<span class="tok-null">false</span>,</span>
<span class="line" id="L1448">                        <span class="tok-str">'n'</span> =&gt; <span class="tok-kw">return</span> .<span class="tok-null">null</span>,</span>
<span class="line" id="L1449">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1450">                    }</span>
<span class="line" id="L1451">                },</span>
<span class="line" id="L1452"></span>
<span class="line" id="L1453">                .post_value =&gt; {</span>
<span class="line" id="L1454">                    <span class="tok-kw">if</span> (<span class="tok-kw">try</span> self.skipWhitespaceCheckEnd()) <span class="tok-kw">return</span> .end_of_document;</span>
<span class="line" id="L1455"></span>
<span class="line" id="L1456">                    <span class="tok-kw">const</span> c = self.input[self.cursor];</span>
<span class="line" id="L1457">                    <span class="tok-kw">if</span> (self.string_is_object_key) {</span>
<span class="line" id="L1458">                        self.string_is_object_key = <span class="tok-null">false</span>;</span>
<span class="line" id="L1459">                        <span class="tok-kw">switch</span> (c) {</span>
<span class="line" id="L1460">                            <span class="tok-str">':'</span> =&gt; {</span>
<span class="line" id="L1461">                                self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1462">                                self.state = .value;</span>
<span class="line" id="L1463">                                <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1464">                            },</span>
<span class="line" id="L1465">                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1466">                        }</span>
<span class="line" id="L1467">                    }</span>
<span class="line" id="L1468"></span>
<span class="line" id="L1469">                    <span class="tok-kw">switch</span> (c) {</span>
<span class="line" id="L1470">                        <span class="tok-str">'}'</span> =&gt; <span class="tok-kw">return</span> .object_end,</span>
<span class="line" id="L1471">                        <span class="tok-str">']'</span> =&gt; <span class="tok-kw">return</span> .array_end,</span>
<span class="line" id="L1472">                        <span class="tok-str">','</span> =&gt; {</span>
<span class="line" id="L1473">                            <span class="tok-kw">switch</span> (self.stack.peek()) {</span>
<span class="line" id="L1474">                                OBJECT_MODE =&gt; {</span>
<span class="line" id="L1475">                                    self.state = .object_post_comma;</span>
<span class="line" id="L1476">                                },</span>
<span class="line" id="L1477">                                ARRAY_MODE =&gt; {</span>
<span class="line" id="L1478">                                    self.state = .value;</span>
<span class="line" id="L1479">                                },</span>
<span class="line" id="L1480">                            }</span>
<span class="line" id="L1481">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1482">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1483">                        },</span>
<span class="line" id="L1484">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1485">                    }</span>
<span class="line" id="L1486">                },</span>
<span class="line" id="L1487"></span>
<span class="line" id="L1488">                .object_start =&gt; {</span>
<span class="line" id="L1489">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.skipWhitespaceExpectByte()) {</span>
<span class="line" id="L1490">                        <span class="tok-str">'&quot;'</span> =&gt; <span class="tok-kw">return</span> .string,</span>
<span class="line" id="L1491">                        <span class="tok-str">'}'</span> =&gt; <span class="tok-kw">return</span> .object_end,</span>
<span class="line" id="L1492">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1493">                    }</span>
<span class="line" id="L1494">                },</span>
<span class="line" id="L1495">                .object_post_comma =&gt; {</span>
<span class="line" id="L1496">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.skipWhitespaceExpectByte()) {</span>
<span class="line" id="L1497">                        <span class="tok-str">'&quot;'</span> =&gt; <span class="tok-kw">return</span> .string,</span>
<span class="line" id="L1498">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1499">                    }</span>
<span class="line" id="L1500">                },</span>
<span class="line" id="L1501"></span>
<span class="line" id="L1502">                .array_start =&gt; {</span>
<span class="line" id="L1503">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.skipWhitespaceExpectByte()) {</span>
<span class="line" id="L1504">                        <span class="tok-str">']'</span> =&gt; <span class="tok-kw">return</span> .array_end,</span>
<span class="line" id="L1505">                        <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L1506">                            self.state = .value;</span>
<span class="line" id="L1507">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1508">                        },</span>
<span class="line" id="L1509">                    }</span>
<span class="line" id="L1510">                },</span>
<span class="line" id="L1511"></span>
<span class="line" id="L1512">                .number_minus,</span>
<span class="line" id="L1513">                .number_leading_zero,</span>
<span class="line" id="L1514">                .number_int,</span>
<span class="line" id="L1515">                .number_post_dot,</span>
<span class="line" id="L1516">                .number_frac,</span>
<span class="line" id="L1517">                .number_post_e,</span>
<span class="line" id="L1518">                .number_post_e_sign,</span>
<span class="line" id="L1519">                .number_exp,</span>
<span class="line" id="L1520">                =&gt; <span class="tok-kw">return</span> .number,</span>
<span class="line" id="L1521"></span>
<span class="line" id="L1522">                .string,</span>
<span class="line" id="L1523">                .string_backslash,</span>
<span class="line" id="L1524">                .string_backslash_u,</span>
<span class="line" id="L1525">                .string_backslash_u_1,</span>
<span class="line" id="L1526">                .string_backslash_u_2,</span>
<span class="line" id="L1527">                .string_backslash_u_3,</span>
<span class="line" id="L1528">                .string_surrogate_half,</span>
<span class="line" id="L1529">                .string_surrogate_half_backslash,</span>
<span class="line" id="L1530">                .string_surrogate_half_backslash_u,</span>
<span class="line" id="L1531">                .string_surrogate_half_backslash_u_1,</span>
<span class="line" id="L1532">                .string_surrogate_half_backslash_u_2,</span>
<span class="line" id="L1533">                .string_surrogate_half_backslash_u_3,</span>
<span class="line" id="L1534">                =&gt; <span class="tok-kw">return</span> .string,</span>
<span class="line" id="L1535"></span>
<span class="line" id="L1536">                .string_utf8_last_byte,</span>
<span class="line" id="L1537">                .string_utf8_second_to_last_byte,</span>
<span class="line" id="L1538">                .string_utf8_second_to_last_byte_guard_against_overlong,</span>
<span class="line" id="L1539">                .string_utf8_second_to_last_byte_guard_against_surrogate_half,</span>
<span class="line" id="L1540">                .string_utf8_third_to_last_byte,</span>
<span class="line" id="L1541">                .string_utf8_third_to_last_byte_guard_against_overlong,</span>
<span class="line" id="L1542">                .string_utf8_third_to_last_byte_guard_against_too_large,</span>
<span class="line" id="L1543">                =&gt; <span class="tok-kw">return</span> .string,</span>
<span class="line" id="L1544"></span>
<span class="line" id="L1545">                .literal_t,</span>
<span class="line" id="L1546">                .literal_tr,</span>
<span class="line" id="L1547">                .literal_tru,</span>
<span class="line" id="L1548">                =&gt; <span class="tok-kw">return</span> .<span class="tok-null">true</span>,</span>
<span class="line" id="L1549">                .literal_f,</span>
<span class="line" id="L1550">                .literal_fa,</span>
<span class="line" id="L1551">                .literal_fal,</span>
<span class="line" id="L1552">                .literal_fals,</span>
<span class="line" id="L1553">                =&gt; <span class="tok-kw">return</span> .<span class="tok-null">false</span>,</span>
<span class="line" id="L1554">                .literal_n,</span>
<span class="line" id="L1555">                .literal_nu,</span>
<span class="line" id="L1556">                .literal_nul,</span>
<span class="line" id="L1557">                =&gt; <span class="tok-kw">return</span> .<span class="tok-null">null</span>,</span>
<span class="line" id="L1558">            }</span>
<span class="line" id="L1559">            <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L1560">        }</span>
<span class="line" id="L1561">    }</span>
<span class="line" id="L1562"></span>
<span class="line" id="L1563">    <span class="tok-kw">const</span> State = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L1564">        value,</span>
<span class="line" id="L1565">        post_value,</span>
<span class="line" id="L1566"></span>
<span class="line" id="L1567">        object_start,</span>
<span class="line" id="L1568">        object_post_comma,</span>
<span class="line" id="L1569"></span>
<span class="line" id="L1570">        array_start,</span>
<span class="line" id="L1571"></span>
<span class="line" id="L1572">        number_minus,</span>
<span class="line" id="L1573">        number_leading_zero,</span>
<span class="line" id="L1574">        number_int,</span>
<span class="line" id="L1575">        number_post_dot,</span>
<span class="line" id="L1576">        number_frac,</span>
<span class="line" id="L1577">        number_post_e,</span>
<span class="line" id="L1578">        number_post_e_sign,</span>
<span class="line" id="L1579">        number_exp,</span>
<span class="line" id="L1580"></span>
<span class="line" id="L1581">        string,</span>
<span class="line" id="L1582">        string_backslash,</span>
<span class="line" id="L1583">        string_backslash_u,</span>
<span class="line" id="L1584">        string_backslash_u_1,</span>
<span class="line" id="L1585">        string_backslash_u_2,</span>
<span class="line" id="L1586">        string_backslash_u_3,</span>
<span class="line" id="L1587">        string_surrogate_half,</span>
<span class="line" id="L1588">        string_surrogate_half_backslash,</span>
<span class="line" id="L1589">        string_surrogate_half_backslash_u,</span>
<span class="line" id="L1590">        string_surrogate_half_backslash_u_1,</span>
<span class="line" id="L1591">        string_surrogate_half_backslash_u_2,</span>
<span class="line" id="L1592">        string_surrogate_half_backslash_u_3,</span>
<span class="line" id="L1593"></span>
<span class="line" id="L1594">        <span class="tok-comment">// From http://unicode.org/mail-arch/unicode-ml/y2003-m02/att-0467/01-The_Algorithm_to_Valide_an_UTF-8_String</span>
</span>
<span class="line" id="L1595">        string_utf8_last_byte, <span class="tok-comment">// State A</span>
</span>
<span class="line" id="L1596">        string_utf8_second_to_last_byte, <span class="tok-comment">// State B</span>
</span>
<span class="line" id="L1597">        string_utf8_second_to_last_byte_guard_against_overlong, <span class="tok-comment">// State C</span>
</span>
<span class="line" id="L1598">        string_utf8_second_to_last_byte_guard_against_surrogate_half, <span class="tok-comment">// State D</span>
</span>
<span class="line" id="L1599">        string_utf8_third_to_last_byte, <span class="tok-comment">// State E</span>
</span>
<span class="line" id="L1600">        string_utf8_third_to_last_byte_guard_against_overlong, <span class="tok-comment">// State F</span>
</span>
<span class="line" id="L1601">        string_utf8_third_to_last_byte_guard_against_too_large, <span class="tok-comment">// State G</span>
</span>
<span class="line" id="L1602"></span>
<span class="line" id="L1603">        literal_t,</span>
<span class="line" id="L1604">        literal_tr,</span>
<span class="line" id="L1605">        literal_tru,</span>
<span class="line" id="L1606">        literal_f,</span>
<span class="line" id="L1607">        literal_fa,</span>
<span class="line" id="L1608">        literal_fal,</span>
<span class="line" id="L1609">        literal_fals,</span>
<span class="line" id="L1610">        literal_n,</span>
<span class="line" id="L1611">        literal_nu,</span>
<span class="line" id="L1612">        literal_nul,</span>
<span class="line" id="L1613">    };</span>
<span class="line" id="L1614"></span>
<span class="line" id="L1615">    <span class="tok-kw">fn</span> <span class="tok-fn">expectByte</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) !<span class="tok-type">u8</span> {</span>
<span class="line" id="L1616">        <span class="tok-kw">if</span> (self.cursor &lt; self.input.len) {</span>
<span class="line" id="L1617">            <span class="tok-kw">return</span> self.input[self.cursor];</span>
<span class="line" id="L1618">        }</span>
<span class="line" id="L1619">        <span class="tok-comment">// No byte.</span>
</span>
<span class="line" id="L1620">        <span class="tok-kw">if</span> (self.is_end_of_input) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedEndOfInput;</span>
<span class="line" id="L1621">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BufferUnderrun;</span>
<span class="line" id="L1622">    }</span>
<span class="line" id="L1623"></span>
<span class="line" id="L1624">    <span class="tok-kw">fn</span> <span class="tok-fn">skipWhitespace</span>(self: *<span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {</span>
<span class="line" id="L1625">        <span class="tok-kw">while</span> (self.cursor &lt; self.input.len) : (self.cursor += <span class="tok-number">1</span>) {</span>
<span class="line" id="L1626">            <span class="tok-kw">switch</span> (self.input[self.cursor]) {</span>
<span class="line" id="L1627">                <span class="tok-comment">// Whitespace</span>
</span>
<span class="line" id="L1628">                <span class="tok-str">' '</span>, <span class="tok-str">'\t'</span>, <span class="tok-str">'\r'</span> =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L1629">                <span class="tok-str">'\n'</span> =&gt; {</span>
<span class="line" id="L1630">                    <span class="tok-kw">if</span> (self.diagnostics) |diag| {</span>
<span class="line" id="L1631">                        diag.line_number += <span class="tok-number">1</span>;</span>
<span class="line" id="L1632">                        <span class="tok-comment">// This will count the newline itself,</span>
</span>
<span class="line" id="L1633">                        <span class="tok-comment">// which means a straight-forward subtraction will give a 1-based column number.</span>
</span>
<span class="line" id="L1634">                        diag.line_start_cursor = self.cursor;</span>
<span class="line" id="L1635">                    }</span>
<span class="line" id="L1636">                    <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1637">                },</span>
<span class="line" id="L1638">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span>,</span>
<span class="line" id="L1639">            }</span>
<span class="line" id="L1640">        }</span>
<span class="line" id="L1641">    }</span>
<span class="line" id="L1642"></span>
<span class="line" id="L1643">    <span class="tok-kw">fn</span> <span class="tok-fn">skipWhitespaceExpectByte</span>(self: *<span class="tok-builtin">@This</span>()) !<span class="tok-type">u8</span> {</span>
<span class="line" id="L1644">        self.skipWhitespace();</span>
<span class="line" id="L1645">        <span class="tok-kw">return</span> self.expectByte();</span>
<span class="line" id="L1646">    }</span>
<span class="line" id="L1647"></span>
<span class="line" id="L1648">    <span class="tok-kw">fn</span> <span class="tok-fn">skipWhitespaceCheckEnd</span>(self: *<span class="tok-builtin">@This</span>()) !<span class="tok-type">bool</span> {</span>
<span class="line" id="L1649">        self.skipWhitespace();</span>
<span class="line" id="L1650">        <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) {</span>
<span class="line" id="L1651">            <span class="tok-comment">// End of buffer.</span>
</span>
<span class="line" id="L1652">            <span class="tok-kw">if</span> (self.is_end_of_input) {</span>
<span class="line" id="L1653">                <span class="tok-comment">// End of everything.</span>
</span>
<span class="line" id="L1654">                <span class="tok-kw">if</span> (self.stackHeight() == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1655">                    <span class="tok-comment">// We did it!</span>
</span>
<span class="line" id="L1656">                    <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L1657">                }</span>
<span class="line" id="L1658">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedEndOfInput;</span>
<span class="line" id="L1659">            }</span>
<span class="line" id="L1660">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BufferUnderrun;</span>
<span class="line" id="L1661">        }</span>
<span class="line" id="L1662">        <span class="tok-kw">if</span> (self.stackHeight() == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError;</span>
<span class="line" id="L1663">        <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L1664">    }</span>
<span class="line" id="L1665"></span>
<span class="line" id="L1666">    <span class="tok-kw">fn</span> <span class="tok-fn">takeValueSlice</span>(self: *<span class="tok-builtin">@This</span>()) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1667">        <span class="tok-kw">const</span> slice = self.input[self.value_start..self.cursor];</span>
<span class="line" id="L1668">        self.value_start = self.cursor;</span>
<span class="line" id="L1669">        <span class="tok-kw">return</span> slice;</span>
<span class="line" id="L1670">    }</span>
<span class="line" id="L1671"></span>
<span class="line" id="L1672">    <span class="tok-kw">fn</span> <span class="tok-fn">endOfBufferInNumber</span>(self: *<span class="tok-builtin">@This</span>(), allow_end: <span class="tok-type">bool</span>) !Token {</span>
<span class="line" id="L1673">        <span class="tok-kw">const</span> slice = self.takeValueSlice();</span>
<span class="line" id="L1674">        <span class="tok-kw">if</span> (self.is_end_of_input) {</span>
<span class="line" id="L1675">            <span class="tok-kw">if</span> (!allow_end) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedEndOfInput;</span>
<span class="line" id="L1676">            self.state = .post_value;</span>
<span class="line" id="L1677">            <span class="tok-kw">return</span> Token{ .number = slice };</span>
<span class="line" id="L1678">        }</span>
<span class="line" id="L1679">        <span class="tok-kw">if</span> (slice.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BufferUnderrun;</span>
<span class="line" id="L1680">        <span class="tok-kw">return</span> Token{ .partial_number = slice };</span>
<span class="line" id="L1681">    }</span>
<span class="line" id="L1682"></span>
<span class="line" id="L1683">    <span class="tok-kw">fn</span> <span class="tok-fn">partialStringCodepoint</span>(self: *<span class="tok-builtin">@This</span>()) Token {</span>
<span class="line" id="L1684">        <span class="tok-kw">const</span> code_point = self.unicode_code_point;</span>
<span class="line" id="L1685">        self.unicode_code_point = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1686">        <span class="tok-kw">var</span> buf: [<span class="tok-number">4</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1687">        <span class="tok-kw">switch</span> (std.unicode.utf8Encode(code_point, &amp;buf) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>) {</span>
<span class="line" id="L1688">            <span class="tok-number">1</span> =&gt; <span class="tok-kw">return</span> Token{ .partial_string_escaped_1 = buf[<span class="tok-number">0</span>..<span class="tok-number">1</span>].* },</span>
<span class="line" id="L1689">            <span class="tok-number">2</span> =&gt; <span class="tok-kw">return</span> Token{ .partial_string_escaped_2 = buf[<span class="tok-number">0</span>..<span class="tok-number">2</span>].* },</span>
<span class="line" id="L1690">            <span class="tok-number">3</span> =&gt; <span class="tok-kw">return</span> Token{ .partial_string_escaped_3 = buf[<span class="tok-number">0</span>..<span class="tok-number">3</span>].* },</span>
<span class="line" id="L1691">            <span class="tok-number">4</span> =&gt; <span class="tok-kw">return</span> Token{ .partial_string_escaped_4 = buf[<span class="tok-number">0</span>..<span class="tok-number">4</span>].* },</span>
<span class="line" id="L1692">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1693">        }</span>
<span class="line" id="L1694">    }</span>
<span class="line" id="L1695">};</span>
<span class="line" id="L1696"></span>
<span class="line" id="L1697"><span class="tok-kw">const</span> OBJECT_MODE = <span class="tok-number">0</span>;</span>
<span class="line" id="L1698"><span class="tok-kw">const</span> ARRAY_MODE = <span class="tok-number">1</span>;</span>
<span class="line" id="L1699"></span>
<span class="line" id="L1700"><span class="tok-kw">const</span> BitStack = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1701">    bytes: std.ArrayList(<span class="tok-type">u8</span>),</span>
<span class="line" id="L1702">    bit_len: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L1703"></span>
<span class="line" id="L1704">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: Allocator) <span class="tok-builtin">@This</span>() {</span>
<span class="line" id="L1705">        <span class="tok-kw">return</span> .{</span>
<span class="line" id="L1706">            .bytes = std.ArrayList(<span class="tok-type">u8</span>).init(allocator),</span>
<span class="line" id="L1707">        };</span>
<span class="line" id="L1708">    }</span>
<span class="line" id="L1709"></span>
<span class="line" id="L1710">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {</span>
<span class="line" id="L1711">        self.bytes.deinit();</span>
<span class="line" id="L1712">        self.* = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1713">    }</span>
<span class="line" id="L1714"></span>
<span class="line" id="L1715">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<span class="tok-builtin">@This</span>(), bit_capcity: <span class="tok-type">u32</span>) Allocator.Error!<span class="tok-type">void</span> {</span>
<span class="line" id="L1716">        <span class="tok-kw">const</span> byte_capacity = (bit_capcity + <span class="tok-number">7</span>) &gt;&gt; <span class="tok-number">3</span>;</span>
<span class="line" id="L1717">        <span class="tok-kw">try</span> self.bytes.ensureTotalCapacity(byte_capacity);</span>
<span class="line" id="L1718">    }</span>
<span class="line" id="L1719"></span>
<span class="line" id="L1720">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">push</span>(self: *<span class="tok-builtin">@This</span>(), b: <span class="tok-type">u1</span>) Allocator.Error!<span class="tok-type">void</span> {</span>
<span class="line" id="L1721">        <span class="tok-kw">const</span> byte_index = self.bit_len &gt;&gt; <span class="tok-number">3</span>;</span>
<span class="line" id="L1722">        <span class="tok-kw">const</span> bit_index = <span class="tok-builtin">@intCast</span>(<span class="tok-type">u3</span>, self.bit_len &amp; <span class="tok-number">7</span>);</span>
<span class="line" id="L1723"></span>
<span class="line" id="L1724">        <span class="tok-kw">if</span> (self.bytes.items.len &lt;= byte_index) {</span>
<span class="line" id="L1725">            <span class="tok-kw">try</span> self.bytes.append(<span class="tok-number">0</span>);</span>
<span class="line" id="L1726">        }</span>
<span class="line" id="L1727"></span>
<span class="line" id="L1728">        self.bytes.items[byte_index] &amp;= ~(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">1</span>) &lt;&lt; bit_index);</span>
<span class="line" id="L1729">        self.bytes.items[byte_index] |= <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, b) &lt;&lt; bit_index;</span>
<span class="line" id="L1730"></span>
<span class="line" id="L1731">        self.bit_len += <span class="tok-number">1</span>;</span>
<span class="line" id="L1732">    }</span>
<span class="line" id="L1733"></span>
<span class="line" id="L1734">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peek</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) <span class="tok-type">u1</span> {</span>
<span class="line" id="L1735">        <span class="tok-kw">const</span> byte_index = (self.bit_len - <span class="tok-number">1</span>) &gt;&gt; <span class="tok-number">3</span>;</span>
<span class="line" id="L1736">        <span class="tok-kw">const</span> bit_index = <span class="tok-builtin">@intCast</span>(<span class="tok-type">u3</span>, (self.bit_len - <span class="tok-number">1</span>) &amp; <span class="tok-number">7</span>);</span>
<span class="line" id="L1737">        <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(<span class="tok-type">u1</span>, (self.bytes.items[byte_index] &gt;&gt; bit_index) &amp; <span class="tok-number">1</span>);</span>
<span class="line" id="L1738">    }</span>
<span class="line" id="L1739"></span>
<span class="line" id="L1740">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<span class="tok-builtin">@This</span>()) <span class="tok-type">u1</span> {</span>
<span class="line" id="L1741">        <span class="tok-kw">const</span> b = self.peek();</span>
<span class="line" id="L1742">        self.bit_len -= <span class="tok-number">1</span>;</span>
<span class="line" id="L1743">        <span class="tok-kw">return</span> b;</span>
<span class="line" id="L1744">    }</span>
<span class="line" id="L1745">};</span>
<span class="line" id="L1746"></span>
<span class="line" id="L1747"><span class="tok-kw">fn</span> <span class="tok-fn">appendSlice</span>(list: *std.ArrayList(<span class="tok-type">u8</span>), buf: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, max_value_len: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1748">    <span class="tok-kw">const</span> new_len = std.math.add(<span class="tok-type">usize</span>, list.items.len, buf.len) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ValueTooLong;</span>
<span class="line" id="L1749">    <span class="tok-kw">if</span> (new_len &gt; max_value_len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ValueTooLong;</span>
<span class="line" id="L1750">    <span class="tok-kw">try</span> list.appendSlice(buf);</span>
<span class="line" id="L1751">}</span>
<span class="line" id="L1752"></span>
<span class="line" id="L1753"><span class="tok-comment">/// For the slice you get from a `Token.number` or `Token.allocated_number`,</span></span>
<span class="line" id="L1754"><span class="tok-comment">/// this function returns true if the number doesn't contain any fraction or exponent components.</span></span>
<span class="line" id="L1755"><span class="tok-comment">/// Note, the numeric value encoded by the value may still be an integer, such as `1.0`.</span></span>
<span class="line" id="L1756"><span class="tok-comment">/// This function is meant to give a hint about whether integer parsing or float parsing should be used on the value.</span></span>
<span class="line" id="L1757"><span class="tok-comment">/// This function will not give meaningful results on non-numeric input.</span></span>
<span class="line" id="L1758"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isNumberFormattedLikeAnInteger</span>(value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L1759">    <span class="tok-kw">return</span> std.mem.indexOfAny(<span class="tok-type">u8</span>, value, <span class="tok-str">&quot;.eE&quot;</span>) == <span class="tok-null">null</span>;</span>
<span class="line" id="L1760">}</span>
<span class="line" id="L1761"></span>
<span class="line" id="L1762"><span class="tok-kw">test</span> {</span>
<span class="line" id="L1763">    _ = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;./scanner_test.zig&quot;</span>);</span>
<span class="line" id="L1764">}</span>
<span class="line" id="L1765"></span>
</code></pre></body>
</html>