<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>json/scanner.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAPNJREFUeNpi/P//PwMlgOXHUjly9E0G4hwgZmQiQZMqEK8H4v9QzUEgQSaoADK+zhH9iAGL+C0gDoAaNg9mGLoLfgA1awK9hS9gzgJxA9RQBmQDrgMxJzRMGKE4HYj/Ial5A8QmQLwCJoBsgBYW2+TR1ChDaWt4LOBxKsi/VUh8XiD+gq4IVyzwQAMJBoKwacZlAB8Qf0bi96IZhtOAe1D6LpqaEiz6rmEzQAeIzwGxCJpieFqApo/vQKyJboAaEBsAsSEupwI1MwKjGBTVHOhegMX5UajYRqiBjMgYmj400cVh0XgTiKdC0zhJgJHS7AwQYABm9EAdCKrEfAAAAABJRU5ErkJggg=="/>
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-comment">// Notes on standards compliance: https://datatracker.ietf.org/doc/html/rfc8259</span>
</span>
<span class="line" id="L2"><span class="tok-comment">// * RFC 8259 requires JSON documents be valid UTF-8,</span>
</span>
<span class="line" id="L3"><span class="tok-comment">//   but makes an allowance for systems that are &quot;part of a closed ecosystem&quot;.</span>
</span>
<span class="line" id="L4"><span class="tok-comment">//   I have no idea what that's supposed to mean in the context of a standard specification.</span>
</span>
<span class="line" id="L5"><span class="tok-comment">//   This implementation requires inputs to be valid UTF-8.</span>
</span>
<span class="line" id="L6"><span class="tok-comment">// * RFC 8259 contradicts itself regarding whether lowercase is allowed in \u hex digits,</span>
</span>
<span class="line" id="L7"><span class="tok-comment">//   but this is probably a bug in the spec, and it's clear that lowercase is meant to be allowed.</span>
</span>
<span class="line" id="L8"><span class="tok-comment">//   (RFC 5234 defines HEXDIG to only allow uppercase.)</span>
</span>
<span class="line" id="L9"><span class="tok-comment">// * When RFC 8259 refers to a &quot;character&quot;, I assume they really mean a &quot;Unicode scalar value&quot;.</span>
</span>
<span class="line" id="L10"><span class="tok-comment">//   See http://www.unicode.org/glossary/#unicode_scalar_value .</span>
</span>
<span class="line" id="L11"><span class="tok-comment">// * RFC 8259 doesn't explicitly disallow unpaired surrogate halves in \u escape sequences,</span>
</span>
<span class="line" id="L12"><span class="tok-comment">//   but vaguely implies that \u escapes are for encoding Unicode &quot;characters&quot; (i.e. Unicode scalar values?),</span>
</span>
<span class="line" id="L13"><span class="tok-comment">//   which would mean that unpaired surrogate halves are forbidden.</span>
</span>
<span class="line" id="L14"><span class="tok-comment">//   By contrast ECMA-404 (a competing(/compatible?) JSON standard, which JavaScript's JSON.parse() conforms to)</span>
</span>
<span class="line" id="L15"><span class="tok-comment">//   explicitly allows unpaired surrogate halves.</span>
</span>
<span class="line" id="L16"><span class="tok-comment">//   This implementation forbids unpaired surrogate halves in \u sequences.</span>
</span>
<span class="line" id="L17"><span class="tok-comment">//   If a high surrogate half appears in a \u sequence,</span>
</span>
<span class="line" id="L18"><span class="tok-comment">//   then a low surrogate half must immediately follow in \u notation.</span>
</span>
<span class="line" id="L19"><span class="tok-comment">// * RFC 8259 allows implementations to &quot;accept non-JSON forms or extensions&quot;.</span>
</span>
<span class="line" id="L20"><span class="tok-comment">//   This implementation does not accept any of that.</span>
</span>
<span class="line" id="L21"><span class="tok-comment">// * RFC 8259 allows implementations to put limits on &quot;the size of texts&quot;,</span>
</span>
<span class="line" id="L22"><span class="tok-comment">//   &quot;the maximum depth of nesting&quot;, &quot;the range and precision of numbers&quot;,</span>
</span>
<span class="line" id="L23"><span class="tok-comment">//   and &quot;the length and character contents of strings&quot;.</span>
</span>
<span class="line" id="L24"><span class="tok-comment">//   This low-level implementation does not limit these,</span>
</span>
<span class="line" id="L25"><span class="tok-comment">//   except where noted above, and except that nesting depth requires memory allocation.</span>
</span>
<span class="line" id="L26"><span class="tok-comment">//   Note that this low-level API does not interpret numbers numerically,</span>
</span>
<span class="line" id="L27"><span class="tok-comment">//   but simply emits their source form for some higher level code to make sense of.</span>
</span>
<span class="line" id="L28"><span class="tok-comment">// * This low-level implementation allows duplicate object keys,</span>
</span>
<span class="line" id="L29"><span class="tok-comment">//   and key/value pairs are emitted in the order they appear in the input.</span>
</span>
<span class="line" id="L30"></span>
<span class="line" id="L31"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);</span>
<span class="line" id="L32"></span>
<span class="line" id="L33"><span class="tok-kw">const</span> Allocator = std.mem.Allocator;</span>
<span class="line" id="L34"><span class="tok-kw">const</span> ArrayList = std.ArrayList;</span>
<span class="line" id="L35"><span class="tok-kw">const</span> assert = std.debug.assert;</span>
<span class="line" id="L36"><span class="tok-kw">const</span> BitStack = std.BitStack;</span>
<span class="line" id="L37"></span>
<span class="line" id="L38"><span class="tok-comment">/// Scan the input and check for malformed JSON.</span></span>
<span class="line" id="L39"><span class="tok-comment">/// On `SyntaxError` or `UnexpectedEndOfInput`, returns `false`.</span></span>
<span class="line" id="L40"><span class="tok-comment">/// Returns any errors from the allocator as-is, which is unlikely,</span></span>
<span class="line" id="L41"><span class="tok-comment">/// but can be caused by extreme nesting depth in the input.</span></span>
<span class="line" id="L42"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">validate</span>(allocator: Allocator, s: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) Allocator.Error!<span class="tok-type">bool</span> {</span>
<span class="line" id="L43">    <span class="tok-kw">var</span> scanner = Scanner.initCompleteInput(allocator, s);</span>
<span class="line" id="L44">    <span class="tok-kw">defer</span> scanner.deinit();</span>
<span class="line" id="L45"></span>
<span class="line" id="L46">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L47">        <span class="tok-kw">const</span> token = scanner.next() <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L48">            <span class="tok-kw">error</span>.SyntaxError, <span class="tok-kw">error</span>.UnexpectedEndOfInput =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,</span>
<span class="line" id="L49">            <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,</span>
<span class="line" id="L50">            <span class="tok-kw">error</span>.BufferUnderrun =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L51">        };</span>
<span class="line" id="L52">        <span class="tok-kw">if</span> (token == .end_of_document) <span class="tok-kw">break</span>;</span>
<span class="line" id="L53">    }</span>
<span class="line" id="L54"></span>
<span class="line" id="L55">    <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L56">}</span>
<span class="line" id="L57"></span>
<span class="line" id="L58"><span class="tok-comment">/// The parsing errors are divided into two categories:</span></span>
<span class="line" id="L59"><span class="tok-comment">///  * `SyntaxError` is for clearly malformed JSON documents,</span></span>
<span class="line" id="L60"><span class="tok-comment">///    such as giving an input document that isn't JSON at all.</span></span>
<span class="line" id="L61"><span class="tok-comment">///  * `UnexpectedEndOfInput` is for signaling that everything's been</span></span>
<span class="line" id="L62"><span class="tok-comment">///    valid so far, but the input appears to be truncated for some reason.</span></span>
<span class="line" id="L63"><span class="tok-comment">/// Note that a completely empty (or whitespace-only) input will give `UnexpectedEndOfInput`.</span></span>
<span class="line" id="L64"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <span class="tok-kw">error</span>{ SyntaxError, UnexpectedEndOfInput };</span>
<span class="line" id="L65"></span>
<span class="line" id="L66"><span class="tok-comment">/// Calls `std.json.Reader` with `std.json.default_buffer_size`.</span></span>
<span class="line" id="L67"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reader</span>(allocator: Allocator, io_reader: <span class="tok-kw">anytype</span>) Reader(default_buffer_size, <span class="tok-builtin">@TypeOf</span>(io_reader)) {</span>
<span class="line" id="L68">    <span class="tok-kw">return</span> Reader(default_buffer_size, <span class="tok-builtin">@TypeOf</span>(io_reader)).init(allocator, io_reader);</span>
<span class="line" id="L69">}</span>
<span class="line" id="L70"><span class="tok-comment">/// Used by `json.reader`.</span></span>
<span class="line" id="L71"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> default_buffer_size = <span class="tok-number">0x1000</span>;</span>
<span class="line" id="L72"></span>
<span class="line" id="L73"><span class="tok-comment">/// The tokens emitted by `std.json.Scanner` and `std.json.Reader` `.next*()` functions follow this grammar:</span></span>
<span class="line" id="L74"><span class="tok-comment">/// ```</span></span>
<span class="line" id="L75"><span class="tok-comment">///  &lt;document&gt; = &lt;value&gt; .end_of_document</span></span>
<span class="line" id="L76"><span class="tok-comment">///  &lt;value&gt; =</span></span>
<span class="line" id="L77"><span class="tok-comment">///    | &lt;object&gt;</span></span>
<span class="line" id="L78"><span class="tok-comment">///    | &lt;array&gt;</span></span>
<span class="line" id="L79"><span class="tok-comment">///    | &lt;number&gt;</span></span>
<span class="line" id="L80"><span class="tok-comment">///    | &lt;string&gt;</span></span>
<span class="line" id="L81"><span class="tok-comment">///    | .true</span></span>
<span class="line" id="L82"><span class="tok-comment">///    | .false</span></span>
<span class="line" id="L83"><span class="tok-comment">///    | .null</span></span>
<span class="line" id="L84"><span class="tok-comment">///  &lt;object&gt; = .object_begin ( &lt;string&gt; &lt;value&gt; )* .object_end</span></span>
<span class="line" id="L85"><span class="tok-comment">///  &lt;array&gt; = .array_begin ( &lt;value&gt; )* .array_end</span></span>
<span class="line" id="L86"><span class="tok-comment">///  &lt;number&gt; = &lt;It depends. See below.&gt;</span></span>
<span class="line" id="L87"><span class="tok-comment">///  &lt;string&gt; = &lt;It depends. See below.&gt;</span></span>
<span class="line" id="L88"><span class="tok-comment">/// ```</span></span>
<span class="line" id="L89"><span class="tok-comment">///</span></span>
<span class="line" id="L90"><span class="tok-comment">/// What you get for `&lt;number&gt;` and `&lt;string&gt;` values depends on which `next*()` method you call:</span></span>
<span class="line" id="L91"><span class="tok-comment">///</span></span>
<span class="line" id="L92"><span class="tok-comment">/// ```</span></span>
<span class="line" id="L93"><span class="tok-comment">/// next():</span></span>
<span class="line" id="L94"><span class="tok-comment">///  &lt;number&gt; = ( .partial_number )* .number</span></span>
<span class="line" id="L95"><span class="tok-comment">///  &lt;string&gt; = ( &lt;partial_string&gt; )* .string</span></span>
<span class="line" id="L96"><span class="tok-comment">///  &lt;partial_string&gt; =</span></span>
<span class="line" id="L97"><span class="tok-comment">///    | .partial_string</span></span>
<span class="line" id="L98"><span class="tok-comment">///    | .partial_string_escaped_1</span></span>
<span class="line" id="L99"><span class="tok-comment">///    | .partial_string_escaped_2</span></span>
<span class="line" id="L100"><span class="tok-comment">///    | .partial_string_escaped_3</span></span>
<span class="line" id="L101"><span class="tok-comment">///    | .partial_string_escaped_4</span></span>
<span class="line" id="L102"><span class="tok-comment">///</span></span>
<span class="line" id="L103"><span class="tok-comment">/// nextAlloc*(..., .alloc_always):</span></span>
<span class="line" id="L104"><span class="tok-comment">///  &lt;number&gt; = .allocated_number</span></span>
<span class="line" id="L105"><span class="tok-comment">///  &lt;string&gt; = .allocated_string</span></span>
<span class="line" id="L106"><span class="tok-comment">///</span></span>
<span class="line" id="L107"><span class="tok-comment">/// nextAlloc*(..., .alloc_if_needed):</span></span>
<span class="line" id="L108"><span class="tok-comment">///  &lt;number&gt; =</span></span>
<span class="line" id="L109"><span class="tok-comment">///    | .number</span></span>
<span class="line" id="L110"><span class="tok-comment">///    | .allocated_number</span></span>
<span class="line" id="L111"><span class="tok-comment">///  &lt;string&gt; =</span></span>
<span class="line" id="L112"><span class="tok-comment">///    | .string</span></span>
<span class="line" id="L113"><span class="tok-comment">///    | .allocated_string</span></span>
<span class="line" id="L114"><span class="tok-comment">/// ```</span></span>
<span class="line" id="L115"><span class="tok-comment">///</span></span>
<span class="line" id="L116"><span class="tok-comment">/// For all tokens with a `[]const u8`, `[]u8`, or `[n]u8` payload, the payload represents the content of the value.</span></span>
<span class="line" id="L117"><span class="tok-comment">/// For number values, this is the representation of the number exactly as it appears in the input.</span></span>
<span class="line" id="L118"><span class="tok-comment">/// For strings, this is the content of the string after resolving escape sequences.</span></span>
<span class="line" id="L119"><span class="tok-comment">///</span></span>
<span class="line" id="L120"><span class="tok-comment">/// For `.allocated_number` and `.allocated_string`, the `[]u8` payloads are allocations made with the given allocator.</span></span>
<span class="line" id="L121"><span class="tok-comment">/// You are responsible for managing that memory. `json.Reader.deinit()` does *not* free those allocations.</span></span>
<span class="line" id="L122"><span class="tok-comment">///</span></span>
<span class="line" id="L123"><span class="tok-comment">/// The `.partial_*` tokens indicate that a value spans multiple input buffers or that a string contains escape sequences.</span></span>
<span class="line" id="L124"><span class="tok-comment">/// To get a complete value in memory, you need to concatenate the values yourself.</span></span>
<span class="line" id="L125"><span class="tok-comment">/// Calling `nextAlloc*()` does this for you, and returns an `.allocated_*` token with the result.</span></span>
<span class="line" id="L126"><span class="tok-comment">///</span></span>
<span class="line" id="L127"><span class="tok-comment">/// For tokens with a `[]const u8` payload, the payload is a slice into the current input buffer.</span></span>
<span class="line" id="L128"><span class="tok-comment">/// The memory may become undefined during the next call to `json.Scanner.feedInput()`</span></span>
<span class="line" id="L129"><span class="tok-comment">/// or any `json.Reader` method whose return error set includes `json.Error`.</span></span>
<span class="line" id="L130"><span class="tok-comment">/// To keep the value persistently, it recommended to make a copy or to use `.alloc_always`,</span></span>
<span class="line" id="L131"><span class="tok-comment">/// which makes a copy for you.</span></span>
<span class="line" id="L132"><span class="tok-comment">///</span></span>
<span class="line" id="L133"><span class="tok-comment">/// Note that `.number` and `.string` tokens that follow `.partial_*` tokens may have `0` length to indicate that</span></span>
<span class="line" id="L134"><span class="tok-comment">/// the previously partial value is completed with no additional bytes.</span></span>
<span class="line" id="L135"><span class="tok-comment">/// (This can happen when the break between input buffers happens to land on the exact end of a value. E.g. `&quot;[1234&quot;`, `&quot;]&quot;`.)</span></span>
<span class="line" id="L136"><span class="tok-comment">/// `.partial_*` tokens never have `0` length.</span></span>
<span class="line" id="L137"><span class="tok-comment">///</span></span>
<span class="line" id="L138"><span class="tok-comment">/// The recommended strategy for using the different `next*()` methods is something like this:</span></span>
<span class="line" id="L139"><span class="tok-comment">///</span></span>
<span class="line" id="L140"><span class="tok-comment">/// When you're expecting an object key, use `.alloc_if_needed`.</span></span>
<span class="line" id="L141"><span class="tok-comment">/// You often don't need a copy of the key string to persist; you might just check which field it is.</span></span>
<span class="line" id="L142"><span class="tok-comment">/// In the case that the key happens to require an allocation, free it immediately after checking it.</span></span>
<span class="line" id="L143"><span class="tok-comment">///</span></span>
<span class="line" id="L144"><span class="tok-comment">/// When you're expecting a meaningful string value (such as on the right of a `:`),</span></span>
<span class="line" id="L145"><span class="tok-comment">/// use `.alloc_always` in order to keep the value valid throughout parsing the rest of the document.</span></span>
<span class="line" id="L146"><span class="tok-comment">///</span></span>
<span class="line" id="L147"><span class="tok-comment">/// When you're expecting a number value, use `.alloc_if_needed`.</span></span>
<span class="line" id="L148"><span class="tok-comment">/// You're probably going to be parsing the string representation of the number into a numeric representation,</span></span>
<span class="line" id="L149"><span class="tok-comment">/// so you need the complete string representation only temporarily.</span></span>
<span class="line" id="L150"><span class="tok-comment">///</span></span>
<span class="line" id="L151"><span class="tok-comment">/// When you're skipping an unrecognized value, use `skipValue()`.</span></span>
<span class="line" id="L152"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Token = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L153">    object_begin,</span>
<span class="line" id="L154">    object_end,</span>
<span class="line" id="L155">    array_begin,</span>
<span class="line" id="L156">    array_end,</span>
<span class="line" id="L157"></span>
<span class="line" id="L158">    <span class="tok-null">true</span>,</span>
<span class="line" id="L159">    <span class="tok-null">false</span>,</span>
<span class="line" id="L160">    <span class="tok-null">null</span>,</span>
<span class="line" id="L161"></span>
<span class="line" id="L162">    number: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L163">    partial_number: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L164">    allocated_number: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L165"></span>
<span class="line" id="L166">    string: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L167">    partial_string: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L168">    partial_string_escaped_1: [<span class="tok-number">1</span>]<span class="tok-type">u8</span>,</span>
<span class="line" id="L169">    partial_string_escaped_2: [<span class="tok-number">2</span>]<span class="tok-type">u8</span>,</span>
<span class="line" id="L170">    partial_string_escaped_3: [<span class="tok-number">3</span>]<span class="tok-type">u8</span>,</span>
<span class="line" id="L171">    partial_string_escaped_4: [<span class="tok-number">4</span>]<span class="tok-type">u8</span>,</span>
<span class="line" id="L172">    allocated_string: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L173"></span>
<span class="line" id="L174">    end_of_document,</span>
<span class="line" id="L175">};</span>
<span class="line" id="L176"></span>
<span class="line" id="L177"><span class="tok-comment">/// This is only used in `peekNextTokenType()` and gives a categorization based on the first byte of the next token that will be emitted from a `next*()` call.</span></span>
<span class="line" id="L178"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> TokenType = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L179">    object_begin,</span>
<span class="line" id="L180">    object_end,</span>
<span class="line" id="L181">    array_begin,</span>
<span class="line" id="L182">    array_end,</span>
<span class="line" id="L183">    <span class="tok-null">true</span>,</span>
<span class="line" id="L184">    <span class="tok-null">false</span>,</span>
<span class="line" id="L185">    <span class="tok-null">null</span>,</span>
<span class="line" id="L186">    number,</span>
<span class="line" id="L187">    string,</span>
<span class="line" id="L188">    end_of_document,</span>
<span class="line" id="L189">};</span>
<span class="line" id="L190"></span>
<span class="line" id="L191"><span class="tok-comment">/// To enable diagnostics, declare `var diagnostics = Diagnostics{};` then call `source.enableDiagnostics(&amp;diagnostics);`</span></span>
<span class="line" id="L192"><span class="tok-comment">/// where `source` is either a `std.json.Reader` or a `std.json.Scanner` that has just been initialized.</span></span>
<span class="line" id="L193"><span class="tok-comment">/// At any time, notably just after an error, call `getLine()`, `getColumn()`, and/or `getByteOffset()`</span></span>
<span class="line" id="L194"><span class="tok-comment">/// to get meaningful information from this.</span></span>
<span class="line" id="L195"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Diagnostics = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L196">    line_number: <span class="tok-type">u64</span> = <span class="tok-number">1</span>,</span>
<span class="line" id="L197">    line_start_cursor: <span class="tok-type">usize</span> = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, -<span class="tok-number">1</span>))), <span class="tok-comment">// Start just &quot;before&quot; the input buffer to get a 1-based column for line 1.</span>
</span>
<span class="line" id="L198">    total_bytes_before_current_input: <span class="tok-type">u64</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L199">    cursor_pointer: *<span class="tok-kw">const</span> <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L200"></span>
<span class="line" id="L201">    <span class="tok-comment">/// Starts at 1.</span></span>
<span class="line" id="L202">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLine</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) <span class="tok-type">u64</span> {</span>
<span class="line" id="L203">        <span class="tok-kw">return</span> self.line_number;</span>
<span class="line" id="L204">    }</span>
<span class="line" id="L205">    <span class="tok-comment">/// Starts at 1.</span></span>
<span class="line" id="L206">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getColumn</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) <span class="tok-type">u64</span> {</span>
<span class="line" id="L207">        <span class="tok-kw">return</span> self.cursor_pointer.* -% self.line_start_cursor;</span>
<span class="line" id="L208">    }</span>
<span class="line" id="L209">    <span class="tok-comment">/// Starts at 0. Measures the byte offset since the start of the input.</span></span>
<span class="line" id="L210">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getByteOffset</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) <span class="tok-type">u64</span> {</span>
<span class="line" id="L211">        <span class="tok-kw">return</span> self.total_bytes_before_current_input + self.cursor_pointer.*;</span>
<span class="line" id="L212">    }</span>
<span class="line" id="L213">};</span>
<span class="line" id="L214"></span>
<span class="line" id="L215"><span class="tok-comment">/// See the documentation for `std.json.Token`.</span></span>
<span class="line" id="L216"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> AllocWhen = <span class="tok-kw">enum</span> { alloc_if_needed, alloc_always };</span>
<span class="line" id="L217"></span>
<span class="line" id="L218"><span class="tok-comment">/// For security, the maximum size allocated to store a single string or number value is limited to 4MiB by default.</span></span>
<span class="line" id="L219"><span class="tok-comment">/// This limit can be specified by calling `nextAllocMax()` instead of `nextAlloc()`.</span></span>
<span class="line" id="L220"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> default_max_value_len = <span class="tok-number">4</span> * <span class="tok-number">1024</span> * <span class="tok-number">1024</span>;</span>
<span class="line" id="L221"></span>
<span class="line" id="L222"><span class="tok-comment">/// Connects a `std.io.Reader` to a `std.json.Scanner`.</span></span>
<span class="line" id="L223"><span class="tok-comment">/// All `next*()` methods here handle `error.BufferUnderrun` from `std.json.Scanner`, and then read from the reader.</span></span>
<span class="line" id="L224"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Reader</span>(<span class="tok-kw">comptime</span> buffer_size: <span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> ReaderType: <span class="tok-type">type</span>) <span class="tok-type">type</span> {</span>
<span class="line" id="L225">    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L226">        scanner: Scanner,</span>
<span class="line" id="L227">        reader: ReaderType,</span>
<span class="line" id="L228"></span>
<span class="line" id="L229">        buffer: [buffer_size]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L230"></span>
<span class="line" id="L231">        <span class="tok-comment">/// The allocator is only used to track `[]` and `{}` nesting levels.</span></span>
<span class="line" id="L232">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: Allocator, io_reader: ReaderType) <span class="tok-builtin">@This</span>() {</span>
<span class="line" id="L233">            <span class="tok-kw">return</span> .{</span>
<span class="line" id="L234">                .scanner = Scanner.initStreaming(allocator),</span>
<span class="line" id="L235">                .reader = io_reader,</span>
<span class="line" id="L236">            };</span>
<span class="line" id="L237">        }</span>
<span class="line" id="L238">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {</span>
<span class="line" id="L239">            self.scanner.deinit();</span>
<span class="line" id="L240">            self.* = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L241">        }</span>
<span class="line" id="L242"></span>
<span class="line" id="L243">        <span class="tok-comment">/// Calls `std.json.Scanner.enableDiagnostics`.</span></span>
<span class="line" id="L244">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">enableDiagnostics</span>(self: *<span class="tok-builtin">@This</span>(), diagnostics: *Diagnostics) <span class="tok-type">void</span> {</span>
<span class="line" id="L245">            self.scanner.enableDiagnostics(diagnostics);</span>
<span class="line" id="L246">        }</span>
<span class="line" id="L247"></span>
<span class="line" id="L248">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> NextError = ReaderType.Error || Error || Allocator.Error;</span>
<span class="line" id="L249">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> SkipError = NextError;</span>
<span class="line" id="L250">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> AllocError = NextError || <span class="tok-kw">error</span>{ValueTooLong};</span>
<span class="line" id="L251">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> PeekError = ReaderType.Error || Error;</span>
<span class="line" id="L252"></span>
<span class="line" id="L253">        <span class="tok-comment">/// Equivalent to `nextAllocMax(allocator, when, default_max_value_len);`</span></span>
<span class="line" id="L254">        <span class="tok-comment">/// See also `std.json.Token` for documentation of `nextAlloc*()` function behavior.</span></span>
<span class="line" id="L255">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextAlloc</span>(self: *<span class="tok-builtin">@This</span>(), allocator: Allocator, when: AllocWhen) AllocError!Token {</span>
<span class="line" id="L256">            <span class="tok-kw">return</span> self.nextAllocMax(allocator, when, default_max_value_len);</span>
<span class="line" id="L257">        }</span>
<span class="line" id="L258">        <span class="tok-comment">/// See also `std.json.Token` for documentation of `nextAlloc*()` function behavior.</span></span>
<span class="line" id="L259">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextAllocMax</span>(self: *<span class="tok-builtin">@This</span>(), allocator: Allocator, when: AllocWhen, max_value_len: <span class="tok-type">usize</span>) AllocError!Token {</span>
<span class="line" id="L260">            <span class="tok-kw">const</span> token_type = <span class="tok-kw">try</span> self.peekNextTokenType();</span>
<span class="line" id="L261">            <span class="tok-kw">switch</span> (token_type) {</span>
<span class="line" id="L262">                .number, .string =&gt; {</span>
<span class="line" id="L263">                    <span class="tok-kw">var</span> value_list = ArrayList(<span class="tok-type">u8</span>).init(allocator);</span>
<span class="line" id="L264">                    <span class="tok-kw">errdefer</span> {</span>
<span class="line" id="L265">                        value_list.deinit();</span>
<span class="line" id="L266">                    }</span>
<span class="line" id="L267">                    <span class="tok-kw">if</span> (<span class="tok-kw">try</span> self.allocNextIntoArrayListMax(&amp;value_list, when, max_value_len)) |slice| {</span>
<span class="line" id="L268">                        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (token_type == .number)</span>
<span class="line" id="L269">                            Token{ .number = slice }</span>
<span class="line" id="L270">                        <span class="tok-kw">else</span></span>
<span class="line" id="L271">                            Token{ .string = slice };</span>
<span class="line" id="L272">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L273">                        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (token_type == .number)</span>
<span class="line" id="L274">                            Token{ .allocated_number = <span class="tok-kw">try</span> value_list.toOwnedSlice() }</span>
<span class="line" id="L275">                        <span class="tok-kw">else</span></span>
<span class="line" id="L276">                            Token{ .allocated_string = <span class="tok-kw">try</span> value_list.toOwnedSlice() };</span>
<span class="line" id="L277">                    }</span>
<span class="line" id="L278">                },</span>
<span class="line" id="L279"></span>
<span class="line" id="L280">                <span class="tok-comment">// Simple tokens never alloc.</span>
</span>
<span class="line" id="L281">                .object_begin,</span>
<span class="line" id="L282">                .object_end,</span>
<span class="line" id="L283">                .array_begin,</span>
<span class="line" id="L284">                .array_end,</span>
<span class="line" id="L285">                .<span class="tok-null">true</span>,</span>
<span class="line" id="L286">                .<span class="tok-null">false</span>,</span>
<span class="line" id="L287">                .<span class="tok-null">null</span>,</span>
<span class="line" id="L288">                .end_of_document,</span>
<span class="line" id="L289">                =&gt; <span class="tok-kw">return</span> <span class="tok-kw">try</span> self.next(),</span>
<span class="line" id="L290">            }</span>
<span class="line" id="L291">        }</span>
<span class="line" id="L292"></span>
<span class="line" id="L293">        <span class="tok-comment">/// Equivalent to `allocNextIntoArrayListMax(value_list, when, default_max_value_len);`</span></span>
<span class="line" id="L294">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocNextIntoArrayList</span>(self: *<span class="tok-builtin">@This</span>(), value_list: *ArrayList(<span class="tok-type">u8</span>), when: AllocWhen) AllocError!?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L295">            <span class="tok-kw">return</span> self.allocNextIntoArrayListMax(value_list, when, default_max_value_len);</span>
<span class="line" id="L296">        }</span>
<span class="line" id="L297">        <span class="tok-comment">/// Calls `std.json.Scanner.allocNextIntoArrayListMax` and handles `error.BufferUnderrun`.</span></span>
<span class="line" id="L298">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocNextIntoArrayListMax</span>(self: *<span class="tok-builtin">@This</span>(), value_list: *ArrayList(<span class="tok-type">u8</span>), when: AllocWhen, max_value_len: <span class="tok-type">usize</span>) AllocError!?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L299">            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L300">                <span class="tok-kw">return</span> self.scanner.allocNextIntoArrayListMax(value_list, when, max_value_len) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L301">                    <span class="tok-kw">error</span>.BufferUnderrun =&gt; {</span>
<span class="line" id="L302">                        <span class="tok-kw">try</span> self.refillBuffer();</span>
<span class="line" id="L303">                        <span class="tok-kw">continue</span>;</span>
<span class="line" id="L304">                    },</span>
<span class="line" id="L305">                    <span class="tok-kw">else</span> =&gt; |other_err| <span class="tok-kw">return</span> other_err,</span>
<span class="line" id="L306">                };</span>
<span class="line" id="L307">            }</span>
<span class="line" id="L308">        }</span>
<span class="line" id="L309"></span>
<span class="line" id="L310">        <span class="tok-comment">/// Like `std.json.Scanner.skipValue`, but handles `error.BufferUnderrun`.</span></span>
<span class="line" id="L311">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">skipValue</span>(self: *<span class="tok-builtin">@This</span>()) SkipError!<span class="tok-type">void</span> {</span>
<span class="line" id="L312">            <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.peekNextTokenType()) {</span>
<span class="line" id="L313">                .object_begin, .array_begin =&gt; {</span>
<span class="line" id="L314">                    <span class="tok-kw">try</span> self.skipUntilStackHeight(self.stackHeight());</span>
<span class="line" id="L315">                },</span>
<span class="line" id="L316">                .number, .string =&gt; {</span>
<span class="line" id="L317">                    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L318">                        <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.next()) {</span>
<span class="line" id="L319">                            .partial_number,</span>
<span class="line" id="L320">                            .partial_string,</span>
<span class="line" id="L321">                            .partial_string_escaped_1,</span>
<span class="line" id="L322">                            .partial_string_escaped_2,</span>
<span class="line" id="L323">                            .partial_string_escaped_3,</span>
<span class="line" id="L324">                            .partial_string_escaped_4,</span>
<span class="line" id="L325">                            =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L326"></span>
<span class="line" id="L327">                            .number, .string =&gt; <span class="tok-kw">break</span>,</span>
<span class="line" id="L328"></span>
<span class="line" id="L329">                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L330">                        }</span>
<span class="line" id="L331">                    }</span>
<span class="line" id="L332">                },</span>
<span class="line" id="L333">                .<span class="tok-null">true</span>, .<span class="tok-null">false</span>, .<span class="tok-null">null</span> =&gt; {</span>
<span class="line" id="L334">                    _ = <span class="tok-kw">try</span> self.next();</span>
<span class="line" id="L335">                },</span>
<span class="line" id="L336"></span>
<span class="line" id="L337">                .object_end, .array_end, .end_of_document =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Attempt to skip a non-value token.</span>
</span>
<span class="line" id="L338">            }</span>
<span class="line" id="L339">        }</span>
<span class="line" id="L340">        <span class="tok-comment">/// Like `std.json.Scanner.skipUntilStackHeight()` but handles `error.BufferUnderrun`.</span></span>
<span class="line" id="L341">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">skipUntilStackHeight</span>(self: *<span class="tok-builtin">@This</span>(), terminal_stack_height: <span class="tok-type">usize</span>) NextError!<span class="tok-type">void</span> {</span>
<span class="line" id="L342">            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L343">                <span class="tok-kw">return</span> self.scanner.skipUntilStackHeight(terminal_stack_height) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L344">                    <span class="tok-kw">error</span>.BufferUnderrun =&gt; {</span>
<span class="line" id="L345">                        <span class="tok-kw">try</span> self.refillBuffer();</span>
<span class="line" id="L346">                        <span class="tok-kw">continue</span>;</span>
<span class="line" id="L347">                    },</span>
<span class="line" id="L348">                    <span class="tok-kw">else</span> =&gt; |other_err| <span class="tok-kw">return</span> other_err,</span>
<span class="line" id="L349">                };</span>
<span class="line" id="L350">            }</span>
<span class="line" id="L351">        }</span>
<span class="line" id="L352"></span>
<span class="line" id="L353">        <span class="tok-comment">/// Calls `std.json.Scanner.stackHeight`.</span></span>
<span class="line" id="L354">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stackHeight</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) <span class="tok-type">usize</span> {</span>
<span class="line" id="L355">            <span class="tok-kw">return</span> self.scanner.stackHeight();</span>
<span class="line" id="L356">        }</span>
<span class="line" id="L357">        <span class="tok-comment">/// Calls `std.json.Scanner.ensureTotalStackCapacity`.</span></span>
<span class="line" id="L358">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalStackCapacity</span>(self: *<span class="tok-builtin">@This</span>(), height: <span class="tok-type">usize</span>) Allocator.Error!<span class="tok-type">void</span> {</span>
<span class="line" id="L359">            <span class="tok-kw">try</span> self.scanner.ensureTotalStackCapacity(height);</span>
<span class="line" id="L360">        }</span>
<span class="line" id="L361"></span>
<span class="line" id="L362">        <span class="tok-comment">/// See `std.json.Token` for documentation of this function.</span></span>
<span class="line" id="L363">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<span class="tok-builtin">@This</span>()) NextError!Token {</span>
<span class="line" id="L364">            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L365">                <span class="tok-kw">return</span> self.scanner.next() <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L366">                    <span class="tok-kw">error</span>.BufferUnderrun =&gt; {</span>
<span class="line" id="L367">                        <span class="tok-kw">try</span> self.refillBuffer();</span>
<span class="line" id="L368">                        <span class="tok-kw">continue</span>;</span>
<span class="line" id="L369">                    },</span>
<span class="line" id="L370">                    <span class="tok-kw">else</span> =&gt; |other_err| <span class="tok-kw">return</span> other_err,</span>
<span class="line" id="L371">                };</span>
<span class="line" id="L372">            }</span>
<span class="line" id="L373">        }</span>
<span class="line" id="L374"></span>
<span class="line" id="L375">        <span class="tok-comment">/// See `std.json.Scanner.peekNextTokenType()`.</span></span>
<span class="line" id="L376">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peekNextTokenType</span>(self: *<span class="tok-builtin">@This</span>()) PeekError!TokenType {</span>
<span class="line" id="L377">            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L378">                <span class="tok-kw">return</span> self.scanner.peekNextTokenType() <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L379">                    <span class="tok-kw">error</span>.BufferUnderrun =&gt; {</span>
<span class="line" id="L380">                        <span class="tok-kw">try</span> self.refillBuffer();</span>
<span class="line" id="L381">                        <span class="tok-kw">continue</span>;</span>
<span class="line" id="L382">                    },</span>
<span class="line" id="L383">                    <span class="tok-kw">else</span> =&gt; |other_err| <span class="tok-kw">return</span> other_err,</span>
<span class="line" id="L384">                };</span>
<span class="line" id="L385">            }</span>
<span class="line" id="L386">        }</span>
<span class="line" id="L387"></span>
<span class="line" id="L388">        <span class="tok-kw">fn</span> <span class="tok-fn">refillBuffer</span>(self: *<span class="tok-builtin">@This</span>()) ReaderType.Error!<span class="tok-type">void</span> {</span>
<span class="line" id="L389">            <span class="tok-kw">const</span> input = self.buffer[<span class="tok-number">0</span>..<span class="tok-kw">try</span> self.reader.read(self.buffer[<span class="tok-number">0</span>..])];</span>
<span class="line" id="L390">            <span class="tok-kw">if</span> (input.len &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L391">                self.scanner.feedInput(input);</span>
<span class="line" id="L392">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L393">                self.scanner.endInput();</span>
<span class="line" id="L394">            }</span>
<span class="line" id="L395">        }</span>
<span class="line" id="L396">    };</span>
<span class="line" id="L397">}</span>
<span class="line" id="L398"></span>
<span class="line" id="L399"><span class="tok-comment">/// The lowest level parsing API in this package;</span></span>
<span class="line" id="L400"><span class="tok-comment">/// supports streaming input with a low memory footprint.</span></span>
<span class="line" id="L401"><span class="tok-comment">/// The memory requirement is `O(d)` where d is the nesting depth of `[]` or `{}` containers in the input.</span></span>
<span class="line" id="L402"><span class="tok-comment">/// Specifically `d/8` bytes are required for this purpose,</span></span>
<span class="line" id="L403"><span class="tok-comment">/// with some extra buffer according to the implementation of `std.ArrayList`.</span></span>
<span class="line" id="L404"><span class="tok-comment">///</span></span>
<span class="line" id="L405"><span class="tok-comment">/// This scanner can emit partial tokens; see `std.json.Token`.</span></span>
<span class="line" id="L406"><span class="tok-comment">/// The input to this class is a sequence of input buffers that you must supply one at a time.</span></span>
<span class="line" id="L407"><span class="tok-comment">/// Call `feedInput()` with the first buffer, then call `next()` repeatedly until `error.BufferUnderrun` is returned.</span></span>
<span class="line" id="L408"><span class="tok-comment">/// Then call `feedInput()` again and so forth.</span></span>
<span class="line" id="L409"><span class="tok-comment">/// Call `endInput()` when the last input buffer has been given to `feedInput()`, either immediately after calling `feedInput()`,</span></span>
<span class="line" id="L410"><span class="tok-comment">/// or when `error.BufferUnderrun` requests more data and there is no more.</span></span>
<span class="line" id="L411"><span class="tok-comment">/// Be sure to call `next()` after calling `endInput()` until `Token.end_of_document` has been returned.</span></span>
<span class="line" id="L412"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Scanner = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L413">    state: State = .value,</span>
<span class="line" id="L414">    string_is_object_key: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L415">    stack: BitStack,</span>
<span class="line" id="L416">    value_start: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L417">    unicode_code_point: <span class="tok-type">u21</span> = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L418"></span>
<span class="line" id="L419">    input: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;&quot;</span>,</span>
<span class="line" id="L420">    cursor: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L421">    is_end_of_input: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L422">    diagnostics: ?*Diagnostics = <span class="tok-null">null</span>,</span>
<span class="line" id="L423"></span>
<span class="line" id="L424">    <span class="tok-comment">/// The allocator is only used to track `[]` and `{}` nesting levels.</span></span>
<span class="line" id="L425">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initStreaming</span>(allocator: Allocator) <span class="tok-builtin">@This</span>() {</span>
<span class="line" id="L426">        <span class="tok-kw">return</span> .{</span>
<span class="line" id="L427">            .stack = BitStack.init(allocator),</span>
<span class="line" id="L428">        };</span>
<span class="line" id="L429">    }</span>
<span class="line" id="L430">    <span class="tok-comment">/// Use this if your input is a single slice.</span></span>
<span class="line" id="L431">    <span class="tok-comment">/// This is effectively equivalent to:</span></span>
<span class="line" id="L432">    <span class="tok-comment">/// ```</span></span>
<span class="line" id="L433">    <span class="tok-comment">/// initStreaming(allocator);</span></span>
<span class="line" id="L434">    <span class="tok-comment">/// feedInput(complete_input);</span></span>
<span class="line" id="L435">    <span class="tok-comment">/// endInput();</span></span>
<span class="line" id="L436">    <span class="tok-comment">/// ```</span></span>
<span class="line" id="L437">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initCompleteInput</span>(allocator: Allocator, complete_input: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-builtin">@This</span>() {</span>
<span class="line" id="L438">        <span class="tok-kw">return</span> .{</span>
<span class="line" id="L439">            .stack = BitStack.init(allocator),</span>
<span class="line" id="L440">            .input = complete_input,</span>
<span class="line" id="L441">            .is_end_of_input = <span class="tok-null">true</span>,</span>
<span class="line" id="L442">        };</span>
<span class="line" id="L443">    }</span>
<span class="line" id="L444">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {</span>
<span class="line" id="L445">        self.stack.deinit();</span>
<span class="line" id="L446">        self.* = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L447">    }</span>
<span class="line" id="L448"></span>
<span class="line" id="L449">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">enableDiagnostics</span>(self: *<span class="tok-builtin">@This</span>(), diagnostics: *Diagnostics) <span class="tok-type">void</span> {</span>
<span class="line" id="L450">        diagnostics.cursor_pointer = &amp;self.cursor;</span>
<span class="line" id="L451">        self.diagnostics = diagnostics;</span>
<span class="line" id="L452">    }</span>
<span class="line" id="L453"></span>
<span class="line" id="L454">    <span class="tok-comment">/// Call this whenever you get `error.BufferUnderrun` from `next()`.</span></span>
<span class="line" id="L455">    <span class="tok-comment">/// When there is no more input to provide, call `endInput()`.</span></span>
<span class="line" id="L456">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">feedInput</span>(self: *<span class="tok-builtin">@This</span>(), input: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L457">        assert(self.cursor == self.input.len); <span class="tok-comment">// Not done with the last input slice.</span>
</span>
<span class="line" id="L458">        <span class="tok-kw">if</span> (self.diagnostics) |diag| {</span>
<span class="line" id="L459">            diag.total_bytes_before_current_input += self.input.len;</span>
<span class="line" id="L460">            <span class="tok-comment">// This usually goes &quot;negative&quot; to measure how far before the beginning</span>
</span>
<span class="line" id="L461">            <span class="tok-comment">// of the new buffer the current line started.</span>
</span>
<span class="line" id="L462">            diag.line_start_cursor -%= self.cursor;</span>
<span class="line" id="L463">        }</span>
<span class="line" id="L464">        self.input = input;</span>
<span class="line" id="L465">        self.cursor = <span class="tok-number">0</span>;</span>
<span class="line" id="L466">        self.value_start = <span class="tok-number">0</span>;</span>
<span class="line" id="L467">    }</span>
<span class="line" id="L468">    <span class="tok-comment">/// Call this when you will no longer call `feedInput()` anymore.</span></span>
<span class="line" id="L469">    <span class="tok-comment">/// This can be called either immediately after the last `feedInput()`,</span></span>
<span class="line" id="L470">    <span class="tok-comment">/// or at any time afterward, such as when getting `error.BufferUnderrun` from `next()`.</span></span>
<span class="line" id="L471">    <span class="tok-comment">/// Don't forget to call `next*()` after `endInput()` until you get `.end_of_document`.</span></span>
<span class="line" id="L472">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">endInput</span>(self: *<span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {</span>
<span class="line" id="L473">        self.is_end_of_input = <span class="tok-null">true</span>;</span>
<span class="line" id="L474">    }</span>
<span class="line" id="L475"></span>
<span class="line" id="L476">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> NextError = Error || Allocator.Error || <span class="tok-kw">error</span>{BufferUnderrun};</span>
<span class="line" id="L477">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> AllocError = Error || Allocator.Error || <span class="tok-kw">error</span>{ValueTooLong};</span>
<span class="line" id="L478">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> PeekError = Error || <span class="tok-kw">error</span>{BufferUnderrun};</span>
<span class="line" id="L479">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> SkipError = Error || Allocator.Error;</span>
<span class="line" id="L480">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> AllocIntoArrayListError = AllocError || <span class="tok-kw">error</span>{BufferUnderrun};</span>
<span class="line" id="L481"></span>
<span class="line" id="L482">    <span class="tok-comment">/// Equivalent to `nextAllocMax(allocator, when, default_max_value_len);`</span></span>
<span class="line" id="L483">    <span class="tok-comment">/// This function is only available after `endInput()` (or `initCompleteInput()`) has been called.</span></span>
<span class="line" id="L484">    <span class="tok-comment">/// See also `std.json.Token` for documentation of `nextAlloc*()` function behavior.</span></span>
<span class="line" id="L485">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextAlloc</span>(self: *<span class="tok-builtin">@This</span>(), allocator: Allocator, when: AllocWhen) AllocError!Token {</span>
<span class="line" id="L486">        <span class="tok-kw">return</span> self.nextAllocMax(allocator, when, default_max_value_len);</span>
<span class="line" id="L487">    }</span>
<span class="line" id="L488"></span>
<span class="line" id="L489">    <span class="tok-comment">/// This function is only available after `endInput()` (or `initCompleteInput()`) has been called.</span></span>
<span class="line" id="L490">    <span class="tok-comment">/// See also `std.json.Token` for documentation of `nextAlloc*()` function behavior.</span></span>
<span class="line" id="L491">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextAllocMax</span>(self: *<span class="tok-builtin">@This</span>(), allocator: Allocator, when: AllocWhen, max_value_len: <span class="tok-type">usize</span>) AllocError!Token {</span>
<span class="line" id="L492">        assert(self.is_end_of_input); <span class="tok-comment">// This function is not available in streaming mode.</span>
</span>
<span class="line" id="L493">        <span class="tok-kw">const</span> token_type = self.peekNextTokenType() <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {</span>
<span class="line" id="L494">            <span class="tok-kw">error</span>.BufferUnderrun =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L495">            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> err,</span>
<span class="line" id="L496">        };</span>
<span class="line" id="L497">        <span class="tok-kw">switch</span> (token_type) {</span>
<span class="line" id="L498">            .number, .string =&gt; {</span>
<span class="line" id="L499">                <span class="tok-kw">var</span> value_list = ArrayList(<span class="tok-type">u8</span>).init(allocator);</span>
<span class="line" id="L500">                <span class="tok-kw">errdefer</span> {</span>
<span class="line" id="L501">                    value_list.deinit();</span>
<span class="line" id="L502">                }</span>
<span class="line" id="L503">                <span class="tok-kw">if</span> (self.allocNextIntoArrayListMax(&amp;value_list, when, max_value_len) <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {</span>
<span class="line" id="L504">                    <span class="tok-kw">error</span>.BufferUnderrun =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L505">                    <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> err,</span>
<span class="line" id="L506">                }) |slice| {</span>
<span class="line" id="L507">                    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (token_type == .number)</span>
<span class="line" id="L508">                        Token{ .number = slice }</span>
<span class="line" id="L509">                    <span class="tok-kw">else</span></span>
<span class="line" id="L510">                        Token{ .string = slice };</span>
<span class="line" id="L511">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L512">                    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (token_type == .number)</span>
<span class="line" id="L513">                        Token{ .allocated_number = <span class="tok-kw">try</span> value_list.toOwnedSlice() }</span>
<span class="line" id="L514">                    <span class="tok-kw">else</span></span>
<span class="line" id="L515">                        Token{ .allocated_string = <span class="tok-kw">try</span> value_list.toOwnedSlice() };</span>
<span class="line" id="L516">                }</span>
<span class="line" id="L517">            },</span>
<span class="line" id="L518"></span>
<span class="line" id="L519">            <span class="tok-comment">// Simple tokens never alloc.</span>
</span>
<span class="line" id="L520">            .object_begin,</span>
<span class="line" id="L521">            .object_end,</span>
<span class="line" id="L522">            .array_begin,</span>
<span class="line" id="L523">            .array_end,</span>
<span class="line" id="L524">            .<span class="tok-null">true</span>,</span>
<span class="line" id="L525">            .<span class="tok-null">false</span>,</span>
<span class="line" id="L526">            .<span class="tok-null">null</span>,</span>
<span class="line" id="L527">            .end_of_document,</span>
<span class="line" id="L528">            =&gt; <span class="tok-kw">return</span> self.next() <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {</span>
<span class="line" id="L529">                <span class="tok-kw">error</span>.BufferUnderrun =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L530">                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> err,</span>
<span class="line" id="L531">            },</span>
<span class="line" id="L532">        }</span>
<span class="line" id="L533">    }</span>
<span class="line" id="L534"></span>
<span class="line" id="L535">    <span class="tok-comment">/// Equivalent to `allocNextIntoArrayListMax(value_list, when, default_max_value_len);`</span></span>
<span class="line" id="L536">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocNextIntoArrayList</span>(self: *<span class="tok-builtin">@This</span>(), value_list: *ArrayList(<span class="tok-type">u8</span>), when: AllocWhen) AllocIntoArrayListError!?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L537">        <span class="tok-kw">return</span> self.allocNextIntoArrayListMax(value_list, when, default_max_value_len);</span>
<span class="line" id="L538">    }</span>
<span class="line" id="L539">    <span class="tok-comment">/// The next token type must be either `.number` or `.string`. See `peekNextTokenType()`.</span></span>
<span class="line" id="L540">    <span class="tok-comment">/// When allocation is not necessary with `.alloc_if_needed`,</span></span>
<span class="line" id="L541">    <span class="tok-comment">/// this method returns the content slice from the input buffer, and `value_list` is not touched.</span></span>
<span class="line" id="L542">    <span class="tok-comment">/// When allocation is necessary or with `.alloc_always`, this method concatenates partial tokens into the given `value_list`,</span></span>
<span class="line" id="L543">    <span class="tok-comment">/// and returns `null` once the final `.number` or `.string` token has been written into it.</span></span>
<span class="line" id="L544">    <span class="tok-comment">/// In case of an `error.BufferUnderrun`, partial values will be left in the given value_list.</span></span>
<span class="line" id="L545">    <span class="tok-comment">/// The given `value_list` is never reset by this method, so an `error.BufferUnderrun` situation</span></span>
<span class="line" id="L546">    <span class="tok-comment">/// can be resumed by passing the same array list in again.</span></span>
<span class="line" id="L547">    <span class="tok-comment">/// This method does not indicate whether the token content being returned is for a `.number` or `.string` token type;</span></span>
<span class="line" id="L548">    <span class="tok-comment">/// the caller of this method is expected to know which type of token is being processed.</span></span>
<span class="line" id="L549">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocNextIntoArrayListMax</span>(self: *<span class="tok-builtin">@This</span>(), value_list: *ArrayList(<span class="tok-type">u8</span>), when: AllocWhen, max_value_len: <span class="tok-type">usize</span>) AllocIntoArrayListError!?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L550">        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L551">            <span class="tok-kw">const</span> token = <span class="tok-kw">try</span> self.next();</span>
<span class="line" id="L552">            <span class="tok-kw">switch</span> (token) {</span>
<span class="line" id="L553">                <span class="tok-comment">// Accumulate partial values.</span>
</span>
<span class="line" id="L554">                .partial_number, .partial_string =&gt; |slice| {</span>
<span class="line" id="L555">                    <span class="tok-kw">try</span> appendSlice(value_list, slice, max_value_len);</span>
<span class="line" id="L556">                },</span>
<span class="line" id="L557">                .partial_string_escaped_1 =&gt; |buf| {</span>
<span class="line" id="L558">                    <span class="tok-kw">try</span> appendSlice(value_list, buf[<span class="tok-number">0</span>..], max_value_len);</span>
<span class="line" id="L559">                },</span>
<span class="line" id="L560">                .partial_string_escaped_2 =&gt; |buf| {</span>
<span class="line" id="L561">                    <span class="tok-kw">try</span> appendSlice(value_list, buf[<span class="tok-number">0</span>..], max_value_len);</span>
<span class="line" id="L562">                },</span>
<span class="line" id="L563">                .partial_string_escaped_3 =&gt; |buf| {</span>
<span class="line" id="L564">                    <span class="tok-kw">try</span> appendSlice(value_list, buf[<span class="tok-number">0</span>..], max_value_len);</span>
<span class="line" id="L565">                },</span>
<span class="line" id="L566">                .partial_string_escaped_4 =&gt; |buf| {</span>
<span class="line" id="L567">                    <span class="tok-kw">try</span> appendSlice(value_list, buf[<span class="tok-number">0</span>..], max_value_len);</span>
<span class="line" id="L568">                },</span>
<span class="line" id="L569"></span>
<span class="line" id="L570">                <span class="tok-comment">// Return complete values.</span>
</span>
<span class="line" id="L571">                .number =&gt; |slice| {</span>
<span class="line" id="L572">                    <span class="tok-kw">if</span> (when == .alloc_if_needed <span class="tok-kw">and</span> value_list.items.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L573">                        <span class="tok-comment">// No alloc necessary.</span>
</span>
<span class="line" id="L574">                        <span class="tok-kw">return</span> slice;</span>
<span class="line" id="L575">                    }</span>
<span class="line" id="L576">                    <span class="tok-kw">try</span> appendSlice(value_list, slice, max_value_len);</span>
<span class="line" id="L577">                    <span class="tok-comment">// The token is complete.</span>
</span>
<span class="line" id="L578">                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L579">                },</span>
<span class="line" id="L580">                .string =&gt; |slice| {</span>
<span class="line" id="L581">                    <span class="tok-kw">if</span> (when == .alloc_if_needed <span class="tok-kw">and</span> value_list.items.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L582">                        <span class="tok-comment">// No alloc necessary.</span>
</span>
<span class="line" id="L583">                        <span class="tok-kw">return</span> slice;</span>
<span class="line" id="L584">                    }</span>
<span class="line" id="L585">                    <span class="tok-kw">try</span> appendSlice(value_list, slice, max_value_len);</span>
<span class="line" id="L586">                    <span class="tok-comment">// The token is complete.</span>
</span>
<span class="line" id="L587">                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L588">                },</span>
<span class="line" id="L589"></span>
<span class="line" id="L590">                .object_begin,</span>
<span class="line" id="L591">                .object_end,</span>
<span class="line" id="L592">                .array_begin,</span>
<span class="line" id="L593">                .array_end,</span>
<span class="line" id="L594">                .<span class="tok-null">true</span>,</span>
<span class="line" id="L595">                .<span class="tok-null">false</span>,</span>
<span class="line" id="L596">                .<span class="tok-null">null</span>,</span>
<span class="line" id="L597">                .end_of_document,</span>
<span class="line" id="L598">                =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Only .number and .string token types are allowed here. Check peekNextTokenType() before calling this.</span>
</span>
<span class="line" id="L599"></span>
<span class="line" id="L600">                .allocated_number, .allocated_string =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L601">            }</span>
<span class="line" id="L602">        }</span>
<span class="line" id="L603">    }</span>
<span class="line" id="L604"></span>
<span class="line" id="L605">    <span class="tok-comment">/// This function is only available after `endInput()` (or `initCompleteInput()`) has been called.</span></span>
<span class="line" id="L606">    <span class="tok-comment">/// If the next token type is `.object_begin` or `.array_begin`,</span></span>
<span class="line" id="L607">    <span class="tok-comment">/// this function calls `next()` repeatedly until the corresponding `.object_end` or `.array_end` is found.</span></span>
<span class="line" id="L608">    <span class="tok-comment">/// If the next token type is `.number` or `.string`,</span></span>
<span class="line" id="L609">    <span class="tok-comment">/// this function calls `next()` repeatedly until the (non `.partial_*`) `.number` or `.string` token is found.</span></span>
<span class="line" id="L610">    <span class="tok-comment">/// If the next token type is `.true`, `.false`, or `.null`, this function calls `next()` once.</span></span>
<span class="line" id="L611">    <span class="tok-comment">/// The next token type must not be `.object_end`, `.array_end`, or `.end_of_document`;</span></span>
<span class="line" id="L612">    <span class="tok-comment">/// see `peekNextTokenType()`.</span></span>
<span class="line" id="L613">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">skipValue</span>(self: *<span class="tok-builtin">@This</span>()) SkipError!<span class="tok-type">void</span> {</span>
<span class="line" id="L614">        assert(self.is_end_of_input); <span class="tok-comment">// This function is not available in streaming mode.</span>
</span>
<span class="line" id="L615">        <span class="tok-kw">switch</span> (self.peekNextTokenType() <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {</span>
<span class="line" id="L616">            <span class="tok-kw">error</span>.BufferUnderrun =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L617">            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> err,</span>
<span class="line" id="L618">        }) {</span>
<span class="line" id="L619">            .object_begin, .array_begin =&gt; {</span>
<span class="line" id="L620">                self.skipUntilStackHeight(self.stackHeight()) <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {</span>
<span class="line" id="L621">                    <span class="tok-kw">error</span>.BufferUnderrun =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L622">                    <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> err,</span>
<span class="line" id="L623">                };</span>
<span class="line" id="L624">            },</span>
<span class="line" id="L625">            .number, .string =&gt; {</span>
<span class="line" id="L626">                <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L627">                    <span class="tok-kw">switch</span> (self.next() <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {</span>
<span class="line" id="L628">                        <span class="tok-kw">error</span>.BufferUnderrun =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L629">                        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> err,</span>
<span class="line" id="L630">                    }) {</span>
<span class="line" id="L631">                        .partial_number,</span>
<span class="line" id="L632">                        .partial_string,</span>
<span class="line" id="L633">                        .partial_string_escaped_1,</span>
<span class="line" id="L634">                        .partial_string_escaped_2,</span>
<span class="line" id="L635">                        .partial_string_escaped_3,</span>
<span class="line" id="L636">                        .partial_string_escaped_4,</span>
<span class="line" id="L637">                        =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L638"></span>
<span class="line" id="L639">                        .number, .string =&gt; <span class="tok-kw">break</span>,</span>
<span class="line" id="L640"></span>
<span class="line" id="L641">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L642">                    }</span>
<span class="line" id="L643">                }</span>
<span class="line" id="L644">            },</span>
<span class="line" id="L645">            .<span class="tok-null">true</span>, .<span class="tok-null">false</span>, .<span class="tok-null">null</span> =&gt; {</span>
<span class="line" id="L646">                _ = self.next() <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {</span>
<span class="line" id="L647">                    <span class="tok-kw">error</span>.BufferUnderrun =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L648">                    <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> err,</span>
<span class="line" id="L649">                };</span>
<span class="line" id="L650">            },</span>
<span class="line" id="L651"></span>
<span class="line" id="L652">            .object_end, .array_end, .end_of_document =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Attempt to skip a non-value token.</span>
</span>
<span class="line" id="L653">        }</span>
<span class="line" id="L654">    }</span>
<span class="line" id="L655"></span>
<span class="line" id="L656">    <span class="tok-comment">/// Skip tokens until an `.object_end` or `.array_end` token results in a `stackHeight()` equal the given stack height.</span></span>
<span class="line" id="L657">    <span class="tok-comment">/// Unlike `skipValue()`, this function is available in streaming mode.</span></span>
<span class="line" id="L658">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">skipUntilStackHeight</span>(self: *<span class="tok-builtin">@This</span>(), terminal_stack_height: <span class="tok-type">usize</span>) NextError!<span class="tok-type">void</span> {</span>
<span class="line" id="L659">        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L660">            <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.next()) {</span>
<span class="line" id="L661">                .object_end, .array_end =&gt; {</span>
<span class="line" id="L662">                    <span class="tok-kw">if</span> (self.stackHeight() == terminal_stack_height) <span class="tok-kw">break</span>;</span>
<span class="line" id="L663">                },</span>
<span class="line" id="L664">                .end_of_document =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L665">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L666">            }</span>
<span class="line" id="L667">        }</span>
<span class="line" id="L668">    }</span>
<span class="line" id="L669"></span>
<span class="line" id="L670">    <span class="tok-comment">/// The depth of `{}` or `[]` nesting levels at the current position.</span></span>
<span class="line" id="L671">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stackHeight</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) <span class="tok-type">usize</span> {</span>
<span class="line" id="L672">        <span class="tok-kw">return</span> self.stack.bit_len;</span>
<span class="line" id="L673">    }</span>
<span class="line" id="L674"></span>
<span class="line" id="L675">    <span class="tok-comment">/// Pre allocate memory to hold the given number of nesting levels.</span></span>
<span class="line" id="L676">    <span class="tok-comment">/// `stackHeight()` up to the given number will not cause allocations.</span></span>
<span class="line" id="L677">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalStackCapacity</span>(self: *<span class="tok-builtin">@This</span>(), height: <span class="tok-type">usize</span>) Allocator.Error!<span class="tok-type">void</span> {</span>
<span class="line" id="L678">        <span class="tok-kw">try</span> self.stack.ensureTotalCapacity(height);</span>
<span class="line" id="L679">    }</span>
<span class="line" id="L680"></span>
<span class="line" id="L681">    <span class="tok-comment">/// See `std.json.Token` for documentation of this function.</span></span>
<span class="line" id="L682">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<span class="tok-builtin">@This</span>()) NextError!Token {</span>
<span class="line" id="L683">        state_loop: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L684">            <span class="tok-kw">switch</span> (self.state) {</span>
<span class="line" id="L685">                .value =&gt; {</span>
<span class="line" id="L686">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.skipWhitespaceExpectByte()) {</span>
<span class="line" id="L687">                        <span class="tok-comment">// Object, Array</span>
</span>
<span class="line" id="L688">                        <span class="tok-str">'{'</span> =&gt; {</span>
<span class="line" id="L689">                            <span class="tok-kw">try</span> self.stack.push(OBJECT_MODE);</span>
<span class="line" id="L690">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L691">                            self.state = .object_start;</span>
<span class="line" id="L692">                            <span class="tok-kw">return</span> .object_begin;</span>
<span class="line" id="L693">                        },</span>
<span class="line" id="L694">                        <span class="tok-str">'['</span> =&gt; {</span>
<span class="line" id="L695">                            <span class="tok-kw">try</span> self.stack.push(ARRAY_MODE);</span>
<span class="line" id="L696">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L697">                            self.state = .array_start;</span>
<span class="line" id="L698">                            <span class="tok-kw">return</span> .array_begin;</span>
<span class="line" id="L699">                        },</span>
<span class="line" id="L700"></span>
<span class="line" id="L701">                        <span class="tok-comment">// String</span>
</span>
<span class="line" id="L702">                        <span class="tok-str">'&quot;'</span> =&gt; {</span>
<span class="line" id="L703">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L704">                            self.value_start = self.cursor;</span>
<span class="line" id="L705">                            self.state = .string;</span>
<span class="line" id="L706">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L707">                        },</span>
<span class="line" id="L708"></span>
<span class="line" id="L709">                        <span class="tok-comment">// Number</span>
</span>
<span class="line" id="L710">                        <span class="tok-str">'1'</span>...<span class="tok-str">'9'</span> =&gt; {</span>
<span class="line" id="L711">                            self.value_start = self.cursor;</span>
<span class="line" id="L712">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L713">                            self.state = .number_int;</span>
<span class="line" id="L714">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L715">                        },</span>
<span class="line" id="L716">                        <span class="tok-str">'0'</span> =&gt; {</span>
<span class="line" id="L717">                            self.value_start = self.cursor;</span>
<span class="line" id="L718">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L719">                            self.state = .number_leading_zero;</span>
<span class="line" id="L720">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L721">                        },</span>
<span class="line" id="L722">                        <span class="tok-str">'-'</span> =&gt; {</span>
<span class="line" id="L723">                            self.value_start = self.cursor;</span>
<span class="line" id="L724">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L725">                            self.state = .number_minus;</span>
<span class="line" id="L726">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L727">                        },</span>
<span class="line" id="L728"></span>
<span class="line" id="L729">                        <span class="tok-comment">// literal values</span>
</span>
<span class="line" id="L730">                        <span class="tok-str">'t'</span> =&gt; {</span>
<span class="line" id="L731">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L732">                            self.state = .literal_t;</span>
<span class="line" id="L733">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L734">                        },</span>
<span class="line" id="L735">                        <span class="tok-str">'f'</span> =&gt; {</span>
<span class="line" id="L736">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L737">                            self.state = .literal_f;</span>
<span class="line" id="L738">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L739">                        },</span>
<span class="line" id="L740">                        <span class="tok-str">'n'</span> =&gt; {</span>
<span class="line" id="L741">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L742">                            self.state = .literal_n;</span>
<span class="line" id="L743">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L744">                        },</span>
<span class="line" id="L745"></span>
<span class="line" id="L746">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L747">                    }</span>
<span class="line" id="L748">                },</span>
<span class="line" id="L749"></span>
<span class="line" id="L750">                .post_value =&gt; {</span>
<span class="line" id="L751">                    <span class="tok-kw">if</span> (<span class="tok-kw">try</span> self.skipWhitespaceCheckEnd()) <span class="tok-kw">return</span> .end_of_document;</span>
<span class="line" id="L752"></span>
<span class="line" id="L753">                    <span class="tok-kw">const</span> c = self.input[self.cursor];</span>
<span class="line" id="L754">                    <span class="tok-kw">if</span> (self.string_is_object_key) {</span>
<span class="line" id="L755">                        self.string_is_object_key = <span class="tok-null">false</span>;</span>
<span class="line" id="L756">                        <span class="tok-kw">switch</span> (c) {</span>
<span class="line" id="L757">                            <span class="tok-str">':'</span> =&gt; {</span>
<span class="line" id="L758">                                self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L759">                                self.state = .value;</span>
<span class="line" id="L760">                                <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L761">                            },</span>
<span class="line" id="L762">                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L763">                        }</span>
<span class="line" id="L764">                    }</span>
<span class="line" id="L765"></span>
<span class="line" id="L766">                    <span class="tok-kw">switch</span> (c) {</span>
<span class="line" id="L767">                        <span class="tok-str">'}'</span> =&gt; {</span>
<span class="line" id="L768">                            <span class="tok-kw">if</span> (self.stack.pop() != OBJECT_MODE) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError;</span>
<span class="line" id="L769">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L770">                            <span class="tok-comment">// stay in .post_value state.</span>
</span>
<span class="line" id="L771">                            <span class="tok-kw">return</span> .object_end;</span>
<span class="line" id="L772">                        },</span>
<span class="line" id="L773">                        <span class="tok-str">']'</span> =&gt; {</span>
<span class="line" id="L774">                            <span class="tok-kw">if</span> (self.stack.pop() != ARRAY_MODE) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError;</span>
<span class="line" id="L775">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L776">                            <span class="tok-comment">// stay in .post_value state.</span>
</span>
<span class="line" id="L777">                            <span class="tok-kw">return</span> .array_end;</span>
<span class="line" id="L778">                        },</span>
<span class="line" id="L779">                        <span class="tok-str">','</span> =&gt; {</span>
<span class="line" id="L780">                            <span class="tok-kw">switch</span> (self.stack.peek()) {</span>
<span class="line" id="L781">                                OBJECT_MODE =&gt; {</span>
<span class="line" id="L782">                                    self.state = .object_post_comma;</span>
<span class="line" id="L783">                                },</span>
<span class="line" id="L784">                                ARRAY_MODE =&gt; {</span>
<span class="line" id="L785">                                    self.state = .value;</span>
<span class="line" id="L786">                                },</span>
<span class="line" id="L787">                            }</span>
<span class="line" id="L788">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L789">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L790">                        },</span>
<span class="line" id="L791">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L792">                    }</span>
<span class="line" id="L793">                },</span>
<span class="line" id="L794"></span>
<span class="line" id="L795">                .object_start =&gt; {</span>
<span class="line" id="L796">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.skipWhitespaceExpectByte()) {</span>
<span class="line" id="L797">                        <span class="tok-str">'&quot;'</span> =&gt; {</span>
<span class="line" id="L798">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L799">                            self.value_start = self.cursor;</span>
<span class="line" id="L800">                            self.state = .string;</span>
<span class="line" id="L801">                            self.string_is_object_key = <span class="tok-null">true</span>;</span>
<span class="line" id="L802">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L803">                        },</span>
<span class="line" id="L804">                        <span class="tok-str">'}'</span> =&gt; {</span>
<span class="line" id="L805">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L806">                            _ = self.stack.pop();</span>
<span class="line" id="L807">                            self.state = .post_value;</span>
<span class="line" id="L808">                            <span class="tok-kw">return</span> .object_end;</span>
<span class="line" id="L809">                        },</span>
<span class="line" id="L810">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L811">                    }</span>
<span class="line" id="L812">                },</span>
<span class="line" id="L813">                .object_post_comma =&gt; {</span>
<span class="line" id="L814">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.skipWhitespaceExpectByte()) {</span>
<span class="line" id="L815">                        <span class="tok-str">'&quot;'</span> =&gt; {</span>
<span class="line" id="L816">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L817">                            self.value_start = self.cursor;</span>
<span class="line" id="L818">                            self.state = .string;</span>
<span class="line" id="L819">                            self.string_is_object_key = <span class="tok-null">true</span>;</span>
<span class="line" id="L820">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L821">                        },</span>
<span class="line" id="L822">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L823">                    }</span>
<span class="line" id="L824">                },</span>
<span class="line" id="L825"></span>
<span class="line" id="L826">                .array_start =&gt; {</span>
<span class="line" id="L827">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.skipWhitespaceExpectByte()) {</span>
<span class="line" id="L828">                        <span class="tok-str">']'</span> =&gt; {</span>
<span class="line" id="L829">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L830">                            _ = self.stack.pop();</span>
<span class="line" id="L831">                            self.state = .post_value;</span>
<span class="line" id="L832">                            <span class="tok-kw">return</span> .array_end;</span>
<span class="line" id="L833">                        },</span>
<span class="line" id="L834">                        <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L835">                            self.state = .value;</span>
<span class="line" id="L836">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L837">                        },</span>
<span class="line" id="L838">                    }</span>
<span class="line" id="L839">                },</span>
<span class="line" id="L840"></span>
<span class="line" id="L841">                .number_minus =&gt; {</span>
<span class="line" id="L842">                    <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInNumber(<span class="tok-null">false</span>);</span>
<span class="line" id="L843">                    <span class="tok-kw">switch</span> (self.input[self.cursor]) {</span>
<span class="line" id="L844">                        <span class="tok-str">'0'</span> =&gt; {</span>
<span class="line" id="L845">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L846">                            self.state = .number_leading_zero;</span>
<span class="line" id="L847">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L848">                        },</span>
<span class="line" id="L849">                        <span class="tok-str">'1'</span>...<span class="tok-str">'9'</span> =&gt; {</span>
<span class="line" id="L850">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L851">                            self.state = .number_int;</span>
<span class="line" id="L852">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L853">                        },</span>
<span class="line" id="L854">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L855">                    }</span>
<span class="line" id="L856">                },</span>
<span class="line" id="L857">                .number_leading_zero =&gt; {</span>
<span class="line" id="L858">                    <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInNumber(<span class="tok-null">true</span>);</span>
<span class="line" id="L859">                    <span class="tok-kw">switch</span> (self.input[self.cursor]) {</span>
<span class="line" id="L860">                        <span class="tok-str">'.'</span> =&gt; {</span>
<span class="line" id="L861">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L862">                            self.state = .number_post_dot;</span>
<span class="line" id="L863">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L864">                        },</span>
<span class="line" id="L865">                        <span class="tok-str">'e'</span>, <span class="tok-str">'E'</span> =&gt; {</span>
<span class="line" id="L866">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L867">                            self.state = .number_post_e;</span>
<span class="line" id="L868">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L869">                        },</span>
<span class="line" id="L870">                        <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L871">                            self.state = .post_value;</span>
<span class="line" id="L872">                            <span class="tok-kw">return</span> Token{ .number = self.takeValueSlice() };</span>
<span class="line" id="L873">                        },</span>
<span class="line" id="L874">                    }</span>
<span class="line" id="L875">                },</span>
<span class="line" id="L876">                .number_int =&gt; {</span>
<span class="line" id="L877">                    <span class="tok-kw">while</span> (self.cursor &lt; self.input.len) : (self.cursor += <span class="tok-number">1</span>) {</span>
<span class="line" id="L878">                        <span class="tok-kw">switch</span> (self.input[self.cursor]) {</span>
<span class="line" id="L879">                            <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L880">                            <span class="tok-str">'.'</span> =&gt; {</span>
<span class="line" id="L881">                                self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L882">                                self.state = .number_post_dot;</span>
<span class="line" id="L883">                                <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L884">                            },</span>
<span class="line" id="L885">                            <span class="tok-str">'e'</span>, <span class="tok-str">'E'</span> =&gt; {</span>
<span class="line" id="L886">                                self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L887">                                self.state = .number_post_e;</span>
<span class="line" id="L888">                                <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L889">                            },</span>
<span class="line" id="L890">                            <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L891">                                self.state = .post_value;</span>
<span class="line" id="L892">                                <span class="tok-kw">return</span> Token{ .number = self.takeValueSlice() };</span>
<span class="line" id="L893">                            },</span>
<span class="line" id="L894">                        }</span>
<span class="line" id="L895">                    }</span>
<span class="line" id="L896">                    <span class="tok-kw">return</span> self.endOfBufferInNumber(<span class="tok-null">true</span>);</span>
<span class="line" id="L897">                },</span>
<span class="line" id="L898">                .number_post_dot =&gt; {</span>
<span class="line" id="L899">                    <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInNumber(<span class="tok-null">false</span>);</span>
<span class="line" id="L900">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L901">                        <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {</span>
<span class="line" id="L902">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L903">                            self.state = .number_frac;</span>
<span class="line" id="L904">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L905">                        },</span>
<span class="line" id="L906">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L907">                    }</span>
<span class="line" id="L908">                },</span>
<span class="line" id="L909">                .number_frac =&gt; {</span>
<span class="line" id="L910">                    <span class="tok-kw">while</span> (self.cursor &lt; self.input.len) : (self.cursor += <span class="tok-number">1</span>) {</span>
<span class="line" id="L911">                        <span class="tok-kw">switch</span> (self.input[self.cursor]) {</span>
<span class="line" id="L912">                            <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L913">                            <span class="tok-str">'e'</span>, <span class="tok-str">'E'</span> =&gt; {</span>
<span class="line" id="L914">                                self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L915">                                self.state = .number_post_e;</span>
<span class="line" id="L916">                                <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L917">                            },</span>
<span class="line" id="L918">                            <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L919">                                self.state = .post_value;</span>
<span class="line" id="L920">                                <span class="tok-kw">return</span> Token{ .number = self.takeValueSlice() };</span>
<span class="line" id="L921">                            },</span>
<span class="line" id="L922">                        }</span>
<span class="line" id="L923">                    }</span>
<span class="line" id="L924">                    <span class="tok-kw">return</span> self.endOfBufferInNumber(<span class="tok-null">true</span>);</span>
<span class="line" id="L925">                },</span>
<span class="line" id="L926">                .number_post_e =&gt; {</span>
<span class="line" id="L927">                    <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInNumber(<span class="tok-null">false</span>);</span>
<span class="line" id="L928">                    <span class="tok-kw">switch</span> (self.input[self.cursor]) {</span>
<span class="line" id="L929">                        <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {</span>
<span class="line" id="L930">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L931">                            self.state = .number_exp;</span>
<span class="line" id="L932">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L933">                        },</span>
<span class="line" id="L934">                        <span class="tok-str">'+'</span>, <span class="tok-str">'-'</span> =&gt; {</span>
<span class="line" id="L935">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L936">                            self.state = .number_post_e_sign;</span>
<span class="line" id="L937">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L938">                        },</span>
<span class="line" id="L939">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L940">                    }</span>
<span class="line" id="L941">                },</span>
<span class="line" id="L942">                .number_post_e_sign =&gt; {</span>
<span class="line" id="L943">                    <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) <span class="tok-kw">return</span> self.endOfBufferInNumber(<span class="tok-null">false</span>);</span>
<span class="line" id="L944">                    <span class="tok-kw">switch</span> (self.input[self.cursor]) {</span>
<span class="line" id="L945">                        <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {</span>
<span class="line" id="L946">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L947">                            self.state = .number_exp;</span>
<span class="line" id="L948">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L949">                        },</span>
<span class="line" id="L950">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L951">                    }</span>
<span class="line" id="L952">                },</span>
<span class="line" id="L953">                .number_exp =&gt; {</span>
<span class="line" id="L954">                    <span class="tok-kw">while</span> (self.cursor &lt; self.input.len) : (self.cursor += <span class="tok-number">1</span>) {</span>
<span class="line" id="L955">                        <span class="tok-kw">switch</span> (self.input[self.cursor]) {</span>
<span class="line" id="L956">                            <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L957">                            <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L958">                                self.state = .post_value;</span>
<span class="line" id="L959">                                <span class="tok-kw">return</span> Token{ .number = self.takeValueSlice() };</span>
<span class="line" id="L960">                            },</span>
<span class="line" id="L961">                        }</span>
<span class="line" id="L962">                    }</span>
<span class="line" id="L963">                    <span class="tok-kw">return</span> self.endOfBufferInNumber(<span class="tok-null">true</span>);</span>
<span class="line" id="L964">                },</span>
<span class="line" id="L965"></span>
<span class="line" id="L966">                .string =&gt; {</span>
<span class="line" id="L967">                    <span class="tok-kw">while</span> (self.cursor &lt; self.input.len) : (self.cursor += <span class="tok-number">1</span>) {</span>
<span class="line" id="L968">                        <span class="tok-kw">switch</span> (self.input[self.cursor]) {</span>
<span class="line" id="L969">                            <span class="tok-number">0</span>...<span class="tok-number">0x1f</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError, <span class="tok-comment">// Bare ASCII control code in string.</span>
</span>
<span class="line" id="L970"></span>
<span class="line" id="L971">                            <span class="tok-comment">// ASCII plain text.</span>
</span>
<span class="line" id="L972">                            <span class="tok-number">0x20</span>...(<span class="tok-str">'&quot;'</span> - <span class="tok-number">1</span>), (<span class="tok-str">'&quot;'</span> + <span class="tok-number">1</span>)...(<span class="tok-str">'\\'</span> - <span class="tok-number">1</span>), (<span class="tok-str">'\\'</span> + <span class="tok-number">1</span>)...<span class="tok-number">0x7F</span> =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L973"></span>
<span class="line" id="L974">                            <span class="tok-comment">// Special characters.</span>
</span>
<span class="line" id="L975">                            <span class="tok-str">'&quot;'</span> =&gt; {</span>
<span class="line" id="L976">                                <span class="tok-kw">const</span> result = Token{ .string = self.takeValueSlice() };</span>
<span class="line" id="L977">                                self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L978">                                self.state = .post_value;</span>
<span class="line" id="L979">                                <span class="tok-kw">return</span> result;</span>
<span class="line" id="L980">                            },</span>
<span class="line" id="L981">                            <span class="tok-str">'\\'</span> =&gt; {</span>
<span class="line" id="L982">                                <span class="tok-kw">const</span> slice = self.takeValueSlice();</span>
<span class="line" id="L983">                                self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L984">                                self.state = .string_backslash;</span>
<span class="line" id="L985">                                <span class="tok-kw">if</span> (slice.len &gt; <span class="tok-number">0</span>) <span class="tok-kw">return</span> Token{ .partial_string = slice };</span>
<span class="line" id="L986">                                <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L987">                            },</span>
<span class="line" id="L988"></span>
<span class="line" id="L989">                            <span class="tok-comment">// UTF-8 validation.</span>
</span>
<span class="line" id="L990">                            <span class="tok-comment">// See http://unicode.org/mail-arch/unicode-ml/y2003-m02/att-0467/01-The_Algorithm_to_Valide_an_UTF-8_String</span>
</span>
<span class="line" id="L991">                            <span class="tok-number">0xC2</span>...<span class="tok-number">0xDF</span> =&gt; {</span>
<span class="line" id="L992">                                self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L993">                                self.state = .string_utf8_last_byte;</span>
<span class="line" id="L994">                                <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L995">                            },</span>
<span class="line" id="L996">                            <span class="tok-number">0xE0</span> =&gt; {</span>
<span class="line" id="L997">                                self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L998">                                self.state = .string_utf8_second_to_last_byte_guard_against_overlong;</span>
<span class="line" id="L999">                                <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1000">                            },</span>
<span class="line" id="L1001">                            <span class="tok-number">0xE1</span>...<span class="tok-number">0xEC</span>, <span class="tok-number">0xEE</span>...<span class="tok-number">0xEF</span> =&gt; {</span>
<span class="line" id="L1002">                                self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1003">                                self.state = .string_utf8_second_to_last_byte;</span>
<span class="line" id="L1004">                                <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1005">                            },</span>
<span class="line" id="L1006">                            <span class="tok-number">0xED</span> =&gt; {</span>
<span class="line" id="L1007">                                self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1008">                                self.state = .string_utf8_second_to_last_byte_guard_against_surrogate_half;</span>
<span class="line" id="L1009">                                <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1010">                            },</span>
<span class="line" id="L1011">                            <span class="tok-number">0xF0</span> =&gt; {</span>
<span class="line" id="L1012">                                self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1013">                                self.state = .string_utf8_third_to_last_byte_guard_against_overlong;</span>
<span class="line" id="L1014">                                <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1015">                            },</span>
<span class="line" id="L1016">                            <span class="tok-number">0xF1</span>...<span class="tok-number">0xF3</span> =&gt; {</span>
<span class="line" id="L1017">                                self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1018">                                self.state = .string_utf8_third_to_last_byte;</span>
<span class="line" id="L1019">                                <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1020">                            },</span>
<span class="line" id="L1021">                            <span class="tok-number">0xF4</span> =&gt; {</span>
<span class="line" id="L1022">                                self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1023">                                self.state = .string_utf8_third_to_last_byte_guard_against_too_large;</span>
<span class="line" id="L1024">                                <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1025">                            },</span>
<span class="line" id="L1026">                            <span class="tok-number">0x80</span>...<span class="tok-number">0xC1</span>, <span class="tok-number">0xF5</span>...<span class="tok-number">0xFF</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError, <span class="tok-comment">// Invalid UTF-8.</span>
</span>
<span class="line" id="L1027">                        }</span>
<span class="line" id="L1028">                    }</span>
<span class="line" id="L1029">                    <span class="tok-kw">if</span> (self.is_end_of_input) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedEndOfInput;</span>
<span class="line" id="L1030">                    <span class="tok-kw">const</span> slice = self.takeValueSlice();</span>
<span class="line" id="L1031">                    <span class="tok-kw">if</span> (slice.len &gt; <span class="tok-number">0</span>) <span class="tok-kw">return</span> Token{ .partial_string = slice };</span>
<span class="line" id="L1032">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BufferUnderrun;</span>
<span class="line" id="L1033">                },</span>
<span class="line" id="L1034">                .string_backslash =&gt; {</span>
<span class="line" id="L1035">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1036">                        <span class="tok-str">'&quot;'</span>, <span class="tok-str">'\\'</span>, <span class="tok-str">'/'</span> =&gt; {</span>
<span class="line" id="L1037">                            <span class="tok-comment">// Since these characters now represent themselves literally,</span>
</span>
<span class="line" id="L1038">                            <span class="tok-comment">// we can simply begin the next plaintext slice here.</span>
</span>
<span class="line" id="L1039">                            self.value_start = self.cursor;</span>
<span class="line" id="L1040">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1041">                            self.state = .string;</span>
<span class="line" id="L1042">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1043">                        },</span>
<span class="line" id="L1044">                        <span class="tok-str">'b'</span> =&gt; {</span>
<span class="line" id="L1045">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1046">                            self.value_start = self.cursor;</span>
<span class="line" id="L1047">                            self.state = .string;</span>
<span class="line" id="L1048">                            <span class="tok-kw">return</span> Token{ .partial_string_escaped_1 = [_]<span class="tok-type">u8</span>{<span class="tok-number">0x08</span>} };</span>
<span class="line" id="L1049">                        },</span>
<span class="line" id="L1050">                        <span class="tok-str">'f'</span> =&gt; {</span>
<span class="line" id="L1051">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1052">                            self.value_start = self.cursor;</span>
<span class="line" id="L1053">                            self.state = .string;</span>
<span class="line" id="L1054">                            <span class="tok-kw">return</span> Token{ .partial_string_escaped_1 = [_]<span class="tok-type">u8</span>{<span class="tok-number">0x0c</span>} };</span>
<span class="line" id="L1055">                        },</span>
<span class="line" id="L1056">                        <span class="tok-str">'n'</span> =&gt; {</span>
<span class="line" id="L1057">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1058">                            self.value_start = self.cursor;</span>
<span class="line" id="L1059">                            self.state = .string;</span>
<span class="line" id="L1060">                            <span class="tok-kw">return</span> Token{ .partial_string_escaped_1 = [_]<span class="tok-type">u8</span>{<span class="tok-str">'\n'</span>} };</span>
<span class="line" id="L1061">                        },</span>
<span class="line" id="L1062">                        <span class="tok-str">'r'</span> =&gt; {</span>
<span class="line" id="L1063">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1064">                            self.value_start = self.cursor;</span>
<span class="line" id="L1065">                            self.state = .string;</span>
<span class="line" id="L1066">                            <span class="tok-kw">return</span> Token{ .partial_string_escaped_1 = [_]<span class="tok-type">u8</span>{<span class="tok-str">'\r'</span>} };</span>
<span class="line" id="L1067">                        },</span>
<span class="line" id="L1068">                        <span class="tok-str">'t'</span> =&gt; {</span>
<span class="line" id="L1069">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1070">                            self.value_start = self.cursor;</span>
<span class="line" id="L1071">                            self.state = .string;</span>
<span class="line" id="L1072">                            <span class="tok-kw">return</span> Token{ .partial_string_escaped_1 = [_]<span class="tok-type">u8</span>{<span class="tok-str">'\t'</span>} };</span>
<span class="line" id="L1073">                        },</span>
<span class="line" id="L1074">                        <span class="tok-str">'u'</span> =&gt; {</span>
<span class="line" id="L1075">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1076">                            self.state = .string_backslash_u;</span>
<span class="line" id="L1077">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1078">                        },</span>
<span class="line" id="L1079">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1080">                    }</span>
<span class="line" id="L1081">                },</span>
<span class="line" id="L1082">                .string_backslash_u =&gt; {</span>
<span class="line" id="L1083">                    <span class="tok-kw">const</span> c = <span class="tok-kw">try</span> self.expectByte();</span>
<span class="line" id="L1084">                    <span class="tok-kw">switch</span> (c) {</span>
<span class="line" id="L1085">                        <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {</span>
<span class="line" id="L1086">                            self.unicode_code_point = <span class="tok-builtin">@as</span>(<span class="tok-type">u21</span>, c - <span class="tok-str">'0'</span>) &lt;&lt; <span class="tok-number">12</span>;</span>
<span class="line" id="L1087">                        },</span>
<span class="line" id="L1088">                        <span class="tok-str">'A'</span>...<span class="tok-str">'F'</span> =&gt; {</span>
<span class="line" id="L1089">                            self.unicode_code_point = <span class="tok-builtin">@as</span>(<span class="tok-type">u21</span>, c - <span class="tok-str">'A'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">12</span>;</span>
<span class="line" id="L1090">                        },</span>
<span class="line" id="L1091">                        <span class="tok-str">'a'</span>...<span class="tok-str">'f'</span> =&gt; {</span>
<span class="line" id="L1092">                            self.unicode_code_point = <span class="tok-builtin">@as</span>(<span class="tok-type">u21</span>, c - <span class="tok-str">'a'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">12</span>;</span>
<span class="line" id="L1093">                        },</span>
<span class="line" id="L1094">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1095">                    }</span>
<span class="line" id="L1096">                    self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1097">                    self.state = .string_backslash_u_1;</span>
<span class="line" id="L1098">                    <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1099">                },</span>
<span class="line" id="L1100">                .string_backslash_u_1 =&gt; {</span>
<span class="line" id="L1101">                    <span class="tok-kw">const</span> c = <span class="tok-kw">try</span> self.expectByte();</span>
<span class="line" id="L1102">                    <span class="tok-kw">switch</span> (c) {</span>
<span class="line" id="L1103">                        <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {</span>
<span class="line" id="L1104">                            self.unicode_code_point |= <span class="tok-builtin">@as</span>(<span class="tok-type">u21</span>, c - <span class="tok-str">'0'</span>) &lt;&lt; <span class="tok-number">8</span>;</span>
<span class="line" id="L1105">                        },</span>
<span class="line" id="L1106">                        <span class="tok-str">'A'</span>...<span class="tok-str">'F'</span> =&gt; {</span>
<span class="line" id="L1107">                            self.unicode_code_point |= <span class="tok-builtin">@as</span>(<span class="tok-type">u21</span>, c - <span class="tok-str">'A'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">8</span>;</span>
<span class="line" id="L1108">                        },</span>
<span class="line" id="L1109">                        <span class="tok-str">'a'</span>...<span class="tok-str">'f'</span> =&gt; {</span>
<span class="line" id="L1110">                            self.unicode_code_point |= <span class="tok-builtin">@as</span>(<span class="tok-type">u21</span>, c - <span class="tok-str">'a'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">8</span>;</span>
<span class="line" id="L1111">                        },</span>
<span class="line" id="L1112">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1113">                    }</span>
<span class="line" id="L1114">                    self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1115">                    self.state = .string_backslash_u_2;</span>
<span class="line" id="L1116">                    <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1117">                },</span>
<span class="line" id="L1118">                .string_backslash_u_2 =&gt; {</span>
<span class="line" id="L1119">                    <span class="tok-kw">const</span> c = <span class="tok-kw">try</span> self.expectByte();</span>
<span class="line" id="L1120">                    <span class="tok-kw">switch</span> (c) {</span>
<span class="line" id="L1121">                        <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {</span>
<span class="line" id="L1122">                            self.unicode_code_point |= <span class="tok-builtin">@as</span>(<span class="tok-type">u21</span>, c - <span class="tok-str">'0'</span>) &lt;&lt; <span class="tok-number">4</span>;</span>
<span class="line" id="L1123">                        },</span>
<span class="line" id="L1124">                        <span class="tok-str">'A'</span>...<span class="tok-str">'F'</span> =&gt; {</span>
<span class="line" id="L1125">                            self.unicode_code_point |= <span class="tok-builtin">@as</span>(<span class="tok-type">u21</span>, c - <span class="tok-str">'A'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">4</span>;</span>
<span class="line" id="L1126">                        },</span>
<span class="line" id="L1127">                        <span class="tok-str">'a'</span>...<span class="tok-str">'f'</span> =&gt; {</span>
<span class="line" id="L1128">                            self.unicode_code_point |= <span class="tok-builtin">@as</span>(<span class="tok-type">u21</span>, c - <span class="tok-str">'a'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">4</span>;</span>
<span class="line" id="L1129">                        },</span>
<span class="line" id="L1130">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1131">                    }</span>
<span class="line" id="L1132">                    self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1133">                    self.state = .string_backslash_u_3;</span>
<span class="line" id="L1134">                    <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1135">                },</span>
<span class="line" id="L1136">                .string_backslash_u_3 =&gt; {</span>
<span class="line" id="L1137">                    <span class="tok-kw">const</span> c = <span class="tok-kw">try</span> self.expectByte();</span>
<span class="line" id="L1138">                    <span class="tok-kw">switch</span> (c) {</span>
<span class="line" id="L1139">                        <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {</span>
<span class="line" id="L1140">                            self.unicode_code_point |= c - <span class="tok-str">'0'</span>;</span>
<span class="line" id="L1141">                        },</span>
<span class="line" id="L1142">                        <span class="tok-str">'A'</span>...<span class="tok-str">'F'</span> =&gt; {</span>
<span class="line" id="L1143">                            self.unicode_code_point |= c - <span class="tok-str">'A'</span> + <span class="tok-number">10</span>;</span>
<span class="line" id="L1144">                        },</span>
<span class="line" id="L1145">                        <span class="tok-str">'a'</span>...<span class="tok-str">'f'</span> =&gt; {</span>
<span class="line" id="L1146">                            self.unicode_code_point |= c - <span class="tok-str">'a'</span> + <span class="tok-number">10</span>;</span>
<span class="line" id="L1147">                        },</span>
<span class="line" id="L1148">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1149">                    }</span>
<span class="line" id="L1150">                    self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1151">                    <span class="tok-kw">switch</span> (self.unicode_code_point) {</span>
<span class="line" id="L1152">                        <span class="tok-number">0xD800</span>...<span class="tok-number">0xDBFF</span> =&gt; {</span>
<span class="line" id="L1153">                            <span class="tok-comment">// High surrogate half.</span>
</span>
<span class="line" id="L1154">                            self.unicode_code_point = <span class="tok-number">0x10000</span> | (self.unicode_code_point &lt;&lt; <span class="tok-number">10</span>);</span>
<span class="line" id="L1155">                            self.state = .string_surrogate_half;</span>
<span class="line" id="L1156">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1157">                        },</span>
<span class="line" id="L1158">                        <span class="tok-number">0xDC00</span>...<span class="tok-number">0xDFFF</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError, <span class="tok-comment">// Unexpected low surrogate half.</span>
</span>
<span class="line" id="L1159">                        <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L1160">                            <span class="tok-comment">// Code point from a single UTF-16 code unit.</span>
</span>
<span class="line" id="L1161">                            self.value_start = self.cursor;</span>
<span class="line" id="L1162">                            self.state = .string;</span>
<span class="line" id="L1163">                            <span class="tok-kw">return</span> self.partialStringCodepoint();</span>
<span class="line" id="L1164">                        },</span>
<span class="line" id="L1165">                    }</span>
<span class="line" id="L1166">                },</span>
<span class="line" id="L1167">                .string_surrogate_half =&gt; {</span>
<span class="line" id="L1168">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1169">                        <span class="tok-str">'\\'</span> =&gt; {</span>
<span class="line" id="L1170">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1171">                            self.state = .string_surrogate_half_backslash;</span>
<span class="line" id="L1172">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1173">                        },</span>
<span class="line" id="L1174">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError, <span class="tok-comment">// Expected low surrogate half.</span>
</span>
<span class="line" id="L1175">                    }</span>
<span class="line" id="L1176">                },</span>
<span class="line" id="L1177">                .string_surrogate_half_backslash =&gt; {</span>
<span class="line" id="L1178">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1179">                        <span class="tok-str">'u'</span> =&gt; {</span>
<span class="line" id="L1180">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1181">                            self.state = .string_surrogate_half_backslash_u;</span>
<span class="line" id="L1182">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1183">                        },</span>
<span class="line" id="L1184">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError, <span class="tok-comment">// Expected low surrogate half.</span>
</span>
<span class="line" id="L1185">                    }</span>
<span class="line" id="L1186">                },</span>
<span class="line" id="L1187">                .string_surrogate_half_backslash_u =&gt; {</span>
<span class="line" id="L1188">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1189">                        <span class="tok-str">'D'</span>, <span class="tok-str">'d'</span> =&gt; {</span>
<span class="line" id="L1190">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1191">                            self.state = .string_surrogate_half_backslash_u_1;</span>
<span class="line" id="L1192">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1193">                        },</span>
<span class="line" id="L1194">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError, <span class="tok-comment">// Expected low surrogate half.</span>
</span>
<span class="line" id="L1195">                    }</span>
<span class="line" id="L1196">                },</span>
<span class="line" id="L1197">                .string_surrogate_half_backslash_u_1 =&gt; {</span>
<span class="line" id="L1198">                    <span class="tok-kw">const</span> c = <span class="tok-kw">try</span> self.expectByte();</span>
<span class="line" id="L1199">                    <span class="tok-kw">switch</span> (c) {</span>
<span class="line" id="L1200">                        <span class="tok-str">'C'</span>...<span class="tok-str">'F'</span> =&gt; {</span>
<span class="line" id="L1201">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1202">                            self.unicode_code_point |= <span class="tok-builtin">@as</span>(<span class="tok-type">u21</span>, c - <span class="tok-str">'C'</span>) &lt;&lt; <span class="tok-number">8</span>;</span>
<span class="line" id="L1203">                            self.state = .string_surrogate_half_backslash_u_2;</span>
<span class="line" id="L1204">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1205">                        },</span>
<span class="line" id="L1206">                        <span class="tok-str">'c'</span>...<span class="tok-str">'f'</span> =&gt; {</span>
<span class="line" id="L1207">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1208">                            self.unicode_code_point |= <span class="tok-builtin">@as</span>(<span class="tok-type">u21</span>, c - <span class="tok-str">'c'</span>) &lt;&lt; <span class="tok-number">8</span>;</span>
<span class="line" id="L1209">                            self.state = .string_surrogate_half_backslash_u_2;</span>
<span class="line" id="L1210">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1211">                        },</span>
<span class="line" id="L1212">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError, <span class="tok-comment">// Expected low surrogate half.</span>
</span>
<span class="line" id="L1213">                    }</span>
<span class="line" id="L1214">                },</span>
<span class="line" id="L1215">                .string_surrogate_half_backslash_u_2 =&gt; {</span>
<span class="line" id="L1216">                    <span class="tok-kw">const</span> c = <span class="tok-kw">try</span> self.expectByte();</span>
<span class="line" id="L1217">                    <span class="tok-kw">switch</span> (c) {</span>
<span class="line" id="L1218">                        <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {</span>
<span class="line" id="L1219">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1220">                            self.unicode_code_point |= <span class="tok-builtin">@as</span>(<span class="tok-type">u21</span>, c - <span class="tok-str">'0'</span>) &lt;&lt; <span class="tok-number">4</span>;</span>
<span class="line" id="L1221">                            self.state = .string_surrogate_half_backslash_u_3;</span>
<span class="line" id="L1222">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1223">                        },</span>
<span class="line" id="L1224">                        <span class="tok-str">'A'</span>...<span class="tok-str">'F'</span> =&gt; {</span>
<span class="line" id="L1225">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1226">                            self.unicode_code_point |= <span class="tok-builtin">@as</span>(<span class="tok-type">u21</span>, c - <span class="tok-str">'A'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">4</span>;</span>
<span class="line" id="L1227">                            self.state = .string_surrogate_half_backslash_u_3;</span>
<span class="line" id="L1228">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1229">                        },</span>
<span class="line" id="L1230">                        <span class="tok-str">'a'</span>...<span class="tok-str">'f'</span> =&gt; {</span>
<span class="line" id="L1231">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1232">                            self.unicode_code_point |= <span class="tok-builtin">@as</span>(<span class="tok-type">u21</span>, c - <span class="tok-str">'a'</span> + <span class="tok-number">10</span>) &lt;&lt; <span class="tok-number">4</span>;</span>
<span class="line" id="L1233">                            self.state = .string_surrogate_half_backslash_u_3;</span>
<span class="line" id="L1234">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1235">                        },</span>
<span class="line" id="L1236">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1237">                    }</span>
<span class="line" id="L1238">                },</span>
<span class="line" id="L1239">                .string_surrogate_half_backslash_u_3 =&gt; {</span>
<span class="line" id="L1240">                    <span class="tok-kw">const</span> c = <span class="tok-kw">try</span> self.expectByte();</span>
<span class="line" id="L1241">                    <span class="tok-kw">switch</span> (c) {</span>
<span class="line" id="L1242">                        <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; {</span>
<span class="line" id="L1243">                            self.unicode_code_point |= c - <span class="tok-str">'0'</span>;</span>
<span class="line" id="L1244">                        },</span>
<span class="line" id="L1245">                        <span class="tok-str">'A'</span>...<span class="tok-str">'F'</span> =&gt; {</span>
<span class="line" id="L1246">                            self.unicode_code_point |= c - <span class="tok-str">'A'</span> + <span class="tok-number">10</span>;</span>
<span class="line" id="L1247">                        },</span>
<span class="line" id="L1248">                        <span class="tok-str">'a'</span>...<span class="tok-str">'f'</span> =&gt; {</span>
<span class="line" id="L1249">                            self.unicode_code_point |= c - <span class="tok-str">'a'</span> + <span class="tok-number">10</span>;</span>
<span class="line" id="L1250">                        },</span>
<span class="line" id="L1251">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1252">                    }</span>
<span class="line" id="L1253">                    self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1254">                    self.value_start = self.cursor;</span>
<span class="line" id="L1255">                    self.state = .string;</span>
<span class="line" id="L1256">                    <span class="tok-kw">return</span> self.partialStringCodepoint();</span>
<span class="line" id="L1257">                },</span>
<span class="line" id="L1258"></span>
<span class="line" id="L1259">                .string_utf8_last_byte =&gt; {</span>
<span class="line" id="L1260">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1261">                        <span class="tok-number">0x80</span>...<span class="tok-number">0xBF</span> =&gt; {</span>
<span class="line" id="L1262">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1263">                            self.state = .string;</span>
<span class="line" id="L1264">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1265">                        },</span>
<span class="line" id="L1266">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError, <span class="tok-comment">// Invalid UTF-8.</span>
</span>
<span class="line" id="L1267">                    }</span>
<span class="line" id="L1268">                },</span>
<span class="line" id="L1269">                .string_utf8_second_to_last_byte =&gt; {</span>
<span class="line" id="L1270">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1271">                        <span class="tok-number">0x80</span>...<span class="tok-number">0xBF</span> =&gt; {</span>
<span class="line" id="L1272">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1273">                            self.state = .string_utf8_last_byte;</span>
<span class="line" id="L1274">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1275">                        },</span>
<span class="line" id="L1276">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError, <span class="tok-comment">// Invalid UTF-8.</span>
</span>
<span class="line" id="L1277">                    }</span>
<span class="line" id="L1278">                },</span>
<span class="line" id="L1279">                .string_utf8_second_to_last_byte_guard_against_overlong =&gt; {</span>
<span class="line" id="L1280">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1281">                        <span class="tok-number">0xA0</span>...<span class="tok-number">0xBF</span> =&gt; {</span>
<span class="line" id="L1282">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1283">                            self.state = .string_utf8_last_byte;</span>
<span class="line" id="L1284">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1285">                        },</span>
<span class="line" id="L1286">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError, <span class="tok-comment">// Invalid UTF-8.</span>
</span>
<span class="line" id="L1287">                    }</span>
<span class="line" id="L1288">                },</span>
<span class="line" id="L1289">                .string_utf8_second_to_last_byte_guard_against_surrogate_half =&gt; {</span>
<span class="line" id="L1290">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1291">                        <span class="tok-number">0x80</span>...<span class="tok-number">0x9F</span> =&gt; {</span>
<span class="line" id="L1292">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1293">                            self.state = .string_utf8_last_byte;</span>
<span class="line" id="L1294">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1295">                        },</span>
<span class="line" id="L1296">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError, <span class="tok-comment">// Invalid UTF-8.</span>
</span>
<span class="line" id="L1297">                    }</span>
<span class="line" id="L1298">                },</span>
<span class="line" id="L1299">                .string_utf8_third_to_last_byte =&gt; {</span>
<span class="line" id="L1300">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1301">                        <span class="tok-number">0x80</span>...<span class="tok-number">0xBF</span> =&gt; {</span>
<span class="line" id="L1302">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1303">                            self.state = .string_utf8_second_to_last_byte;</span>
<span class="line" id="L1304">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1305">                        },</span>
<span class="line" id="L1306">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError, <span class="tok-comment">// Invalid UTF-8.</span>
</span>
<span class="line" id="L1307">                    }</span>
<span class="line" id="L1308">                },</span>
<span class="line" id="L1309">                .string_utf8_third_to_last_byte_guard_against_overlong =&gt; {</span>
<span class="line" id="L1310">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1311">                        <span class="tok-number">0x90</span>...<span class="tok-number">0xBF</span> =&gt; {</span>
<span class="line" id="L1312">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1313">                            self.state = .string_utf8_second_to_last_byte;</span>
<span class="line" id="L1314">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1315">                        },</span>
<span class="line" id="L1316">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError, <span class="tok-comment">// Invalid UTF-8.</span>
</span>
<span class="line" id="L1317">                    }</span>
<span class="line" id="L1318">                },</span>
<span class="line" id="L1319">                .string_utf8_third_to_last_byte_guard_against_too_large =&gt; {</span>
<span class="line" id="L1320">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1321">                        <span class="tok-number">0x80</span>...<span class="tok-number">0x8F</span> =&gt; {</span>
<span class="line" id="L1322">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1323">                            self.state = .string_utf8_second_to_last_byte;</span>
<span class="line" id="L1324">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1325">                        },</span>
<span class="line" id="L1326">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError, <span class="tok-comment">// Invalid UTF-8.</span>
</span>
<span class="line" id="L1327">                    }</span>
<span class="line" id="L1328">                },</span>
<span class="line" id="L1329"></span>
<span class="line" id="L1330">                .literal_t =&gt; {</span>
<span class="line" id="L1331">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1332">                        <span class="tok-str">'r'</span> =&gt; {</span>
<span class="line" id="L1333">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1334">                            self.state = .literal_tr;</span>
<span class="line" id="L1335">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1336">                        },</span>
<span class="line" id="L1337">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1338">                    }</span>
<span class="line" id="L1339">                },</span>
<span class="line" id="L1340">                .literal_tr =&gt; {</span>
<span class="line" id="L1341">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1342">                        <span class="tok-str">'u'</span> =&gt; {</span>
<span class="line" id="L1343">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1344">                            self.state = .literal_tru;</span>
<span class="line" id="L1345">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1346">                        },</span>
<span class="line" id="L1347">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1348">                    }</span>
<span class="line" id="L1349">                },</span>
<span class="line" id="L1350">                .literal_tru =&gt; {</span>
<span class="line" id="L1351">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1352">                        <span class="tok-str">'e'</span> =&gt; {</span>
<span class="line" id="L1353">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1354">                            self.state = .post_value;</span>
<span class="line" id="L1355">                            <span class="tok-kw">return</span> .<span class="tok-null">true</span>;</span>
<span class="line" id="L1356">                        },</span>
<span class="line" id="L1357">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1358">                    }</span>
<span class="line" id="L1359">                },</span>
<span class="line" id="L1360">                .literal_f =&gt; {</span>
<span class="line" id="L1361">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1362">                        <span class="tok-str">'a'</span> =&gt; {</span>
<span class="line" id="L1363">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1364">                            self.state = .literal_fa;</span>
<span class="line" id="L1365">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1366">                        },</span>
<span class="line" id="L1367">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1368">                    }</span>
<span class="line" id="L1369">                },</span>
<span class="line" id="L1370">                .literal_fa =&gt; {</span>
<span class="line" id="L1371">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1372">                        <span class="tok-str">'l'</span> =&gt; {</span>
<span class="line" id="L1373">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1374">                            self.state = .literal_fal;</span>
<span class="line" id="L1375">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1376">                        },</span>
<span class="line" id="L1377">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1378">                    }</span>
<span class="line" id="L1379">                },</span>
<span class="line" id="L1380">                .literal_fal =&gt; {</span>
<span class="line" id="L1381">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1382">                        <span class="tok-str">'s'</span> =&gt; {</span>
<span class="line" id="L1383">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1384">                            self.state = .literal_fals;</span>
<span class="line" id="L1385">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1386">                        },</span>
<span class="line" id="L1387">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1388">                    }</span>
<span class="line" id="L1389">                },</span>
<span class="line" id="L1390">                .literal_fals =&gt; {</span>
<span class="line" id="L1391">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1392">                        <span class="tok-str">'e'</span> =&gt; {</span>
<span class="line" id="L1393">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1394">                            self.state = .post_value;</span>
<span class="line" id="L1395">                            <span class="tok-kw">return</span> .<span class="tok-null">false</span>;</span>
<span class="line" id="L1396">                        },</span>
<span class="line" id="L1397">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1398">                    }</span>
<span class="line" id="L1399">                },</span>
<span class="line" id="L1400">                .literal_n =&gt; {</span>
<span class="line" id="L1401">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1402">                        <span class="tok-str">'u'</span> =&gt; {</span>
<span class="line" id="L1403">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1404">                            self.state = .literal_nu;</span>
<span class="line" id="L1405">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1406">                        },</span>
<span class="line" id="L1407">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1408">                    }</span>
<span class="line" id="L1409">                },</span>
<span class="line" id="L1410">                .literal_nu =&gt; {</span>
<span class="line" id="L1411">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1412">                        <span class="tok-str">'l'</span> =&gt; {</span>
<span class="line" id="L1413">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1414">                            self.state = .literal_nul;</span>
<span class="line" id="L1415">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1416">                        },</span>
<span class="line" id="L1417">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1418">                    }</span>
<span class="line" id="L1419">                },</span>
<span class="line" id="L1420">                .literal_nul =&gt; {</span>
<span class="line" id="L1421">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.expectByte()) {</span>
<span class="line" id="L1422">                        <span class="tok-str">'l'</span> =&gt; {</span>
<span class="line" id="L1423">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1424">                            self.state = .post_value;</span>
<span class="line" id="L1425">                            <span class="tok-kw">return</span> .<span class="tok-null">null</span>;</span>
<span class="line" id="L1426">                        },</span>
<span class="line" id="L1427">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1428">                    }</span>
<span class="line" id="L1429">                },</span>
<span class="line" id="L1430">            }</span>
<span class="line" id="L1431">            <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L1432">        }</span>
<span class="line" id="L1433">    }</span>
<span class="line" id="L1434"></span>
<span class="line" id="L1435">    <span class="tok-comment">/// Seeks ahead in the input until the first byte of the next token (or the end of the input)</span></span>
<span class="line" id="L1436">    <span class="tok-comment">/// determines which type of token will be returned from the next `next*()` call.</span></span>
<span class="line" id="L1437">    <span class="tok-comment">/// This function is idempotent, only advancing past commas, colons, and inter-token whitespace.</span></span>
<span class="line" id="L1438">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peekNextTokenType</span>(self: *<span class="tok-builtin">@This</span>()) PeekError!TokenType {</span>
<span class="line" id="L1439">        state_loop: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L1440">            <span class="tok-kw">switch</span> (self.state) {</span>
<span class="line" id="L1441">                .value =&gt; {</span>
<span class="line" id="L1442">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.skipWhitespaceExpectByte()) {</span>
<span class="line" id="L1443">                        <span class="tok-str">'{'</span> =&gt; <span class="tok-kw">return</span> .object_begin,</span>
<span class="line" id="L1444">                        <span class="tok-str">'['</span> =&gt; <span class="tok-kw">return</span> .array_begin,</span>
<span class="line" id="L1445">                        <span class="tok-str">'&quot;'</span> =&gt; <span class="tok-kw">return</span> .string,</span>
<span class="line" id="L1446">                        <span class="tok-str">'-'</span>, <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; <span class="tok-kw">return</span> .number,</span>
<span class="line" id="L1447">                        <span class="tok-str">'t'</span> =&gt; <span class="tok-kw">return</span> .<span class="tok-null">true</span>,</span>
<span class="line" id="L1448">                        <span class="tok-str">'f'</span> =&gt; <span class="tok-kw">return</span> .<span class="tok-null">false</span>,</span>
<span class="line" id="L1449">                        <span class="tok-str">'n'</span> =&gt; <span class="tok-kw">return</span> .<span class="tok-null">null</span>,</span>
<span class="line" id="L1450">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1451">                    }</span>
<span class="line" id="L1452">                },</span>
<span class="line" id="L1453"></span>
<span class="line" id="L1454">                .post_value =&gt; {</span>
<span class="line" id="L1455">                    <span class="tok-kw">if</span> (<span class="tok-kw">try</span> self.skipWhitespaceCheckEnd()) <span class="tok-kw">return</span> .end_of_document;</span>
<span class="line" id="L1456"></span>
<span class="line" id="L1457">                    <span class="tok-kw">const</span> c = self.input[self.cursor];</span>
<span class="line" id="L1458">                    <span class="tok-kw">if</span> (self.string_is_object_key) {</span>
<span class="line" id="L1459">                        self.string_is_object_key = <span class="tok-null">false</span>;</span>
<span class="line" id="L1460">                        <span class="tok-kw">switch</span> (c) {</span>
<span class="line" id="L1461">                            <span class="tok-str">':'</span> =&gt; {</span>
<span class="line" id="L1462">                                self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1463">                                self.state = .value;</span>
<span class="line" id="L1464">                                <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1465">                            },</span>
<span class="line" id="L1466">                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1467">                        }</span>
<span class="line" id="L1468">                    }</span>
<span class="line" id="L1469"></span>
<span class="line" id="L1470">                    <span class="tok-kw">switch</span> (c) {</span>
<span class="line" id="L1471">                        <span class="tok-str">'}'</span> =&gt; <span class="tok-kw">return</span> .object_end,</span>
<span class="line" id="L1472">                        <span class="tok-str">']'</span> =&gt; <span class="tok-kw">return</span> .array_end,</span>
<span class="line" id="L1473">                        <span class="tok-str">','</span> =&gt; {</span>
<span class="line" id="L1474">                            <span class="tok-kw">switch</span> (self.stack.peek()) {</span>
<span class="line" id="L1475">                                OBJECT_MODE =&gt; {</span>
<span class="line" id="L1476">                                    self.state = .object_post_comma;</span>
<span class="line" id="L1477">                                },</span>
<span class="line" id="L1478">                                ARRAY_MODE =&gt; {</span>
<span class="line" id="L1479">                                    self.state = .value;</span>
<span class="line" id="L1480">                                },</span>
<span class="line" id="L1481">                            }</span>
<span class="line" id="L1482">                            self.cursor += <span class="tok-number">1</span>;</span>
<span class="line" id="L1483">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1484">                        },</span>
<span class="line" id="L1485">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1486">                    }</span>
<span class="line" id="L1487">                },</span>
<span class="line" id="L1488"></span>
<span class="line" id="L1489">                .object_start =&gt; {</span>
<span class="line" id="L1490">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.skipWhitespaceExpectByte()) {</span>
<span class="line" id="L1491">                        <span class="tok-str">'&quot;'</span> =&gt; <span class="tok-kw">return</span> .string,</span>
<span class="line" id="L1492">                        <span class="tok-str">'}'</span> =&gt; <span class="tok-kw">return</span> .object_end,</span>
<span class="line" id="L1493">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1494">                    }</span>
<span class="line" id="L1495">                },</span>
<span class="line" id="L1496">                .object_post_comma =&gt; {</span>
<span class="line" id="L1497">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.skipWhitespaceExpectByte()) {</span>
<span class="line" id="L1498">                        <span class="tok-str">'&quot;'</span> =&gt; <span class="tok-kw">return</span> .string,</span>
<span class="line" id="L1499">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError,</span>
<span class="line" id="L1500">                    }</span>
<span class="line" id="L1501">                },</span>
<span class="line" id="L1502"></span>
<span class="line" id="L1503">                .array_start =&gt; {</span>
<span class="line" id="L1504">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.skipWhitespaceExpectByte()) {</span>
<span class="line" id="L1505">                        <span class="tok-str">']'</span> =&gt; <span class="tok-kw">return</span> .array_end,</span>
<span class="line" id="L1506">                        <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L1507">                            self.state = .value;</span>
<span class="line" id="L1508">                            <span class="tok-kw">continue</span> :state_loop;</span>
<span class="line" id="L1509">                        },</span>
<span class="line" id="L1510">                    }</span>
<span class="line" id="L1511">                },</span>
<span class="line" id="L1512"></span>
<span class="line" id="L1513">                .number_minus,</span>
<span class="line" id="L1514">                .number_leading_zero,</span>
<span class="line" id="L1515">                .number_int,</span>
<span class="line" id="L1516">                .number_post_dot,</span>
<span class="line" id="L1517">                .number_frac,</span>
<span class="line" id="L1518">                .number_post_e,</span>
<span class="line" id="L1519">                .number_post_e_sign,</span>
<span class="line" id="L1520">                .number_exp,</span>
<span class="line" id="L1521">                =&gt; <span class="tok-kw">return</span> .number,</span>
<span class="line" id="L1522"></span>
<span class="line" id="L1523">                .string,</span>
<span class="line" id="L1524">                .string_backslash,</span>
<span class="line" id="L1525">                .string_backslash_u,</span>
<span class="line" id="L1526">                .string_backslash_u_1,</span>
<span class="line" id="L1527">                .string_backslash_u_2,</span>
<span class="line" id="L1528">                .string_backslash_u_3,</span>
<span class="line" id="L1529">                .string_surrogate_half,</span>
<span class="line" id="L1530">                .string_surrogate_half_backslash,</span>
<span class="line" id="L1531">                .string_surrogate_half_backslash_u,</span>
<span class="line" id="L1532">                .string_surrogate_half_backslash_u_1,</span>
<span class="line" id="L1533">                .string_surrogate_half_backslash_u_2,</span>
<span class="line" id="L1534">                .string_surrogate_half_backslash_u_3,</span>
<span class="line" id="L1535">                =&gt; <span class="tok-kw">return</span> .string,</span>
<span class="line" id="L1536"></span>
<span class="line" id="L1537">                .string_utf8_last_byte,</span>
<span class="line" id="L1538">                .string_utf8_second_to_last_byte,</span>
<span class="line" id="L1539">                .string_utf8_second_to_last_byte_guard_against_overlong,</span>
<span class="line" id="L1540">                .string_utf8_second_to_last_byte_guard_against_surrogate_half,</span>
<span class="line" id="L1541">                .string_utf8_third_to_last_byte,</span>
<span class="line" id="L1542">                .string_utf8_third_to_last_byte_guard_against_overlong,</span>
<span class="line" id="L1543">                .string_utf8_third_to_last_byte_guard_against_too_large,</span>
<span class="line" id="L1544">                =&gt; <span class="tok-kw">return</span> .string,</span>
<span class="line" id="L1545"></span>
<span class="line" id="L1546">                .literal_t,</span>
<span class="line" id="L1547">                .literal_tr,</span>
<span class="line" id="L1548">                .literal_tru,</span>
<span class="line" id="L1549">                =&gt; <span class="tok-kw">return</span> .<span class="tok-null">true</span>,</span>
<span class="line" id="L1550">                .literal_f,</span>
<span class="line" id="L1551">                .literal_fa,</span>
<span class="line" id="L1552">                .literal_fal,</span>
<span class="line" id="L1553">                .literal_fals,</span>
<span class="line" id="L1554">                =&gt; <span class="tok-kw">return</span> .<span class="tok-null">false</span>,</span>
<span class="line" id="L1555">                .literal_n,</span>
<span class="line" id="L1556">                .literal_nu,</span>
<span class="line" id="L1557">                .literal_nul,</span>
<span class="line" id="L1558">                =&gt; <span class="tok-kw">return</span> .<span class="tok-null">null</span>,</span>
<span class="line" id="L1559">            }</span>
<span class="line" id="L1560">            <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L1561">        }</span>
<span class="line" id="L1562">    }</span>
<span class="line" id="L1563"></span>
<span class="line" id="L1564">    <span class="tok-kw">const</span> State = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L1565">        value,</span>
<span class="line" id="L1566">        post_value,</span>
<span class="line" id="L1567"></span>
<span class="line" id="L1568">        object_start,</span>
<span class="line" id="L1569">        object_post_comma,</span>
<span class="line" id="L1570"></span>
<span class="line" id="L1571">        array_start,</span>
<span class="line" id="L1572"></span>
<span class="line" id="L1573">        number_minus,</span>
<span class="line" id="L1574">        number_leading_zero,</span>
<span class="line" id="L1575">        number_int,</span>
<span class="line" id="L1576">        number_post_dot,</span>
<span class="line" id="L1577">        number_frac,</span>
<span class="line" id="L1578">        number_post_e,</span>
<span class="line" id="L1579">        number_post_e_sign,</span>
<span class="line" id="L1580">        number_exp,</span>
<span class="line" id="L1581"></span>
<span class="line" id="L1582">        string,</span>
<span class="line" id="L1583">        string_backslash,</span>
<span class="line" id="L1584">        string_backslash_u,</span>
<span class="line" id="L1585">        string_backslash_u_1,</span>
<span class="line" id="L1586">        string_backslash_u_2,</span>
<span class="line" id="L1587">        string_backslash_u_3,</span>
<span class="line" id="L1588">        string_surrogate_half,</span>
<span class="line" id="L1589">        string_surrogate_half_backslash,</span>
<span class="line" id="L1590">        string_surrogate_half_backslash_u,</span>
<span class="line" id="L1591">        string_surrogate_half_backslash_u_1,</span>
<span class="line" id="L1592">        string_surrogate_half_backslash_u_2,</span>
<span class="line" id="L1593">        string_surrogate_half_backslash_u_3,</span>
<span class="line" id="L1594"></span>
<span class="line" id="L1595">        <span class="tok-comment">// From http://unicode.org/mail-arch/unicode-ml/y2003-m02/att-0467/01-The_Algorithm_to_Valide_an_UTF-8_String</span>
</span>
<span class="line" id="L1596">        string_utf8_last_byte, <span class="tok-comment">// State A</span>
</span>
<span class="line" id="L1597">        string_utf8_second_to_last_byte, <span class="tok-comment">// State B</span>
</span>
<span class="line" id="L1598">        string_utf8_second_to_last_byte_guard_against_overlong, <span class="tok-comment">// State C</span>
</span>
<span class="line" id="L1599">        string_utf8_second_to_last_byte_guard_against_surrogate_half, <span class="tok-comment">// State D</span>
</span>
<span class="line" id="L1600">        string_utf8_third_to_last_byte, <span class="tok-comment">// State E</span>
</span>
<span class="line" id="L1601">        string_utf8_third_to_last_byte_guard_against_overlong, <span class="tok-comment">// State F</span>
</span>
<span class="line" id="L1602">        string_utf8_third_to_last_byte_guard_against_too_large, <span class="tok-comment">// State G</span>
</span>
<span class="line" id="L1603"></span>
<span class="line" id="L1604">        literal_t,</span>
<span class="line" id="L1605">        literal_tr,</span>
<span class="line" id="L1606">        literal_tru,</span>
<span class="line" id="L1607">        literal_f,</span>
<span class="line" id="L1608">        literal_fa,</span>
<span class="line" id="L1609">        literal_fal,</span>
<span class="line" id="L1610">        literal_fals,</span>
<span class="line" id="L1611">        literal_n,</span>
<span class="line" id="L1612">        literal_nu,</span>
<span class="line" id="L1613">        literal_nul,</span>
<span class="line" id="L1614">    };</span>
<span class="line" id="L1615"></span>
<span class="line" id="L1616">    <span class="tok-kw">fn</span> <span class="tok-fn">expectByte</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) !<span class="tok-type">u8</span> {</span>
<span class="line" id="L1617">        <span class="tok-kw">if</span> (self.cursor &lt; self.input.len) {</span>
<span class="line" id="L1618">            <span class="tok-kw">return</span> self.input[self.cursor];</span>
<span class="line" id="L1619">        }</span>
<span class="line" id="L1620">        <span class="tok-comment">// No byte.</span>
</span>
<span class="line" id="L1621">        <span class="tok-kw">if</span> (self.is_end_of_input) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedEndOfInput;</span>
<span class="line" id="L1622">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BufferUnderrun;</span>
<span class="line" id="L1623">    }</span>
<span class="line" id="L1624"></span>
<span class="line" id="L1625">    <span class="tok-kw">fn</span> <span class="tok-fn">skipWhitespace</span>(self: *<span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {</span>
<span class="line" id="L1626">        <span class="tok-kw">while</span> (self.cursor &lt; self.input.len) : (self.cursor += <span class="tok-number">1</span>) {</span>
<span class="line" id="L1627">            <span class="tok-kw">switch</span> (self.input[self.cursor]) {</span>
<span class="line" id="L1628">                <span class="tok-comment">// Whitespace</span>
</span>
<span class="line" id="L1629">                <span class="tok-str">' '</span>, <span class="tok-str">'\t'</span>, <span class="tok-str">'\r'</span> =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L1630">                <span class="tok-str">'\n'</span> =&gt; {</span>
<span class="line" id="L1631">                    <span class="tok-kw">if</span> (self.diagnostics) |diag| {</span>
<span class="line" id="L1632">                        diag.line_number += <span class="tok-number">1</span>;</span>
<span class="line" id="L1633">                        <span class="tok-comment">// This will count the newline itself,</span>
</span>
<span class="line" id="L1634">                        <span class="tok-comment">// which means a straight-forward subtraction will give a 1-based column number.</span>
</span>
<span class="line" id="L1635">                        diag.line_start_cursor = self.cursor;</span>
<span class="line" id="L1636">                    }</span>
<span class="line" id="L1637">                    <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1638">                },</span>
<span class="line" id="L1639">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span>,</span>
<span class="line" id="L1640">            }</span>
<span class="line" id="L1641">        }</span>
<span class="line" id="L1642">    }</span>
<span class="line" id="L1643"></span>
<span class="line" id="L1644">    <span class="tok-kw">fn</span> <span class="tok-fn">skipWhitespaceExpectByte</span>(self: *<span class="tok-builtin">@This</span>()) !<span class="tok-type">u8</span> {</span>
<span class="line" id="L1645">        self.skipWhitespace();</span>
<span class="line" id="L1646">        <span class="tok-kw">return</span> self.expectByte();</span>
<span class="line" id="L1647">    }</span>
<span class="line" id="L1648"></span>
<span class="line" id="L1649">    <span class="tok-kw">fn</span> <span class="tok-fn">skipWhitespaceCheckEnd</span>(self: *<span class="tok-builtin">@This</span>()) !<span class="tok-type">bool</span> {</span>
<span class="line" id="L1650">        self.skipWhitespace();</span>
<span class="line" id="L1651">        <span class="tok-kw">if</span> (self.cursor &gt;= self.input.len) {</span>
<span class="line" id="L1652">            <span class="tok-comment">// End of buffer.</span>
</span>
<span class="line" id="L1653">            <span class="tok-kw">if</span> (self.is_end_of_input) {</span>
<span class="line" id="L1654">                <span class="tok-comment">// End of everything.</span>
</span>
<span class="line" id="L1655">                <span class="tok-kw">if</span> (self.stackHeight() == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1656">                    <span class="tok-comment">// We did it!</span>
</span>
<span class="line" id="L1657">                    <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L1658">                }</span>
<span class="line" id="L1659">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedEndOfInput;</span>
<span class="line" id="L1660">            }</span>
<span class="line" id="L1661">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BufferUnderrun;</span>
<span class="line" id="L1662">        }</span>
<span class="line" id="L1663">        <span class="tok-kw">if</span> (self.stackHeight() == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SyntaxError;</span>
<span class="line" id="L1664">        <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L1665">    }</span>
<span class="line" id="L1666"></span>
<span class="line" id="L1667">    <span class="tok-kw">fn</span> <span class="tok-fn">takeValueSlice</span>(self: *<span class="tok-builtin">@This</span>()) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1668">        <span class="tok-kw">const</span> slice = self.input[self.value_start..self.cursor];</span>
<span class="line" id="L1669">        self.value_start = self.cursor;</span>
<span class="line" id="L1670">        <span class="tok-kw">return</span> slice;</span>
<span class="line" id="L1671">    }</span>
<span class="line" id="L1672"></span>
<span class="line" id="L1673">    <span class="tok-kw">fn</span> <span class="tok-fn">endOfBufferInNumber</span>(self: *<span class="tok-builtin">@This</span>(), allow_end: <span class="tok-type">bool</span>) !Token {</span>
<span class="line" id="L1674">        <span class="tok-kw">const</span> slice = self.takeValueSlice();</span>
<span class="line" id="L1675">        <span class="tok-kw">if</span> (self.is_end_of_input) {</span>
<span class="line" id="L1676">            <span class="tok-kw">if</span> (!allow_end) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedEndOfInput;</span>
<span class="line" id="L1677">            self.state = .post_value;</span>
<span class="line" id="L1678">            <span class="tok-kw">return</span> Token{ .number = slice };</span>
<span class="line" id="L1679">        }</span>
<span class="line" id="L1680">        <span class="tok-kw">if</span> (slice.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BufferUnderrun;</span>
<span class="line" id="L1681">        <span class="tok-kw">return</span> Token{ .partial_number = slice };</span>
<span class="line" id="L1682">    }</span>
<span class="line" id="L1683"></span>
<span class="line" id="L1684">    <span class="tok-kw">fn</span> <span class="tok-fn">partialStringCodepoint</span>(self: *<span class="tok-builtin">@This</span>()) Token {</span>
<span class="line" id="L1685">        <span class="tok-kw">const</span> code_point = self.unicode_code_point;</span>
<span class="line" id="L1686">        self.unicode_code_point = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1687">        <span class="tok-kw">var</span> buf: [<span class="tok-number">4</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1688">        <span class="tok-kw">switch</span> (std.unicode.utf8Encode(code_point, &amp;buf) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>) {</span>
<span class="line" id="L1689">            <span class="tok-number">1</span> =&gt; <span class="tok-kw">return</span> Token{ .partial_string_escaped_1 = buf[<span class="tok-number">0</span>..<span class="tok-number">1</span>].* },</span>
<span class="line" id="L1690">            <span class="tok-number">2</span> =&gt; <span class="tok-kw">return</span> Token{ .partial_string_escaped_2 = buf[<span class="tok-number">0</span>..<span class="tok-number">2</span>].* },</span>
<span class="line" id="L1691">            <span class="tok-number">3</span> =&gt; <span class="tok-kw">return</span> Token{ .partial_string_escaped_3 = buf[<span class="tok-number">0</span>..<span class="tok-number">3</span>].* },</span>
<span class="line" id="L1692">            <span class="tok-number">4</span> =&gt; <span class="tok-kw">return</span> Token{ .partial_string_escaped_4 = buf[<span class="tok-number">0</span>..<span class="tok-number">4</span>].* },</span>
<span class="line" id="L1693">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1694">        }</span>
<span class="line" id="L1695">    }</span>
<span class="line" id="L1696">};</span>
<span class="line" id="L1697"></span>
<span class="line" id="L1698"><span class="tok-kw">const</span> OBJECT_MODE = <span class="tok-number">0</span>;</span>
<span class="line" id="L1699"><span class="tok-kw">const</span> ARRAY_MODE = <span class="tok-number">1</span>;</span>
<span class="line" id="L1700"></span>
<span class="line" id="L1701"><span class="tok-kw">fn</span> <span class="tok-fn">appendSlice</span>(list: *std.ArrayList(<span class="tok-type">u8</span>), buf: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, max_value_len: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1702">    <span class="tok-kw">const</span> new_len = std.math.add(<span class="tok-type">usize</span>, list.items.len, buf.len) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ValueTooLong;</span>
<span class="line" id="L1703">    <span class="tok-kw">if</span> (new_len &gt; max_value_len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ValueTooLong;</span>
<span class="line" id="L1704">    <span class="tok-kw">try</span> list.appendSlice(buf);</span>
<span class="line" id="L1705">}</span>
<span class="line" id="L1706"></span>
<span class="line" id="L1707"><span class="tok-comment">/// For the slice you get from a `Token.number` or `Token.allocated_number`,</span></span>
<span class="line" id="L1708"><span class="tok-comment">/// this function returns true if the number doesn't contain any fraction or exponent components.</span></span>
<span class="line" id="L1709"><span class="tok-comment">/// Note, the numeric value encoded by the value may still be an integer, such as `1.0`.</span></span>
<span class="line" id="L1710"><span class="tok-comment">/// This function is meant to give a hint about whether integer parsing or float parsing should be used on the value.</span></span>
<span class="line" id="L1711"><span class="tok-comment">/// This function will not give meaningful results on non-numeric input.</span></span>
<span class="line" id="L1712"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isNumberFormattedLikeAnInteger</span>(value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L1713">    <span class="tok-kw">return</span> std.mem.indexOfAny(<span class="tok-type">u8</span>, value, <span class="tok-str">&quot;.eE&quot;</span>) == <span class="tok-null">null</span>;</span>
<span class="line" id="L1714">}</span>
<span class="line" id="L1715"></span>
<span class="line" id="L1716"><span class="tok-kw">test</span> {</span>
<span class="line" id="L1717">    _ = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;./scanner_test.zig&quot;</span>);</span>
<span class="line" id="L1718">}</span>
<span class="line" id="L1719"></span>
</code></pre></body>
</html>