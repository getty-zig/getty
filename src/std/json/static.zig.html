<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>json/static.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAPNJREFUeNpi/P//PwMlgOXHUjly9E0G4hwgZmQiQZMqEK8H4v9QzUEgQSaoADK+zhH9iAGL+C0gDoAaNg9mGLoLfgA1awK9hS9gzgJxA9RQBmQDrgMxJzRMGKE4HYj/Ial5A8QmQLwCJoBsgBYW2+TR1ChDaWt4LOBxKsi/VUh8XiD+gq4IVyzwQAMJBoKwacZlAB8Qf0bi96IZhtOAe1D6LpqaEiz6rmEzQAeIzwGxCJpieFqApo/vQKyJboAaEBsAsSEupwI1MwKjGBTVHOhegMX5UajYRqiBjMgYmj400cVh0XgTiKdC0zhJgJHS7AwQYABm9EAdCKrEfAAAAABJRU5ErkJggg=="/>
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);</span>
<span class="line" id="L2"><span class="tok-kw">const</span> assert = std.debug.assert;</span>
<span class="line" id="L3"><span class="tok-kw">const</span> Allocator = std.mem.Allocator;</span>
<span class="line" id="L4"><span class="tok-kw">const</span> ArrayList = std.ArrayList;</span>
<span class="line" id="L5"></span>
<span class="line" id="L6"><span class="tok-kw">const</span> Scanner = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;./scanner.zig&quot;</span>).Scanner;</span>
<span class="line" id="L7"><span class="tok-kw">const</span> Token = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;./scanner.zig&quot;</span>).Token;</span>
<span class="line" id="L8"><span class="tok-kw">const</span> AllocWhen = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;./scanner.zig&quot;</span>).AllocWhen;</span>
<span class="line" id="L9"><span class="tok-kw">const</span> default_max_value_len = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;./scanner.zig&quot;</span>).default_max_value_len;</span>
<span class="line" id="L10"><span class="tok-kw">const</span> isNumberFormattedLikeAnInteger = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;./scanner.zig&quot;</span>).isNumberFormattedLikeAnInteger;</span>
<span class="line" id="L11"></span>
<span class="line" id="L12"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ParseOptions = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L13">    <span class="tok-comment">/// Behaviour when a duplicate field is encountered.</span></span>
<span class="line" id="L14">    duplicate_field_behavior: <span class="tok-kw">enum</span> {</span>
<span class="line" id="L15">        use_first,</span>
<span class="line" id="L16">        @&quot;error&quot;,</span>
<span class="line" id="L17">        use_last,</span>
<span class="line" id="L18">    } = .@&quot;error&quot;,</span>
<span class="line" id="L19"></span>
<span class="line" id="L20">    <span class="tok-comment">/// If false, finding an unknown field returns an error.</span></span>
<span class="line" id="L21">    ignore_unknown_fields: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L22"></span>
<span class="line" id="L23">    <span class="tok-comment">/// Passed to json.Scanner.nextAllocMax() or json.Reader.nextAllocMax().</span></span>
<span class="line" id="L24">    <span class="tok-comment">/// The default for parseFromSlice() or parseFromTokenSource() with a *json.Scanner input</span></span>
<span class="line" id="L25">    <span class="tok-comment">/// is the length of the input slice, which means error.ValueTooLong will never be returned.</span></span>
<span class="line" id="L26">    <span class="tok-comment">/// The default for parseFromTokenSource() with a *json.Reader is default_max_value_len.</span></span>
<span class="line" id="L27">    max_value_len: ?<span class="tok-type">usize</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L28">};</span>
<span class="line" id="L29"></span>
<span class="line" id="L30"><span class="tok-comment">/// Parses the json document from s and returns the result.</span></span>
<span class="line" id="L31"><span class="tok-comment">/// The provided allocator is used both for temporary allocations during parsing the document,</span></span>
<span class="line" id="L32"><span class="tok-comment">/// and also to allocate any pointer values in the return type.</span></span>
<span class="line" id="L33"><span class="tok-comment">/// If T contains any pointers, free the memory with `std.json.parseFree`.</span></span>
<span class="line" id="L34"><span class="tok-comment">/// Note that `error.BufferUnderrun` is not actually possible to return from this function.</span></span>
<span class="line" id="L35"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseFromSlice</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, allocator: Allocator, s: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, options: ParseOptions) ParseError(T, Scanner)!T {</span>
<span class="line" id="L36">    <span class="tok-kw">var</span> scanner = Scanner.initCompleteInput(allocator, s);</span>
<span class="line" id="L37">    <span class="tok-kw">defer</span> scanner.deinit();</span>
<span class="line" id="L38"></span>
<span class="line" id="L39">    <span class="tok-kw">return</span> parseFromTokenSource(T, allocator, &amp;scanner, options);</span>
<span class="line" id="L40">}</span>
<span class="line" id="L41"></span>
<span class="line" id="L42"><span class="tok-comment">/// `scanner_or_reader` must be either a `*std.json.Scanner` with complete input or a `*std.json.Reader`.</span></span>
<span class="line" id="L43"><span class="tok-comment">/// allocator is used to allocate the data of T if necessary,</span></span>
<span class="line" id="L44"><span class="tok-comment">/// such as if T is `*u32` or `[]u32`.</span></span>
<span class="line" id="L45"><span class="tok-comment">/// If T contains any pointers, free the memory with `std.json.parseFree`.</span></span>
<span class="line" id="L46"><span class="tok-comment">/// If T contains no pointers, the allocator may sometimes be used for temporary allocations,</span></span>
<span class="line" id="L47"><span class="tok-comment">/// but no call to `std.json.parseFree` will be necessary;</span></span>
<span class="line" id="L48"><span class="tok-comment">/// all temporary allocations will be freed before this function returns.</span></span>
<span class="line" id="L49"><span class="tok-comment">/// Note that `error.BufferUnderrun` is not actually possible to return from this function.</span></span>
<span class="line" id="L50"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseFromTokenSource</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, allocator: Allocator, scanner_or_reader: <span class="tok-kw">anytype</span>, options: ParseOptions) ParseError(T, <span class="tok-builtin">@TypeOf</span>(scanner_or_reader.*))!T {</span>
<span class="line" id="L51">    <span class="tok-kw">if</span> (<span class="tok-builtin">@TypeOf</span>(scanner_or_reader.*) == Scanner) {</span>
<span class="line" id="L52">        assert(scanner_or_reader.is_end_of_input);</span>
<span class="line" id="L53">    }</span>
<span class="line" id="L54"></span>
<span class="line" id="L55">    <span class="tok-kw">var</span> resolved_options = options;</span>
<span class="line" id="L56">    <span class="tok-kw">if</span> (resolved_options.max_value_len == <span class="tok-null">null</span>) {</span>
<span class="line" id="L57">        <span class="tok-kw">if</span> (<span class="tok-builtin">@TypeOf</span>(scanner_or_reader.*) == Scanner) {</span>
<span class="line" id="L58">            resolved_options.max_value_len = scanner_or_reader.input.len;</span>
<span class="line" id="L59">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L60">            resolved_options.max_value_len = default_max_value_len;</span>
<span class="line" id="L61">        }</span>
<span class="line" id="L62">    }</span>
<span class="line" id="L63"></span>
<span class="line" id="L64">    <span class="tok-kw">const</span> r = <span class="tok-kw">try</span> parseInternal(T, allocator, scanner_or_reader, resolved_options);</span>
<span class="line" id="L65">    <span class="tok-kw">errdefer</span> parseFree(T, allocator, r);</span>
<span class="line" id="L66"></span>
<span class="line" id="L67">    assert(.end_of_document == <span class="tok-kw">try</span> scanner_or_reader.next());</span>
<span class="line" id="L68"></span>
<span class="line" id="L69">    <span class="tok-kw">return</span> r;</span>
<span class="line" id="L70">}</span>
<span class="line" id="L71"></span>
<span class="line" id="L72"><span class="tok-comment">/// The error set that will be returned from parsing T from *Source.</span></span>
<span class="line" id="L73"><span class="tok-comment">/// Note that this may contain error.BufferUnderrun, but that error will never actually be returned.</span></span>
<span class="line" id="L74"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ParseError</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Source: <span class="tok-type">type</span>) <span class="tok-type">type</span> {</span>
<span class="line" id="L75">    <span class="tok-comment">// `inferred_types` is used to avoid infinite recursion for recursive type definitions.</span>
</span>
<span class="line" id="L76">    <span class="tok-kw">const</span> inferred_types = [_]<span class="tok-type">type</span>{};</span>
<span class="line" id="L77">    <span class="tok-comment">// A few of these will either always be present or present enough of the time that</span>
</span>
<span class="line" id="L78">    <span class="tok-comment">// omitting them is more confusing than always including them.</span>
</span>
<span class="line" id="L79">    <span class="tok-kw">return</span> <span class="tok-kw">error</span>{UnexpectedToken} || Source.NextError || Source.PeekError ||</span>
<span class="line" id="L80">        ParseInternalErrorImpl(T, Source, &amp;inferred_types);</span>
<span class="line" id="L81">}</span>
<span class="line" id="L82"></span>
<span class="line" id="L83"><span class="tok-kw">fn</span> <span class="tok-fn">ParseInternalErrorImpl</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Source: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> inferred_types: []<span class="tok-kw">const</span> <span class="tok-type">type</span>) <span class="tok-type">type</span> {</span>
<span class="line" id="L84">    <span class="tok-kw">for</span> (inferred_types) |ty| {</span>
<span class="line" id="L85">        <span class="tok-kw">if</span> (T == ty) <span class="tok-kw">return</span> <span class="tok-kw">error</span>{};</span>
<span class="line" id="L86">    }</span>
<span class="line" id="L87"></span>
<span class="line" id="L88">    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {</span>
<span class="line" id="L89">        .Bool =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>{},</span>
<span class="line" id="L90">        .Float, .ComptimeFloat =&gt; <span class="tok-kw">return</span> Source.AllocError || std.fmt.ParseFloatError,</span>
<span class="line" id="L91">        .Int, .ComptimeInt =&gt; {</span>
<span class="line" id="L92">            <span class="tok-kw">return</span> Source.AllocError || <span class="tok-kw">error</span>{ InvalidNumber, Overflow } ||</span>
<span class="line" id="L93">                std.fmt.ParseIntError || std.fmt.ParseFloatError;</span>
<span class="line" id="L94">        },</span>
<span class="line" id="L95">        .Optional =&gt; |optional_info| <span class="tok-kw">return</span> ParseInternalErrorImpl(optional_info.child, Source, inferred_types ++ [_]<span class="tok-type">type</span>{T}),</span>
<span class="line" id="L96">        .Enum =&gt; <span class="tok-kw">return</span> Source.AllocError || <span class="tok-kw">error</span>{InvalidEnumTag},</span>
<span class="line" id="L97">        .Union =&gt; |unionInfo| {</span>
<span class="line" id="L98">            <span class="tok-kw">if</span> (unionInfo.tag_type) |_| {</span>
<span class="line" id="L99">                <span class="tok-kw">var</span> errors = Source.AllocError || <span class="tok-kw">error</span>{UnknownField};</span>
<span class="line" id="L100">                <span class="tok-kw">for</span> (unionInfo.fields) |u_field| {</span>
<span class="line" id="L101">                    errors = errors || ParseInternalErrorImpl(u_field.<span class="tok-type">type</span>, Source, inferred_types ++ [_]<span class="tok-type">type</span>{T});</span>
<span class="line" id="L102">                }</span>
<span class="line" id="L103">                <span class="tok-kw">return</span> errors;</span>
<span class="line" id="L104">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L105">                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unable to parse into untagged union '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>);</span>
<span class="line" id="L106">            }</span>
<span class="line" id="L107">        },</span>
<span class="line" id="L108">        .Struct =&gt; |structInfo| {</span>
<span class="line" id="L109">            <span class="tok-kw">var</span> errors = Scanner.AllocError || <span class="tok-kw">error</span>{</span>
<span class="line" id="L110">                DuplicateField,</span>
<span class="line" id="L111">                UnknownField,</span>
<span class="line" id="L112">                MissingField,</span>
<span class="line" id="L113">            };</span>
<span class="line" id="L114">            <span class="tok-kw">for</span> (structInfo.fields) |field| {</span>
<span class="line" id="L115">                errors = errors || ParseInternalErrorImpl(field.<span class="tok-type">type</span>, Source, inferred_types ++ [_]<span class="tok-type">type</span>{T});</span>
<span class="line" id="L116">            }</span>
<span class="line" id="L117">            <span class="tok-kw">return</span> errors;</span>
<span class="line" id="L118">        },</span>
<span class="line" id="L119">        .Array =&gt; |arrayInfo| {</span>
<span class="line" id="L120">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>{LengthMismatch} ||</span>
<span class="line" id="L121">                ParseInternalErrorImpl(arrayInfo.child, Source, inferred_types ++ [_]<span class="tok-type">type</span>{T});</span>
<span class="line" id="L122">        },</span>
<span class="line" id="L123">        .Vector =&gt; |vecInfo| {</span>
<span class="line" id="L124">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>{LengthMismatch} ||</span>
<span class="line" id="L125">                ParseInternalErrorImpl(vecInfo.child, Source, inferred_types ++ [_]<span class="tok-type">type</span>{T});</span>
<span class="line" id="L126">        },</span>
<span class="line" id="L127">        .Pointer =&gt; |ptrInfo| {</span>
<span class="line" id="L128">            <span class="tok-kw">switch</span> (ptrInfo.size) {</span>
<span class="line" id="L129">                .One, .Slice =&gt; {</span>
<span class="line" id="L130">                    <span class="tok-kw">return</span> ParseInternalErrorImpl(ptrInfo.child, Source, inferred_types ++ [_]<span class="tok-type">type</span>{T});</span>
<span class="line" id="L131">                },</span>
<span class="line" id="L132">                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unable to parse into type '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>),</span>
<span class="line" id="L133">            }</span>
<span class="line" id="L134">        },</span>
<span class="line" id="L135">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>{},</span>
<span class="line" id="L136">    }</span>
<span class="line" id="L137">    <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L138">}</span>
<span class="line" id="L139"></span>
<span class="line" id="L140"><span class="tok-kw">fn</span> <span class="tok-fn">parseInternal</span>(</span>
<span class="line" id="L141">    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,</span>
<span class="line" id="L142">    allocator: Allocator,</span>
<span class="line" id="L143">    source: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L144">    options: ParseOptions,</span>
<span class="line" id="L145">) ParseError(T, <span class="tok-builtin">@TypeOf</span>(source.*))!T {</span>
<span class="line" id="L146">    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {</span>
<span class="line" id="L147">        .Bool =&gt; {</span>
<span class="line" id="L148">            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> source.next()) {</span>
<span class="line" id="L149">                .<span class="tok-null">true</span> =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L150">                .<span class="tok-null">false</span> =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L151">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">error</span>.UnexpectedToken,</span>
<span class="line" id="L152">            };</span>
<span class="line" id="L153">        },</span>
<span class="line" id="L154">        .Float, .ComptimeFloat =&gt; {</span>
<span class="line" id="L155">            <span class="tok-kw">const</span> token = <span class="tok-kw">try</span> source.nextAllocMax(allocator, .alloc_if_needed, options.max_value_len.?);</span>
<span class="line" id="L156">            <span class="tok-kw">defer</span> freeAllocated(allocator, token);</span>
<span class="line" id="L157">            <span class="tok-kw">const</span> slice = <span class="tok-kw">switch</span> (token) {</span>
<span class="line" id="L158">                .number, .string =&gt; |slice| slice,</span>
<span class="line" id="L159">                .allocated_number, .allocated_string =&gt; |slice| slice,</span>
<span class="line" id="L160">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken,</span>
<span class="line" id="L161">            };</span>
<span class="line" id="L162">            <span class="tok-kw">return</span> <span class="tok-kw">try</span> std.fmt.parseFloat(T, slice);</span>
<span class="line" id="L163">        },</span>
<span class="line" id="L164">        .Int, .ComptimeInt =&gt; {</span>
<span class="line" id="L165">            <span class="tok-kw">const</span> token = <span class="tok-kw">try</span> source.nextAllocMax(allocator, .alloc_if_needed, options.max_value_len.?);</span>
<span class="line" id="L166">            <span class="tok-kw">defer</span> freeAllocated(allocator, token);</span>
<span class="line" id="L167">            <span class="tok-kw">const</span> slice = <span class="tok-kw">switch</span> (token) {</span>
<span class="line" id="L168">                .number, .string =&gt; |slice| slice,</span>
<span class="line" id="L169">                .allocated_number, .allocated_string =&gt; |slice| slice,</span>
<span class="line" id="L170">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken,</span>
<span class="line" id="L171">            };</span>
<span class="line" id="L172">            <span class="tok-kw">if</span> (isNumberFormattedLikeAnInteger(slice))</span>
<span class="line" id="L173">                <span class="tok-kw">return</span> std.fmt.parseInt(T, slice, <span class="tok-number">10</span>);</span>
<span class="line" id="L174">            <span class="tok-comment">// Try to coerce a float to an integer.</span>
</span>
<span class="line" id="L175">            <span class="tok-kw">const</span> float = <span class="tok-kw">try</span> std.fmt.parseFloat(<span class="tok-type">f128</span>, slice);</span>
<span class="line" id="L176">            <span class="tok-kw">if</span> (<span class="tok-builtin">@round</span>(float) != float) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidNumber;</span>
<span class="line" id="L177">            <span class="tok-kw">if</span> (float &gt; std.math.maxInt(T) <span class="tok-kw">or</span> float &lt; std.math.minInt(T)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;</span>
<span class="line" id="L178">            <span class="tok-kw">return</span> <span class="tok-builtin">@floatToInt</span>(T, float);</span>
<span class="line" id="L179">        },</span>
<span class="line" id="L180">        .Optional =&gt; |optionalInfo| {</span>
<span class="line" id="L181">            <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> source.peekNextTokenType()) {</span>
<span class="line" id="L182">                .<span class="tok-null">null</span> =&gt; {</span>
<span class="line" id="L183">                    _ = <span class="tok-kw">try</span> source.next();</span>
<span class="line" id="L184">                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L185">                },</span>
<span class="line" id="L186">                <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L187">                    <span class="tok-kw">return</span> <span class="tok-kw">try</span> parseInternal(optionalInfo.child, allocator, source, options);</span>
<span class="line" id="L188">                },</span>
<span class="line" id="L189">            }</span>
<span class="line" id="L190">        },</span>
<span class="line" id="L191">        .Enum =&gt; |enumInfo| {</span>
<span class="line" id="L192">            <span class="tok-kw">const</span> token = <span class="tok-kw">try</span> source.nextAllocMax(allocator, .alloc_if_needed, options.max_value_len.?);</span>
<span class="line" id="L193">            <span class="tok-kw">defer</span> freeAllocated(allocator, token);</span>
<span class="line" id="L194">            <span class="tok-kw">const</span> slice = <span class="tok-kw">switch</span> (token) {</span>
<span class="line" id="L195">                .number, .string =&gt; |slice| slice,</span>
<span class="line" id="L196">                .allocated_number, .allocated_string =&gt; |slice| slice,</span>
<span class="line" id="L197">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken,</span>
<span class="line" id="L198">            };</span>
<span class="line" id="L199">            <span class="tok-comment">// Check for a named value.</span>
</span>
<span class="line" id="L200">            <span class="tok-kw">if</span> (std.meta.stringToEnum(T, slice)) |value| <span class="tok-kw">return</span> value;</span>
<span class="line" id="L201">            <span class="tok-comment">// Check for a numeric value.</span>
</span>
<span class="line" id="L202">            <span class="tok-kw">if</span> (!isNumberFormattedLikeAnInteger(slice)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidEnumTag;</span>
<span class="line" id="L203">            <span class="tok-kw">const</span> n = std.fmt.parseInt(enumInfo.tag_type, slice, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidEnumTag;</span>
<span class="line" id="L204">            <span class="tok-kw">return</span> <span class="tok-kw">try</span> std.meta.intToEnum(T, n);</span>
<span class="line" id="L205">        },</span>
<span class="line" id="L206">        .Union =&gt; |unionInfo| {</span>
<span class="line" id="L207">            <span class="tok-kw">const</span> UnionTagType = unionInfo.tag_type <span class="tok-kw">orelse</span> <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unable to parse into untagged union '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>);</span>
<span class="line" id="L208"></span>
<span class="line" id="L209">            <span class="tok-kw">if</span> (.object_begin != <span class="tok-kw">try</span> source.next()) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken;</span>
<span class="line" id="L210"></span>
<span class="line" id="L211">            <span class="tok-kw">var</span> result: ?T = <span class="tok-null">null</span>;</span>
<span class="line" id="L212">            <span class="tok-kw">errdefer</span> {</span>
<span class="line" id="L213">                <span class="tok-kw">if</span> (result) |r| {</span>
<span class="line" id="L214">                    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (unionInfo.fields) |u_field| {</span>
<span class="line" id="L215">                        <span class="tok-kw">if</span> (r == <span class="tok-builtin">@field</span>(UnionTagType, u_field.name)) {</span>
<span class="line" id="L216">                            parseFree(u_field.<span class="tok-type">type</span>, allocator, <span class="tok-builtin">@field</span>(r, u_field.name));</span>
<span class="line" id="L217">                        }</span>
<span class="line" id="L218">                    }</span>
<span class="line" id="L219">                }</span>
<span class="line" id="L220">            }</span>
<span class="line" id="L221"></span>
<span class="line" id="L222">            <span class="tok-kw">var</span> name_token: ?Token = <span class="tok-kw">try</span> source.nextAllocMax(allocator, .alloc_if_needed, options.max_value_len.?);</span>
<span class="line" id="L223">            <span class="tok-kw">errdefer</span> {</span>
<span class="line" id="L224">                <span class="tok-kw">if</span> (name_token) |t| {</span>
<span class="line" id="L225">                    freeAllocated(allocator, t);</span>
<span class="line" id="L226">                }</span>
<span class="line" id="L227">            }</span>
<span class="line" id="L228">            <span class="tok-kw">const</span> field_name = <span class="tok-kw">switch</span> (name_token.?) {</span>
<span class="line" id="L229">                .string =&gt; |slice| slice,</span>
<span class="line" id="L230">                .allocated_string =&gt; |slice| slice,</span>
<span class="line" id="L231">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken,</span>
<span class="line" id="L232">            };</span>
<span class="line" id="L233"></span>
<span class="line" id="L234">            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (unionInfo.fields) |u_field| {</span>
<span class="line" id="L235">                <span class="tok-kw">if</span> (std.mem.eql(<span class="tok-type">u8</span>, u_field.name, field_name)) {</span>
<span class="line" id="L236">                    <span class="tok-comment">// Free the name token now in case we're using an allocator that optimizes freeing the last allocated object.</span>
</span>
<span class="line" id="L237">                    <span class="tok-comment">// (Recursing into parseInternal() might trigger more allocations.)</span>
</span>
<span class="line" id="L238">                    freeAllocated(allocator, name_token.?);</span>
<span class="line" id="L239">                    name_token = <span class="tok-null">null</span>;</span>
<span class="line" id="L240"></span>
<span class="line" id="L241">                    <span class="tok-kw">if</span> (u_field.<span class="tok-type">type</span> == <span class="tok-type">void</span>) {</span>
<span class="line" id="L242">                        <span class="tok-comment">// void isn't really a json type, but we can support void payload union tags with {} as a value.</span>
</span>
<span class="line" id="L243">                        <span class="tok-kw">if</span> (.object_begin != <span class="tok-kw">try</span> source.next()) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken;</span>
<span class="line" id="L244">                        <span class="tok-kw">if</span> (.object_end != <span class="tok-kw">try</span> source.next()) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken;</span>
<span class="line" id="L245">                        result = <span class="tok-builtin">@unionInit</span>(T, u_field.name, {});</span>
<span class="line" id="L246">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L247">                        <span class="tok-comment">// Recurse.</span>
</span>
<span class="line" id="L248">                        result = <span class="tok-builtin">@unionInit</span>(T, u_field.name, <span class="tok-kw">try</span> parseInternal(u_field.<span class="tok-type">type</span>, allocator, source, options));</span>
<span class="line" id="L249">                    }</span>
<span class="line" id="L250">                    <span class="tok-kw">break</span>;</span>
<span class="line" id="L251">                }</span>
<span class="line" id="L252">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L253">                <span class="tok-comment">// Didn't match anything.</span>
</span>
<span class="line" id="L254">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownField;</span>
<span class="line" id="L255">            }</span>
<span class="line" id="L256"></span>
<span class="line" id="L257">            <span class="tok-kw">if</span> (.object_end != <span class="tok-kw">try</span> source.next()) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken;</span>
<span class="line" id="L258"></span>
<span class="line" id="L259">            <span class="tok-kw">return</span> result.?;</span>
<span class="line" id="L260">        },</span>
<span class="line" id="L261"></span>
<span class="line" id="L262">        .Struct =&gt; |structInfo| {</span>
<span class="line" id="L263">            <span class="tok-kw">if</span> (structInfo.is_tuple) {</span>
<span class="line" id="L264">                <span class="tok-kw">if</span> (.array_begin != <span class="tok-kw">try</span> source.next()) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken;</span>
<span class="line" id="L265"></span>
<span class="line" id="L266">                <span class="tok-kw">var</span> r: T = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L267">                <span class="tok-kw">var</span> fields_seen: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L268">                <span class="tok-kw">errdefer</span> {</span>
<span class="line" id="L269">                    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-number">0</span>..structInfo.fields.len) |i| {</span>
<span class="line" id="L270">                        <span class="tok-kw">if</span> (i &lt; fields_seen) {</span>
<span class="line" id="L271">                            parseFree(structInfo.fields[i].<span class="tok-type">type</span>, allocator, r[i]);</span>
<span class="line" id="L272">                        }</span>
<span class="line" id="L273">                    }</span>
<span class="line" id="L274">                }</span>
<span class="line" id="L275">                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-number">0</span>..structInfo.fields.len) |i| {</span>
<span class="line" id="L276">                    r[i] = <span class="tok-kw">try</span> parseInternal(structInfo.fields[i].<span class="tok-type">type</span>, allocator, source, options);</span>
<span class="line" id="L277">                    fields_seen = i + <span class="tok-number">1</span>;</span>
<span class="line" id="L278">                }</span>
<span class="line" id="L279"></span>
<span class="line" id="L280">                <span class="tok-kw">if</span> (.array_end != <span class="tok-kw">try</span> source.next()) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken;</span>
<span class="line" id="L281"></span>
<span class="line" id="L282">                <span class="tok-kw">return</span> r;</span>
<span class="line" id="L283">            }</span>
<span class="line" id="L284"></span>
<span class="line" id="L285">            <span class="tok-kw">if</span> (.object_begin != <span class="tok-kw">try</span> source.next()) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken;</span>
<span class="line" id="L286"></span>
<span class="line" id="L287">            <span class="tok-kw">var</span> r: T = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L288">            <span class="tok-kw">var</span> fields_seen = [_]<span class="tok-type">bool</span>{<span class="tok-null">false</span>} ** structInfo.fields.len;</span>
<span class="line" id="L289">            <span class="tok-kw">errdefer</span> {</span>
<span class="line" id="L290">                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (structInfo.fields, <span class="tok-number">0</span>..) |field, i| {</span>
<span class="line" id="L291">                    <span class="tok-kw">if</span> (fields_seen[i]) {</span>
<span class="line" id="L292">                        parseFree(field.<span class="tok-type">type</span>, allocator, <span class="tok-builtin">@field</span>(r, field.name));</span>
<span class="line" id="L293">                    }</span>
<span class="line" id="L294">                }</span>
<span class="line" id="L295">            }</span>
<span class="line" id="L296"></span>
<span class="line" id="L297">            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L298">                <span class="tok-kw">var</span> name_token: ?Token = <span class="tok-kw">try</span> source.nextAllocMax(allocator, .alloc_if_needed, options.max_value_len.?);</span>
<span class="line" id="L299">                <span class="tok-kw">errdefer</span> {</span>
<span class="line" id="L300">                    <span class="tok-kw">if</span> (name_token) |t| {</span>
<span class="line" id="L301">                        freeAllocated(allocator, t);</span>
<span class="line" id="L302">                    }</span>
<span class="line" id="L303">                }</span>
<span class="line" id="L304">                <span class="tok-kw">const</span> field_name = <span class="tok-kw">switch</span> (name_token.?) {</span>
<span class="line" id="L305">                    .object_end =&gt; <span class="tok-kw">break</span>, <span class="tok-comment">// No more fields.</span>
</span>
<span class="line" id="L306">                    .string =&gt; |slice| slice,</span>
<span class="line" id="L307">                    .allocated_string =&gt; |slice| slice,</span>
<span class="line" id="L308">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken,</span>
<span class="line" id="L309">                };</span>
<span class="line" id="L310"></span>
<span class="line" id="L311">                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (structInfo.fields, <span class="tok-number">0</span>..) |field, i| {</span>
<span class="line" id="L312">                    <span class="tok-kw">if</span> (field.is_comptime) <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;comptime fields are not supported: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;.&quot;</span> ++ field.name);</span>
<span class="line" id="L313">                    <span class="tok-kw">if</span> (std.mem.eql(<span class="tok-type">u8</span>, field.name, field_name)) {</span>
<span class="line" id="L314">                        <span class="tok-comment">// Free the name token now in case we're using an allocator that optimizes freeing the last allocated object.</span>
</span>
<span class="line" id="L315">                        <span class="tok-comment">// (Recursing into parseInternal() might trigger more allocations.)</span>
</span>
<span class="line" id="L316">                        freeAllocated(allocator, name_token.?);</span>
<span class="line" id="L317">                        name_token = <span class="tok-null">null</span>;</span>
<span class="line" id="L318"></span>
<span class="line" id="L319">                        <span class="tok-kw">if</span> (fields_seen[i]) {</span>
<span class="line" id="L320">                            <span class="tok-kw">switch</span> (options.duplicate_field_behavior) {</span>
<span class="line" id="L321">                                .use_first =&gt; {</span>
<span class="line" id="L322">                                    <span class="tok-comment">// Parse and then delete the redundant value.</span>
</span>
<span class="line" id="L323">                                    <span class="tok-comment">// We don't want to skip the value, because we want type checking.</span>
</span>
<span class="line" id="L324">                                    <span class="tok-kw">const</span> ignored_value = <span class="tok-kw">try</span> parseInternal(field.<span class="tok-type">type</span>, allocator, source, options);</span>
<span class="line" id="L325">                                    parseFree(field.<span class="tok-type">type</span>, allocator, ignored_value);</span>
<span class="line" id="L326">                                    <span class="tok-kw">break</span>;</span>
<span class="line" id="L327">                                },</span>
<span class="line" id="L328">                                .@&quot;error&quot; =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DuplicateField,</span>
<span class="line" id="L329">                                .use_last =&gt; {</span>
<span class="line" id="L330">                                    <span class="tok-comment">// Delete the stale value. We're about to get a new one.</span>
</span>
<span class="line" id="L331">                                    parseFree(field.<span class="tok-type">type</span>, allocator, <span class="tok-builtin">@field</span>(r, field.name));</span>
<span class="line" id="L332">                                    fields_seen[i] = <span class="tok-null">false</span>;</span>
<span class="line" id="L333">                                },</span>
<span class="line" id="L334">                            }</span>
<span class="line" id="L335">                        }</span>
<span class="line" id="L336">                        <span class="tok-builtin">@field</span>(r, field.name) = <span class="tok-kw">try</span> parseInternal(field.<span class="tok-type">type</span>, allocator, source, options);</span>
<span class="line" id="L337">                        fields_seen[i] = <span class="tok-null">true</span>;</span>
<span class="line" id="L338">                        <span class="tok-kw">break</span>;</span>
<span class="line" id="L339">                    }</span>
<span class="line" id="L340">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L341">                    <span class="tok-comment">// Didn't match anything.</span>
</span>
<span class="line" id="L342">                    freeAllocated(allocator, name_token.?);</span>
<span class="line" id="L343">                    <span class="tok-kw">if</span> (options.ignore_unknown_fields) {</span>
<span class="line" id="L344">                        <span class="tok-kw">try</span> source.skipValue();</span>
<span class="line" id="L345">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L346">                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownField;</span>
<span class="line" id="L347">                    }</span>
<span class="line" id="L348">                }</span>
<span class="line" id="L349">            }</span>
<span class="line" id="L350">            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (structInfo.fields, <span class="tok-number">0</span>..) |field, i| {</span>
<span class="line" id="L351">                <span class="tok-kw">if</span> (!fields_seen[i]) {</span>
<span class="line" id="L352">                    <span class="tok-kw">if</span> (field.default_value) |default_ptr| {</span>
<span class="line" id="L353">                        <span class="tok-kw">const</span> default = <span class="tok-builtin">@ptrCast</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> field.<span class="tok-type">type</span>, default_ptr).*;</span>
<span class="line" id="L354">                        <span class="tok-builtin">@field</span>(r, field.name) = default;</span>
<span class="line" id="L355">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L356">                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingField;</span>
<span class="line" id="L357">                    }</span>
<span class="line" id="L358">                }</span>
<span class="line" id="L359">            }</span>
<span class="line" id="L360">            <span class="tok-kw">return</span> r;</span>
<span class="line" id="L361">        },</span>
<span class="line" id="L362"></span>
<span class="line" id="L363">        .Array =&gt; |arrayInfo| {</span>
<span class="line" id="L364">            <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> source.peekNextTokenType()) {</span>
<span class="line" id="L365">                .array_begin =&gt; {</span>
<span class="line" id="L366">                    <span class="tok-comment">// Typical array.</span>
</span>
<span class="line" id="L367">                    <span class="tok-kw">return</span> parseInternalArray(T, arrayInfo.child, arrayInfo.len, allocator, source, options);</span>
<span class="line" id="L368">                },</span>
<span class="line" id="L369">                .string =&gt; {</span>
<span class="line" id="L370">                    <span class="tok-kw">if</span> (arrayInfo.child != <span class="tok-type">u8</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken;</span>
<span class="line" id="L371">                    <span class="tok-comment">// Fixed-length string.</span>
</span>
<span class="line" id="L372"></span>
<span class="line" id="L373">                    <span class="tok-kw">var</span> r: T = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L374">                    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L375">                    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L376">                        <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> source.next()) {</span>
<span class="line" id="L377">                            .string =&gt; |slice| {</span>
<span class="line" id="L378">                                <span class="tok-kw">if</span> (i + slice.len != r.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LengthMismatch;</span>
<span class="line" id="L379">                                <span class="tok-builtin">@memcpy</span>(r[i..][<span class="tok-number">0</span>..slice.len], slice);</span>
<span class="line" id="L380">                                <span class="tok-kw">break</span>;</span>
<span class="line" id="L381">                            },</span>
<span class="line" id="L382">                            .partial_string =&gt; |slice| {</span>
<span class="line" id="L383">                                <span class="tok-kw">if</span> (i + slice.len &gt; r.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LengthMismatch;</span>
<span class="line" id="L384">                                <span class="tok-builtin">@memcpy</span>(r[i..][<span class="tok-number">0</span>..slice.len], slice);</span>
<span class="line" id="L385">                                i += slice.len;</span>
<span class="line" id="L386">                            },</span>
<span class="line" id="L387">                            .partial_string_escaped_1 =&gt; |arr| {</span>
<span class="line" id="L388">                                <span class="tok-kw">if</span> (i + arr.len &gt; r.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LengthMismatch;</span>
<span class="line" id="L389">                                <span class="tok-builtin">@memcpy</span>(r[i..][<span class="tok-number">0</span>..arr.len], arr[<span class="tok-number">0</span>..]);</span>
<span class="line" id="L390">                                i += arr.len;</span>
<span class="line" id="L391">                            },</span>
<span class="line" id="L392">                            .partial_string_escaped_2 =&gt; |arr| {</span>
<span class="line" id="L393">                                <span class="tok-kw">if</span> (i + arr.len &gt; r.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LengthMismatch;</span>
<span class="line" id="L394">                                <span class="tok-builtin">@memcpy</span>(r[i..][<span class="tok-number">0</span>..arr.len], arr[<span class="tok-number">0</span>..]);</span>
<span class="line" id="L395">                                i += arr.len;</span>
<span class="line" id="L396">                            },</span>
<span class="line" id="L397">                            .partial_string_escaped_3 =&gt; |arr| {</span>
<span class="line" id="L398">                                <span class="tok-kw">if</span> (i + arr.len &gt; r.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LengthMismatch;</span>
<span class="line" id="L399">                                <span class="tok-builtin">@memcpy</span>(r[i..][<span class="tok-number">0</span>..arr.len], arr[<span class="tok-number">0</span>..]);</span>
<span class="line" id="L400">                                i += arr.len;</span>
<span class="line" id="L401">                            },</span>
<span class="line" id="L402">                            .partial_string_escaped_4 =&gt; |arr| {</span>
<span class="line" id="L403">                                <span class="tok-kw">if</span> (i + arr.len &gt; r.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LengthMismatch;</span>
<span class="line" id="L404">                                <span class="tok-builtin">@memcpy</span>(r[i..][<span class="tok-number">0</span>..arr.len], arr[<span class="tok-number">0</span>..]);</span>
<span class="line" id="L405">                                i += arr.len;</span>
<span class="line" id="L406">                            },</span>
<span class="line" id="L407">                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L408">                        }</span>
<span class="line" id="L409">                    }</span>
<span class="line" id="L410"></span>
<span class="line" id="L411">                    <span class="tok-kw">return</span> r;</span>
<span class="line" id="L412">                },</span>
<span class="line" id="L413"></span>
<span class="line" id="L414">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken,</span>
<span class="line" id="L415">            }</span>
<span class="line" id="L416">        },</span>
<span class="line" id="L417"></span>
<span class="line" id="L418">        .Vector =&gt; |vecInfo| {</span>
<span class="line" id="L419">            <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> source.peekNextTokenType()) {</span>
<span class="line" id="L420">                .array_begin =&gt; {</span>
<span class="line" id="L421">                    <span class="tok-kw">return</span> parseInternalArray(T, vecInfo.child, vecInfo.len, allocator, source, options);</span>
<span class="line" id="L422">                },</span>
<span class="line" id="L423">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken,</span>
<span class="line" id="L424">            }</span>
<span class="line" id="L425">        },</span>
<span class="line" id="L426"></span>
<span class="line" id="L427">        .Pointer =&gt; |ptrInfo| {</span>
<span class="line" id="L428">            <span class="tok-kw">switch</span> (ptrInfo.size) {</span>
<span class="line" id="L429">                .One =&gt; {</span>
<span class="line" id="L430">                    <span class="tok-kw">const</span> r: *ptrInfo.child = <span class="tok-kw">try</span> allocator.create(ptrInfo.child);</span>
<span class="line" id="L431">                    <span class="tok-kw">errdefer</span> allocator.destroy(r);</span>
<span class="line" id="L432">                    r.* = <span class="tok-kw">try</span> parseInternal(ptrInfo.child, allocator, source, options);</span>
<span class="line" id="L433">                    <span class="tok-kw">return</span> r;</span>
<span class="line" id="L434">                },</span>
<span class="line" id="L435">                .Slice =&gt; {</span>
<span class="line" id="L436">                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> source.peekNextTokenType()) {</span>
<span class="line" id="L437">                        .array_begin =&gt; {</span>
<span class="line" id="L438">                            _ = <span class="tok-kw">try</span> source.next();</span>
<span class="line" id="L439"></span>
<span class="line" id="L440">                            <span class="tok-comment">// Typical array.</span>
</span>
<span class="line" id="L441">                            <span class="tok-kw">var</span> arraylist = ArrayList(ptrInfo.child).init(allocator);</span>
<span class="line" id="L442">                            <span class="tok-kw">errdefer</span> {</span>
<span class="line" id="L443">                                <span class="tok-kw">while</span> (arraylist.popOrNull()) |v| {</span>
<span class="line" id="L444">                                    parseFree(ptrInfo.child, allocator, v);</span>
<span class="line" id="L445">                                }</span>
<span class="line" id="L446">                                arraylist.deinit();</span>
<span class="line" id="L447">                            }</span>
<span class="line" id="L448"></span>
<span class="line" id="L449">                            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L450">                                <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> source.peekNextTokenType()) {</span>
<span class="line" id="L451">                                    .array_end =&gt; {</span>
<span class="line" id="L452">                                        _ = <span class="tok-kw">try</span> source.next();</span>
<span class="line" id="L453">                                        <span class="tok-kw">break</span>;</span>
<span class="line" id="L454">                                    },</span>
<span class="line" id="L455">                                    <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L456">                                }</span>
<span class="line" id="L457"></span>
<span class="line" id="L458">                                <span class="tok-kw">try</span> arraylist.ensureUnusedCapacity(<span class="tok-number">1</span>);</span>
<span class="line" id="L459">                                arraylist.appendAssumeCapacity(<span class="tok-kw">try</span> parseInternal(ptrInfo.child, allocator, source, options));</span>
<span class="line" id="L460">                            }</span>
<span class="line" id="L461"></span>
<span class="line" id="L462">                            <span class="tok-kw">if</span> (ptrInfo.sentinel) |some| {</span>
<span class="line" id="L463">                                <span class="tok-kw">const</span> sentinel_value = <span class="tok-builtin">@ptrCast</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> ptrInfo.child, some).*;</span>
<span class="line" id="L464">                                <span class="tok-kw">return</span> <span class="tok-kw">try</span> arraylist.toOwnedSliceSentinel(sentinel_value);</span>
<span class="line" id="L465">                            }</span>
<span class="line" id="L466"></span>
<span class="line" id="L467">                            <span class="tok-kw">return</span> <span class="tok-kw">try</span> arraylist.toOwnedSlice();</span>
<span class="line" id="L468">                        },</span>
<span class="line" id="L469">                        .string =&gt; {</span>
<span class="line" id="L470">                            <span class="tok-kw">if</span> (ptrInfo.child != <span class="tok-type">u8</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken;</span>
<span class="line" id="L471"></span>
<span class="line" id="L472">                            <span class="tok-comment">// Dynamic length string.</span>
</span>
<span class="line" id="L473">                            <span class="tok-kw">if</span> (ptrInfo.sentinel) |sentinel_ptr| {</span>
<span class="line" id="L474">                                <span class="tok-comment">// Use our own array list so we can append the sentinel.</span>
</span>
<span class="line" id="L475">                                <span class="tok-kw">var</span> value_list = ArrayList(<span class="tok-type">u8</span>).init(allocator);</span>
<span class="line" id="L476">                                <span class="tok-kw">errdefer</span> value_list.deinit();</span>
<span class="line" id="L477">                                _ = <span class="tok-kw">try</span> source.allocNextIntoArrayList(&amp;value_list, .alloc_always);</span>
<span class="line" id="L478">                                <span class="tok-kw">return</span> <span class="tok-kw">try</span> value_list.toOwnedSliceSentinel(<span class="tok-builtin">@ptrCast</span>(*<span class="tok-kw">const</span> <span class="tok-type">u8</span>, sentinel_ptr).*);</span>
<span class="line" id="L479">                            }</span>
<span class="line" id="L480">                            <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> source.nextAllocMax(allocator, .alloc_always, options.max_value_len.?)) {</span>
<span class="line" id="L481">                                .allocated_string =&gt; |slice| <span class="tok-kw">return</span> slice,</span>
<span class="line" id="L482">                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L483">                            }</span>
<span class="line" id="L484">                        },</span>
<span class="line" id="L485">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken,</span>
<span class="line" id="L486">                    }</span>
<span class="line" id="L487">                },</span>
<span class="line" id="L488">                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unable to parse into type '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>),</span>
<span class="line" id="L489">            }</span>
<span class="line" id="L490">        },</span>
<span class="line" id="L491">        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unable to parse into type '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>),</span>
<span class="line" id="L492">    }</span>
<span class="line" id="L493">    <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L494">}</span>
<span class="line" id="L495"></span>
<span class="line" id="L496"><span class="tok-kw">fn</span> <span class="tok-fn">parseInternalArray</span>(</span>
<span class="line" id="L497">    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,</span>
<span class="line" id="L498">    <span class="tok-kw">comptime</span> Child: <span class="tok-type">type</span>,</span>
<span class="line" id="L499">    <span class="tok-kw">comptime</span> len: <span class="tok-type">comptime_int</span>,</span>
<span class="line" id="L500">    allocator: Allocator,</span>
<span class="line" id="L501">    source: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L502">    options: ParseOptions,</span>
<span class="line" id="L503">) !T {</span>
<span class="line" id="L504">    assert(.array_begin == <span class="tok-kw">try</span> source.next());</span>
<span class="line" id="L505"></span>
<span class="line" id="L506">    <span class="tok-kw">var</span> r: T = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L507">    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L508">    <span class="tok-kw">errdefer</span> {</span>
<span class="line" id="L509">        <span class="tok-comment">// Without the len check `r[i]` is not allowed</span>
</span>
<span class="line" id="L510">        <span class="tok-kw">if</span> (len &gt; <span class="tok-number">0</span>) <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (i -= <span class="tok-number">1</span>) {</span>
<span class="line" id="L511">            parseFree(Child, allocator, r[i]);</span>
<span class="line" id="L512">            <span class="tok-kw">if</span> (i == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;</span>
<span class="line" id="L513">        };</span>
<span class="line" id="L514">    }</span>
<span class="line" id="L515">    <span class="tok-kw">while</span> (i &lt; len) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L516">        r[i] = <span class="tok-kw">try</span> parseInternal(Child, allocator, source, options);</span>
<span class="line" id="L517">    }</span>
<span class="line" id="L518"></span>
<span class="line" id="L519">    <span class="tok-kw">if</span> (.array_end != <span class="tok-kw">try</span> source.next()) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken;</span>
<span class="line" id="L520"></span>
<span class="line" id="L521">    <span class="tok-kw">return</span> r;</span>
<span class="line" id="L522">}</span>
<span class="line" id="L523"></span>
<span class="line" id="L524"><span class="tok-kw">fn</span> <span class="tok-fn">freeAllocated</span>(allocator: Allocator, token: Token) <span class="tok-type">void</span> {</span>
<span class="line" id="L525">    <span class="tok-kw">switch</span> (token) {</span>
<span class="line" id="L526">        .allocated_number, .allocated_string =&gt; |slice| {</span>
<span class="line" id="L527">            allocator.free(slice);</span>
<span class="line" id="L528">        },</span>
<span class="line" id="L529">        <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L530">    }</span>
<span class="line" id="L531">}</span>
<span class="line" id="L532"></span>
<span class="line" id="L533"><span class="tok-comment">/// Releases resources created by parseFromSlice() or parseFromTokenSource().</span></span>
<span class="line" id="L534"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseFree</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, allocator: Allocator, value: T) <span class="tok-type">void</span> {</span>
<span class="line" id="L535">    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {</span>
<span class="line" id="L536">        .Bool, .Float, .ComptimeFloat, .Int, .ComptimeInt, .Enum =&gt; {},</span>
<span class="line" id="L537">        .Optional =&gt; {</span>
<span class="line" id="L538">            <span class="tok-kw">if</span> (value) |v| {</span>
<span class="line" id="L539">                <span class="tok-kw">return</span> parseFree(<span class="tok-builtin">@TypeOf</span>(v), allocator, v);</span>
<span class="line" id="L540">            }</span>
<span class="line" id="L541">        },</span>
<span class="line" id="L542">        .Union =&gt; |unionInfo| {</span>
<span class="line" id="L543">            <span class="tok-kw">if</span> (unionInfo.tag_type) |UnionTagType| {</span>
<span class="line" id="L544">                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (unionInfo.fields) |u_field| {</span>
<span class="line" id="L545">                    <span class="tok-kw">if</span> (value == <span class="tok-builtin">@field</span>(UnionTagType, u_field.name)) {</span>
<span class="line" id="L546">                        parseFree(u_field.<span class="tok-type">type</span>, allocator, <span class="tok-builtin">@field</span>(value, u_field.name));</span>
<span class="line" id="L547">                        <span class="tok-kw">break</span>;</span>
<span class="line" id="L548">                    }</span>
<span class="line" id="L549">                }</span>
<span class="line" id="L550">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L551">                <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L552">            }</span>
<span class="line" id="L553">        },</span>
<span class="line" id="L554">        .Struct =&gt; |structInfo| {</span>
<span class="line" id="L555">            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (structInfo.fields) |field| {</span>
<span class="line" id="L556">                <span class="tok-kw">var</span> should_free = <span class="tok-null">true</span>;</span>
<span class="line" id="L557">                <span class="tok-kw">if</span> (field.default_value) |default| {</span>
<span class="line" id="L558">                    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(field.<span class="tok-type">type</span>)) {</span>
<span class="line" id="L559">                        <span class="tok-comment">// We must not attempt to free pointers to struct default values</span>
</span>
<span class="line" id="L560">                        .Pointer =&gt; |fieldPtrInfo| {</span>
<span class="line" id="L561">                            <span class="tok-kw">const</span> field_value = <span class="tok-builtin">@field</span>(value, field.name);</span>
<span class="line" id="L562">                            <span class="tok-kw">const</span> field_ptr = <span class="tok-kw">switch</span> (fieldPtrInfo.size) {</span>
<span class="line" id="L563">                                .One =&gt; field_value,</span>
<span class="line" id="L564">                                .Slice =&gt; field_value.ptr,</span>
<span class="line" id="L565">                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Other pointer types are not parseable</span>
</span>
<span class="line" id="L566">                            };</span>
<span class="line" id="L567">                            <span class="tok-kw">const</span> field_addr = <span class="tok-builtin">@ptrToInt</span>(field_ptr);</span>
<span class="line" id="L568"></span>
<span class="line" id="L569">                            <span class="tok-kw">const</span> casted_default = <span class="tok-builtin">@ptrCast</span>(*<span class="tok-kw">const</span> field.<span class="tok-type">type</span>, <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@alignOf</span>(field.<span class="tok-type">type</span>), default)).*;</span>
<span class="line" id="L570">                            <span class="tok-kw">const</span> default_ptr = <span class="tok-kw">switch</span> (fieldPtrInfo.size) {</span>
<span class="line" id="L571">                                .One =&gt; casted_default,</span>
<span class="line" id="L572">                                .Slice =&gt; casted_default.ptr,</span>
<span class="line" id="L573">                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Other pointer types are not parseable</span>
</span>
<span class="line" id="L574">                            };</span>
<span class="line" id="L575">                            <span class="tok-kw">const</span> default_addr = <span class="tok-builtin">@ptrToInt</span>(default_ptr);</span>
<span class="line" id="L576"></span>
<span class="line" id="L577">                            <span class="tok-kw">if</span> (field_addr == default_addr) {</span>
<span class="line" id="L578">                                should_free = <span class="tok-null">false</span>;</span>
<span class="line" id="L579">                            }</span>
<span class="line" id="L580">                        },</span>
<span class="line" id="L581">                        <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L582">                    }</span>
<span class="line" id="L583">                }</span>
<span class="line" id="L584">                <span class="tok-kw">if</span> (should_free) {</span>
<span class="line" id="L585">                    parseFree(field.<span class="tok-type">type</span>, allocator, <span class="tok-builtin">@field</span>(value, field.name));</span>
<span class="line" id="L586">                }</span>
<span class="line" id="L587">            }</span>
<span class="line" id="L588">        },</span>
<span class="line" id="L589">        .Array =&gt; |arrayInfo| {</span>
<span class="line" id="L590">            <span class="tok-kw">for</span> (value) |v| {</span>
<span class="line" id="L591">                parseFree(arrayInfo.child, allocator, v);</span>
<span class="line" id="L592">            }</span>
<span class="line" id="L593">        },</span>
<span class="line" id="L594">        .Vector =&gt; |vecInfo| {</span>
<span class="line" id="L595">            <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L596">            <span class="tok-kw">while</span> (i &lt; vecInfo.len) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L597">                parseFree(vecInfo.child, allocator, value[i]);</span>
<span class="line" id="L598">            }</span>
<span class="line" id="L599">        },</span>
<span class="line" id="L600">        .Pointer =&gt; |ptrInfo| {</span>
<span class="line" id="L601">            <span class="tok-kw">switch</span> (ptrInfo.size) {</span>
<span class="line" id="L602">                .One =&gt; {</span>
<span class="line" id="L603">                    parseFree(ptrInfo.child, allocator, value.*);</span>
<span class="line" id="L604">                    allocator.destroy(value);</span>
<span class="line" id="L605">                },</span>
<span class="line" id="L606">                .Slice =&gt; {</span>
<span class="line" id="L607">                    <span class="tok-kw">for</span> (value) |v| {</span>
<span class="line" id="L608">                        parseFree(ptrInfo.child, allocator, v);</span>
<span class="line" id="L609">                    }</span>
<span class="line" id="L610">                    allocator.free(value);</span>
<span class="line" id="L611">                },</span>
<span class="line" id="L612">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L613">            }</span>
<span class="line" id="L614">        },</span>
<span class="line" id="L615">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L616">    }</span>
<span class="line" id="L617">}</span>
<span class="line" id="L618"></span>
<span class="line" id="L619"><span class="tok-kw">test</span> {</span>
<span class="line" id="L620">    _ = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;./static_test.zig&quot;</span>);</span>
<span class="line" id="L621">}</span>
<span class="line" id="L622"></span>
</code></pre></body>
</html>