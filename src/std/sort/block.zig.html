<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>sort/block.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAPNJREFUeNpi/P//PwMlgOXHUjly9E0G4hwgZmQiQZMqEK8H4v9QzUEgQSaoADK+zhH9iAGL+C0gDoAaNg9mGLoLfgA1awK9hS9gzgJxA9RQBmQDrgMxJzRMGKE4HYj/Ial5A8QmQLwCJoBsgBYW2+TR1ChDaWt4LOBxKsi/VUh8XiD+gq4IVyzwQAMJBoKwacZlAB8Qf0bi96IZhtOAe1D6LpqaEiz6rmEzQAeIzwGxCJpieFqApo/vQKyJboAaEBsAsSEupwI1MwKjGBTVHOhegMX5UajYRqiBjMgYmj400cVh0XgTiKdC0zhJgJHS7AwQYABm9EAdCKrEfAAAAABJRU5ErkJggg=="/>
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;../std.zig&quot;</span>);</span>
<span class="line" id="L2"><span class="tok-kw">const</span> sort = std.sort;</span>
<span class="line" id="L3"><span class="tok-kw">const</span> math = std.math;</span>
<span class="line" id="L4"><span class="tok-kw">const</span> mem = std.mem;</span>
<span class="line" id="L5"></span>
<span class="line" id="L6"><span class="tok-kw">const</span> Range = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L7">    start: <span class="tok-type">usize</span>,</span>
<span class="line" id="L8">    end: <span class="tok-type">usize</span>,</span>
<span class="line" id="L9"></span>
<span class="line" id="L10">    <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(start: <span class="tok-type">usize</span>, end: <span class="tok-type">usize</span>) Range {</span>
<span class="line" id="L11">        <span class="tok-kw">return</span> Range{</span>
<span class="line" id="L12">            .start = start,</span>
<span class="line" id="L13">            .end = end,</span>
<span class="line" id="L14">        };</span>
<span class="line" id="L15">    }</span>
<span class="line" id="L16"></span>
<span class="line" id="L17">    <span class="tok-kw">fn</span> <span class="tok-fn">length</span>(self: Range) <span class="tok-type">usize</span> {</span>
<span class="line" id="L18">        <span class="tok-kw">return</span> self.end - self.start;</span>
<span class="line" id="L19">    }</span>
<span class="line" id="L20">};</span>
<span class="line" id="L21"></span>
<span class="line" id="L22"><span class="tok-kw">const</span> Iterator = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L23">    size: <span class="tok-type">usize</span>,</span>
<span class="line" id="L24">    power_of_two: <span class="tok-type">usize</span>,</span>
<span class="line" id="L25">    numerator: <span class="tok-type">usize</span>,</span>
<span class="line" id="L26">    decimal: <span class="tok-type">usize</span>,</span>
<span class="line" id="L27">    denominator: <span class="tok-type">usize</span>,</span>
<span class="line" id="L28">    decimal_step: <span class="tok-type">usize</span>,</span>
<span class="line" id="L29">    numerator_step: <span class="tok-type">usize</span>,</span>
<span class="line" id="L30"></span>
<span class="line" id="L31">    <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(size2: <span class="tok-type">usize</span>, min_level: <span class="tok-type">usize</span>) Iterator {</span>
<span class="line" id="L32">        <span class="tok-kw">const</span> power_of_two = math.floorPowerOfTwo(<span class="tok-type">usize</span>, size2);</span>
<span class="line" id="L33">        <span class="tok-kw">const</span> denominator = power_of_two / min_level;</span>
<span class="line" id="L34">        <span class="tok-kw">return</span> Iterator{</span>
<span class="line" id="L35">            .numerator = <span class="tok-number">0</span>,</span>
<span class="line" id="L36">            .decimal = <span class="tok-number">0</span>,</span>
<span class="line" id="L37">            .size = size2,</span>
<span class="line" id="L38">            .power_of_two = power_of_two,</span>
<span class="line" id="L39">            .denominator = denominator,</span>
<span class="line" id="L40">            .decimal_step = size2 / denominator,</span>
<span class="line" id="L41">            .numerator_step = size2 % denominator,</span>
<span class="line" id="L42">        };</span>
<span class="line" id="L43">    }</span>
<span class="line" id="L44"></span>
<span class="line" id="L45">    <span class="tok-kw">fn</span> <span class="tok-fn">begin</span>(self: *Iterator) <span class="tok-type">void</span> {</span>
<span class="line" id="L46">        self.numerator = <span class="tok-number">0</span>;</span>
<span class="line" id="L47">        self.decimal = <span class="tok-number">0</span>;</span>
<span class="line" id="L48">    }</span>
<span class="line" id="L49"></span>
<span class="line" id="L50">    <span class="tok-kw">fn</span> <span class="tok-fn">nextRange</span>(self: *Iterator) Range {</span>
<span class="line" id="L51">        <span class="tok-kw">const</span> start = self.decimal;</span>
<span class="line" id="L52"></span>
<span class="line" id="L53">        self.decimal += self.decimal_step;</span>
<span class="line" id="L54">        self.numerator += self.numerator_step;</span>
<span class="line" id="L55">        <span class="tok-kw">if</span> (self.numerator &gt;= self.denominator) {</span>
<span class="line" id="L56">            self.numerator -= self.denominator;</span>
<span class="line" id="L57">            self.decimal += <span class="tok-number">1</span>;</span>
<span class="line" id="L58">        }</span>
<span class="line" id="L59"></span>
<span class="line" id="L60">        <span class="tok-kw">return</span> Range{</span>
<span class="line" id="L61">            .start = start,</span>
<span class="line" id="L62">            .end = self.decimal,</span>
<span class="line" id="L63">        };</span>
<span class="line" id="L64">    }</span>
<span class="line" id="L65"></span>
<span class="line" id="L66">    <span class="tok-kw">fn</span> <span class="tok-fn">finished</span>(self: *Iterator) <span class="tok-type">bool</span> {</span>
<span class="line" id="L67">        <span class="tok-kw">return</span> self.decimal &gt;= self.size;</span>
<span class="line" id="L68">    }</span>
<span class="line" id="L69"></span>
<span class="line" id="L70">    <span class="tok-kw">fn</span> <span class="tok-fn">nextLevel</span>(self: *Iterator) <span class="tok-type">bool</span> {</span>
<span class="line" id="L71">        self.decimal_step += self.decimal_step;</span>
<span class="line" id="L72">        self.numerator_step += self.numerator_step;</span>
<span class="line" id="L73">        <span class="tok-kw">if</span> (self.numerator_step &gt;= self.denominator) {</span>
<span class="line" id="L74">            self.numerator_step -= self.denominator;</span>
<span class="line" id="L75">            self.decimal_step += <span class="tok-number">1</span>;</span>
<span class="line" id="L76">        }</span>
<span class="line" id="L77"></span>
<span class="line" id="L78">        <span class="tok-kw">return</span> (self.decimal_step &lt; self.size);</span>
<span class="line" id="L79">    }</span>
<span class="line" id="L80"></span>
<span class="line" id="L81">    <span class="tok-kw">fn</span> <span class="tok-fn">length</span>(self: *Iterator) <span class="tok-type">usize</span> {</span>
<span class="line" id="L82">        <span class="tok-kw">return</span> self.decimal_step;</span>
<span class="line" id="L83">    }</span>
<span class="line" id="L84">};</span>
<span class="line" id="L85"></span>
<span class="line" id="L86"><span class="tok-kw">const</span> Pull = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L87">    from: <span class="tok-type">usize</span>,</span>
<span class="line" id="L88">    to: <span class="tok-type">usize</span>,</span>
<span class="line" id="L89">    count: <span class="tok-type">usize</span>,</span>
<span class="line" id="L90">    range: Range,</span>
<span class="line" id="L91">};</span>
<span class="line" id="L92"></span>
<span class="line" id="L93"><span class="tok-comment">/// Stable in-place sort. O(n) best case, O(n*log(n)) worst case and average case.</span></span>
<span class="line" id="L94"><span class="tok-comment">/// O(1) memory (no allocator required).</span></span>
<span class="line" id="L95"><span class="tok-comment">/// Sorts in ascending order with respect to the given `lessThan` function.</span></span>
<span class="line" id="L96"><span class="tok-comment">///</span></span>
<span class="line" id="L97"><span class="tok-comment">/// NOTE: the algorithm only work when the comparison is less-than or greater-than</span></span>
<span class="line" id="L98"><span class="tok-comment">///       (See https://github.com/ziglang/zig/issues/8289)</span></span>
<span class="line" id="L99"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">block</span>(</span>
<span class="line" id="L100">    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,</span>
<span class="line" id="L101">    items: []T,</span>
<span class="line" id="L102">    context: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L103">    <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,</span>
<span class="line" id="L104">) <span class="tok-type">void</span> {</span>
<span class="line" id="L105"></span>
<span class="line" id="L106">    <span class="tok-comment">// Implementation ported from https://github.com/BonzaiThePenguin/WikiSort/blob/master/WikiSort.c</span>
</span>
<span class="line" id="L107">    <span class="tok-kw">var</span> cache: [<span class="tok-number">512</span>]T = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L108"></span>
<span class="line" id="L109">    <span class="tok-kw">if</span> (items.len &lt; <span class="tok-number">4</span>) {</span>
<span class="line" id="L110">        <span class="tok-kw">if</span> (items.len == <span class="tok-number">3</span>) {</span>
<span class="line" id="L111">            <span class="tok-comment">// hard coded insertion sort</span>
</span>
<span class="line" id="L112">            <span class="tok-kw">if</span> (lessThan(context, items[<span class="tok-number">1</span>], items[<span class="tok-number">0</span>])) mem.swap(T, &amp;items[<span class="tok-number">0</span>], &amp;items[<span class="tok-number">1</span>]);</span>
<span class="line" id="L113">            <span class="tok-kw">if</span> (lessThan(context, items[<span class="tok-number">2</span>], items[<span class="tok-number">1</span>])) {</span>
<span class="line" id="L114">                mem.swap(T, &amp;items[<span class="tok-number">1</span>], &amp;items[<span class="tok-number">2</span>]);</span>
<span class="line" id="L115">                <span class="tok-kw">if</span> (lessThan(context, items[<span class="tok-number">1</span>], items[<span class="tok-number">0</span>])) mem.swap(T, &amp;items[<span class="tok-number">0</span>], &amp;items[<span class="tok-number">1</span>]);</span>
<span class="line" id="L116">            }</span>
<span class="line" id="L117">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (items.len == <span class="tok-number">2</span>) {</span>
<span class="line" id="L118">            <span class="tok-kw">if</span> (lessThan(context, items[<span class="tok-number">1</span>], items[<span class="tok-number">0</span>])) mem.swap(T, &amp;items[<span class="tok-number">0</span>], &amp;items[<span class="tok-number">1</span>]);</span>
<span class="line" id="L119">        }</span>
<span class="line" id="L120">        <span class="tok-kw">return</span>;</span>
<span class="line" id="L121">    }</span>
<span class="line" id="L122"></span>
<span class="line" id="L123">    <span class="tok-comment">// sort groups of 4-8 items at a time using an unstable sorting network,</span>
</span>
<span class="line" id="L124">    <span class="tok-comment">// but keep track of the original item orders to force it to be stable</span>
</span>
<span class="line" id="L125">    <span class="tok-comment">// http://pages.ripco.net/~jgamble/nw.html</span>
</span>
<span class="line" id="L126">    <span class="tok-kw">var</span> iterator = Iterator.init(items.len, <span class="tok-number">4</span>);</span>
<span class="line" id="L127">    <span class="tok-kw">while</span> (!iterator.finished()) {</span>
<span class="line" id="L128">        <span class="tok-kw">var</span> order = [_]<span class="tok-type">u8</span>{ <span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span> };</span>
<span class="line" id="L129">        <span class="tok-kw">const</span> range = iterator.nextRange();</span>
<span class="line" id="L130"></span>
<span class="line" id="L131">        <span class="tok-kw">const</span> sliced_items = items[range.start..];</span>
<span class="line" id="L132">        <span class="tok-kw">switch</span> (range.length()) {</span>
<span class="line" id="L133">            <span class="tok-number">8</span> =&gt; {</span>
<span class="line" id="L134">                swap(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">1</span>, context, lessThan);</span>
<span class="line" id="L135">                swap(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">3</span>, context, lessThan);</span>
<span class="line" id="L136">                swap(T, sliced_items, &amp;order, <span class="tok-number">4</span>, <span class="tok-number">5</span>, context, lessThan);</span>
<span class="line" id="L137">                swap(T, sliced_items, &amp;order, <span class="tok-number">6</span>, <span class="tok-number">7</span>, context, lessThan);</span>
<span class="line" id="L138">                swap(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">2</span>, context, lessThan);</span>
<span class="line" id="L139">                swap(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">3</span>, context, lessThan);</span>
<span class="line" id="L140">                swap(T, sliced_items, &amp;order, <span class="tok-number">4</span>, <span class="tok-number">6</span>, context, lessThan);</span>
<span class="line" id="L141">                swap(T, sliced_items, &amp;order, <span class="tok-number">5</span>, <span class="tok-number">7</span>, context, lessThan);</span>
<span class="line" id="L142">                swap(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">2</span>, context, lessThan);</span>
<span class="line" id="L143">                swap(T, sliced_items, &amp;order, <span class="tok-number">5</span>, <span class="tok-number">6</span>, context, lessThan);</span>
<span class="line" id="L144">                swap(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">4</span>, context, lessThan);</span>
<span class="line" id="L145">                swap(T, sliced_items, &amp;order, <span class="tok-number">3</span>, <span class="tok-number">7</span>, context, lessThan);</span>
<span class="line" id="L146">                swap(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">5</span>, context, lessThan);</span>
<span class="line" id="L147">                swap(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">6</span>, context, lessThan);</span>
<span class="line" id="L148">                swap(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">4</span>, context, lessThan);</span>
<span class="line" id="L149">                swap(T, sliced_items, &amp;order, <span class="tok-number">3</span>, <span class="tok-number">6</span>, context, lessThan);</span>
<span class="line" id="L150">                swap(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">4</span>, context, lessThan);</span>
<span class="line" id="L151">                swap(T, sliced_items, &amp;order, <span class="tok-number">3</span>, <span class="tok-number">5</span>, context, lessThan);</span>
<span class="line" id="L152">                swap(T, sliced_items, &amp;order, <span class="tok-number">3</span>, <span class="tok-number">4</span>, context, lessThan);</span>
<span class="line" id="L153">            },</span>
<span class="line" id="L154">            <span class="tok-number">7</span> =&gt; {</span>
<span class="line" id="L155">                swap(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">2</span>, context, lessThan);</span>
<span class="line" id="L156">                swap(T, sliced_items, &amp;order, <span class="tok-number">3</span>, <span class="tok-number">4</span>, context, lessThan);</span>
<span class="line" id="L157">                swap(T, sliced_items, &amp;order, <span class="tok-number">5</span>, <span class="tok-number">6</span>, context, lessThan);</span>
<span class="line" id="L158">                swap(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">2</span>, context, lessThan);</span>
<span class="line" id="L159">                swap(T, sliced_items, &amp;order, <span class="tok-number">3</span>, <span class="tok-number">5</span>, context, lessThan);</span>
<span class="line" id="L160">                swap(T, sliced_items, &amp;order, <span class="tok-number">4</span>, <span class="tok-number">6</span>, context, lessThan);</span>
<span class="line" id="L161">                swap(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">1</span>, context, lessThan);</span>
<span class="line" id="L162">                swap(T, sliced_items, &amp;order, <span class="tok-number">4</span>, <span class="tok-number">5</span>, context, lessThan);</span>
<span class="line" id="L163">                swap(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">6</span>, context, lessThan);</span>
<span class="line" id="L164">                swap(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">4</span>, context, lessThan);</span>
<span class="line" id="L165">                swap(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">5</span>, context, lessThan);</span>
<span class="line" id="L166">                swap(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">3</span>, context, lessThan);</span>
<span class="line" id="L167">                swap(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">5</span>, context, lessThan);</span>
<span class="line" id="L168">                swap(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">3</span>, context, lessThan);</span>
<span class="line" id="L169">                swap(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">4</span>, context, lessThan);</span>
<span class="line" id="L170">                swap(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">3</span>, context, lessThan);</span>
<span class="line" id="L171">            },</span>
<span class="line" id="L172">            <span class="tok-number">6</span> =&gt; {</span>
<span class="line" id="L173">                swap(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">2</span>, context, lessThan);</span>
<span class="line" id="L174">                swap(T, sliced_items, &amp;order, <span class="tok-number">4</span>, <span class="tok-number">5</span>, context, lessThan);</span>
<span class="line" id="L175">                swap(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">2</span>, context, lessThan);</span>
<span class="line" id="L176">                swap(T, sliced_items, &amp;order, <span class="tok-number">3</span>, <span class="tok-number">5</span>, context, lessThan);</span>
<span class="line" id="L177">                swap(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">1</span>, context, lessThan);</span>
<span class="line" id="L178">                swap(T, sliced_items, &amp;order, <span class="tok-number">3</span>, <span class="tok-number">4</span>, context, lessThan);</span>
<span class="line" id="L179">                swap(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">5</span>, context, lessThan);</span>
<span class="line" id="L180">                swap(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">3</span>, context, lessThan);</span>
<span class="line" id="L181">                swap(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">4</span>, context, lessThan);</span>
<span class="line" id="L182">                swap(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">4</span>, context, lessThan);</span>
<span class="line" id="L183">                swap(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">3</span>, context, lessThan);</span>
<span class="line" id="L184">                swap(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">3</span>, context, lessThan);</span>
<span class="line" id="L185">            },</span>
<span class="line" id="L186">            <span class="tok-number">5</span> =&gt; {</span>
<span class="line" id="L187">                swap(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">1</span>, context, lessThan);</span>
<span class="line" id="L188">                swap(T, sliced_items, &amp;order, <span class="tok-number">3</span>, <span class="tok-number">4</span>, context, lessThan);</span>
<span class="line" id="L189">                swap(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">4</span>, context, lessThan);</span>
<span class="line" id="L190">                swap(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">3</span>, context, lessThan);</span>
<span class="line" id="L191">                swap(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">4</span>, context, lessThan);</span>
<span class="line" id="L192">                swap(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">3</span>, context, lessThan);</span>
<span class="line" id="L193">                swap(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">2</span>, context, lessThan);</span>
<span class="line" id="L194">                swap(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">3</span>, context, lessThan);</span>
<span class="line" id="L195">                swap(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">2</span>, context, lessThan);</span>
<span class="line" id="L196">            },</span>
<span class="line" id="L197">            <span class="tok-number">4</span> =&gt; {</span>
<span class="line" id="L198">                swap(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">1</span>, context, lessThan);</span>
<span class="line" id="L199">                swap(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">3</span>, context, lessThan);</span>
<span class="line" id="L200">                swap(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">2</span>, context, lessThan);</span>
<span class="line" id="L201">                swap(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">3</span>, context, lessThan);</span>
<span class="line" id="L202">                swap(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">2</span>, context, lessThan);</span>
<span class="line" id="L203">            },</span>
<span class="line" id="L204">            <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L205">        }</span>
<span class="line" id="L206">    }</span>
<span class="line" id="L207">    <span class="tok-kw">if</span> (items.len &lt; <span class="tok-number">8</span>) <span class="tok-kw">return</span>;</span>
<span class="line" id="L208"></span>
<span class="line" id="L209">    <span class="tok-comment">// then merge sort the higher levels, which can be 8-15, 16-31, 32-63, 64-127, etc.</span>
</span>
<span class="line" id="L210">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L211">        <span class="tok-comment">// if every A and B block will fit into the cache, use a special branch</span>
</span>
<span class="line" id="L212">        <span class="tok-comment">// specifically for merging with the cache</span>
</span>
<span class="line" id="L213">        <span class="tok-comment">// (we use &lt; rather than &lt;= since the block size might be one more than</span>
</span>
<span class="line" id="L214">        <span class="tok-comment">// iterator.length())</span>
</span>
<span class="line" id="L215">        <span class="tok-kw">if</span> (iterator.length() &lt; cache.len) {</span>
<span class="line" id="L216">            <span class="tok-comment">// if four subarrays fit into the cache, it's faster to merge both</span>
</span>
<span class="line" id="L217">            <span class="tok-comment">// pairs of subarrays into the cache,</span>
</span>
<span class="line" id="L218">            <span class="tok-comment">// then merge the two merged subarrays from the cache back into the original array</span>
</span>
<span class="line" id="L219">            <span class="tok-kw">if</span> ((iterator.length() + <span class="tok-number">1</span>) * <span class="tok-number">4</span> &lt;= cache.len <span class="tok-kw">and</span> iterator.length() * <span class="tok-number">4</span> &lt;= items.len) {</span>
<span class="line" id="L220">                iterator.begin();</span>
<span class="line" id="L221">                <span class="tok-kw">while</span> (!iterator.finished()) {</span>
<span class="line" id="L222">                    <span class="tok-comment">// merge A1 and B1 into the cache</span>
</span>
<span class="line" id="L223">                    <span class="tok-kw">var</span> A1 = iterator.nextRange();</span>
<span class="line" id="L224">                    <span class="tok-kw">var</span> B1 = iterator.nextRange();</span>
<span class="line" id="L225">                    <span class="tok-kw">var</span> A2 = iterator.nextRange();</span>
<span class="line" id="L226">                    <span class="tok-kw">var</span> B2 = iterator.nextRange();</span>
<span class="line" id="L227"></span>
<span class="line" id="L228">                    <span class="tok-kw">if</span> (lessThan(context, items[B1.end - <span class="tok-number">1</span>], items[A1.start])) {</span>
<span class="line" id="L229">                        <span class="tok-comment">// the two ranges are in reverse order, so copy them in reverse order into the cache</span>
</span>
<span class="line" id="L230">                        <span class="tok-kw">const</span> a1_items = items[A1.start..A1.end];</span>
<span class="line" id="L231">                        <span class="tok-builtin">@memcpy</span>(cache[B1.length()..][<span class="tok-number">0</span>..a1_items.len], a1_items);</span>
<span class="line" id="L232">                        <span class="tok-kw">const</span> b1_items = items[B1.start..B1.end];</span>
<span class="line" id="L233">                        <span class="tok-builtin">@memcpy</span>(cache[<span class="tok-number">0</span>..b1_items.len], b1_items);</span>
<span class="line" id="L234">                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (lessThan(context, items[B1.start], items[A1.end - <span class="tok-number">1</span>])) {</span>
<span class="line" id="L235">                        <span class="tok-comment">// these two ranges weren't already in order, so merge them into the cache</span>
</span>
<span class="line" id="L236">                        mergeInto(T, items, A1, B1, cache[<span class="tok-number">0</span>..], context, lessThan);</span>
<span class="line" id="L237">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L238">                        <span class="tok-comment">// if A1, B1, A2, and B2 are all in order, skip doing anything else</span>
</span>
<span class="line" id="L239">                        <span class="tok-kw">if</span> (!lessThan(context, items[B2.start], items[A2.end - <span class="tok-number">1</span>]) <span class="tok-kw">and</span> !lessThan(context, items[A2.start], items[B1.end - <span class="tok-number">1</span>])) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L240"></span>
<span class="line" id="L241">                        <span class="tok-comment">// copy A1 and B1 into the cache in the same order</span>
</span>
<span class="line" id="L242">                        <span class="tok-kw">const</span> a1_items = items[A1.start..A1.end];</span>
<span class="line" id="L243">                        <span class="tok-builtin">@memcpy</span>(cache[<span class="tok-number">0</span>..a1_items.len], a1_items);</span>
<span class="line" id="L244">                        <span class="tok-kw">const</span> b1_items = items[B1.start..B1.end];</span>
<span class="line" id="L245">                        <span class="tok-builtin">@memcpy</span>(cache[A1.length()..][<span class="tok-number">0</span>..b1_items.len], b1_items);</span>
<span class="line" id="L246">                    }</span>
<span class="line" id="L247">                    A1 = Range.init(A1.start, B1.end);</span>
<span class="line" id="L248"></span>
<span class="line" id="L249">                    <span class="tok-comment">// merge A2 and B2 into the cache</span>
</span>
<span class="line" id="L250">                    <span class="tok-kw">if</span> (lessThan(context, items[B2.end - <span class="tok-number">1</span>], items[A2.start])) {</span>
<span class="line" id="L251">                        <span class="tok-comment">// the two ranges are in reverse order, so copy them in reverse order into the cache</span>
</span>
<span class="line" id="L252">                        <span class="tok-kw">const</span> a2_items = items[A2.start..A2.end];</span>
<span class="line" id="L253">                        <span class="tok-builtin">@memcpy</span>(cache[A1.length() + B2.length() ..][<span class="tok-number">0</span>..a2_items.len], a2_items);</span>
<span class="line" id="L254">                        <span class="tok-kw">const</span> b2_items = items[B2.start..B2.end];</span>
<span class="line" id="L255">                        <span class="tok-builtin">@memcpy</span>(cache[A1.length()..][<span class="tok-number">0</span>..b2_items.len], b2_items);</span>
<span class="line" id="L256">                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (lessThan(context, items[B2.start], items[A2.end - <span class="tok-number">1</span>])) {</span>
<span class="line" id="L257">                        <span class="tok-comment">// these two ranges weren't already in order, so merge them into the cache</span>
</span>
<span class="line" id="L258">                        mergeInto(T, items, A2, B2, cache[A1.length()..], context, lessThan);</span>
<span class="line" id="L259">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L260">                        <span class="tok-comment">// copy A2 and B2 into the cache in the same order</span>
</span>
<span class="line" id="L261">                        <span class="tok-kw">const</span> a2_items = items[A2.start..A2.end];</span>
<span class="line" id="L262">                        <span class="tok-builtin">@memcpy</span>(cache[A1.length()..][<span class="tok-number">0</span>..a2_items.len], a2_items);</span>
<span class="line" id="L263">                        <span class="tok-kw">const</span> b2_items = items[B2.start..B2.end];</span>
<span class="line" id="L264">                        <span class="tok-builtin">@memcpy</span>(cache[A1.length() + A2.length() ..][<span class="tok-number">0</span>..b2_items.len], b2_items);</span>
<span class="line" id="L265">                    }</span>
<span class="line" id="L266">                    A2 = Range.init(A2.start, B2.end);</span>
<span class="line" id="L267"></span>
<span class="line" id="L268">                    <span class="tok-comment">// merge A1 and A2 from the cache into the items</span>
</span>
<span class="line" id="L269">                    <span class="tok-kw">const</span> A3 = Range.init(<span class="tok-number">0</span>, A1.length());</span>
<span class="line" id="L270">                    <span class="tok-kw">const</span> B3 = Range.init(A1.length(), A1.length() + A2.length());</span>
<span class="line" id="L271"></span>
<span class="line" id="L272">                    <span class="tok-kw">if</span> (lessThan(context, cache[B3.end - <span class="tok-number">1</span>], cache[A3.start])) {</span>
<span class="line" id="L273">                        <span class="tok-comment">// the two ranges are in reverse order, so copy them in reverse order into the items</span>
</span>
<span class="line" id="L274">                        <span class="tok-kw">const</span> a3_items = cache[A3.start..A3.end];</span>
<span class="line" id="L275">                        <span class="tok-builtin">@memcpy</span>(items[A1.start + A2.length() ..][<span class="tok-number">0</span>..a3_items.len], a3_items);</span>
<span class="line" id="L276">                        <span class="tok-kw">const</span> b3_items = cache[B3.start..B3.end];</span>
<span class="line" id="L277">                        <span class="tok-builtin">@memcpy</span>(items[A1.start..][<span class="tok-number">0</span>..b3_items.len], b3_items);</span>
<span class="line" id="L278">                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (lessThan(context, cache[B3.start], cache[A3.end - <span class="tok-number">1</span>])) {</span>
<span class="line" id="L279">                        <span class="tok-comment">// these two ranges weren't already in order, so merge them back into the items</span>
</span>
<span class="line" id="L280">                        mergeInto(T, cache[<span class="tok-number">0</span>..], A3, B3, items[A1.start..], context, lessThan);</span>
<span class="line" id="L281">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L282">                        <span class="tok-comment">// copy A3 and B3 into the items in the same order</span>
</span>
<span class="line" id="L283">                        <span class="tok-kw">const</span> a3_items = cache[A3.start..A3.end];</span>
<span class="line" id="L284">                        <span class="tok-builtin">@memcpy</span>(items[A1.start..][<span class="tok-number">0</span>..a3_items.len], a3_items);</span>
<span class="line" id="L285">                        <span class="tok-kw">const</span> b3_items = cache[B3.start..B3.end];</span>
<span class="line" id="L286">                        <span class="tok-builtin">@memcpy</span>(items[A1.start + A1.length() ..][<span class="tok-number">0</span>..b3_items.len], b3_items);</span>
<span class="line" id="L287">                    }</span>
<span class="line" id="L288">                }</span>
<span class="line" id="L289"></span>
<span class="line" id="L290">                <span class="tok-comment">// we merged two levels at the same time, so we're done with this level already</span>
</span>
<span class="line" id="L291">                <span class="tok-comment">// (iterator.nextLevel() is called again at the bottom of this outer merge loop)</span>
</span>
<span class="line" id="L292">                _ = iterator.nextLevel();</span>
<span class="line" id="L293">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L294">                iterator.begin();</span>
<span class="line" id="L295">                <span class="tok-kw">while</span> (!iterator.finished()) {</span>
<span class="line" id="L296">                    <span class="tok-kw">var</span> A = iterator.nextRange();</span>
<span class="line" id="L297">                    <span class="tok-kw">var</span> B = iterator.nextRange();</span>
<span class="line" id="L298"></span>
<span class="line" id="L299">                    <span class="tok-kw">if</span> (lessThan(context, items[B.end - <span class="tok-number">1</span>], items[A.start])) {</span>
<span class="line" id="L300">                        <span class="tok-comment">// the two ranges are in reverse order, so a simple rotation should fix it</span>
</span>
<span class="line" id="L301">                        mem.rotate(T, items[A.start..B.end], A.length());</span>
<span class="line" id="L302">                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (lessThan(context, items[B.start], items[A.end - <span class="tok-number">1</span>])) {</span>
<span class="line" id="L303">                        <span class="tok-comment">// these two ranges weren't already in order, so we'll need to merge them!</span>
</span>
<span class="line" id="L304">                        <span class="tok-kw">const</span> a_items = items[A.start..A.end];</span>
<span class="line" id="L305">                        <span class="tok-builtin">@memcpy</span>(cache[<span class="tok-number">0</span>..a_items.len], a_items);</span>
<span class="line" id="L306">                        mergeExternal(T, items, A, B, cache[<span class="tok-number">0</span>..], context, lessThan);</span>
<span class="line" id="L307">                    }</span>
<span class="line" id="L308">                }</span>
<span class="line" id="L309">            }</span>
<span class="line" id="L310">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L311">            <span class="tok-comment">// this is where the in-place merge logic starts!</span>
</span>
<span class="line" id="L312">            <span class="tok-comment">// 1. pull out two internal buffers each containing √A unique values</span>
</span>
<span class="line" id="L313">            <span class="tok-comment">//    1a. adjust block_size and buffer_size if we couldn't find enough unique values</span>
</span>
<span class="line" id="L314">            <span class="tok-comment">// 2. loop over the A and B subarrays within this level of the merge sort</span>
</span>
<span class="line" id="L315">            <span class="tok-comment">// 3. break A and B into blocks of size 'block_size'</span>
</span>
<span class="line" id="L316">            <span class="tok-comment">// 4. &quot;tag&quot; each of the A blocks with values from the first internal buffer</span>
</span>
<span class="line" id="L317">            <span class="tok-comment">// 5. roll the A blocks through the B blocks and drop/rotate them where they belong</span>
</span>
<span class="line" id="L318">            <span class="tok-comment">// 6. merge each A block with any B values that follow, using the cache or the second internal buffer</span>
</span>
<span class="line" id="L319">            <span class="tok-comment">// 7. sort the second internal buffer if it exists</span>
</span>
<span class="line" id="L320">            <span class="tok-comment">// 8. redistribute the two internal buffers back into the items</span>
</span>
<span class="line" id="L321">            <span class="tok-kw">var</span> block_size: <span class="tok-type">usize</span> = math.sqrt(iterator.length());</span>
<span class="line" id="L322">            <span class="tok-kw">var</span> buffer_size = iterator.length() / block_size + <span class="tok-number">1</span>;</span>
<span class="line" id="L323"></span>
<span class="line" id="L324">            <span class="tok-comment">// as an optimization, we really only need to pull out the internal buffers once for each level of merges</span>
</span>
<span class="line" id="L325">            <span class="tok-comment">// after that we can reuse the same buffers over and over, then redistribute it when we're finished with this level</span>
</span>
<span class="line" id="L326">            <span class="tok-kw">var</span> A: Range = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L327">            <span class="tok-kw">var</span> B: Range = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L328">            <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L329">            <span class="tok-kw">var</span> last: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L330">            <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L331">            <span class="tok-kw">var</span> find: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L332">            <span class="tok-kw">var</span> start: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L333">            <span class="tok-kw">var</span> pull_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L334">            <span class="tok-kw">var</span> pull = [_]Pull{</span>
<span class="line" id="L335">                Pull{</span>
<span class="line" id="L336">                    .from = <span class="tok-number">0</span>,</span>
<span class="line" id="L337">                    .to = <span class="tok-number">0</span>,</span>
<span class="line" id="L338">                    .count = <span class="tok-number">0</span>,</span>
<span class="line" id="L339">                    .range = Range.init(<span class="tok-number">0</span>, <span class="tok-number">0</span>),</span>
<span class="line" id="L340">                },</span>
<span class="line" id="L341">                Pull{</span>
<span class="line" id="L342">                    .from = <span class="tok-number">0</span>,</span>
<span class="line" id="L343">                    .to = <span class="tok-number">0</span>,</span>
<span class="line" id="L344">                    .count = <span class="tok-number">0</span>,</span>
<span class="line" id="L345">                    .range = Range.init(<span class="tok-number">0</span>, <span class="tok-number">0</span>),</span>
<span class="line" id="L346">                },</span>
<span class="line" id="L347">            };</span>
<span class="line" id="L348"></span>
<span class="line" id="L349">            <span class="tok-kw">var</span> buffer1 = Range.init(<span class="tok-number">0</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L350">            <span class="tok-kw">var</span> buffer2 = Range.init(<span class="tok-number">0</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L351"></span>
<span class="line" id="L352">            <span class="tok-comment">// find two internal buffers of size 'buffer_size' each</span>
</span>
<span class="line" id="L353">            find = buffer_size + buffer_size;</span>
<span class="line" id="L354">            <span class="tok-kw">var</span> find_separately = <span class="tok-null">false</span>;</span>
<span class="line" id="L355"></span>
<span class="line" id="L356">            <span class="tok-kw">if</span> (block_size &lt;= cache.len) {</span>
<span class="line" id="L357">                <span class="tok-comment">// if every A block fits into the cache then we won't need the second internal buffer,</span>
</span>
<span class="line" id="L358">                <span class="tok-comment">// so we really only need to find 'buffer_size' unique values</span>
</span>
<span class="line" id="L359">                find = buffer_size;</span>
<span class="line" id="L360">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (find &gt; iterator.length()) {</span>
<span class="line" id="L361">                <span class="tok-comment">// we can't fit both buffers into the same A or B subarray, so find two buffers separately</span>
</span>
<span class="line" id="L362">                find = buffer_size;</span>
<span class="line" id="L363">                find_separately = <span class="tok-null">true</span>;</span>
<span class="line" id="L364">            }</span>
<span class="line" id="L365"></span>
<span class="line" id="L366">            <span class="tok-comment">// we need to find either a single contiguous space containing 2√A unique values (which will be split up into two buffers of size √A each),</span>
</span>
<span class="line" id="L367">            <span class="tok-comment">// or we need to find one buffer of &lt; 2√A unique values, and a second buffer of √A unique values,</span>
</span>
<span class="line" id="L368">            <span class="tok-comment">// OR if we couldn't find that many unique values, we need the largest possible buffer we can get</span>
</span>
<span class="line" id="L369"></span>
<span class="line" id="L370">            <span class="tok-comment">// in the case where it couldn't find a single buffer of at least √A unique values,</span>
</span>
<span class="line" id="L371">            <span class="tok-comment">// all of the Merge steps must be replaced by a different merge algorithm (MergeInPlace)</span>
</span>
<span class="line" id="L372">            iterator.begin();</span>
<span class="line" id="L373">            <span class="tok-kw">while</span> (!iterator.finished()) {</span>
<span class="line" id="L374">                A = iterator.nextRange();</span>
<span class="line" id="L375">                B = iterator.nextRange();</span>
<span class="line" id="L376"></span>
<span class="line" id="L377">                <span class="tok-comment">// just store information about where the values will be pulled from and to,</span>
</span>
<span class="line" id="L378">                <span class="tok-comment">// as well as how many values there are, to create the two internal buffers</span>
</span>
<span class="line" id="L379"></span>
<span class="line" id="L380">                <span class="tok-comment">// check A for the number of unique values we need to fill an internal buffer</span>
</span>
<span class="line" id="L381">                <span class="tok-comment">// these values will be pulled out to the start of A</span>
</span>
<span class="line" id="L382">                last = A.start;</span>
<span class="line" id="L383">                count = <span class="tok-number">1</span>;</span>
<span class="line" id="L384">                <span class="tok-kw">while</span> (count &lt; find) : ({</span>
<span class="line" id="L385">                    last = index;</span>
<span class="line" id="L386">                    count += <span class="tok-number">1</span>;</span>
<span class="line" id="L387">                }) {</span>
<span class="line" id="L388">                    index = findLastForward(T, items, items[last], Range.init(last + <span class="tok-number">1</span>, A.end), find - count, context, lessThan);</span>
<span class="line" id="L389">                    <span class="tok-kw">if</span> (index == A.end) <span class="tok-kw">break</span>;</span>
<span class="line" id="L390">                }</span>
<span class="line" id="L391">                index = last;</span>
<span class="line" id="L392"></span>
<span class="line" id="L393">                <span class="tok-kw">if</span> (count &gt;= buffer_size) {</span>
<span class="line" id="L394">                    <span class="tok-comment">// keep track of the range within the items where we'll need to &quot;pull out&quot; these values to create the internal buffer</span>
</span>
<span class="line" id="L395">                    pull[pull_index] = Pull{</span>
<span class="line" id="L396">                        .range = Range.init(A.start, B.end),</span>
<span class="line" id="L397">                        .count = count,</span>
<span class="line" id="L398">                        .from = index,</span>
<span class="line" id="L399">                        .to = A.start,</span>
<span class="line" id="L400">                    };</span>
<span class="line" id="L401">                    pull_index = <span class="tok-number">1</span>;</span>
<span class="line" id="L402"></span>
<span class="line" id="L403">                    <span class="tok-kw">if</span> (count == buffer_size + buffer_size) {</span>
<span class="line" id="L404">                        <span class="tok-comment">// we were able to find a single contiguous section containing 2√A unique values,</span>
</span>
<span class="line" id="L405">                        <span class="tok-comment">// so this section can be used to contain both of the internal buffers we'll need</span>
</span>
<span class="line" id="L406">                        buffer1 = Range.init(A.start, A.start + buffer_size);</span>
<span class="line" id="L407">                        buffer2 = Range.init(A.start + buffer_size, A.start + count);</span>
<span class="line" id="L408">                        <span class="tok-kw">break</span>;</span>
<span class="line" id="L409">                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (find == buffer_size + buffer_size) {</span>
<span class="line" id="L410">                        <span class="tok-comment">// we found a buffer that contains at least √A unique values, but did not contain the full 2√A unique values,</span>
</span>
<span class="line" id="L411">                        <span class="tok-comment">// so we still need to find a second separate buffer of at least √A unique values</span>
</span>
<span class="line" id="L412">                        buffer1 = Range.init(A.start, A.start + count);</span>
<span class="line" id="L413">                        find = buffer_size;</span>
<span class="line" id="L414">                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (block_size &lt;= cache.len) {</span>
<span class="line" id="L415">                        <span class="tok-comment">// we found the first and only internal buffer that we need, so we're done!</span>
</span>
<span class="line" id="L416">                        buffer1 = Range.init(A.start, A.start + count);</span>
<span class="line" id="L417">                        <span class="tok-kw">break</span>;</span>
<span class="line" id="L418">                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (find_separately) {</span>
<span class="line" id="L419">                        <span class="tok-comment">// found one buffer, but now find the other one</span>
</span>
<span class="line" id="L420">                        buffer1 = Range.init(A.start, A.start + count);</span>
<span class="line" id="L421">                        find_separately = <span class="tok-null">false</span>;</span>
<span class="line" id="L422">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L423">                        <span class="tok-comment">// we found a second buffer in an 'A' subarray containing √A unique values, so we're done!</span>
</span>
<span class="line" id="L424">                        buffer2 = Range.init(A.start, A.start + count);</span>
<span class="line" id="L425">                        <span class="tok-kw">break</span>;</span>
<span class="line" id="L426">                    }</span>
<span class="line" id="L427">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (pull_index == <span class="tok-number">0</span> <span class="tok-kw">and</span> count &gt; buffer1.length()) {</span>
<span class="line" id="L428">                    <span class="tok-comment">// keep track of the largest buffer we were able to find</span>
</span>
<span class="line" id="L429">                    buffer1 = Range.init(A.start, A.start + count);</span>
<span class="line" id="L430">                    pull[pull_index] = Pull{</span>
<span class="line" id="L431">                        .range = Range.init(A.start, B.end),</span>
<span class="line" id="L432">                        .count = count,</span>
<span class="line" id="L433">                        .from = index,</span>
<span class="line" id="L434">                        .to = A.start,</span>
<span class="line" id="L435">                    };</span>
<span class="line" id="L436">                }</span>
<span class="line" id="L437"></span>
<span class="line" id="L438">                <span class="tok-comment">// check B for the number of unique values we need to fill an internal buffer</span>
</span>
<span class="line" id="L439">                <span class="tok-comment">// these values will be pulled out to the end of B</span>
</span>
<span class="line" id="L440">                last = B.end - <span class="tok-number">1</span>;</span>
<span class="line" id="L441">                count = <span class="tok-number">1</span>;</span>
<span class="line" id="L442">                <span class="tok-kw">while</span> (count &lt; find) : ({</span>
<span class="line" id="L443">                    last = index - <span class="tok-number">1</span>;</span>
<span class="line" id="L444">                    count += <span class="tok-number">1</span>;</span>
<span class="line" id="L445">                }) {</span>
<span class="line" id="L446">                    index = findFirstBackward(T, items, items[last], Range.init(B.start, last), find - count, context, lessThan);</span>
<span class="line" id="L447">                    <span class="tok-kw">if</span> (index == B.start) <span class="tok-kw">break</span>;</span>
<span class="line" id="L448">                }</span>
<span class="line" id="L449">                index = last;</span>
<span class="line" id="L450"></span>
<span class="line" id="L451">                <span class="tok-kw">if</span> (count &gt;= buffer_size) {</span>
<span class="line" id="L452">                    <span class="tok-comment">// keep track of the range within the items where we'll need to &quot;pull out&quot; these values to create the internal buffe</span>
</span>
<span class="line" id="L453">                    pull[pull_index] = Pull{</span>
<span class="line" id="L454">                        .range = Range.init(A.start, B.end),</span>
<span class="line" id="L455">                        .count = count,</span>
<span class="line" id="L456">                        .from = index,</span>
<span class="line" id="L457">                        .to = B.end,</span>
<span class="line" id="L458">                    };</span>
<span class="line" id="L459">                    pull_index = <span class="tok-number">1</span>;</span>
<span class="line" id="L460"></span>
<span class="line" id="L461">                    <span class="tok-kw">if</span> (count == buffer_size + buffer_size) {</span>
<span class="line" id="L462">                        <span class="tok-comment">// we were able to find a single contiguous section containing 2√A unique values,</span>
</span>
<span class="line" id="L463">                        <span class="tok-comment">// so this section can be used to contain both of the internal buffers we'll need</span>
</span>
<span class="line" id="L464">                        buffer1 = Range.init(B.end - count, B.end - buffer_size);</span>
<span class="line" id="L465">                        buffer2 = Range.init(B.end - buffer_size, B.end);</span>
<span class="line" id="L466">                        <span class="tok-kw">break</span>;</span>
<span class="line" id="L467">                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (find == buffer_size + buffer_size) {</span>
<span class="line" id="L468">                        <span class="tok-comment">// we found a buffer that contains at least √A unique values, but did not contain the full 2√A unique values,</span>
</span>
<span class="line" id="L469">                        <span class="tok-comment">// so we still need to find a second separate buffer of at least √A unique values</span>
</span>
<span class="line" id="L470">                        buffer1 = Range.init(B.end - count, B.end);</span>
<span class="line" id="L471">                        find = buffer_size;</span>
<span class="line" id="L472">                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (block_size &lt;= cache.len) {</span>
<span class="line" id="L473">                        <span class="tok-comment">// we found the first and only internal buffer that we need, so we're done!</span>
</span>
<span class="line" id="L474">                        buffer1 = Range.init(B.end - count, B.end);</span>
<span class="line" id="L475">                        <span class="tok-kw">break</span>;</span>
<span class="line" id="L476">                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (find_separately) {</span>
<span class="line" id="L477">                        <span class="tok-comment">// found one buffer, but now find the other one</span>
</span>
<span class="line" id="L478">                        buffer1 = Range.init(B.end - count, B.end);</span>
<span class="line" id="L479">                        find_separately = <span class="tok-null">false</span>;</span>
<span class="line" id="L480">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L481">                        <span class="tok-comment">// buffer2 will be pulled out from a 'B' subarray, so if the first buffer was pulled out from the corresponding 'A' subarray,</span>
</span>
<span class="line" id="L482">                        <span class="tok-comment">// we need to adjust the end point for that A subarray so it knows to stop redistributing its values before reaching buffer2</span>
</span>
<span class="line" id="L483">                        <span class="tok-kw">if</span> (pull[<span class="tok-number">0</span>].range.start == A.start) pull[<span class="tok-number">0</span>].range.end -= pull[<span class="tok-number">1</span>].count;</span>
<span class="line" id="L484"></span>
<span class="line" id="L485">                        <span class="tok-comment">// we found a second buffer in an 'B' subarray containing √A unique values, so we're done!</span>
</span>
<span class="line" id="L486">                        buffer2 = Range.init(B.end - count, B.end);</span>
<span class="line" id="L487">                        <span class="tok-kw">break</span>;</span>
<span class="line" id="L488">                    }</span>
<span class="line" id="L489">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (pull_index == <span class="tok-number">0</span> <span class="tok-kw">and</span> count &gt; buffer1.length()) {</span>
<span class="line" id="L490">                    <span class="tok-comment">// keep track of the largest buffer we were able to find</span>
</span>
<span class="line" id="L491">                    buffer1 = Range.init(B.end - count, B.end);</span>
<span class="line" id="L492">                    pull[pull_index] = Pull{</span>
<span class="line" id="L493">                        .range = Range.init(A.start, B.end),</span>
<span class="line" id="L494">                        .count = count,</span>
<span class="line" id="L495">                        .from = index,</span>
<span class="line" id="L496">                        .to = B.end,</span>
<span class="line" id="L497">                    };</span>
<span class="line" id="L498">                }</span>
<span class="line" id="L499">            }</span>
<span class="line" id="L500"></span>
<span class="line" id="L501">            <span class="tok-comment">// pull out the two ranges so we can use them as internal buffers</span>
</span>
<span class="line" id="L502">            pull_index = <span class="tok-number">0</span>;</span>
<span class="line" id="L503">            <span class="tok-kw">while</span> (pull_index &lt; <span class="tok-number">2</span>) : (pull_index += <span class="tok-number">1</span>) {</span>
<span class="line" id="L504">                <span class="tok-kw">const</span> length = pull[pull_index].count;</span>
<span class="line" id="L505"></span>
<span class="line" id="L506">                <span class="tok-kw">if</span> (pull[pull_index].to &lt; pull[pull_index].from) {</span>
<span class="line" id="L507">                    <span class="tok-comment">// we're pulling the values out to the left, which means the start of an A subarray</span>
</span>
<span class="line" id="L508">                    index = pull[pull_index].from;</span>
<span class="line" id="L509">                    count = <span class="tok-number">1</span>;</span>
<span class="line" id="L510">                    <span class="tok-kw">while</span> (count &lt; length) : (count += <span class="tok-number">1</span>) {</span>
<span class="line" id="L511">                        index = findFirstBackward(T, items, items[index - <span class="tok-number">1</span>], Range.init(pull[pull_index].to, pull[pull_index].from - (count - <span class="tok-number">1</span>)), length - count, context, lessThan);</span>
<span class="line" id="L512">                        <span class="tok-kw">const</span> range = Range.init(index + <span class="tok-number">1</span>, pull[pull_index].from + <span class="tok-number">1</span>);</span>
<span class="line" id="L513">                        mem.rotate(T, items[range.start..range.end], range.length() - count);</span>
<span class="line" id="L514">                        pull[pull_index].from = index + count;</span>
<span class="line" id="L515">                    }</span>
<span class="line" id="L516">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (pull[pull_index].to &gt; pull[pull_index].from) {</span>
<span class="line" id="L517">                    <span class="tok-comment">// we're pulling values out to the right, which means the end of a B subarray</span>
</span>
<span class="line" id="L518">                    index = pull[pull_index].from + <span class="tok-number">1</span>;</span>
<span class="line" id="L519">                    count = <span class="tok-number">1</span>;</span>
<span class="line" id="L520">                    <span class="tok-kw">while</span> (count &lt; length) : (count += <span class="tok-number">1</span>) {</span>
<span class="line" id="L521">                        index = findLastForward(T, items, items[index], Range.init(index, pull[pull_index].to), length - count, context, lessThan);</span>
<span class="line" id="L522">                        <span class="tok-kw">const</span> range = Range.init(pull[pull_index].from, index - <span class="tok-number">1</span>);</span>
<span class="line" id="L523">                        mem.rotate(T, items[range.start..range.end], count);</span>
<span class="line" id="L524">                        pull[pull_index].from = index - <span class="tok-number">1</span> - count;</span>
<span class="line" id="L525">                    }</span>
<span class="line" id="L526">                }</span>
<span class="line" id="L527">            }</span>
<span class="line" id="L528"></span>
<span class="line" id="L529">            <span class="tok-comment">// adjust block_size and buffer_size based on the values we were able to pull out</span>
</span>
<span class="line" id="L530">            buffer_size = buffer1.length();</span>
<span class="line" id="L531">            block_size = iterator.length() / buffer_size + <span class="tok-number">1</span>;</span>
<span class="line" id="L532"></span>
<span class="line" id="L533">            <span class="tok-comment">// the first buffer NEEDS to be large enough to tag each of the evenly sized A blocks,</span>
</span>
<span class="line" id="L534">            <span class="tok-comment">// so this was originally here to test the math for adjusting block_size above</span>
</span>
<span class="line" id="L535">            <span class="tok-comment">// assert((iterator.length() + 1)/block_size &lt;= buffer_size);</span>
</span>
<span class="line" id="L536"></span>
<span class="line" id="L537">            <span class="tok-comment">// now that the two internal buffers have been created, it's time to merge each A+B combination at this level of the merge sort!</span>
</span>
<span class="line" id="L538">            iterator.begin();</span>
<span class="line" id="L539">            <span class="tok-kw">while</span> (!iterator.finished()) {</span>
<span class="line" id="L540">                A = iterator.nextRange();</span>
<span class="line" id="L541">                B = iterator.nextRange();</span>
<span class="line" id="L542"></span>
<span class="line" id="L543">                <span class="tok-comment">// remove any parts of A or B that are being used by the internal buffers</span>
</span>
<span class="line" id="L544">                start = A.start;</span>
<span class="line" id="L545">                <span class="tok-kw">if</span> (start == pull[<span class="tok-number">0</span>].range.start) {</span>
<span class="line" id="L546">                    <span class="tok-kw">if</span> (pull[<span class="tok-number">0</span>].from &gt; pull[<span class="tok-number">0</span>].to) {</span>
<span class="line" id="L547">                        A.start += pull[<span class="tok-number">0</span>].count;</span>
<span class="line" id="L548"></span>
<span class="line" id="L549">                        <span class="tok-comment">// if the internal buffer takes up the entire A or B subarray, then there's nothing to merge</span>
</span>
<span class="line" id="L550">                        <span class="tok-comment">// this only happens for very small subarrays, like √4 = 2, 2 * (2 internal buffers) = 4,</span>
</span>
<span class="line" id="L551">                        <span class="tok-comment">// which also only happens when cache.len is small or 0 since it'd otherwise use MergeExternal</span>
</span>
<span class="line" id="L552">                        <span class="tok-kw">if</span> (A.length() == <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L553">                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (pull[<span class="tok-number">0</span>].from &lt; pull[<span class="tok-number">0</span>].to) {</span>
<span class="line" id="L554">                        B.end -= pull[<span class="tok-number">0</span>].count;</span>
<span class="line" id="L555">                        <span class="tok-kw">if</span> (B.length() == <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L556">                    }</span>
<span class="line" id="L557">                }</span>
<span class="line" id="L558">                <span class="tok-kw">if</span> (start == pull[<span class="tok-number">1</span>].range.start) {</span>
<span class="line" id="L559">                    <span class="tok-kw">if</span> (pull[<span class="tok-number">1</span>].from &gt; pull[<span class="tok-number">1</span>].to) {</span>
<span class="line" id="L560">                        A.start += pull[<span class="tok-number">1</span>].count;</span>
<span class="line" id="L561">                        <span class="tok-kw">if</span> (A.length() == <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L562">                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (pull[<span class="tok-number">1</span>].from &lt; pull[<span class="tok-number">1</span>].to) {</span>
<span class="line" id="L563">                        B.end -= pull[<span class="tok-number">1</span>].count;</span>
<span class="line" id="L564">                        <span class="tok-kw">if</span> (B.length() == <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L565">                    }</span>
<span class="line" id="L566">                }</span>
<span class="line" id="L567"></span>
<span class="line" id="L568">                <span class="tok-kw">if</span> (lessThan(context, items[B.end - <span class="tok-number">1</span>], items[A.start])) {</span>
<span class="line" id="L569">                    <span class="tok-comment">// the two ranges are in reverse order, so a simple rotation should fix it</span>
</span>
<span class="line" id="L570">                    mem.rotate(T, items[A.start..B.end], A.length());</span>
<span class="line" id="L571">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (lessThan(context, items[A.end], items[A.end - <span class="tok-number">1</span>])) {</span>
<span class="line" id="L572">                    <span class="tok-comment">// these two ranges weren't already in order, so we'll need to merge them!</span>
</span>
<span class="line" id="L573">                    <span class="tok-kw">var</span> findA: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L574"></span>
<span class="line" id="L575">                    <span class="tok-comment">// break the remainder of A into blocks. firstA is the uneven-sized first A block</span>
</span>
<span class="line" id="L576">                    <span class="tok-kw">var</span> blockA = Range.init(A.start, A.end);</span>
<span class="line" id="L577">                    <span class="tok-kw">var</span> firstA = Range.init(A.start, A.start + blockA.length() % block_size);</span>
<span class="line" id="L578"></span>
<span class="line" id="L579">                    <span class="tok-comment">// swap the first value of each A block with the value in buffer1</span>
</span>
<span class="line" id="L580">                    <span class="tok-kw">var</span> indexA = buffer1.start;</span>
<span class="line" id="L581">                    index = firstA.end;</span>
<span class="line" id="L582">                    <span class="tok-kw">while</span> (index &lt; blockA.end) : ({</span>
<span class="line" id="L583">                        indexA += <span class="tok-number">1</span>;</span>
<span class="line" id="L584">                        index += block_size;</span>
<span class="line" id="L585">                    }) {</span>
<span class="line" id="L586">                        mem.swap(T, &amp;items[indexA], &amp;items[index]);</span>
<span class="line" id="L587">                    }</span>
<span class="line" id="L588"></span>
<span class="line" id="L589">                    <span class="tok-comment">// start rolling the A blocks through the B blocks!</span>
</span>
<span class="line" id="L590">                    <span class="tok-comment">// whenever we leave an A block behind, we'll need to merge the previous A block with any B blocks that follow it, so track that information as well</span>
</span>
<span class="line" id="L591">                    <span class="tok-kw">var</span> lastA = firstA;</span>
<span class="line" id="L592">                    <span class="tok-kw">var</span> lastB = Range.init(<span class="tok-number">0</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L593">                    <span class="tok-kw">var</span> blockB = Range.init(B.start, B.start + math.min(block_size, B.length()));</span>
<span class="line" id="L594">                    blockA.start += firstA.length();</span>
<span class="line" id="L595">                    indexA = buffer1.start;</span>
<span class="line" id="L596"></span>
<span class="line" id="L597">                    <span class="tok-comment">// if the first unevenly sized A block fits into the cache, copy it there for when we go to Merge it</span>
</span>
<span class="line" id="L598">                    <span class="tok-comment">// otherwise, if the second buffer is available, block swap the contents into that</span>
</span>
<span class="line" id="L599">                    <span class="tok-kw">if</span> (lastA.length() &lt;= cache.len) {</span>
<span class="line" id="L600">                        <span class="tok-kw">const</span> last_a_items = items[lastA.start..lastA.end];</span>
<span class="line" id="L601">                        <span class="tok-builtin">@memcpy</span>(cache[<span class="tok-number">0</span>..last_a_items.len], last_a_items);</span>
<span class="line" id="L602">                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (buffer2.length() &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L603">                        blockSwap(T, items, lastA.start, buffer2.start, lastA.length());</span>
<span class="line" id="L604">                    }</span>
<span class="line" id="L605"></span>
<span class="line" id="L606">                    <span class="tok-kw">if</span> (blockA.length() &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L607">                        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L608">                            <span class="tok-comment">// if there's a previous B block and the first value of the minimum A block is &lt;= the last value of the previous B block,</span>
</span>
<span class="line" id="L609">                            <span class="tok-comment">// then drop that minimum A block behind. or if there are no B blocks left then keep dropping the remaining A blocks.</span>
</span>
<span class="line" id="L610">                            <span class="tok-kw">if</span> ((lastB.length() &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> !lessThan(context, items[lastB.end - <span class="tok-number">1</span>], items[indexA])) <span class="tok-kw">or</span> blockB.length() == <span class="tok-number">0</span>) {</span>
<span class="line" id="L611">                                <span class="tok-comment">// figure out where to split the previous B block, and rotate it at the split</span>
</span>
<span class="line" id="L612">                                <span class="tok-kw">const</span> B_split = binaryFirst(T, items, items[indexA], lastB, context, lessThan);</span>
<span class="line" id="L613">                                <span class="tok-kw">const</span> B_remaining = lastB.end - B_split;</span>
<span class="line" id="L614"></span>
<span class="line" id="L615">                                <span class="tok-comment">// swap the minimum A block to the beginning of the rolling A blocks</span>
</span>
<span class="line" id="L616">                                <span class="tok-kw">var</span> minA = blockA.start;</span>
<span class="line" id="L617">                                findA = minA + block_size;</span>
<span class="line" id="L618">                                <span class="tok-kw">while</span> (findA &lt; blockA.end) : (findA += block_size) {</span>
<span class="line" id="L619">                                    <span class="tok-kw">if</span> (lessThan(context, items[findA], items[minA])) {</span>
<span class="line" id="L620">                                        minA = findA;</span>
<span class="line" id="L621">                                    }</span>
<span class="line" id="L622">                                }</span>
<span class="line" id="L623">                                blockSwap(T, items, blockA.start, minA, block_size);</span>
<span class="line" id="L624"></span>
<span class="line" id="L625">                                <span class="tok-comment">// swap the first item of the previous A block back with its original value, which is stored in buffer1</span>
</span>
<span class="line" id="L626">                                mem.swap(T, &amp;items[blockA.start], &amp;items[indexA]);</span>
<span class="line" id="L627">                                indexA += <span class="tok-number">1</span>;</span>
<span class="line" id="L628"></span>
<span class="line" id="L629">                                <span class="tok-comment">// locally merge the previous A block with the B values that follow it</span>
</span>
<span class="line" id="L630">                                <span class="tok-comment">// if lastA fits into the external cache we'll use that (with MergeExternal),</span>
</span>
<span class="line" id="L631">                                <span class="tok-comment">// or if the second internal buffer exists we'll use that (with MergeInternal),</span>
</span>
<span class="line" id="L632">                                <span class="tok-comment">// or failing that we'll use a strictly in-place merge algorithm (MergeInPlace)</span>
</span>
<span class="line" id="L633"></span>
<span class="line" id="L634">                                <span class="tok-kw">if</span> (lastA.length() &lt;= cache.len) {</span>
<span class="line" id="L635">                                    mergeExternal(T, items, lastA, Range.init(lastA.end, B_split), cache[<span class="tok-number">0</span>..], context, lessThan);</span>
<span class="line" id="L636">                                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (buffer2.length() &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L637">                                    mergeInternal(T, items, lastA, Range.init(lastA.end, B_split), buffer2, context, lessThan);</span>
<span class="line" id="L638">                                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L639">                                    mergeInPlace(T, items, lastA, Range.init(lastA.end, B_split), context, lessThan);</span>
<span class="line" id="L640">                                }</span>
<span class="line" id="L641"></span>
<span class="line" id="L642">                                <span class="tok-kw">if</span> (buffer2.length() &gt; <span class="tok-number">0</span> <span class="tok-kw">or</span> block_size &lt;= cache.len) {</span>
<span class="line" id="L643">                                    <span class="tok-comment">// copy the previous A block into the cache or buffer2, since that's where we need it to be when we go to merge it anyway</span>
</span>
<span class="line" id="L644">                                    <span class="tok-kw">if</span> (block_size &lt;= cache.len) {</span>
<span class="line" id="L645">                                        <span class="tok-builtin">@memcpy</span>(cache[<span class="tok-number">0</span>..block_size], items[blockA.start..][<span class="tok-number">0</span>..block_size]);</span>
<span class="line" id="L646">                                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L647">                                        blockSwap(T, items, blockA.start, buffer2.start, block_size);</span>
<span class="line" id="L648">                                    }</span>
<span class="line" id="L649"></span>
<span class="line" id="L650">                                    <span class="tok-comment">// this is equivalent to rotating, but faster</span>
</span>
<span class="line" id="L651">                                    <span class="tok-comment">// the area normally taken up by the A block is either the contents of buffer2, or data we don't need anymore since we memcopied it</span>
</span>
<span class="line" id="L652">                                    <span class="tok-comment">// either way, we don't need to retain the order of those items, so instead of rotating we can just block swap B to where it belongs</span>
</span>
<span class="line" id="L653">                                    blockSwap(T, items, B_split, blockA.start + block_size - B_remaining, B_remaining);</span>
<span class="line" id="L654">                                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L655">                                    <span class="tok-comment">// we are unable to use the 'buffer2' trick to speed up the rotation operation since buffer2 doesn't exist, so perform a normal rotation</span>
</span>
<span class="line" id="L656">                                    mem.rotate(T, items[B_split .. blockA.start + block_size], blockA.start - B_split);</span>
<span class="line" id="L657">                                }</span>
<span class="line" id="L658"></span>
<span class="line" id="L659">                                <span class="tok-comment">// update the range for the remaining A blocks, and the range remaining from the B block after it was split</span>
</span>
<span class="line" id="L660">                                lastA = Range.init(blockA.start - B_remaining, blockA.start - B_remaining + block_size);</span>
<span class="line" id="L661">                                lastB = Range.init(lastA.end, lastA.end + B_remaining);</span>
<span class="line" id="L662"></span>
<span class="line" id="L663">                                <span class="tok-comment">// if there are no more A blocks remaining, this step is finished!</span>
</span>
<span class="line" id="L664">                                blockA.start += block_size;</span>
<span class="line" id="L665">                                <span class="tok-kw">if</span> (blockA.length() == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;</span>
<span class="line" id="L666">                            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (blockB.length() &lt; block_size) {</span>
<span class="line" id="L667">                                <span class="tok-comment">// move the last B block, which is unevenly sized, to before the remaining A blocks, by using a rotation</span>
</span>
<span class="line" id="L668">                                <span class="tok-comment">// the cache is disabled here since it might contain the contents of the previous A block</span>
</span>
<span class="line" id="L669">                                mem.rotate(T, items[blockA.start..blockB.end], blockB.start - blockA.start);</span>
<span class="line" id="L670"></span>
<span class="line" id="L671">                                lastB = Range.init(blockA.start, blockA.start + blockB.length());</span>
<span class="line" id="L672">                                blockA.start += blockB.length();</span>
<span class="line" id="L673">                                blockA.end += blockB.length();</span>
<span class="line" id="L674">                                blockB.end = blockB.start;</span>
<span class="line" id="L675">                            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L676">                                <span class="tok-comment">// roll the leftmost A block to the end by swapping it with the next B block</span>
</span>
<span class="line" id="L677">                                blockSwap(T, items, blockA.start, blockB.start, block_size);</span>
<span class="line" id="L678">                                lastB = Range.init(blockA.start, blockA.start + block_size);</span>
<span class="line" id="L679"></span>
<span class="line" id="L680">                                blockA.start += block_size;</span>
<span class="line" id="L681">                                blockA.end += block_size;</span>
<span class="line" id="L682">                                blockB.start += block_size;</span>
<span class="line" id="L683"></span>
<span class="line" id="L684">                                <span class="tok-kw">if</span> (blockB.end &gt; B.end - block_size) {</span>
<span class="line" id="L685">                                    blockB.end = B.end;</span>
<span class="line" id="L686">                                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L687">                                    blockB.end += block_size;</span>
<span class="line" id="L688">                                }</span>
<span class="line" id="L689">                            }</span>
<span class="line" id="L690">                        }</span>
<span class="line" id="L691">                    }</span>
<span class="line" id="L692"></span>
<span class="line" id="L693">                    <span class="tok-comment">// merge the last A block with the remaining B values</span>
</span>
<span class="line" id="L694">                    <span class="tok-kw">if</span> (lastA.length() &lt;= cache.len) {</span>
<span class="line" id="L695">                        mergeExternal(T, items, lastA, Range.init(lastA.end, B.end), cache[<span class="tok-number">0</span>..], context, lessThan);</span>
<span class="line" id="L696">                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (buffer2.length() &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L697">                        mergeInternal(T, items, lastA, Range.init(lastA.end, B.end), buffer2, context, lessThan);</span>
<span class="line" id="L698">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L699">                        mergeInPlace(T, items, lastA, Range.init(lastA.end, B.end), context, lessThan);</span>
<span class="line" id="L700">                    }</span>
<span class="line" id="L701">                }</span>
<span class="line" id="L702">            }</span>
<span class="line" id="L703"></span>
<span class="line" id="L704">            <span class="tok-comment">// when we're finished with this merge step we should have the one</span>
</span>
<span class="line" id="L705">            <span class="tok-comment">// or two internal buffers left over, where the second buffer is all jumbled up</span>
</span>
<span class="line" id="L706">            <span class="tok-comment">// insertion sort the second buffer, then redistribute the buffers</span>
</span>
<span class="line" id="L707">            <span class="tok-comment">// back into the items using the opposite process used for creating the buffer</span>
</span>
<span class="line" id="L708"></span>
<span class="line" id="L709">            <span class="tok-comment">// while an unstable sort like quicksort could be applied here, in benchmarks</span>
</span>
<span class="line" id="L710">            <span class="tok-comment">// it was consistently slightly slower than a simple insertion sort,</span>
</span>
<span class="line" id="L711">            <span class="tok-comment">// even for tens of millions of items. this may be because insertion</span>
</span>
<span class="line" id="L712">            <span class="tok-comment">// sort is quite fast when the data is already somewhat sorted, like it is here</span>
</span>
<span class="line" id="L713">            sort.insertion(T, items[buffer2.start..buffer2.end], context, lessThan);</span>
<span class="line" id="L714"></span>
<span class="line" id="L715">            pull_index = <span class="tok-number">0</span>;</span>
<span class="line" id="L716">            <span class="tok-kw">while</span> (pull_index &lt; <span class="tok-number">2</span>) : (pull_index += <span class="tok-number">1</span>) {</span>
<span class="line" id="L717">                <span class="tok-kw">var</span> unique = pull[pull_index].count * <span class="tok-number">2</span>;</span>
<span class="line" id="L718">                <span class="tok-kw">if</span> (pull[pull_index].from &gt; pull[pull_index].to) {</span>
<span class="line" id="L719">                    <span class="tok-comment">// the values were pulled out to the left, so redistribute them back to the right</span>
</span>
<span class="line" id="L720">                    <span class="tok-kw">var</span> buffer = Range.init(pull[pull_index].range.start, pull[pull_index].range.start + pull[pull_index].count);</span>
<span class="line" id="L721">                    <span class="tok-kw">while</span> (buffer.length() &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L722">                        index = findFirstForward(T, items, items[buffer.start], Range.init(buffer.end, pull[pull_index].range.end), unique, context, lessThan);</span>
<span class="line" id="L723">                        <span class="tok-kw">const</span> amount = index - buffer.end;</span>
<span class="line" id="L724">                        mem.rotate(T, items[buffer.start..index], buffer.length());</span>
<span class="line" id="L725">                        buffer.start += (amount + <span class="tok-number">1</span>);</span>
<span class="line" id="L726">                        buffer.end += amount;</span>
<span class="line" id="L727">                        unique -= <span class="tok-number">2</span>;</span>
<span class="line" id="L728">                    }</span>
<span class="line" id="L729">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (pull[pull_index].from &lt; pull[pull_index].to) {</span>
<span class="line" id="L730">                    <span class="tok-comment">// the values were pulled out to the right, so redistribute them back to the left</span>
</span>
<span class="line" id="L731">                    <span class="tok-kw">var</span> buffer = Range.init(pull[pull_index].range.end - pull[pull_index].count, pull[pull_index].range.end);</span>
<span class="line" id="L732">                    <span class="tok-kw">while</span> (buffer.length() &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L733">                        index = findLastBackward(T, items, items[buffer.end - <span class="tok-number">1</span>], Range.init(pull[pull_index].range.start, buffer.start), unique, context, lessThan);</span>
<span class="line" id="L734">                        <span class="tok-kw">const</span> amount = buffer.start - index;</span>
<span class="line" id="L735">                        mem.rotate(T, items[index..buffer.end], amount);</span>
<span class="line" id="L736">                        buffer.start -= amount;</span>
<span class="line" id="L737">                        buffer.end -= (amount + <span class="tok-number">1</span>);</span>
<span class="line" id="L738">                        unique -= <span class="tok-number">2</span>;</span>
<span class="line" id="L739">                    }</span>
<span class="line" id="L740">                }</span>
<span class="line" id="L741">            }</span>
<span class="line" id="L742">        }</span>
<span class="line" id="L743"></span>
<span class="line" id="L744">        <span class="tok-comment">// double the size of each A and B subarray that will be merged in the next level</span>
</span>
<span class="line" id="L745">        <span class="tok-kw">if</span> (!iterator.nextLevel()) <span class="tok-kw">break</span>;</span>
<span class="line" id="L746">    }</span>
<span class="line" id="L747">}</span>
<span class="line" id="L748"><span class="tok-comment">// merge operation without a buffer</span>
</span>
<span class="line" id="L749"><span class="tok-kw">fn</span> <span class="tok-fn">mergeInPlace</span>(</span>
<span class="line" id="L750">    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,</span>
<span class="line" id="L751">    items: []T,</span>
<span class="line" id="L752">    A_arg: Range,</span>
<span class="line" id="L753">    B_arg: Range,</span>
<span class="line" id="L754">    context: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L755">    <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,</span>
<span class="line" id="L756">) <span class="tok-type">void</span> {</span>
<span class="line" id="L757">    <span class="tok-kw">if</span> (A_arg.length() == <span class="tok-number">0</span> <span class="tok-kw">or</span> B_arg.length() == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;</span>
<span class="line" id="L758"></span>
<span class="line" id="L759">    <span class="tok-comment">// this just repeatedly binary searches into B and rotates A into position.</span>
</span>
<span class="line" id="L760">    <span class="tok-comment">// the paper suggests using the 'rotation-based Hwang and Lin algorithm' here,</span>
</span>
<span class="line" id="L761">    <span class="tok-comment">// but I decided to stick with this because it had better situational performance</span>
</span>
<span class="line" id="L762">    <span class="tok-comment">//</span>
</span>
<span class="line" id="L763">    <span class="tok-comment">// (Hwang and Lin is designed for merging subarrays of very different sizes,</span>
</span>
<span class="line" id="L764">    <span class="tok-comment">// but WikiSort almost always uses subarrays that are roughly the same size)</span>
</span>
<span class="line" id="L765">    <span class="tok-comment">//</span>
</span>
<span class="line" id="L766">    <span class="tok-comment">// normally this is incredibly suboptimal, but this function is only called</span>
</span>
<span class="line" id="L767">    <span class="tok-comment">// when none of the A or B blocks in any subarray contained 2√A unique values,</span>
</span>
<span class="line" id="L768">    <span class="tok-comment">// which places a hard limit on the number of times this will ACTUALLY need</span>
</span>
<span class="line" id="L769">    <span class="tok-comment">// to binary search and rotate.</span>
</span>
<span class="line" id="L770">    <span class="tok-comment">//</span>
</span>
<span class="line" id="L771">    <span class="tok-comment">// according to my analysis the worst case is √A rotations performed on √A items</span>
</span>
<span class="line" id="L772">    <span class="tok-comment">// once the constant factors are removed, which ends up being O(n)</span>
</span>
<span class="line" id="L773">    <span class="tok-comment">//</span>
</span>
<span class="line" id="L774">    <span class="tok-comment">// again, this is NOT a general-purpose solution – it only works well in this case!</span>
</span>
<span class="line" id="L775">    <span class="tok-comment">// kind of like how the O(n^2) insertion sort is used in some places</span>
</span>
<span class="line" id="L776"></span>
<span class="line" id="L777">    <span class="tok-kw">var</span> A = A_arg;</span>
<span class="line" id="L778">    <span class="tok-kw">var</span> B = B_arg;</span>
<span class="line" id="L779"></span>
<span class="line" id="L780">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L781">        <span class="tok-comment">// find the first place in B where the first item in A needs to be inserted</span>
</span>
<span class="line" id="L782">        <span class="tok-kw">const</span> mid = binaryFirst(T, items, items[A.start], B, context, lessThan);</span>
<span class="line" id="L783"></span>
<span class="line" id="L784">        <span class="tok-comment">// rotate A into place</span>
</span>
<span class="line" id="L785">        <span class="tok-kw">const</span> amount = mid - A.end;</span>
<span class="line" id="L786">        mem.rotate(T, items[A.start..mid], A.length());</span>
<span class="line" id="L787">        <span class="tok-kw">if</span> (B.end == mid) <span class="tok-kw">break</span>;</span>
<span class="line" id="L788"></span>
<span class="line" id="L789">        <span class="tok-comment">// calculate the new A and B ranges</span>
</span>
<span class="line" id="L790">        B.start = mid;</span>
<span class="line" id="L791">        A = Range.init(A.start + amount, B.start);</span>
<span class="line" id="L792">        A.start = binaryLast(T, items, items[A.start], A, context, lessThan);</span>
<span class="line" id="L793">        <span class="tok-kw">if</span> (A.length() == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;</span>
<span class="line" id="L794">    }</span>
<span class="line" id="L795">}</span>
<span class="line" id="L796"></span>
<span class="line" id="L797"><span class="tok-comment">// merge operation using an internal buffer</span>
</span>
<span class="line" id="L798"><span class="tok-kw">fn</span> <span class="tok-fn">mergeInternal</span>(</span>
<span class="line" id="L799">    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,</span>
<span class="line" id="L800">    items: []T,</span>
<span class="line" id="L801">    A: Range,</span>
<span class="line" id="L802">    B: Range,</span>
<span class="line" id="L803">    buffer: Range,</span>
<span class="line" id="L804">    context: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L805">    <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,</span>
<span class="line" id="L806">) <span class="tok-type">void</span> {</span>
<span class="line" id="L807">    <span class="tok-comment">// whenever we find a value to add to the final array, swap it with the value that's already in that spot</span>
</span>
<span class="line" id="L808">    <span class="tok-comment">// when this algorithm is finished, 'buffer' will contain its original contents, but in a different order</span>
</span>
<span class="line" id="L809">    <span class="tok-kw">var</span> A_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L810">    <span class="tok-kw">var</span> B_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L811">    <span class="tok-kw">var</span> insert: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L812"></span>
<span class="line" id="L813">    <span class="tok-kw">if</span> (B.length() &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> A.length() &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L814">        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L815">            <span class="tok-kw">if</span> (!lessThan(context, items[B.start + B_count], items[buffer.start + A_count])) {</span>
<span class="line" id="L816">                mem.swap(T, &amp;items[A.start + insert], &amp;items[buffer.start + A_count]);</span>
<span class="line" id="L817">                A_count += <span class="tok-number">1</span>;</span>
<span class="line" id="L818">                insert += <span class="tok-number">1</span>;</span>
<span class="line" id="L819">                <span class="tok-kw">if</span> (A_count &gt;= A.length()) <span class="tok-kw">break</span>;</span>
<span class="line" id="L820">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L821">                mem.swap(T, &amp;items[A.start + insert], &amp;items[B.start + B_count]);</span>
<span class="line" id="L822">                B_count += <span class="tok-number">1</span>;</span>
<span class="line" id="L823">                insert += <span class="tok-number">1</span>;</span>
<span class="line" id="L824">                <span class="tok-kw">if</span> (B_count &gt;= B.length()) <span class="tok-kw">break</span>;</span>
<span class="line" id="L825">            }</span>
<span class="line" id="L826">        }</span>
<span class="line" id="L827">    }</span>
<span class="line" id="L828"></span>
<span class="line" id="L829">    <span class="tok-comment">// swap the remainder of A into the final array</span>
</span>
<span class="line" id="L830">    blockSwap(T, items, buffer.start + A_count, A.start + insert, A.length() - A_count);</span>
<span class="line" id="L831">}</span>
<span class="line" id="L832"></span>
<span class="line" id="L833"><span class="tok-kw">fn</span> <span class="tok-fn">blockSwap</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, items: []T, start1: <span class="tok-type">usize</span>, start2: <span class="tok-type">usize</span>, block_size: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L834">    <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L835">    <span class="tok-kw">while</span> (index &lt; block_size) : (index += <span class="tok-number">1</span>) {</span>
<span class="line" id="L836">        mem.swap(T, &amp;items[start1 + index], &amp;items[start2 + index]);</span>
<span class="line" id="L837">    }</span>
<span class="line" id="L838">}</span>
<span class="line" id="L839"></span>
<span class="line" id="L840"><span class="tok-comment">// combine a linear search with a binary search to reduce the number of comparisons in situations</span>
</span>
<span class="line" id="L841"><span class="tok-comment">// where have some idea as to how many unique values there are and where the next value might be</span>
</span>
<span class="line" id="L842"><span class="tok-kw">fn</span> <span class="tok-fn">findFirstForward</span>(</span>
<span class="line" id="L843">    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,</span>
<span class="line" id="L844">    items: []T,</span>
<span class="line" id="L845">    value: T,</span>
<span class="line" id="L846">    range: Range,</span>
<span class="line" id="L847">    unique: <span class="tok-type">usize</span>,</span>
<span class="line" id="L848">    context: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L849">    <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,</span>
<span class="line" id="L850">) <span class="tok-type">usize</span> {</span>
<span class="line" id="L851">    <span class="tok-kw">if</span> (range.length() == <span class="tok-number">0</span>) <span class="tok-kw">return</span> range.start;</span>
<span class="line" id="L852">    <span class="tok-kw">const</span> skip = math.max(range.length() / unique, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>));</span>
<span class="line" id="L853"></span>
<span class="line" id="L854">    <span class="tok-kw">var</span> index = range.start + skip;</span>
<span class="line" id="L855">    <span class="tok-kw">while</span> (lessThan(context, items[index - <span class="tok-number">1</span>], value)) : (index += skip) {</span>
<span class="line" id="L856">        <span class="tok-kw">if</span> (index &gt;= range.end - skip) {</span>
<span class="line" id="L857">            <span class="tok-kw">return</span> binaryFirst(T, items, value, Range.init(index, range.end), context, lessThan);</span>
<span class="line" id="L858">        }</span>
<span class="line" id="L859">    }</span>
<span class="line" id="L860"></span>
<span class="line" id="L861">    <span class="tok-kw">return</span> binaryFirst(T, items, value, Range.init(index - skip, index), context, lessThan);</span>
<span class="line" id="L862">}</span>
<span class="line" id="L863"></span>
<span class="line" id="L864"><span class="tok-kw">fn</span> <span class="tok-fn">findFirstBackward</span>(</span>
<span class="line" id="L865">    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,</span>
<span class="line" id="L866">    items: []T,</span>
<span class="line" id="L867">    value: T,</span>
<span class="line" id="L868">    range: Range,</span>
<span class="line" id="L869">    unique: <span class="tok-type">usize</span>,</span>
<span class="line" id="L870">    context: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L871">    <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,</span>
<span class="line" id="L872">) <span class="tok-type">usize</span> {</span>
<span class="line" id="L873">    <span class="tok-kw">if</span> (range.length() == <span class="tok-number">0</span>) <span class="tok-kw">return</span> range.start;</span>
<span class="line" id="L874">    <span class="tok-kw">const</span> skip = math.max(range.length() / unique, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>));</span>
<span class="line" id="L875"></span>
<span class="line" id="L876">    <span class="tok-kw">var</span> index = range.end - skip;</span>
<span class="line" id="L877">    <span class="tok-kw">while</span> (index &gt; range.start <span class="tok-kw">and</span> !lessThan(context, items[index - <span class="tok-number">1</span>], value)) : (index -= skip) {</span>
<span class="line" id="L878">        <span class="tok-kw">if</span> (index &lt; range.start + skip) {</span>
<span class="line" id="L879">            <span class="tok-kw">return</span> binaryFirst(T, items, value, Range.init(range.start, index), context, lessThan);</span>
<span class="line" id="L880">        }</span>
<span class="line" id="L881">    }</span>
<span class="line" id="L882"></span>
<span class="line" id="L883">    <span class="tok-kw">return</span> binaryFirst(T, items, value, Range.init(index, index + skip), context, lessThan);</span>
<span class="line" id="L884">}</span>
<span class="line" id="L885"></span>
<span class="line" id="L886"><span class="tok-kw">fn</span> <span class="tok-fn">findLastForward</span>(</span>
<span class="line" id="L887">    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,</span>
<span class="line" id="L888">    items: []T,</span>
<span class="line" id="L889">    value: T,</span>
<span class="line" id="L890">    range: Range,</span>
<span class="line" id="L891">    unique: <span class="tok-type">usize</span>,</span>
<span class="line" id="L892">    context: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L893">    <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,</span>
<span class="line" id="L894">) <span class="tok-type">usize</span> {</span>
<span class="line" id="L895">    <span class="tok-kw">if</span> (range.length() == <span class="tok-number">0</span>) <span class="tok-kw">return</span> range.start;</span>
<span class="line" id="L896">    <span class="tok-kw">const</span> skip = math.max(range.length() / unique, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>));</span>
<span class="line" id="L897"></span>
<span class="line" id="L898">    <span class="tok-kw">var</span> index = range.start + skip;</span>
<span class="line" id="L899">    <span class="tok-kw">while</span> (!lessThan(context, value, items[index - <span class="tok-number">1</span>])) : (index += skip) {</span>
<span class="line" id="L900">        <span class="tok-kw">if</span> (index &gt;= range.end - skip) {</span>
<span class="line" id="L901">            <span class="tok-kw">return</span> binaryLast(T, items, value, Range.init(index, range.end), context, lessThan);</span>
<span class="line" id="L902">        }</span>
<span class="line" id="L903">    }</span>
<span class="line" id="L904"></span>
<span class="line" id="L905">    <span class="tok-kw">return</span> binaryLast(T, items, value, Range.init(index - skip, index), context, lessThan);</span>
<span class="line" id="L906">}</span>
<span class="line" id="L907"></span>
<span class="line" id="L908"><span class="tok-kw">fn</span> <span class="tok-fn">findLastBackward</span>(</span>
<span class="line" id="L909">    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,</span>
<span class="line" id="L910">    items: []T,</span>
<span class="line" id="L911">    value: T,</span>
<span class="line" id="L912">    range: Range,</span>
<span class="line" id="L913">    unique: <span class="tok-type">usize</span>,</span>
<span class="line" id="L914">    context: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L915">    <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,</span>
<span class="line" id="L916">) <span class="tok-type">usize</span> {</span>
<span class="line" id="L917">    <span class="tok-kw">if</span> (range.length() == <span class="tok-number">0</span>) <span class="tok-kw">return</span> range.start;</span>
<span class="line" id="L918">    <span class="tok-kw">const</span> skip = math.max(range.length() / unique, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>));</span>
<span class="line" id="L919"></span>
<span class="line" id="L920">    <span class="tok-kw">var</span> index = range.end - skip;</span>
<span class="line" id="L921">    <span class="tok-kw">while</span> (index &gt; range.start <span class="tok-kw">and</span> lessThan(context, value, items[index - <span class="tok-number">1</span>])) : (index -= skip) {</span>
<span class="line" id="L922">        <span class="tok-kw">if</span> (index &lt; range.start + skip) {</span>
<span class="line" id="L923">            <span class="tok-kw">return</span> binaryLast(T, items, value, Range.init(range.start, index), context, lessThan);</span>
<span class="line" id="L924">        }</span>
<span class="line" id="L925">    }</span>
<span class="line" id="L926"></span>
<span class="line" id="L927">    <span class="tok-kw">return</span> binaryLast(T, items, value, Range.init(index, index + skip), context, lessThan);</span>
<span class="line" id="L928">}</span>
<span class="line" id="L929"></span>
<span class="line" id="L930"><span class="tok-kw">fn</span> <span class="tok-fn">binaryFirst</span>(</span>
<span class="line" id="L931">    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,</span>
<span class="line" id="L932">    items: []T,</span>
<span class="line" id="L933">    value: T,</span>
<span class="line" id="L934">    range: Range,</span>
<span class="line" id="L935">    context: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L936">    <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,</span>
<span class="line" id="L937">) <span class="tok-type">usize</span> {</span>
<span class="line" id="L938">    <span class="tok-kw">var</span> curr = range.start;</span>
<span class="line" id="L939">    <span class="tok-kw">var</span> size = range.length();</span>
<span class="line" id="L940">    <span class="tok-kw">if</span> (range.start &gt;= range.end) <span class="tok-kw">return</span> range.end;</span>
<span class="line" id="L941">    <span class="tok-kw">while</span> (size &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L942">        <span class="tok-kw">const</span> offset = size % <span class="tok-number">2</span>;</span>
<span class="line" id="L943"></span>
<span class="line" id="L944">        size /= <span class="tok-number">2</span>;</span>
<span class="line" id="L945">        <span class="tok-kw">const</span> mid_item = items[curr + size];</span>
<span class="line" id="L946">        <span class="tok-kw">if</span> (lessThan(context, mid_item, value)) {</span>
<span class="line" id="L947">            curr += size + offset;</span>
<span class="line" id="L948">        }</span>
<span class="line" id="L949">    }</span>
<span class="line" id="L950">    <span class="tok-kw">return</span> curr;</span>
<span class="line" id="L951">}</span>
<span class="line" id="L952"></span>
<span class="line" id="L953"><span class="tok-kw">fn</span> <span class="tok-fn">binaryLast</span>(</span>
<span class="line" id="L954">    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,</span>
<span class="line" id="L955">    items: []T,</span>
<span class="line" id="L956">    value: T,</span>
<span class="line" id="L957">    range: Range,</span>
<span class="line" id="L958">    context: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L959">    <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,</span>
<span class="line" id="L960">) <span class="tok-type">usize</span> {</span>
<span class="line" id="L961">    <span class="tok-kw">var</span> curr = range.start;</span>
<span class="line" id="L962">    <span class="tok-kw">var</span> size = range.length();</span>
<span class="line" id="L963">    <span class="tok-kw">if</span> (range.start &gt;= range.end) <span class="tok-kw">return</span> range.end;</span>
<span class="line" id="L964">    <span class="tok-kw">while</span> (size &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L965">        <span class="tok-kw">const</span> offset = size % <span class="tok-number">2</span>;</span>
<span class="line" id="L966"></span>
<span class="line" id="L967">        size /= <span class="tok-number">2</span>;</span>
<span class="line" id="L968">        <span class="tok-kw">const</span> mid_item = items[curr + size];</span>
<span class="line" id="L969">        <span class="tok-kw">if</span> (!lessThan(context, value, mid_item)) {</span>
<span class="line" id="L970">            curr += size + offset;</span>
<span class="line" id="L971">        }</span>
<span class="line" id="L972">    }</span>
<span class="line" id="L973">    <span class="tok-kw">return</span> curr;</span>
<span class="line" id="L974">}</span>
<span class="line" id="L975"></span>
<span class="line" id="L976"><span class="tok-kw">fn</span> <span class="tok-fn">mergeInto</span>(</span>
<span class="line" id="L977">    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,</span>
<span class="line" id="L978">    from: []T,</span>
<span class="line" id="L979">    A: Range,</span>
<span class="line" id="L980">    B: Range,</span>
<span class="line" id="L981">    into: []T,</span>
<span class="line" id="L982">    context: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L983">    <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,</span>
<span class="line" id="L984">) <span class="tok-type">void</span> {</span>
<span class="line" id="L985">    <span class="tok-kw">var</span> A_index: <span class="tok-type">usize</span> = A.start;</span>
<span class="line" id="L986">    <span class="tok-kw">var</span> B_index: <span class="tok-type">usize</span> = B.start;</span>
<span class="line" id="L987">    <span class="tok-kw">const</span> A_last = A.end;</span>
<span class="line" id="L988">    <span class="tok-kw">const</span> B_last = B.end;</span>
<span class="line" id="L989">    <span class="tok-kw">var</span> insert_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L990"></span>
<span class="line" id="L991">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L992">        <span class="tok-kw">if</span> (!lessThan(context, from[B_index], from[A_index])) {</span>
<span class="line" id="L993">            into[insert_index] = from[A_index];</span>
<span class="line" id="L994">            A_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L995">            insert_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L996">            <span class="tok-kw">if</span> (A_index == A_last) {</span>
<span class="line" id="L997">                <span class="tok-comment">// copy the remainder of B into the final array</span>
</span>
<span class="line" id="L998">                <span class="tok-kw">const</span> from_b = from[B_index..B_last];</span>
<span class="line" id="L999">                <span class="tok-builtin">@memcpy</span>(into[insert_index..][<span class="tok-number">0</span>..from_b.len], from_b);</span>
<span class="line" id="L1000">                <span class="tok-kw">break</span>;</span>
<span class="line" id="L1001">            }</span>
<span class="line" id="L1002">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1003">            into[insert_index] = from[B_index];</span>
<span class="line" id="L1004">            B_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L1005">            insert_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L1006">            <span class="tok-kw">if</span> (B_index == B_last) {</span>
<span class="line" id="L1007">                <span class="tok-comment">// copy the remainder of A into the final array</span>
</span>
<span class="line" id="L1008">                <span class="tok-kw">const</span> from_a = from[A_index..A_last];</span>
<span class="line" id="L1009">                <span class="tok-builtin">@memcpy</span>(into[insert_index..][<span class="tok-number">0</span>..from_a.len], from_a);</span>
<span class="line" id="L1010">                <span class="tok-kw">break</span>;</span>
<span class="line" id="L1011">            }</span>
<span class="line" id="L1012">        }</span>
<span class="line" id="L1013">    }</span>
<span class="line" id="L1014">}</span>
<span class="line" id="L1015"></span>
<span class="line" id="L1016"><span class="tok-kw">fn</span> <span class="tok-fn">mergeExternal</span>(</span>
<span class="line" id="L1017">    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,</span>
<span class="line" id="L1018">    items: []T,</span>
<span class="line" id="L1019">    A: Range,</span>
<span class="line" id="L1020">    B: Range,</span>
<span class="line" id="L1021">    cache: []T,</span>
<span class="line" id="L1022">    context: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L1023">    <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,</span>
<span class="line" id="L1024">) <span class="tok-type">void</span> {</span>
<span class="line" id="L1025">    <span class="tok-comment">// A fits into the cache, so use that instead of the internal buffer</span>
</span>
<span class="line" id="L1026">    <span class="tok-kw">var</span> A_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1027">    <span class="tok-kw">var</span> B_index: <span class="tok-type">usize</span> = B.start;</span>
<span class="line" id="L1028">    <span class="tok-kw">var</span> insert_index: <span class="tok-type">usize</span> = A.start;</span>
<span class="line" id="L1029">    <span class="tok-kw">const</span> A_last = A.length();</span>
<span class="line" id="L1030">    <span class="tok-kw">const</span> B_last = B.end;</span>
<span class="line" id="L1031"></span>
<span class="line" id="L1032">    <span class="tok-kw">if</span> (B.length() &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> A.length() &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L1033">        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L1034">            <span class="tok-kw">if</span> (!lessThan(context, items[B_index], cache[A_index])) {</span>
<span class="line" id="L1035">                items[insert_index] = cache[A_index];</span>
<span class="line" id="L1036">                A_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L1037">                insert_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L1038">                <span class="tok-kw">if</span> (A_index == A_last) <span class="tok-kw">break</span>;</span>
<span class="line" id="L1039">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1040">                items[insert_index] = items[B_index];</span>
<span class="line" id="L1041">                B_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L1042">                insert_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L1043">                <span class="tok-kw">if</span> (B_index == B_last) <span class="tok-kw">break</span>;</span>
<span class="line" id="L1044">            }</span>
<span class="line" id="L1045">        }</span>
<span class="line" id="L1046">    }</span>
<span class="line" id="L1047"></span>
<span class="line" id="L1048">    <span class="tok-comment">// copy the remainder of A into the final array</span>
</span>
<span class="line" id="L1049">    <span class="tok-kw">const</span> cache_a = cache[A_index..A_last];</span>
<span class="line" id="L1050">    <span class="tok-builtin">@memcpy</span>(items[insert_index..][<span class="tok-number">0</span>..cache_a.len], cache_a);</span>
<span class="line" id="L1051">}</span>
<span class="line" id="L1052"></span>
<span class="line" id="L1053"><span class="tok-kw">fn</span> <span class="tok-fn">swap</span>(</span>
<span class="line" id="L1054">    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,</span>
<span class="line" id="L1055">    items: []T,</span>
<span class="line" id="L1056">    order: *[<span class="tok-number">8</span>]<span class="tok-type">u8</span>,</span>
<span class="line" id="L1057">    x: <span class="tok-type">usize</span>,</span>
<span class="line" id="L1058">    y: <span class="tok-type">usize</span>,</span>
<span class="line" id="L1059">    context: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L1060">    <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,</span>
<span class="line" id="L1061">) <span class="tok-type">void</span> {</span>
<span class="line" id="L1062">    <span class="tok-kw">if</span> (lessThan(context, items[y], items[x]) <span class="tok-kw">or</span> ((order.*)[x] &gt; (order.*)[y] <span class="tok-kw">and</span> !lessThan(context, items[x], items[y]))) {</span>
<span class="line" id="L1063">        mem.swap(T, &amp;items[x], &amp;items[y]);</span>
<span class="line" id="L1064">        mem.swap(<span class="tok-type">u8</span>, &amp;(order.*)[x], &amp;(order.*)[y]);</span>
<span class="line" id="L1065">    }</span>
<span class="line" id="L1066">}</span>
<span class="line" id="L1067"></span>
</code></pre></body>
</html>