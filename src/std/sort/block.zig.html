<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>sort/block.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAPNJREFUeNpi/P//PwMlgOXHUjly9E0G4hwgZmQiQZMqEK8H4v9QzUEgQSaoADK+zhH9iAGL+C0gDoAaNg9mGLoLfgA1awK9hS9gzgJxA9RQBmQDrgMxJzRMGKE4HYj/Ial5A8QmQLwCJoBsgBYW2+TR1ChDaWt4LOBxKsi/VUh8XiD+gq4IVyzwQAMJBoKwacZlAB8Qf0bi96IZhtOAe1D6LpqaEiz6rmEzQAeIzwGxCJpieFqApo/vQKyJboAaEBsAsSEupwI1MwKjGBTVHOhegMX5UajYRqiBjMgYmj400cVh0XgTiKdC0zhJgJHS7AwQYABm9EAdCKrEfAAAAABJRU5ErkJggg=="/>
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);</span>
<span class="line" id="L2"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;../std.zig&quot;</span>);</span>
<span class="line" id="L3"><span class="tok-kw">const</span> sort = std.sort;</span>
<span class="line" id="L4"><span class="tok-kw">const</span> math = std.math;</span>
<span class="line" id="L5"><span class="tok-kw">const</span> mem = std.mem;</span>
<span class="line" id="L6"></span>
<span class="line" id="L7"><span class="tok-kw">const</span> Range = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L8">    start: <span class="tok-type">usize</span>,</span>
<span class="line" id="L9">    end: <span class="tok-type">usize</span>,</span>
<span class="line" id="L10"></span>
<span class="line" id="L11">    <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(start: <span class="tok-type">usize</span>, end: <span class="tok-type">usize</span>) Range {</span>
<span class="line" id="L12">        <span class="tok-kw">return</span> Range{</span>
<span class="line" id="L13">            .start = start,</span>
<span class="line" id="L14">            .end = end,</span>
<span class="line" id="L15">        };</span>
<span class="line" id="L16">    }</span>
<span class="line" id="L17"></span>
<span class="line" id="L18">    <span class="tok-kw">fn</span> <span class="tok-fn">length</span>(self: Range) <span class="tok-type">usize</span> {</span>
<span class="line" id="L19">        <span class="tok-kw">return</span> self.end - self.start;</span>
<span class="line" id="L20">    }</span>
<span class="line" id="L21">};</span>
<span class="line" id="L22"></span>
<span class="line" id="L23"><span class="tok-kw">const</span> Iterator = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L24">    size: <span class="tok-type">usize</span>,</span>
<span class="line" id="L25">    power_of_two: <span class="tok-type">usize</span>,</span>
<span class="line" id="L26">    numerator: <span class="tok-type">usize</span>,</span>
<span class="line" id="L27">    decimal: <span class="tok-type">usize</span>,</span>
<span class="line" id="L28">    denominator: <span class="tok-type">usize</span>,</span>
<span class="line" id="L29">    decimal_step: <span class="tok-type">usize</span>,</span>
<span class="line" id="L30">    numerator_step: <span class="tok-type">usize</span>,</span>
<span class="line" id="L31"></span>
<span class="line" id="L32">    <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(size2: <span class="tok-type">usize</span>, min_level: <span class="tok-type">usize</span>) Iterator {</span>
<span class="line" id="L33">        <span class="tok-kw">const</span> power_of_two = math.floorPowerOfTwo(<span class="tok-type">usize</span>, size2);</span>
<span class="line" id="L34">        <span class="tok-kw">const</span> denominator = power_of_two / min_level;</span>
<span class="line" id="L35">        <span class="tok-kw">return</span> Iterator{</span>
<span class="line" id="L36">            .numerator = <span class="tok-number">0</span>,</span>
<span class="line" id="L37">            .decimal = <span class="tok-number">0</span>,</span>
<span class="line" id="L38">            .size = size2,</span>
<span class="line" id="L39">            .power_of_two = power_of_two,</span>
<span class="line" id="L40">            .denominator = denominator,</span>
<span class="line" id="L41">            .decimal_step = size2 / denominator,</span>
<span class="line" id="L42">            .numerator_step = size2 % denominator,</span>
<span class="line" id="L43">        };</span>
<span class="line" id="L44">    }</span>
<span class="line" id="L45"></span>
<span class="line" id="L46">    <span class="tok-kw">fn</span> <span class="tok-fn">begin</span>(self: *Iterator) <span class="tok-type">void</span> {</span>
<span class="line" id="L47">        self.numerator = <span class="tok-number">0</span>;</span>
<span class="line" id="L48">        self.decimal = <span class="tok-number">0</span>;</span>
<span class="line" id="L49">    }</span>
<span class="line" id="L50"></span>
<span class="line" id="L51">    <span class="tok-kw">fn</span> <span class="tok-fn">nextRange</span>(self: *Iterator) Range {</span>
<span class="line" id="L52">        <span class="tok-kw">const</span> start = self.decimal;</span>
<span class="line" id="L53"></span>
<span class="line" id="L54">        self.decimal += self.decimal_step;</span>
<span class="line" id="L55">        self.numerator += self.numerator_step;</span>
<span class="line" id="L56">        <span class="tok-kw">if</span> (self.numerator &gt;= self.denominator) {</span>
<span class="line" id="L57">            self.numerator -= self.denominator;</span>
<span class="line" id="L58">            self.decimal += <span class="tok-number">1</span>;</span>
<span class="line" id="L59">        }</span>
<span class="line" id="L60"></span>
<span class="line" id="L61">        <span class="tok-kw">return</span> Range{</span>
<span class="line" id="L62">            .start = start,</span>
<span class="line" id="L63">            .end = self.decimal,</span>
<span class="line" id="L64">        };</span>
<span class="line" id="L65">    }</span>
<span class="line" id="L66"></span>
<span class="line" id="L67">    <span class="tok-kw">fn</span> <span class="tok-fn">finished</span>(self: *Iterator) <span class="tok-type">bool</span> {</span>
<span class="line" id="L68">        <span class="tok-kw">return</span> self.decimal &gt;= self.size;</span>
<span class="line" id="L69">    }</span>
<span class="line" id="L70"></span>
<span class="line" id="L71">    <span class="tok-kw">fn</span> <span class="tok-fn">nextLevel</span>(self: *Iterator) <span class="tok-type">bool</span> {</span>
<span class="line" id="L72">        self.decimal_step += self.decimal_step;</span>
<span class="line" id="L73">        self.numerator_step += self.numerator_step;</span>
<span class="line" id="L74">        <span class="tok-kw">if</span> (self.numerator_step &gt;= self.denominator) {</span>
<span class="line" id="L75">            self.numerator_step -= self.denominator;</span>
<span class="line" id="L76">            self.decimal_step += <span class="tok-number">1</span>;</span>
<span class="line" id="L77">        }</span>
<span class="line" id="L78"></span>
<span class="line" id="L79">        <span class="tok-kw">return</span> (self.decimal_step &lt; self.size);</span>
<span class="line" id="L80">    }</span>
<span class="line" id="L81"></span>
<span class="line" id="L82">    <span class="tok-kw">fn</span> <span class="tok-fn">length</span>(self: *Iterator) <span class="tok-type">usize</span> {</span>
<span class="line" id="L83">        <span class="tok-kw">return</span> self.decimal_step;</span>
<span class="line" id="L84">    }</span>
<span class="line" id="L85">};</span>
<span class="line" id="L86"></span>
<span class="line" id="L87"><span class="tok-kw">const</span> Pull = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L88">    from: <span class="tok-type">usize</span>,</span>
<span class="line" id="L89">    to: <span class="tok-type">usize</span>,</span>
<span class="line" id="L90">    count: <span class="tok-type">usize</span>,</span>
<span class="line" id="L91">    range: Range,</span>
<span class="line" id="L92">};</span>
<span class="line" id="L93"></span>
<span class="line" id="L94"><span class="tok-comment">/// Stable in-place sort. O(n) best case, O(n*log(n)) worst case and average case.</span></span>
<span class="line" id="L95"><span class="tok-comment">/// O(1) memory (no allocator required).</span></span>
<span class="line" id="L96"><span class="tok-comment">/// Sorts in ascending order with respect to the given `lessThan` function.</span></span>
<span class="line" id="L97"><span class="tok-comment">///</span></span>
<span class="line" id="L98"><span class="tok-comment">/// NOTE: the algorithm only work when the comparison is less-than or greater-than</span></span>
<span class="line" id="L99"><span class="tok-comment">///       (See https://github.com/ziglang/zig/issues/8289)</span></span>
<span class="line" id="L100"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">block</span>(</span>
<span class="line" id="L101">    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,</span>
<span class="line" id="L102">    items: []T,</span>
<span class="line" id="L103">    context: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L104">    <span class="tok-kw">comptime</span> lessThanFn: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,</span>
<span class="line" id="L105">) <span class="tok-type">void</span> {</span>
<span class="line" id="L106">    <span class="tok-kw">const</span> lessThan = <span class="tok-kw">if</span> (builtin.mode == .Debug) <span class="tok-kw">struct</span> {</span>
<span class="line" id="L107">        <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(ctx: <span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span> {</span>
<span class="line" id="L108">            <span class="tok-kw">const</span> lt = lessThanFn(ctx, lhs, rhs);</span>
<span class="line" id="L109">            <span class="tok-kw">const</span> gt = lessThanFn(ctx, rhs, lhs);</span>
<span class="line" id="L110">            std.debug.assert(!(lt <span class="tok-kw">and</span> gt));</span>
<span class="line" id="L111">            <span class="tok-kw">return</span> lt;</span>
<span class="line" id="L112">        }</span>
<span class="line" id="L113">    }.lessThan <span class="tok-kw">else</span> lessThanFn;</span>
<span class="line" id="L114"></span>
<span class="line" id="L115">    <span class="tok-comment">// Implementation ported from https://github.com/BonzaiThePenguin/WikiSort/blob/master/WikiSort.c</span>
</span>
<span class="line" id="L116">    <span class="tok-kw">var</span> cache: [<span class="tok-number">512</span>]T = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L117"></span>
<span class="line" id="L118">    <span class="tok-kw">if</span> (items.len &lt; <span class="tok-number">4</span>) {</span>
<span class="line" id="L119">        <span class="tok-kw">if</span> (items.len == <span class="tok-number">3</span>) {</span>
<span class="line" id="L120">            <span class="tok-comment">// hard coded insertion sort</span>
</span>
<span class="line" id="L121">            <span class="tok-kw">if</span> (lessThan(context, items[<span class="tok-number">1</span>], items[<span class="tok-number">0</span>])) mem.swap(T, &amp;items[<span class="tok-number">0</span>], &amp;items[<span class="tok-number">1</span>]);</span>
<span class="line" id="L122">            <span class="tok-kw">if</span> (lessThan(context, items[<span class="tok-number">2</span>], items[<span class="tok-number">1</span>])) {</span>
<span class="line" id="L123">                mem.swap(T, &amp;items[<span class="tok-number">1</span>], &amp;items[<span class="tok-number">2</span>]);</span>
<span class="line" id="L124">                <span class="tok-kw">if</span> (lessThan(context, items[<span class="tok-number">1</span>], items[<span class="tok-number">0</span>])) mem.swap(T, &amp;items[<span class="tok-number">0</span>], &amp;items[<span class="tok-number">1</span>]);</span>
<span class="line" id="L125">            }</span>
<span class="line" id="L126">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (items.len == <span class="tok-number">2</span>) {</span>
<span class="line" id="L127">            <span class="tok-kw">if</span> (lessThan(context, items[<span class="tok-number">1</span>], items[<span class="tok-number">0</span>])) mem.swap(T, &amp;items[<span class="tok-number">0</span>], &amp;items[<span class="tok-number">1</span>]);</span>
<span class="line" id="L128">        }</span>
<span class="line" id="L129">        <span class="tok-kw">return</span>;</span>
<span class="line" id="L130">    }</span>
<span class="line" id="L131"></span>
<span class="line" id="L132">    <span class="tok-comment">// sort groups of 4-8 items at a time using an unstable sorting network,</span>
</span>
<span class="line" id="L133">    <span class="tok-comment">// but keep track of the original item orders to force it to be stable</span>
</span>
<span class="line" id="L134">    <span class="tok-comment">// http://pages.ripco.net/~jgamble/nw.html</span>
</span>
<span class="line" id="L135">    <span class="tok-kw">var</span> iterator = Iterator.init(items.len, <span class="tok-number">4</span>);</span>
<span class="line" id="L136">    <span class="tok-kw">while</span> (!iterator.finished()) {</span>
<span class="line" id="L137">        <span class="tok-kw">var</span> order = [_]<span class="tok-type">u8</span>{ <span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span> };</span>
<span class="line" id="L138">        <span class="tok-kw">const</span> range = iterator.nextRange();</span>
<span class="line" id="L139"></span>
<span class="line" id="L140">        <span class="tok-kw">const</span> sliced_items = items[range.start..];</span>
<span class="line" id="L141">        <span class="tok-kw">switch</span> (range.length()) {</span>
<span class="line" id="L142">            <span class="tok-number">8</span> =&gt; {</span>
<span class="line" id="L143">                swap(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">1</span>, context, lessThan);</span>
<span class="line" id="L144">                swap(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">3</span>, context, lessThan);</span>
<span class="line" id="L145">                swap(T, sliced_items, &amp;order, <span class="tok-number">4</span>, <span class="tok-number">5</span>, context, lessThan);</span>
<span class="line" id="L146">                swap(T, sliced_items, &amp;order, <span class="tok-number">6</span>, <span class="tok-number">7</span>, context, lessThan);</span>
<span class="line" id="L147">                swap(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">2</span>, context, lessThan);</span>
<span class="line" id="L148">                swap(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">3</span>, context, lessThan);</span>
<span class="line" id="L149">                swap(T, sliced_items, &amp;order, <span class="tok-number">4</span>, <span class="tok-number">6</span>, context, lessThan);</span>
<span class="line" id="L150">                swap(T, sliced_items, &amp;order, <span class="tok-number">5</span>, <span class="tok-number">7</span>, context, lessThan);</span>
<span class="line" id="L151">                swap(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">2</span>, context, lessThan);</span>
<span class="line" id="L152">                swap(T, sliced_items, &amp;order, <span class="tok-number">5</span>, <span class="tok-number">6</span>, context, lessThan);</span>
<span class="line" id="L153">                swap(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">4</span>, context, lessThan);</span>
<span class="line" id="L154">                swap(T, sliced_items, &amp;order, <span class="tok-number">3</span>, <span class="tok-number">7</span>, context, lessThan);</span>
<span class="line" id="L155">                swap(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">5</span>, context, lessThan);</span>
<span class="line" id="L156">                swap(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">6</span>, context, lessThan);</span>
<span class="line" id="L157">                swap(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">4</span>, context, lessThan);</span>
<span class="line" id="L158">                swap(T, sliced_items, &amp;order, <span class="tok-number">3</span>, <span class="tok-number">6</span>, context, lessThan);</span>
<span class="line" id="L159">                swap(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">4</span>, context, lessThan);</span>
<span class="line" id="L160">                swap(T, sliced_items, &amp;order, <span class="tok-number">3</span>, <span class="tok-number">5</span>, context, lessThan);</span>
<span class="line" id="L161">                swap(T, sliced_items, &amp;order, <span class="tok-number">3</span>, <span class="tok-number">4</span>, context, lessThan);</span>
<span class="line" id="L162">            },</span>
<span class="line" id="L163">            <span class="tok-number">7</span> =&gt; {</span>
<span class="line" id="L164">                swap(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">2</span>, context, lessThan);</span>
<span class="line" id="L165">                swap(T, sliced_items, &amp;order, <span class="tok-number">3</span>, <span class="tok-number">4</span>, context, lessThan);</span>
<span class="line" id="L166">                swap(T, sliced_items, &amp;order, <span class="tok-number">5</span>, <span class="tok-number">6</span>, context, lessThan);</span>
<span class="line" id="L167">                swap(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">2</span>, context, lessThan);</span>
<span class="line" id="L168">                swap(T, sliced_items, &amp;order, <span class="tok-number">3</span>, <span class="tok-number">5</span>, context, lessThan);</span>
<span class="line" id="L169">                swap(T, sliced_items, &amp;order, <span class="tok-number">4</span>, <span class="tok-number">6</span>, context, lessThan);</span>
<span class="line" id="L170">                swap(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">1</span>, context, lessThan);</span>
<span class="line" id="L171">                swap(T, sliced_items, &amp;order, <span class="tok-number">4</span>, <span class="tok-number">5</span>, context, lessThan);</span>
<span class="line" id="L172">                swap(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">6</span>, context, lessThan);</span>
<span class="line" id="L173">                swap(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">4</span>, context, lessThan);</span>
<span class="line" id="L174">                swap(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">5</span>, context, lessThan);</span>
<span class="line" id="L175">                swap(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">3</span>, context, lessThan);</span>
<span class="line" id="L176">                swap(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">5</span>, context, lessThan);</span>
<span class="line" id="L177">                swap(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">3</span>, context, lessThan);</span>
<span class="line" id="L178">                swap(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">4</span>, context, lessThan);</span>
<span class="line" id="L179">                swap(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">3</span>, context, lessThan);</span>
<span class="line" id="L180">            },</span>
<span class="line" id="L181">            <span class="tok-number">6</span> =&gt; {</span>
<span class="line" id="L182">                swap(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">2</span>, context, lessThan);</span>
<span class="line" id="L183">                swap(T, sliced_items, &amp;order, <span class="tok-number">4</span>, <span class="tok-number">5</span>, context, lessThan);</span>
<span class="line" id="L184">                swap(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">2</span>, context, lessThan);</span>
<span class="line" id="L185">                swap(T, sliced_items, &amp;order, <span class="tok-number">3</span>, <span class="tok-number">5</span>, context, lessThan);</span>
<span class="line" id="L186">                swap(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">1</span>, context, lessThan);</span>
<span class="line" id="L187">                swap(T, sliced_items, &amp;order, <span class="tok-number">3</span>, <span class="tok-number">4</span>, context, lessThan);</span>
<span class="line" id="L188">                swap(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">5</span>, context, lessThan);</span>
<span class="line" id="L189">                swap(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">3</span>, context, lessThan);</span>
<span class="line" id="L190">                swap(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">4</span>, context, lessThan);</span>
<span class="line" id="L191">                swap(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">4</span>, context, lessThan);</span>
<span class="line" id="L192">                swap(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">3</span>, context, lessThan);</span>
<span class="line" id="L193">                swap(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">3</span>, context, lessThan);</span>
<span class="line" id="L194">            },</span>
<span class="line" id="L195">            <span class="tok-number">5</span> =&gt; {</span>
<span class="line" id="L196">                swap(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">1</span>, context, lessThan);</span>
<span class="line" id="L197">                swap(T, sliced_items, &amp;order, <span class="tok-number">3</span>, <span class="tok-number">4</span>, context, lessThan);</span>
<span class="line" id="L198">                swap(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">4</span>, context, lessThan);</span>
<span class="line" id="L199">                swap(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">3</span>, context, lessThan);</span>
<span class="line" id="L200">                swap(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">4</span>, context, lessThan);</span>
<span class="line" id="L201">                swap(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">3</span>, context, lessThan);</span>
<span class="line" id="L202">                swap(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">2</span>, context, lessThan);</span>
<span class="line" id="L203">                swap(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">3</span>, context, lessThan);</span>
<span class="line" id="L204">                swap(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">2</span>, context, lessThan);</span>
<span class="line" id="L205">            },</span>
<span class="line" id="L206">            <span class="tok-number">4</span> =&gt; {</span>
<span class="line" id="L207">                swap(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">1</span>, context, lessThan);</span>
<span class="line" id="L208">                swap(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">3</span>, context, lessThan);</span>
<span class="line" id="L209">                swap(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">2</span>, context, lessThan);</span>
<span class="line" id="L210">                swap(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">3</span>, context, lessThan);</span>
<span class="line" id="L211">                swap(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">2</span>, context, lessThan);</span>
<span class="line" id="L212">            },</span>
<span class="line" id="L213">            <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L214">        }</span>
<span class="line" id="L215">    }</span>
<span class="line" id="L216">    <span class="tok-kw">if</span> (items.len &lt; <span class="tok-number">8</span>) <span class="tok-kw">return</span>;</span>
<span class="line" id="L217"></span>
<span class="line" id="L218">    <span class="tok-comment">// then merge sort the higher levels, which can be 8-15, 16-31, 32-63, 64-127, etc.</span>
</span>
<span class="line" id="L219">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L220">        <span class="tok-comment">// if every A and B block will fit into the cache, use a special branch</span>
</span>
<span class="line" id="L221">        <span class="tok-comment">// specifically for merging with the cache</span>
</span>
<span class="line" id="L222">        <span class="tok-comment">// (we use &lt; rather than &lt;= since the block size might be one more than</span>
</span>
<span class="line" id="L223">        <span class="tok-comment">// iterator.length())</span>
</span>
<span class="line" id="L224">        <span class="tok-kw">if</span> (iterator.length() &lt; cache.len) {</span>
<span class="line" id="L225">            <span class="tok-comment">// if four subarrays fit into the cache, it's faster to merge both</span>
</span>
<span class="line" id="L226">            <span class="tok-comment">// pairs of subarrays into the cache,</span>
</span>
<span class="line" id="L227">            <span class="tok-comment">// then merge the two merged subarrays from the cache back into the original array</span>
</span>
<span class="line" id="L228">            <span class="tok-kw">if</span> ((iterator.length() + <span class="tok-number">1</span>) * <span class="tok-number">4</span> &lt;= cache.len <span class="tok-kw">and</span> iterator.length() * <span class="tok-number">4</span> &lt;= items.len) {</span>
<span class="line" id="L229">                iterator.begin();</span>
<span class="line" id="L230">                <span class="tok-kw">while</span> (!iterator.finished()) {</span>
<span class="line" id="L231">                    <span class="tok-comment">// merge A1 and B1 into the cache</span>
</span>
<span class="line" id="L232">                    <span class="tok-kw">var</span> A1 = iterator.nextRange();</span>
<span class="line" id="L233">                    <span class="tok-kw">var</span> B1 = iterator.nextRange();</span>
<span class="line" id="L234">                    <span class="tok-kw">var</span> A2 = iterator.nextRange();</span>
<span class="line" id="L235">                    <span class="tok-kw">var</span> B2 = iterator.nextRange();</span>
<span class="line" id="L236"></span>
<span class="line" id="L237">                    <span class="tok-kw">if</span> (lessThan(context, items[B1.end - <span class="tok-number">1</span>], items[A1.start])) {</span>
<span class="line" id="L238">                        <span class="tok-comment">// the two ranges are in reverse order, so copy them in reverse order into the cache</span>
</span>
<span class="line" id="L239">                        <span class="tok-kw">const</span> a1_items = items[A1.start..A1.end];</span>
<span class="line" id="L240">                        <span class="tok-builtin">@memcpy</span>(cache[B1.length()..][<span class="tok-number">0</span>..a1_items.len], a1_items);</span>
<span class="line" id="L241">                        <span class="tok-kw">const</span> b1_items = items[B1.start..B1.end];</span>
<span class="line" id="L242">                        <span class="tok-builtin">@memcpy</span>(cache[<span class="tok-number">0</span>..b1_items.len], b1_items);</span>
<span class="line" id="L243">                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (lessThan(context, items[B1.start], items[A1.end - <span class="tok-number">1</span>])) {</span>
<span class="line" id="L244">                        <span class="tok-comment">// these two ranges weren't already in order, so merge them into the cache</span>
</span>
<span class="line" id="L245">                        mergeInto(T, items, A1, B1, cache[<span class="tok-number">0</span>..], context, lessThan);</span>
<span class="line" id="L246">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L247">                        <span class="tok-comment">// if A1, B1, A2, and B2 are all in order, skip doing anything else</span>
</span>
<span class="line" id="L248">                        <span class="tok-kw">if</span> (!lessThan(context, items[B2.start], items[A2.end - <span class="tok-number">1</span>]) <span class="tok-kw">and</span> !lessThan(context, items[A2.start], items[B1.end - <span class="tok-number">1</span>])) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L249"></span>
<span class="line" id="L250">                        <span class="tok-comment">// copy A1 and B1 into the cache in the same order</span>
</span>
<span class="line" id="L251">                        <span class="tok-kw">const</span> a1_items = items[A1.start..A1.end];</span>
<span class="line" id="L252">                        <span class="tok-builtin">@memcpy</span>(cache[<span class="tok-number">0</span>..a1_items.len], a1_items);</span>
<span class="line" id="L253">                        <span class="tok-kw">const</span> b1_items = items[B1.start..B1.end];</span>
<span class="line" id="L254">                        <span class="tok-builtin">@memcpy</span>(cache[A1.length()..][<span class="tok-number">0</span>..b1_items.len], b1_items);</span>
<span class="line" id="L255">                    }</span>
<span class="line" id="L256">                    A1 = Range.init(A1.start, B1.end);</span>
<span class="line" id="L257"></span>
<span class="line" id="L258">                    <span class="tok-comment">// merge A2 and B2 into the cache</span>
</span>
<span class="line" id="L259">                    <span class="tok-kw">if</span> (lessThan(context, items[B2.end - <span class="tok-number">1</span>], items[A2.start])) {</span>
<span class="line" id="L260">                        <span class="tok-comment">// the two ranges are in reverse order, so copy them in reverse order into the cache</span>
</span>
<span class="line" id="L261">                        <span class="tok-kw">const</span> a2_items = items[A2.start..A2.end];</span>
<span class="line" id="L262">                        <span class="tok-builtin">@memcpy</span>(cache[A1.length() + B2.length() ..][<span class="tok-number">0</span>..a2_items.len], a2_items);</span>
<span class="line" id="L263">                        <span class="tok-kw">const</span> b2_items = items[B2.start..B2.end];</span>
<span class="line" id="L264">                        <span class="tok-builtin">@memcpy</span>(cache[A1.length()..][<span class="tok-number">0</span>..b2_items.len], b2_items);</span>
<span class="line" id="L265">                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (lessThan(context, items[B2.start], items[A2.end - <span class="tok-number">1</span>])) {</span>
<span class="line" id="L266">                        <span class="tok-comment">// these two ranges weren't already in order, so merge them into the cache</span>
</span>
<span class="line" id="L267">                        mergeInto(T, items, A2, B2, cache[A1.length()..], context, lessThan);</span>
<span class="line" id="L268">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L269">                        <span class="tok-comment">// copy A2 and B2 into the cache in the same order</span>
</span>
<span class="line" id="L270">                        <span class="tok-kw">const</span> a2_items = items[A2.start..A2.end];</span>
<span class="line" id="L271">                        <span class="tok-builtin">@memcpy</span>(cache[A1.length()..][<span class="tok-number">0</span>..a2_items.len], a2_items);</span>
<span class="line" id="L272">                        <span class="tok-kw">const</span> b2_items = items[B2.start..B2.end];</span>
<span class="line" id="L273">                        <span class="tok-builtin">@memcpy</span>(cache[A1.length() + A2.length() ..][<span class="tok-number">0</span>..b2_items.len], b2_items);</span>
<span class="line" id="L274">                    }</span>
<span class="line" id="L275">                    A2 = Range.init(A2.start, B2.end);</span>
<span class="line" id="L276"></span>
<span class="line" id="L277">                    <span class="tok-comment">// merge A1 and A2 from the cache into the items</span>
</span>
<span class="line" id="L278">                    <span class="tok-kw">const</span> A3 = Range.init(<span class="tok-number">0</span>, A1.length());</span>
<span class="line" id="L279">                    <span class="tok-kw">const</span> B3 = Range.init(A1.length(), A1.length() + A2.length());</span>
<span class="line" id="L280"></span>
<span class="line" id="L281">                    <span class="tok-kw">if</span> (lessThan(context, cache[B3.end - <span class="tok-number">1</span>], cache[A3.start])) {</span>
<span class="line" id="L282">                        <span class="tok-comment">// the two ranges are in reverse order, so copy them in reverse order into the items</span>
</span>
<span class="line" id="L283">                        <span class="tok-kw">const</span> a3_items = cache[A3.start..A3.end];</span>
<span class="line" id="L284">                        <span class="tok-builtin">@memcpy</span>(items[A1.start + A2.length() ..][<span class="tok-number">0</span>..a3_items.len], a3_items);</span>
<span class="line" id="L285">                        <span class="tok-kw">const</span> b3_items = cache[B3.start..B3.end];</span>
<span class="line" id="L286">                        <span class="tok-builtin">@memcpy</span>(items[A1.start..][<span class="tok-number">0</span>..b3_items.len], b3_items);</span>
<span class="line" id="L287">                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (lessThan(context, cache[B3.start], cache[A3.end - <span class="tok-number">1</span>])) {</span>
<span class="line" id="L288">                        <span class="tok-comment">// these two ranges weren't already in order, so merge them back into the items</span>
</span>
<span class="line" id="L289">                        mergeInto(T, cache[<span class="tok-number">0</span>..], A3, B3, items[A1.start..], context, lessThan);</span>
<span class="line" id="L290">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L291">                        <span class="tok-comment">// copy A3 and B3 into the items in the same order</span>
</span>
<span class="line" id="L292">                        <span class="tok-kw">const</span> a3_items = cache[A3.start..A3.end];</span>
<span class="line" id="L293">                        <span class="tok-builtin">@memcpy</span>(items[A1.start..][<span class="tok-number">0</span>..a3_items.len], a3_items);</span>
<span class="line" id="L294">                        <span class="tok-kw">const</span> b3_items = cache[B3.start..B3.end];</span>
<span class="line" id="L295">                        <span class="tok-builtin">@memcpy</span>(items[A1.start + A1.length() ..][<span class="tok-number">0</span>..b3_items.len], b3_items);</span>
<span class="line" id="L296">                    }</span>
<span class="line" id="L297">                }</span>
<span class="line" id="L298"></span>
<span class="line" id="L299">                <span class="tok-comment">// we merged two levels at the same time, so we're done with this level already</span>
</span>
<span class="line" id="L300">                <span class="tok-comment">// (iterator.nextLevel() is called again at the bottom of this outer merge loop)</span>
</span>
<span class="line" id="L301">                _ = iterator.nextLevel();</span>
<span class="line" id="L302">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L303">                iterator.begin();</span>
<span class="line" id="L304">                <span class="tok-kw">while</span> (!iterator.finished()) {</span>
<span class="line" id="L305">                    <span class="tok-kw">var</span> A = iterator.nextRange();</span>
<span class="line" id="L306">                    <span class="tok-kw">var</span> B = iterator.nextRange();</span>
<span class="line" id="L307"></span>
<span class="line" id="L308">                    <span class="tok-kw">if</span> (lessThan(context, items[B.end - <span class="tok-number">1</span>], items[A.start])) {</span>
<span class="line" id="L309">                        <span class="tok-comment">// the two ranges are in reverse order, so a simple rotation should fix it</span>
</span>
<span class="line" id="L310">                        mem.rotate(T, items[A.start..B.end], A.length());</span>
<span class="line" id="L311">                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (lessThan(context, items[B.start], items[A.end - <span class="tok-number">1</span>])) {</span>
<span class="line" id="L312">                        <span class="tok-comment">// these two ranges weren't already in order, so we'll need to merge them!</span>
</span>
<span class="line" id="L313">                        <span class="tok-kw">const</span> a_items = items[A.start..A.end];</span>
<span class="line" id="L314">                        <span class="tok-builtin">@memcpy</span>(cache[<span class="tok-number">0</span>..a_items.len], a_items);</span>
<span class="line" id="L315">                        mergeExternal(T, items, A, B, cache[<span class="tok-number">0</span>..], context, lessThan);</span>
<span class="line" id="L316">                    }</span>
<span class="line" id="L317">                }</span>
<span class="line" id="L318">            }</span>
<span class="line" id="L319">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L320">            <span class="tok-comment">// this is where the in-place merge logic starts!</span>
</span>
<span class="line" id="L321">            <span class="tok-comment">// 1. pull out two internal buffers each containing √A unique values</span>
</span>
<span class="line" id="L322">            <span class="tok-comment">//    1a. adjust block_size and buffer_size if we couldn't find enough unique values</span>
</span>
<span class="line" id="L323">            <span class="tok-comment">// 2. loop over the A and B subarrays within this level of the merge sort</span>
</span>
<span class="line" id="L324">            <span class="tok-comment">// 3. break A and B into blocks of size 'block_size'</span>
</span>
<span class="line" id="L325">            <span class="tok-comment">// 4. &quot;tag&quot; each of the A blocks with values from the first internal buffer</span>
</span>
<span class="line" id="L326">            <span class="tok-comment">// 5. roll the A blocks through the B blocks and drop/rotate them where they belong</span>
</span>
<span class="line" id="L327">            <span class="tok-comment">// 6. merge each A block with any B values that follow, using the cache or the second internal buffer</span>
</span>
<span class="line" id="L328">            <span class="tok-comment">// 7. sort the second internal buffer if it exists</span>
</span>
<span class="line" id="L329">            <span class="tok-comment">// 8. redistribute the two internal buffers back into the items</span>
</span>
<span class="line" id="L330">            <span class="tok-kw">var</span> block_size: <span class="tok-type">usize</span> = math.sqrt(iterator.length());</span>
<span class="line" id="L331">            <span class="tok-kw">var</span> buffer_size = iterator.length() / block_size + <span class="tok-number">1</span>;</span>
<span class="line" id="L332"></span>
<span class="line" id="L333">            <span class="tok-comment">// as an optimization, we really only need to pull out the internal buffers once for each level of merges</span>
</span>
<span class="line" id="L334">            <span class="tok-comment">// after that we can reuse the same buffers over and over, then redistribute it when we're finished with this level</span>
</span>
<span class="line" id="L335">            <span class="tok-kw">var</span> A: Range = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L336">            <span class="tok-kw">var</span> B: Range = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L337">            <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L338">            <span class="tok-kw">var</span> last: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L339">            <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L340">            <span class="tok-kw">var</span> find: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L341">            <span class="tok-kw">var</span> start: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L342">            <span class="tok-kw">var</span> pull_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L343">            <span class="tok-kw">var</span> pull = [_]Pull{</span>
<span class="line" id="L344">                Pull{</span>
<span class="line" id="L345">                    .from = <span class="tok-number">0</span>,</span>
<span class="line" id="L346">                    .to = <span class="tok-number">0</span>,</span>
<span class="line" id="L347">                    .count = <span class="tok-number">0</span>,</span>
<span class="line" id="L348">                    .range = Range.init(<span class="tok-number">0</span>, <span class="tok-number">0</span>),</span>
<span class="line" id="L349">                },</span>
<span class="line" id="L350">                Pull{</span>
<span class="line" id="L351">                    .from = <span class="tok-number">0</span>,</span>
<span class="line" id="L352">                    .to = <span class="tok-number">0</span>,</span>
<span class="line" id="L353">                    .count = <span class="tok-number">0</span>,</span>
<span class="line" id="L354">                    .range = Range.init(<span class="tok-number">0</span>, <span class="tok-number">0</span>),</span>
<span class="line" id="L355">                },</span>
<span class="line" id="L356">            };</span>
<span class="line" id="L357"></span>
<span class="line" id="L358">            <span class="tok-kw">var</span> buffer1 = Range.init(<span class="tok-number">0</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L359">            <span class="tok-kw">var</span> buffer2 = Range.init(<span class="tok-number">0</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L360"></span>
<span class="line" id="L361">            <span class="tok-comment">// find two internal buffers of size 'buffer_size' each</span>
</span>
<span class="line" id="L362">            find = buffer_size + buffer_size;</span>
<span class="line" id="L363">            <span class="tok-kw">var</span> find_separately = <span class="tok-null">false</span>;</span>
<span class="line" id="L364"></span>
<span class="line" id="L365">            <span class="tok-kw">if</span> (block_size &lt;= cache.len) {</span>
<span class="line" id="L366">                <span class="tok-comment">// if every A block fits into the cache then we won't need the second internal buffer,</span>
</span>
<span class="line" id="L367">                <span class="tok-comment">// so we really only need to find 'buffer_size' unique values</span>
</span>
<span class="line" id="L368">                find = buffer_size;</span>
<span class="line" id="L369">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (find &gt; iterator.length()) {</span>
<span class="line" id="L370">                <span class="tok-comment">// we can't fit both buffers into the same A or B subarray, so find two buffers separately</span>
</span>
<span class="line" id="L371">                find = buffer_size;</span>
<span class="line" id="L372">                find_separately = <span class="tok-null">true</span>;</span>
<span class="line" id="L373">            }</span>
<span class="line" id="L374"></span>
<span class="line" id="L375">            <span class="tok-comment">// we need to find either a single contiguous space containing 2√A unique values (which will be split up into two buffers of size √A each),</span>
</span>
<span class="line" id="L376">            <span class="tok-comment">// or we need to find one buffer of &lt; 2√A unique values, and a second buffer of √A unique values,</span>
</span>
<span class="line" id="L377">            <span class="tok-comment">// OR if we couldn't find that many unique values, we need the largest possible buffer we can get</span>
</span>
<span class="line" id="L378"></span>
<span class="line" id="L379">            <span class="tok-comment">// in the case where it couldn't find a single buffer of at least √A unique values,</span>
</span>
<span class="line" id="L380">            <span class="tok-comment">// all of the Merge steps must be replaced by a different merge algorithm (MergeInPlace)</span>
</span>
<span class="line" id="L381">            iterator.begin();</span>
<span class="line" id="L382">            <span class="tok-kw">while</span> (!iterator.finished()) {</span>
<span class="line" id="L383">                A = iterator.nextRange();</span>
<span class="line" id="L384">                B = iterator.nextRange();</span>
<span class="line" id="L385"></span>
<span class="line" id="L386">                <span class="tok-comment">// just store information about where the values will be pulled from and to,</span>
</span>
<span class="line" id="L387">                <span class="tok-comment">// as well as how many values there are, to create the two internal buffers</span>
</span>
<span class="line" id="L388"></span>
<span class="line" id="L389">                <span class="tok-comment">// check A for the number of unique values we need to fill an internal buffer</span>
</span>
<span class="line" id="L390">                <span class="tok-comment">// these values will be pulled out to the start of A</span>
</span>
<span class="line" id="L391">                last = A.start;</span>
<span class="line" id="L392">                count = <span class="tok-number">1</span>;</span>
<span class="line" id="L393">                <span class="tok-kw">while</span> (count &lt; find) : ({</span>
<span class="line" id="L394">                    last = index;</span>
<span class="line" id="L395">                    count += <span class="tok-number">1</span>;</span>
<span class="line" id="L396">                }) {</span>
<span class="line" id="L397">                    index = findLastForward(T, items, items[last], Range.init(last + <span class="tok-number">1</span>, A.end), find - count, context, lessThan);</span>
<span class="line" id="L398">                    <span class="tok-kw">if</span> (index == A.end) <span class="tok-kw">break</span>;</span>
<span class="line" id="L399">                }</span>
<span class="line" id="L400">                index = last;</span>
<span class="line" id="L401"></span>
<span class="line" id="L402">                <span class="tok-kw">if</span> (count &gt;= buffer_size) {</span>
<span class="line" id="L403">                    <span class="tok-comment">// keep track of the range within the items where we'll need to &quot;pull out&quot; these values to create the internal buffer</span>
</span>
<span class="line" id="L404">                    pull[pull_index] = Pull{</span>
<span class="line" id="L405">                        .range = Range.init(A.start, B.end),</span>
<span class="line" id="L406">                        .count = count,</span>
<span class="line" id="L407">                        .from = index,</span>
<span class="line" id="L408">                        .to = A.start,</span>
<span class="line" id="L409">                    };</span>
<span class="line" id="L410">                    pull_index = <span class="tok-number">1</span>;</span>
<span class="line" id="L411"></span>
<span class="line" id="L412">                    <span class="tok-kw">if</span> (count == buffer_size + buffer_size) {</span>
<span class="line" id="L413">                        <span class="tok-comment">// we were able to find a single contiguous section containing 2√A unique values,</span>
</span>
<span class="line" id="L414">                        <span class="tok-comment">// so this section can be used to contain both of the internal buffers we'll need</span>
</span>
<span class="line" id="L415">                        buffer1 = Range.init(A.start, A.start + buffer_size);</span>
<span class="line" id="L416">                        buffer2 = Range.init(A.start + buffer_size, A.start + count);</span>
<span class="line" id="L417">                        <span class="tok-kw">break</span>;</span>
<span class="line" id="L418">                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (find == buffer_size + buffer_size) {</span>
<span class="line" id="L419">                        <span class="tok-comment">// we found a buffer that contains at least √A unique values, but did not contain the full 2√A unique values,</span>
</span>
<span class="line" id="L420">                        <span class="tok-comment">// so we still need to find a second separate buffer of at least √A unique values</span>
</span>
<span class="line" id="L421">                        buffer1 = Range.init(A.start, A.start + count);</span>
<span class="line" id="L422">                        find = buffer_size;</span>
<span class="line" id="L423">                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (block_size &lt;= cache.len) {</span>
<span class="line" id="L424">                        <span class="tok-comment">// we found the first and only internal buffer that we need, so we're done!</span>
</span>
<span class="line" id="L425">                        buffer1 = Range.init(A.start, A.start + count);</span>
<span class="line" id="L426">                        <span class="tok-kw">break</span>;</span>
<span class="line" id="L427">                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (find_separately) {</span>
<span class="line" id="L428">                        <span class="tok-comment">// found one buffer, but now find the other one</span>
</span>
<span class="line" id="L429">                        buffer1 = Range.init(A.start, A.start + count);</span>
<span class="line" id="L430">                        find_separately = <span class="tok-null">false</span>;</span>
<span class="line" id="L431">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L432">                        <span class="tok-comment">// we found a second buffer in an 'A' subarray containing √A unique values, so we're done!</span>
</span>
<span class="line" id="L433">                        buffer2 = Range.init(A.start, A.start + count);</span>
<span class="line" id="L434">                        <span class="tok-kw">break</span>;</span>
<span class="line" id="L435">                    }</span>
<span class="line" id="L436">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (pull_index == <span class="tok-number">0</span> <span class="tok-kw">and</span> count &gt; buffer1.length()) {</span>
<span class="line" id="L437">                    <span class="tok-comment">// keep track of the largest buffer we were able to find</span>
</span>
<span class="line" id="L438">                    buffer1 = Range.init(A.start, A.start + count);</span>
<span class="line" id="L439">                    pull[pull_index] = Pull{</span>
<span class="line" id="L440">                        .range = Range.init(A.start, B.end),</span>
<span class="line" id="L441">                        .count = count,</span>
<span class="line" id="L442">                        .from = index,</span>
<span class="line" id="L443">                        .to = A.start,</span>
<span class="line" id="L444">                    };</span>
<span class="line" id="L445">                }</span>
<span class="line" id="L446"></span>
<span class="line" id="L447">                <span class="tok-comment">// check B for the number of unique values we need to fill an internal buffer</span>
</span>
<span class="line" id="L448">                <span class="tok-comment">// these values will be pulled out to the end of B</span>
</span>
<span class="line" id="L449">                last = B.end - <span class="tok-number">1</span>;</span>
<span class="line" id="L450">                count = <span class="tok-number">1</span>;</span>
<span class="line" id="L451">                <span class="tok-kw">while</span> (count &lt; find) : ({</span>
<span class="line" id="L452">                    last = index - <span class="tok-number">1</span>;</span>
<span class="line" id="L453">                    count += <span class="tok-number">1</span>;</span>
<span class="line" id="L454">                }) {</span>
<span class="line" id="L455">                    index = findFirstBackward(T, items, items[last], Range.init(B.start, last), find - count, context, lessThan);</span>
<span class="line" id="L456">                    <span class="tok-kw">if</span> (index == B.start) <span class="tok-kw">break</span>;</span>
<span class="line" id="L457">                }</span>
<span class="line" id="L458">                index = last;</span>
<span class="line" id="L459"></span>
<span class="line" id="L460">                <span class="tok-kw">if</span> (count &gt;= buffer_size) {</span>
<span class="line" id="L461">                    <span class="tok-comment">// keep track of the range within the items where we'll need to &quot;pull out&quot; these values to create the internal buffe</span>
</span>
<span class="line" id="L462">                    pull[pull_index] = Pull{</span>
<span class="line" id="L463">                        .range = Range.init(A.start, B.end),</span>
<span class="line" id="L464">                        .count = count,</span>
<span class="line" id="L465">                        .from = index,</span>
<span class="line" id="L466">                        .to = B.end,</span>
<span class="line" id="L467">                    };</span>
<span class="line" id="L468">                    pull_index = <span class="tok-number">1</span>;</span>
<span class="line" id="L469"></span>
<span class="line" id="L470">                    <span class="tok-kw">if</span> (count == buffer_size + buffer_size) {</span>
<span class="line" id="L471">                        <span class="tok-comment">// we were able to find a single contiguous section containing 2√A unique values,</span>
</span>
<span class="line" id="L472">                        <span class="tok-comment">// so this section can be used to contain both of the internal buffers we'll need</span>
</span>
<span class="line" id="L473">                        buffer1 = Range.init(B.end - count, B.end - buffer_size);</span>
<span class="line" id="L474">                        buffer2 = Range.init(B.end - buffer_size, B.end);</span>
<span class="line" id="L475">                        <span class="tok-kw">break</span>;</span>
<span class="line" id="L476">                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (find == buffer_size + buffer_size) {</span>
<span class="line" id="L477">                        <span class="tok-comment">// we found a buffer that contains at least √A unique values, but did not contain the full 2√A unique values,</span>
</span>
<span class="line" id="L478">                        <span class="tok-comment">// so we still need to find a second separate buffer of at least √A unique values</span>
</span>
<span class="line" id="L479">                        buffer1 = Range.init(B.end - count, B.end);</span>
<span class="line" id="L480">                        find = buffer_size;</span>
<span class="line" id="L481">                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (block_size &lt;= cache.len) {</span>
<span class="line" id="L482">                        <span class="tok-comment">// we found the first and only internal buffer that we need, so we're done!</span>
</span>
<span class="line" id="L483">                        buffer1 = Range.init(B.end - count, B.end);</span>
<span class="line" id="L484">                        <span class="tok-kw">break</span>;</span>
<span class="line" id="L485">                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (find_separately) {</span>
<span class="line" id="L486">                        <span class="tok-comment">// found one buffer, but now find the other one</span>
</span>
<span class="line" id="L487">                        buffer1 = Range.init(B.end - count, B.end);</span>
<span class="line" id="L488">                        find_separately = <span class="tok-null">false</span>;</span>
<span class="line" id="L489">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L490">                        <span class="tok-comment">// buffer2 will be pulled out from a 'B' subarray, so if the first buffer was pulled out from the corresponding 'A' subarray,</span>
</span>
<span class="line" id="L491">                        <span class="tok-comment">// we need to adjust the end point for that A subarray so it knows to stop redistributing its values before reaching buffer2</span>
</span>
<span class="line" id="L492">                        <span class="tok-kw">if</span> (pull[<span class="tok-number">0</span>].range.start == A.start) pull[<span class="tok-number">0</span>].range.end -= pull[<span class="tok-number">1</span>].count;</span>
<span class="line" id="L493"></span>
<span class="line" id="L494">                        <span class="tok-comment">// we found a second buffer in an 'B' subarray containing √A unique values, so we're done!</span>
</span>
<span class="line" id="L495">                        buffer2 = Range.init(B.end - count, B.end);</span>
<span class="line" id="L496">                        <span class="tok-kw">break</span>;</span>
<span class="line" id="L497">                    }</span>
<span class="line" id="L498">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (pull_index == <span class="tok-number">0</span> <span class="tok-kw">and</span> count &gt; buffer1.length()) {</span>
<span class="line" id="L499">                    <span class="tok-comment">// keep track of the largest buffer we were able to find</span>
</span>
<span class="line" id="L500">                    buffer1 = Range.init(B.end - count, B.end);</span>
<span class="line" id="L501">                    pull[pull_index] = Pull{</span>
<span class="line" id="L502">                        .range = Range.init(A.start, B.end),</span>
<span class="line" id="L503">                        .count = count,</span>
<span class="line" id="L504">                        .from = index,</span>
<span class="line" id="L505">                        .to = B.end,</span>
<span class="line" id="L506">                    };</span>
<span class="line" id="L507">                }</span>
<span class="line" id="L508">            }</span>
<span class="line" id="L509"></span>
<span class="line" id="L510">            <span class="tok-comment">// pull out the two ranges so we can use them as internal buffers</span>
</span>
<span class="line" id="L511">            pull_index = <span class="tok-number">0</span>;</span>
<span class="line" id="L512">            <span class="tok-kw">while</span> (pull_index &lt; <span class="tok-number">2</span>) : (pull_index += <span class="tok-number">1</span>) {</span>
<span class="line" id="L513">                <span class="tok-kw">const</span> length = pull[pull_index].count;</span>
<span class="line" id="L514"></span>
<span class="line" id="L515">                <span class="tok-kw">if</span> (pull[pull_index].to &lt; pull[pull_index].from) {</span>
<span class="line" id="L516">                    <span class="tok-comment">// we're pulling the values out to the left, which means the start of an A subarray</span>
</span>
<span class="line" id="L517">                    index = pull[pull_index].from;</span>
<span class="line" id="L518">                    count = <span class="tok-number">1</span>;</span>
<span class="line" id="L519">                    <span class="tok-kw">while</span> (count &lt; length) : (count += <span class="tok-number">1</span>) {</span>
<span class="line" id="L520">                        index = findFirstBackward(T, items, items[index - <span class="tok-number">1</span>], Range.init(pull[pull_index].to, pull[pull_index].from - (count - <span class="tok-number">1</span>)), length - count, context, lessThan);</span>
<span class="line" id="L521">                        <span class="tok-kw">const</span> range = Range.init(index + <span class="tok-number">1</span>, pull[pull_index].from + <span class="tok-number">1</span>);</span>
<span class="line" id="L522">                        mem.rotate(T, items[range.start..range.end], range.length() - count);</span>
<span class="line" id="L523">                        pull[pull_index].from = index + count;</span>
<span class="line" id="L524">                    }</span>
<span class="line" id="L525">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (pull[pull_index].to &gt; pull[pull_index].from) {</span>
<span class="line" id="L526">                    <span class="tok-comment">// we're pulling values out to the right, which means the end of a B subarray</span>
</span>
<span class="line" id="L527">                    index = pull[pull_index].from + <span class="tok-number">1</span>;</span>
<span class="line" id="L528">                    count = <span class="tok-number">1</span>;</span>
<span class="line" id="L529">                    <span class="tok-kw">while</span> (count &lt; length) : (count += <span class="tok-number">1</span>) {</span>
<span class="line" id="L530">                        index = findLastForward(T, items, items[index], Range.init(index, pull[pull_index].to), length - count, context, lessThan);</span>
<span class="line" id="L531">                        <span class="tok-kw">const</span> range = Range.init(pull[pull_index].from, index - <span class="tok-number">1</span>);</span>
<span class="line" id="L532">                        mem.rotate(T, items[range.start..range.end], count);</span>
<span class="line" id="L533">                        pull[pull_index].from = index - <span class="tok-number">1</span> - count;</span>
<span class="line" id="L534">                    }</span>
<span class="line" id="L535">                }</span>
<span class="line" id="L536">            }</span>
<span class="line" id="L537"></span>
<span class="line" id="L538">            <span class="tok-comment">// adjust block_size and buffer_size based on the values we were able to pull out</span>
</span>
<span class="line" id="L539">            buffer_size = buffer1.length();</span>
<span class="line" id="L540">            block_size = iterator.length() / buffer_size + <span class="tok-number">1</span>;</span>
<span class="line" id="L541"></span>
<span class="line" id="L542">            <span class="tok-comment">// the first buffer NEEDS to be large enough to tag each of the evenly sized A blocks,</span>
</span>
<span class="line" id="L543">            <span class="tok-comment">// so this was originally here to test the math for adjusting block_size above</span>
</span>
<span class="line" id="L544">            <span class="tok-comment">// assert((iterator.length() + 1)/block_size &lt;= buffer_size);</span>
</span>
<span class="line" id="L545"></span>
<span class="line" id="L546">            <span class="tok-comment">// now that the two internal buffers have been created, it's time to merge each A+B combination at this level of the merge sort!</span>
</span>
<span class="line" id="L547">            iterator.begin();</span>
<span class="line" id="L548">            <span class="tok-kw">while</span> (!iterator.finished()) {</span>
<span class="line" id="L549">                A = iterator.nextRange();</span>
<span class="line" id="L550">                B = iterator.nextRange();</span>
<span class="line" id="L551"></span>
<span class="line" id="L552">                <span class="tok-comment">// remove any parts of A or B that are being used by the internal buffers</span>
</span>
<span class="line" id="L553">                start = A.start;</span>
<span class="line" id="L554">                <span class="tok-kw">if</span> (start == pull[<span class="tok-number">0</span>].range.start) {</span>
<span class="line" id="L555">                    <span class="tok-kw">if</span> (pull[<span class="tok-number">0</span>].from &gt; pull[<span class="tok-number">0</span>].to) {</span>
<span class="line" id="L556">                        A.start += pull[<span class="tok-number">0</span>].count;</span>
<span class="line" id="L557"></span>
<span class="line" id="L558">                        <span class="tok-comment">// if the internal buffer takes up the entire A or B subarray, then there's nothing to merge</span>
</span>
<span class="line" id="L559">                        <span class="tok-comment">// this only happens for very small subarrays, like √4 = 2, 2 * (2 internal buffers) = 4,</span>
</span>
<span class="line" id="L560">                        <span class="tok-comment">// which also only happens when cache.len is small or 0 since it'd otherwise use MergeExternal</span>
</span>
<span class="line" id="L561">                        <span class="tok-kw">if</span> (A.length() == <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L562">                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (pull[<span class="tok-number">0</span>].from &lt; pull[<span class="tok-number">0</span>].to) {</span>
<span class="line" id="L563">                        B.end -= pull[<span class="tok-number">0</span>].count;</span>
<span class="line" id="L564">                        <span class="tok-kw">if</span> (B.length() == <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L565">                    }</span>
<span class="line" id="L566">                }</span>
<span class="line" id="L567">                <span class="tok-kw">if</span> (start == pull[<span class="tok-number">1</span>].range.start) {</span>
<span class="line" id="L568">                    <span class="tok-kw">if</span> (pull[<span class="tok-number">1</span>].from &gt; pull[<span class="tok-number">1</span>].to) {</span>
<span class="line" id="L569">                        A.start += pull[<span class="tok-number">1</span>].count;</span>
<span class="line" id="L570">                        <span class="tok-kw">if</span> (A.length() == <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L571">                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (pull[<span class="tok-number">1</span>].from &lt; pull[<span class="tok-number">1</span>].to) {</span>
<span class="line" id="L572">                        B.end -= pull[<span class="tok-number">1</span>].count;</span>
<span class="line" id="L573">                        <span class="tok-kw">if</span> (B.length() == <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L574">                    }</span>
<span class="line" id="L575">                }</span>
<span class="line" id="L576"></span>
<span class="line" id="L577">                <span class="tok-kw">if</span> (lessThan(context, items[B.end - <span class="tok-number">1</span>], items[A.start])) {</span>
<span class="line" id="L578">                    <span class="tok-comment">// the two ranges are in reverse order, so a simple rotation should fix it</span>
</span>
<span class="line" id="L579">                    mem.rotate(T, items[A.start..B.end], A.length());</span>
<span class="line" id="L580">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (lessThan(context, items[A.end], items[A.end - <span class="tok-number">1</span>])) {</span>
<span class="line" id="L581">                    <span class="tok-comment">// these two ranges weren't already in order, so we'll need to merge them!</span>
</span>
<span class="line" id="L582">                    <span class="tok-kw">var</span> findA: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L583"></span>
<span class="line" id="L584">                    <span class="tok-comment">// break the remainder of A into blocks. firstA is the uneven-sized first A block</span>
</span>
<span class="line" id="L585">                    <span class="tok-kw">var</span> blockA = Range.init(A.start, A.end);</span>
<span class="line" id="L586">                    <span class="tok-kw">var</span> firstA = Range.init(A.start, A.start + blockA.length() % block_size);</span>
<span class="line" id="L587"></span>
<span class="line" id="L588">                    <span class="tok-comment">// swap the first value of each A block with the value in buffer1</span>
</span>
<span class="line" id="L589">                    <span class="tok-kw">var</span> indexA = buffer1.start;</span>
<span class="line" id="L590">                    index = firstA.end;</span>
<span class="line" id="L591">                    <span class="tok-kw">while</span> (index &lt; blockA.end) : ({</span>
<span class="line" id="L592">                        indexA += <span class="tok-number">1</span>;</span>
<span class="line" id="L593">                        index += block_size;</span>
<span class="line" id="L594">                    }) {</span>
<span class="line" id="L595">                        mem.swap(T, &amp;items[indexA], &amp;items[index]);</span>
<span class="line" id="L596">                    }</span>
<span class="line" id="L597"></span>
<span class="line" id="L598">                    <span class="tok-comment">// start rolling the A blocks through the B blocks!</span>
</span>
<span class="line" id="L599">                    <span class="tok-comment">// whenever we leave an A block behind, we'll need to merge the previous A block with any B blocks that follow it, so track that information as well</span>
</span>
<span class="line" id="L600">                    <span class="tok-kw">var</span> lastA = firstA;</span>
<span class="line" id="L601">                    <span class="tok-kw">var</span> lastB = Range.init(<span class="tok-number">0</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L602">                    <span class="tok-kw">var</span> blockB = Range.init(B.start, B.start + <span class="tok-builtin">@min</span>(block_size, B.length()));</span>
<span class="line" id="L603">                    blockA.start += firstA.length();</span>
<span class="line" id="L604">                    indexA = buffer1.start;</span>
<span class="line" id="L605"></span>
<span class="line" id="L606">                    <span class="tok-comment">// if the first unevenly sized A block fits into the cache, copy it there for when we go to Merge it</span>
</span>
<span class="line" id="L607">                    <span class="tok-comment">// otherwise, if the second buffer is available, block swap the contents into that</span>
</span>
<span class="line" id="L608">                    <span class="tok-kw">if</span> (lastA.length() &lt;= cache.len) {</span>
<span class="line" id="L609">                        <span class="tok-kw">const</span> last_a_items = items[lastA.start..lastA.end];</span>
<span class="line" id="L610">                        <span class="tok-builtin">@memcpy</span>(cache[<span class="tok-number">0</span>..last_a_items.len], last_a_items);</span>
<span class="line" id="L611">                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (buffer2.length() &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L612">                        blockSwap(T, items, lastA.start, buffer2.start, lastA.length());</span>
<span class="line" id="L613">                    }</span>
<span class="line" id="L614"></span>
<span class="line" id="L615">                    <span class="tok-kw">if</span> (blockA.length() &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L616">                        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L617">                            <span class="tok-comment">// if there's a previous B block and the first value of the minimum A block is &lt;= the last value of the previous B block,</span>
</span>
<span class="line" id="L618">                            <span class="tok-comment">// then drop that minimum A block behind. or if there are no B blocks left then keep dropping the remaining A blocks.</span>
</span>
<span class="line" id="L619">                            <span class="tok-kw">if</span> ((lastB.length() &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> !lessThan(context, items[lastB.end - <span class="tok-number">1</span>], items[indexA])) <span class="tok-kw">or</span> blockB.length() == <span class="tok-number">0</span>) {</span>
<span class="line" id="L620">                                <span class="tok-comment">// figure out where to split the previous B block, and rotate it at the split</span>
</span>
<span class="line" id="L621">                                <span class="tok-kw">const</span> B_split = binaryFirst(T, items, items[indexA], lastB, context, lessThan);</span>
<span class="line" id="L622">                                <span class="tok-kw">const</span> B_remaining = lastB.end - B_split;</span>
<span class="line" id="L623"></span>
<span class="line" id="L624">                                <span class="tok-comment">// swap the minimum A block to the beginning of the rolling A blocks</span>
</span>
<span class="line" id="L625">                                <span class="tok-kw">var</span> minA = blockA.start;</span>
<span class="line" id="L626">                                findA = minA + block_size;</span>
<span class="line" id="L627">                                <span class="tok-kw">while</span> (findA &lt; blockA.end) : (findA += block_size) {</span>
<span class="line" id="L628">                                    <span class="tok-kw">if</span> (lessThan(context, items[findA], items[minA])) {</span>
<span class="line" id="L629">                                        minA = findA;</span>
<span class="line" id="L630">                                    }</span>
<span class="line" id="L631">                                }</span>
<span class="line" id="L632">                                blockSwap(T, items, blockA.start, minA, block_size);</span>
<span class="line" id="L633"></span>
<span class="line" id="L634">                                <span class="tok-comment">// swap the first item of the previous A block back with its original value, which is stored in buffer1</span>
</span>
<span class="line" id="L635">                                mem.swap(T, &amp;items[blockA.start], &amp;items[indexA]);</span>
<span class="line" id="L636">                                indexA += <span class="tok-number">1</span>;</span>
<span class="line" id="L637"></span>
<span class="line" id="L638">                                <span class="tok-comment">// locally merge the previous A block with the B values that follow it</span>
</span>
<span class="line" id="L639">                                <span class="tok-comment">// if lastA fits into the external cache we'll use that (with MergeExternal),</span>
</span>
<span class="line" id="L640">                                <span class="tok-comment">// or if the second internal buffer exists we'll use that (with MergeInternal),</span>
</span>
<span class="line" id="L641">                                <span class="tok-comment">// or failing that we'll use a strictly in-place merge algorithm (MergeInPlace)</span>
</span>
<span class="line" id="L642"></span>
<span class="line" id="L643">                                <span class="tok-kw">if</span> (lastA.length() &lt;= cache.len) {</span>
<span class="line" id="L644">                                    mergeExternal(T, items, lastA, Range.init(lastA.end, B_split), cache[<span class="tok-number">0</span>..], context, lessThan);</span>
<span class="line" id="L645">                                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (buffer2.length() &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L646">                                    mergeInternal(T, items, lastA, Range.init(lastA.end, B_split), buffer2, context, lessThan);</span>
<span class="line" id="L647">                                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L648">                                    mergeInPlace(T, items, lastA, Range.init(lastA.end, B_split), context, lessThan);</span>
<span class="line" id="L649">                                }</span>
<span class="line" id="L650"></span>
<span class="line" id="L651">                                <span class="tok-kw">if</span> (buffer2.length() &gt; <span class="tok-number">0</span> <span class="tok-kw">or</span> block_size &lt;= cache.len) {</span>
<span class="line" id="L652">                                    <span class="tok-comment">// copy the previous A block into the cache or buffer2, since that's where we need it to be when we go to merge it anyway</span>
</span>
<span class="line" id="L653">                                    <span class="tok-kw">if</span> (block_size &lt;= cache.len) {</span>
<span class="line" id="L654">                                        <span class="tok-builtin">@memcpy</span>(cache[<span class="tok-number">0</span>..block_size], items[blockA.start..][<span class="tok-number">0</span>..block_size]);</span>
<span class="line" id="L655">                                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L656">                                        blockSwap(T, items, blockA.start, buffer2.start, block_size);</span>
<span class="line" id="L657">                                    }</span>
<span class="line" id="L658"></span>
<span class="line" id="L659">                                    <span class="tok-comment">// this is equivalent to rotating, but faster</span>
</span>
<span class="line" id="L660">                                    <span class="tok-comment">// the area normally taken up by the A block is either the contents of buffer2, or data we don't need anymore since we memcopied it</span>
</span>
<span class="line" id="L661">                                    <span class="tok-comment">// either way, we don't need to retain the order of those items, so instead of rotating we can just block swap B to where it belongs</span>
</span>
<span class="line" id="L662">                                    blockSwap(T, items, B_split, blockA.start + block_size - B_remaining, B_remaining);</span>
<span class="line" id="L663">                                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L664">                                    <span class="tok-comment">// we are unable to use the 'buffer2' trick to speed up the rotation operation since buffer2 doesn't exist, so perform a normal rotation</span>
</span>
<span class="line" id="L665">                                    mem.rotate(T, items[B_split .. blockA.start + block_size], blockA.start - B_split);</span>
<span class="line" id="L666">                                }</span>
<span class="line" id="L667"></span>
<span class="line" id="L668">                                <span class="tok-comment">// update the range for the remaining A blocks, and the range remaining from the B block after it was split</span>
</span>
<span class="line" id="L669">                                lastA = Range.init(blockA.start - B_remaining, blockA.start - B_remaining + block_size);</span>
<span class="line" id="L670">                                lastB = Range.init(lastA.end, lastA.end + B_remaining);</span>
<span class="line" id="L671"></span>
<span class="line" id="L672">                                <span class="tok-comment">// if there are no more A blocks remaining, this step is finished!</span>
</span>
<span class="line" id="L673">                                blockA.start += block_size;</span>
<span class="line" id="L674">                                <span class="tok-kw">if</span> (blockA.length() == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;</span>
<span class="line" id="L675">                            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (blockB.length() &lt; block_size) {</span>
<span class="line" id="L676">                                <span class="tok-comment">// move the last B block, which is unevenly sized, to before the remaining A blocks, by using a rotation</span>
</span>
<span class="line" id="L677">                                <span class="tok-comment">// the cache is disabled here since it might contain the contents of the previous A block</span>
</span>
<span class="line" id="L678">                                mem.rotate(T, items[blockA.start..blockB.end], blockB.start - blockA.start);</span>
<span class="line" id="L679"></span>
<span class="line" id="L680">                                lastB = Range.init(blockA.start, blockA.start + blockB.length());</span>
<span class="line" id="L681">                                blockA.start += blockB.length();</span>
<span class="line" id="L682">                                blockA.end += blockB.length();</span>
<span class="line" id="L683">                                blockB.end = blockB.start;</span>
<span class="line" id="L684">                            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L685">                                <span class="tok-comment">// roll the leftmost A block to the end by swapping it with the next B block</span>
</span>
<span class="line" id="L686">                                blockSwap(T, items, blockA.start, blockB.start, block_size);</span>
<span class="line" id="L687">                                lastB = Range.init(blockA.start, blockA.start + block_size);</span>
<span class="line" id="L688"></span>
<span class="line" id="L689">                                blockA.start += block_size;</span>
<span class="line" id="L690">                                blockA.end += block_size;</span>
<span class="line" id="L691">                                blockB.start += block_size;</span>
<span class="line" id="L692"></span>
<span class="line" id="L693">                                <span class="tok-kw">if</span> (blockB.end &gt; B.end - block_size) {</span>
<span class="line" id="L694">                                    blockB.end = B.end;</span>
<span class="line" id="L695">                                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L696">                                    blockB.end += block_size;</span>
<span class="line" id="L697">                                }</span>
<span class="line" id="L698">                            }</span>
<span class="line" id="L699">                        }</span>
<span class="line" id="L700">                    }</span>
<span class="line" id="L701"></span>
<span class="line" id="L702">                    <span class="tok-comment">// merge the last A block with the remaining B values</span>
</span>
<span class="line" id="L703">                    <span class="tok-kw">if</span> (lastA.length() &lt;= cache.len) {</span>
<span class="line" id="L704">                        mergeExternal(T, items, lastA, Range.init(lastA.end, B.end), cache[<span class="tok-number">0</span>..], context, lessThan);</span>
<span class="line" id="L705">                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (buffer2.length() &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L706">                        mergeInternal(T, items, lastA, Range.init(lastA.end, B.end), buffer2, context, lessThan);</span>
<span class="line" id="L707">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L708">                        mergeInPlace(T, items, lastA, Range.init(lastA.end, B.end), context, lessThan);</span>
<span class="line" id="L709">                    }</span>
<span class="line" id="L710">                }</span>
<span class="line" id="L711">            }</span>
<span class="line" id="L712"></span>
<span class="line" id="L713">            <span class="tok-comment">// when we're finished with this merge step we should have the one</span>
</span>
<span class="line" id="L714">            <span class="tok-comment">// or two internal buffers left over, where the second buffer is all jumbled up</span>
</span>
<span class="line" id="L715">            <span class="tok-comment">// insertion sort the second buffer, then redistribute the buffers</span>
</span>
<span class="line" id="L716">            <span class="tok-comment">// back into the items using the opposite process used for creating the buffer</span>
</span>
<span class="line" id="L717"></span>
<span class="line" id="L718">            <span class="tok-comment">// while an unstable sort like quicksort could be applied here, in benchmarks</span>
</span>
<span class="line" id="L719">            <span class="tok-comment">// it was consistently slightly slower than a simple insertion sort,</span>
</span>
<span class="line" id="L720">            <span class="tok-comment">// even for tens of millions of items. this may be because insertion</span>
</span>
<span class="line" id="L721">            <span class="tok-comment">// sort is quite fast when the data is already somewhat sorted, like it is here</span>
</span>
<span class="line" id="L722">            sort.insertion(T, items[buffer2.start..buffer2.end], context, lessThan);</span>
<span class="line" id="L723"></span>
<span class="line" id="L724">            pull_index = <span class="tok-number">0</span>;</span>
<span class="line" id="L725">            <span class="tok-kw">while</span> (pull_index &lt; <span class="tok-number">2</span>) : (pull_index += <span class="tok-number">1</span>) {</span>
<span class="line" id="L726">                <span class="tok-kw">var</span> unique = pull[pull_index].count * <span class="tok-number">2</span>;</span>
<span class="line" id="L727">                <span class="tok-kw">if</span> (pull[pull_index].from &gt; pull[pull_index].to) {</span>
<span class="line" id="L728">                    <span class="tok-comment">// the values were pulled out to the left, so redistribute them back to the right</span>
</span>
<span class="line" id="L729">                    <span class="tok-kw">var</span> buffer = Range.init(pull[pull_index].range.start, pull[pull_index].range.start + pull[pull_index].count);</span>
<span class="line" id="L730">                    <span class="tok-kw">while</span> (buffer.length() &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L731">                        index = findFirstForward(T, items, items[buffer.start], Range.init(buffer.end, pull[pull_index].range.end), unique, context, lessThan);</span>
<span class="line" id="L732">                        <span class="tok-kw">const</span> amount = index - buffer.end;</span>
<span class="line" id="L733">                        mem.rotate(T, items[buffer.start..index], buffer.length());</span>
<span class="line" id="L734">                        buffer.start += (amount + <span class="tok-number">1</span>);</span>
<span class="line" id="L735">                        buffer.end += amount;</span>
<span class="line" id="L736">                        unique -= <span class="tok-number">2</span>;</span>
<span class="line" id="L737">                    }</span>
<span class="line" id="L738">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (pull[pull_index].from &lt; pull[pull_index].to) {</span>
<span class="line" id="L739">                    <span class="tok-comment">// the values were pulled out to the right, so redistribute them back to the left</span>
</span>
<span class="line" id="L740">                    <span class="tok-kw">var</span> buffer = Range.init(pull[pull_index].range.end - pull[pull_index].count, pull[pull_index].range.end);</span>
<span class="line" id="L741">                    <span class="tok-kw">while</span> (buffer.length() &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L742">                        index = findLastBackward(T, items, items[buffer.end - <span class="tok-number">1</span>], Range.init(pull[pull_index].range.start, buffer.start), unique, context, lessThan);</span>
<span class="line" id="L743">                        <span class="tok-kw">const</span> amount = buffer.start - index;</span>
<span class="line" id="L744">                        mem.rotate(T, items[index..buffer.end], amount);</span>
<span class="line" id="L745">                        buffer.start -= amount;</span>
<span class="line" id="L746">                        buffer.end -= (amount + <span class="tok-number">1</span>);</span>
<span class="line" id="L747">                        unique -= <span class="tok-number">2</span>;</span>
<span class="line" id="L748">                    }</span>
<span class="line" id="L749">                }</span>
<span class="line" id="L750">            }</span>
<span class="line" id="L751">        }</span>
<span class="line" id="L752"></span>
<span class="line" id="L753">        <span class="tok-comment">// double the size of each A and B subarray that will be merged in the next level</span>
</span>
<span class="line" id="L754">        <span class="tok-kw">if</span> (!iterator.nextLevel()) <span class="tok-kw">break</span>;</span>
<span class="line" id="L755">    }</span>
<span class="line" id="L756">}</span>
<span class="line" id="L757"><span class="tok-comment">// merge operation without a buffer</span>
</span>
<span class="line" id="L758"><span class="tok-kw">fn</span> <span class="tok-fn">mergeInPlace</span>(</span>
<span class="line" id="L759">    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,</span>
<span class="line" id="L760">    items: []T,</span>
<span class="line" id="L761">    A_arg: Range,</span>
<span class="line" id="L762">    B_arg: Range,</span>
<span class="line" id="L763">    context: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L764">    <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,</span>
<span class="line" id="L765">) <span class="tok-type">void</span> {</span>
<span class="line" id="L766">    <span class="tok-kw">if</span> (A_arg.length() == <span class="tok-number">0</span> <span class="tok-kw">or</span> B_arg.length() == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;</span>
<span class="line" id="L767"></span>
<span class="line" id="L768">    <span class="tok-comment">// this just repeatedly binary searches into B and rotates A into position.</span>
</span>
<span class="line" id="L769">    <span class="tok-comment">// the paper suggests using the 'rotation-based Hwang and Lin algorithm' here,</span>
</span>
<span class="line" id="L770">    <span class="tok-comment">// but I decided to stick with this because it had better situational performance</span>
</span>
<span class="line" id="L771">    <span class="tok-comment">//</span>
</span>
<span class="line" id="L772">    <span class="tok-comment">// (Hwang and Lin is designed for merging subarrays of very different sizes,</span>
</span>
<span class="line" id="L773">    <span class="tok-comment">// but WikiSort almost always uses subarrays that are roughly the same size)</span>
</span>
<span class="line" id="L774">    <span class="tok-comment">//</span>
</span>
<span class="line" id="L775">    <span class="tok-comment">// normally this is incredibly suboptimal, but this function is only called</span>
</span>
<span class="line" id="L776">    <span class="tok-comment">// when none of the A or B blocks in any subarray contained 2√A unique values,</span>
</span>
<span class="line" id="L777">    <span class="tok-comment">// which places a hard limit on the number of times this will ACTUALLY need</span>
</span>
<span class="line" id="L778">    <span class="tok-comment">// to binary search and rotate.</span>
</span>
<span class="line" id="L779">    <span class="tok-comment">//</span>
</span>
<span class="line" id="L780">    <span class="tok-comment">// according to my analysis the worst case is √A rotations performed on √A items</span>
</span>
<span class="line" id="L781">    <span class="tok-comment">// once the constant factors are removed, which ends up being O(n)</span>
</span>
<span class="line" id="L782">    <span class="tok-comment">//</span>
</span>
<span class="line" id="L783">    <span class="tok-comment">// again, this is NOT a general-purpose solution – it only works well in this case!</span>
</span>
<span class="line" id="L784">    <span class="tok-comment">// kind of like how the O(n^2) insertion sort is used in some places</span>
</span>
<span class="line" id="L785"></span>
<span class="line" id="L786">    <span class="tok-kw">var</span> A = A_arg;</span>
<span class="line" id="L787">    <span class="tok-kw">var</span> B = B_arg;</span>
<span class="line" id="L788"></span>
<span class="line" id="L789">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L790">        <span class="tok-comment">// find the first place in B where the first item in A needs to be inserted</span>
</span>
<span class="line" id="L791">        <span class="tok-kw">const</span> mid = binaryFirst(T, items, items[A.start], B, context, lessThan);</span>
<span class="line" id="L792"></span>
<span class="line" id="L793">        <span class="tok-comment">// rotate A into place</span>
</span>
<span class="line" id="L794">        <span class="tok-kw">const</span> amount = mid - A.end;</span>
<span class="line" id="L795">        mem.rotate(T, items[A.start..mid], A.length());</span>
<span class="line" id="L796">        <span class="tok-kw">if</span> (B.end == mid) <span class="tok-kw">break</span>;</span>
<span class="line" id="L797"></span>
<span class="line" id="L798">        <span class="tok-comment">// calculate the new A and B ranges</span>
</span>
<span class="line" id="L799">        B.start = mid;</span>
<span class="line" id="L800">        A = Range.init(A.start + amount, B.start);</span>
<span class="line" id="L801">        A.start = binaryLast(T, items, items[A.start], A, context, lessThan);</span>
<span class="line" id="L802">        <span class="tok-kw">if</span> (A.length() == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;</span>
<span class="line" id="L803">    }</span>
<span class="line" id="L804">}</span>
<span class="line" id="L805"></span>
<span class="line" id="L806"><span class="tok-comment">// merge operation using an internal buffer</span>
</span>
<span class="line" id="L807"><span class="tok-kw">fn</span> <span class="tok-fn">mergeInternal</span>(</span>
<span class="line" id="L808">    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,</span>
<span class="line" id="L809">    items: []T,</span>
<span class="line" id="L810">    A: Range,</span>
<span class="line" id="L811">    B: Range,</span>
<span class="line" id="L812">    buffer: Range,</span>
<span class="line" id="L813">    context: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L814">    <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,</span>
<span class="line" id="L815">) <span class="tok-type">void</span> {</span>
<span class="line" id="L816">    <span class="tok-comment">// whenever we find a value to add to the final array, swap it with the value that's already in that spot</span>
</span>
<span class="line" id="L817">    <span class="tok-comment">// when this algorithm is finished, 'buffer' will contain its original contents, but in a different order</span>
</span>
<span class="line" id="L818">    <span class="tok-kw">var</span> A_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L819">    <span class="tok-kw">var</span> B_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L820">    <span class="tok-kw">var</span> insert: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L821"></span>
<span class="line" id="L822">    <span class="tok-kw">if</span> (B.length() &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> A.length() &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L823">        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L824">            <span class="tok-kw">if</span> (!lessThan(context, items[B.start + B_count], items[buffer.start + A_count])) {</span>
<span class="line" id="L825">                mem.swap(T, &amp;items[A.start + insert], &amp;items[buffer.start + A_count]);</span>
<span class="line" id="L826">                A_count += <span class="tok-number">1</span>;</span>
<span class="line" id="L827">                insert += <span class="tok-number">1</span>;</span>
<span class="line" id="L828">                <span class="tok-kw">if</span> (A_count &gt;= A.length()) <span class="tok-kw">break</span>;</span>
<span class="line" id="L829">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L830">                mem.swap(T, &amp;items[A.start + insert], &amp;items[B.start + B_count]);</span>
<span class="line" id="L831">                B_count += <span class="tok-number">1</span>;</span>
<span class="line" id="L832">                insert += <span class="tok-number">1</span>;</span>
<span class="line" id="L833">                <span class="tok-kw">if</span> (B_count &gt;= B.length()) <span class="tok-kw">break</span>;</span>
<span class="line" id="L834">            }</span>
<span class="line" id="L835">        }</span>
<span class="line" id="L836">    }</span>
<span class="line" id="L837"></span>
<span class="line" id="L838">    <span class="tok-comment">// swap the remainder of A into the final array</span>
</span>
<span class="line" id="L839">    blockSwap(T, items, buffer.start + A_count, A.start + insert, A.length() - A_count);</span>
<span class="line" id="L840">}</span>
<span class="line" id="L841"></span>
<span class="line" id="L842"><span class="tok-kw">fn</span> <span class="tok-fn">blockSwap</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, items: []T, start1: <span class="tok-type">usize</span>, start2: <span class="tok-type">usize</span>, block_size: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L843">    <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L844">    <span class="tok-kw">while</span> (index &lt; block_size) : (index += <span class="tok-number">1</span>) {</span>
<span class="line" id="L845">        mem.swap(T, &amp;items[start1 + index], &amp;items[start2 + index]);</span>
<span class="line" id="L846">    }</span>
<span class="line" id="L847">}</span>
<span class="line" id="L848"></span>
<span class="line" id="L849"><span class="tok-comment">// combine a linear search with a binary search to reduce the number of comparisons in situations</span>
</span>
<span class="line" id="L850"><span class="tok-comment">// where have some idea as to how many unique values there are and where the next value might be</span>
</span>
<span class="line" id="L851"><span class="tok-kw">fn</span> <span class="tok-fn">findFirstForward</span>(</span>
<span class="line" id="L852">    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,</span>
<span class="line" id="L853">    items: []T,</span>
<span class="line" id="L854">    value: T,</span>
<span class="line" id="L855">    range: Range,</span>
<span class="line" id="L856">    unique: <span class="tok-type">usize</span>,</span>
<span class="line" id="L857">    context: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L858">    <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,</span>
<span class="line" id="L859">) <span class="tok-type">usize</span> {</span>
<span class="line" id="L860">    <span class="tok-kw">if</span> (range.length() == <span class="tok-number">0</span>) <span class="tok-kw">return</span> range.start;</span>
<span class="line" id="L861">    <span class="tok-kw">const</span> skip = <span class="tok-builtin">@max</span>(range.length() / unique, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>));</span>
<span class="line" id="L862"></span>
<span class="line" id="L863">    <span class="tok-kw">var</span> index = range.start + skip;</span>
<span class="line" id="L864">    <span class="tok-kw">while</span> (lessThan(context, items[index - <span class="tok-number">1</span>], value)) : (index += skip) {</span>
<span class="line" id="L865">        <span class="tok-kw">if</span> (index &gt;= range.end - skip) {</span>
<span class="line" id="L866">            <span class="tok-kw">return</span> binaryFirst(T, items, value, Range.init(index, range.end), context, lessThan);</span>
<span class="line" id="L867">        }</span>
<span class="line" id="L868">    }</span>
<span class="line" id="L869"></span>
<span class="line" id="L870">    <span class="tok-kw">return</span> binaryFirst(T, items, value, Range.init(index - skip, index), context, lessThan);</span>
<span class="line" id="L871">}</span>
<span class="line" id="L872"></span>
<span class="line" id="L873"><span class="tok-kw">fn</span> <span class="tok-fn">findFirstBackward</span>(</span>
<span class="line" id="L874">    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,</span>
<span class="line" id="L875">    items: []T,</span>
<span class="line" id="L876">    value: T,</span>
<span class="line" id="L877">    range: Range,</span>
<span class="line" id="L878">    unique: <span class="tok-type">usize</span>,</span>
<span class="line" id="L879">    context: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L880">    <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,</span>
<span class="line" id="L881">) <span class="tok-type">usize</span> {</span>
<span class="line" id="L882">    <span class="tok-kw">if</span> (range.length() == <span class="tok-number">0</span>) <span class="tok-kw">return</span> range.start;</span>
<span class="line" id="L883">    <span class="tok-kw">const</span> skip = <span class="tok-builtin">@max</span>(range.length() / unique, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>));</span>
<span class="line" id="L884"></span>
<span class="line" id="L885">    <span class="tok-kw">var</span> index = range.end - skip;</span>
<span class="line" id="L886">    <span class="tok-kw">while</span> (index &gt; range.start <span class="tok-kw">and</span> !lessThan(context, items[index - <span class="tok-number">1</span>], value)) : (index -= skip) {</span>
<span class="line" id="L887">        <span class="tok-kw">if</span> (index &lt; range.start + skip) {</span>
<span class="line" id="L888">            <span class="tok-kw">return</span> binaryFirst(T, items, value, Range.init(range.start, index), context, lessThan);</span>
<span class="line" id="L889">        }</span>
<span class="line" id="L890">    }</span>
<span class="line" id="L891"></span>
<span class="line" id="L892">    <span class="tok-kw">return</span> binaryFirst(T, items, value, Range.init(index, index + skip), context, lessThan);</span>
<span class="line" id="L893">}</span>
<span class="line" id="L894"></span>
<span class="line" id="L895"><span class="tok-kw">fn</span> <span class="tok-fn">findLastForward</span>(</span>
<span class="line" id="L896">    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,</span>
<span class="line" id="L897">    items: []T,</span>
<span class="line" id="L898">    value: T,</span>
<span class="line" id="L899">    range: Range,</span>
<span class="line" id="L900">    unique: <span class="tok-type">usize</span>,</span>
<span class="line" id="L901">    context: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L902">    <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,</span>
<span class="line" id="L903">) <span class="tok-type">usize</span> {</span>
<span class="line" id="L904">    <span class="tok-kw">if</span> (range.length() == <span class="tok-number">0</span>) <span class="tok-kw">return</span> range.start;</span>
<span class="line" id="L905">    <span class="tok-kw">const</span> skip = <span class="tok-builtin">@max</span>(range.length() / unique, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>));</span>
<span class="line" id="L906"></span>
<span class="line" id="L907">    <span class="tok-kw">var</span> index = range.start + skip;</span>
<span class="line" id="L908">    <span class="tok-kw">while</span> (!lessThan(context, value, items[index - <span class="tok-number">1</span>])) : (index += skip) {</span>
<span class="line" id="L909">        <span class="tok-kw">if</span> (index &gt;= range.end - skip) {</span>
<span class="line" id="L910">            <span class="tok-kw">return</span> binaryLast(T, items, value, Range.init(index, range.end), context, lessThan);</span>
<span class="line" id="L911">        }</span>
<span class="line" id="L912">    }</span>
<span class="line" id="L913"></span>
<span class="line" id="L914">    <span class="tok-kw">return</span> binaryLast(T, items, value, Range.init(index - skip, index), context, lessThan);</span>
<span class="line" id="L915">}</span>
<span class="line" id="L916"></span>
<span class="line" id="L917"><span class="tok-kw">fn</span> <span class="tok-fn">findLastBackward</span>(</span>
<span class="line" id="L918">    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,</span>
<span class="line" id="L919">    items: []T,</span>
<span class="line" id="L920">    value: T,</span>
<span class="line" id="L921">    range: Range,</span>
<span class="line" id="L922">    unique: <span class="tok-type">usize</span>,</span>
<span class="line" id="L923">    context: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L924">    <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,</span>
<span class="line" id="L925">) <span class="tok-type">usize</span> {</span>
<span class="line" id="L926">    <span class="tok-kw">if</span> (range.length() == <span class="tok-number">0</span>) <span class="tok-kw">return</span> range.start;</span>
<span class="line" id="L927">    <span class="tok-kw">const</span> skip = <span class="tok-builtin">@max</span>(range.length() / unique, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>));</span>
<span class="line" id="L928"></span>
<span class="line" id="L929">    <span class="tok-kw">var</span> index = range.end - skip;</span>
<span class="line" id="L930">    <span class="tok-kw">while</span> (index &gt; range.start <span class="tok-kw">and</span> lessThan(context, value, items[index - <span class="tok-number">1</span>])) : (index -= skip) {</span>
<span class="line" id="L931">        <span class="tok-kw">if</span> (index &lt; range.start + skip) {</span>
<span class="line" id="L932">            <span class="tok-kw">return</span> binaryLast(T, items, value, Range.init(range.start, index), context, lessThan);</span>
<span class="line" id="L933">        }</span>
<span class="line" id="L934">    }</span>
<span class="line" id="L935"></span>
<span class="line" id="L936">    <span class="tok-kw">return</span> binaryLast(T, items, value, Range.init(index, index + skip), context, lessThan);</span>
<span class="line" id="L937">}</span>
<span class="line" id="L938"></span>
<span class="line" id="L939"><span class="tok-kw">fn</span> <span class="tok-fn">binaryFirst</span>(</span>
<span class="line" id="L940">    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,</span>
<span class="line" id="L941">    items: []T,</span>
<span class="line" id="L942">    value: T,</span>
<span class="line" id="L943">    range: Range,</span>
<span class="line" id="L944">    context: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L945">    <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,</span>
<span class="line" id="L946">) <span class="tok-type">usize</span> {</span>
<span class="line" id="L947">    <span class="tok-kw">var</span> curr = range.start;</span>
<span class="line" id="L948">    <span class="tok-kw">var</span> size = range.length();</span>
<span class="line" id="L949">    <span class="tok-kw">if</span> (range.start &gt;= range.end) <span class="tok-kw">return</span> range.end;</span>
<span class="line" id="L950">    <span class="tok-kw">while</span> (size &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L951">        <span class="tok-kw">const</span> offset = size % <span class="tok-number">2</span>;</span>
<span class="line" id="L952"></span>
<span class="line" id="L953">        size /= <span class="tok-number">2</span>;</span>
<span class="line" id="L954">        <span class="tok-kw">const</span> mid_item = items[curr + size];</span>
<span class="line" id="L955">        <span class="tok-kw">if</span> (lessThan(context, mid_item, value)) {</span>
<span class="line" id="L956">            curr += size + offset;</span>
<span class="line" id="L957">        }</span>
<span class="line" id="L958">    }</span>
<span class="line" id="L959">    <span class="tok-kw">return</span> curr;</span>
<span class="line" id="L960">}</span>
<span class="line" id="L961"></span>
<span class="line" id="L962"><span class="tok-kw">fn</span> <span class="tok-fn">binaryLast</span>(</span>
<span class="line" id="L963">    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,</span>
<span class="line" id="L964">    items: []T,</span>
<span class="line" id="L965">    value: T,</span>
<span class="line" id="L966">    range: Range,</span>
<span class="line" id="L967">    context: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L968">    <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,</span>
<span class="line" id="L969">) <span class="tok-type">usize</span> {</span>
<span class="line" id="L970">    <span class="tok-kw">var</span> curr = range.start;</span>
<span class="line" id="L971">    <span class="tok-kw">var</span> size = range.length();</span>
<span class="line" id="L972">    <span class="tok-kw">if</span> (range.start &gt;= range.end) <span class="tok-kw">return</span> range.end;</span>
<span class="line" id="L973">    <span class="tok-kw">while</span> (size &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L974">        <span class="tok-kw">const</span> offset = size % <span class="tok-number">2</span>;</span>
<span class="line" id="L975"></span>
<span class="line" id="L976">        size /= <span class="tok-number">2</span>;</span>
<span class="line" id="L977">        <span class="tok-kw">const</span> mid_item = items[curr + size];</span>
<span class="line" id="L978">        <span class="tok-kw">if</span> (!lessThan(context, value, mid_item)) {</span>
<span class="line" id="L979">            curr += size + offset;</span>
<span class="line" id="L980">        }</span>
<span class="line" id="L981">    }</span>
<span class="line" id="L982">    <span class="tok-kw">return</span> curr;</span>
<span class="line" id="L983">}</span>
<span class="line" id="L984"></span>
<span class="line" id="L985"><span class="tok-kw">fn</span> <span class="tok-fn">mergeInto</span>(</span>
<span class="line" id="L986">    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,</span>
<span class="line" id="L987">    from: []T,</span>
<span class="line" id="L988">    A: Range,</span>
<span class="line" id="L989">    B: Range,</span>
<span class="line" id="L990">    into: []T,</span>
<span class="line" id="L991">    context: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L992">    <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,</span>
<span class="line" id="L993">) <span class="tok-type">void</span> {</span>
<span class="line" id="L994">    <span class="tok-kw">var</span> A_index: <span class="tok-type">usize</span> = A.start;</span>
<span class="line" id="L995">    <span class="tok-kw">var</span> B_index: <span class="tok-type">usize</span> = B.start;</span>
<span class="line" id="L996">    <span class="tok-kw">const</span> A_last = A.end;</span>
<span class="line" id="L997">    <span class="tok-kw">const</span> B_last = B.end;</span>
<span class="line" id="L998">    <span class="tok-kw">var</span> insert_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L999"></span>
<span class="line" id="L1000">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L1001">        <span class="tok-kw">if</span> (!lessThan(context, from[B_index], from[A_index])) {</span>
<span class="line" id="L1002">            into[insert_index] = from[A_index];</span>
<span class="line" id="L1003">            A_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L1004">            insert_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L1005">            <span class="tok-kw">if</span> (A_index == A_last) {</span>
<span class="line" id="L1006">                <span class="tok-comment">// copy the remainder of B into the final array</span>
</span>
<span class="line" id="L1007">                <span class="tok-kw">const</span> from_b = from[B_index..B_last];</span>
<span class="line" id="L1008">                <span class="tok-builtin">@memcpy</span>(into[insert_index..][<span class="tok-number">0</span>..from_b.len], from_b);</span>
<span class="line" id="L1009">                <span class="tok-kw">break</span>;</span>
<span class="line" id="L1010">            }</span>
<span class="line" id="L1011">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1012">            into[insert_index] = from[B_index];</span>
<span class="line" id="L1013">            B_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L1014">            insert_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L1015">            <span class="tok-kw">if</span> (B_index == B_last) {</span>
<span class="line" id="L1016">                <span class="tok-comment">// copy the remainder of A into the final array</span>
</span>
<span class="line" id="L1017">                <span class="tok-kw">const</span> from_a = from[A_index..A_last];</span>
<span class="line" id="L1018">                <span class="tok-builtin">@memcpy</span>(into[insert_index..][<span class="tok-number">0</span>..from_a.len], from_a);</span>
<span class="line" id="L1019">                <span class="tok-kw">break</span>;</span>
<span class="line" id="L1020">            }</span>
<span class="line" id="L1021">        }</span>
<span class="line" id="L1022">    }</span>
<span class="line" id="L1023">}</span>
<span class="line" id="L1024"></span>
<span class="line" id="L1025"><span class="tok-kw">fn</span> <span class="tok-fn">mergeExternal</span>(</span>
<span class="line" id="L1026">    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,</span>
<span class="line" id="L1027">    items: []T,</span>
<span class="line" id="L1028">    A: Range,</span>
<span class="line" id="L1029">    B: Range,</span>
<span class="line" id="L1030">    cache: []T,</span>
<span class="line" id="L1031">    context: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L1032">    <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,</span>
<span class="line" id="L1033">) <span class="tok-type">void</span> {</span>
<span class="line" id="L1034">    <span class="tok-comment">// A fits into the cache, so use that instead of the internal buffer</span>
</span>
<span class="line" id="L1035">    <span class="tok-kw">var</span> A_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1036">    <span class="tok-kw">var</span> B_index: <span class="tok-type">usize</span> = B.start;</span>
<span class="line" id="L1037">    <span class="tok-kw">var</span> insert_index: <span class="tok-type">usize</span> = A.start;</span>
<span class="line" id="L1038">    <span class="tok-kw">const</span> A_last = A.length();</span>
<span class="line" id="L1039">    <span class="tok-kw">const</span> B_last = B.end;</span>
<span class="line" id="L1040"></span>
<span class="line" id="L1041">    <span class="tok-kw">if</span> (B.length() &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> A.length() &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L1042">        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L1043">            <span class="tok-kw">if</span> (!lessThan(context, items[B_index], cache[A_index])) {</span>
<span class="line" id="L1044">                items[insert_index] = cache[A_index];</span>
<span class="line" id="L1045">                A_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L1046">                insert_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L1047">                <span class="tok-kw">if</span> (A_index == A_last) <span class="tok-kw">break</span>;</span>
<span class="line" id="L1048">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1049">                items[insert_index] = items[B_index];</span>
<span class="line" id="L1050">                B_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L1051">                insert_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L1052">                <span class="tok-kw">if</span> (B_index == B_last) <span class="tok-kw">break</span>;</span>
<span class="line" id="L1053">            }</span>
<span class="line" id="L1054">        }</span>
<span class="line" id="L1055">    }</span>
<span class="line" id="L1056"></span>
<span class="line" id="L1057">    <span class="tok-comment">// copy the remainder of A into the final array</span>
</span>
<span class="line" id="L1058">    <span class="tok-kw">const</span> cache_a = cache[A_index..A_last];</span>
<span class="line" id="L1059">    <span class="tok-builtin">@memcpy</span>(items[insert_index..][<span class="tok-number">0</span>..cache_a.len], cache_a);</span>
<span class="line" id="L1060">}</span>
<span class="line" id="L1061"></span>
<span class="line" id="L1062"><span class="tok-kw">fn</span> <span class="tok-fn">swap</span>(</span>
<span class="line" id="L1063">    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,</span>
<span class="line" id="L1064">    items: []T,</span>
<span class="line" id="L1065">    order: *[<span class="tok-number">8</span>]<span class="tok-type">u8</span>,</span>
<span class="line" id="L1066">    x: <span class="tok-type">usize</span>,</span>
<span class="line" id="L1067">    y: <span class="tok-type">usize</span>,</span>
<span class="line" id="L1068">    context: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L1069">    <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,</span>
<span class="line" id="L1070">) <span class="tok-type">void</span> {</span>
<span class="line" id="L1071">    <span class="tok-kw">if</span> (lessThan(context, items[y], items[x]) <span class="tok-kw">or</span> ((order.*)[x] &gt; (order.*)[y] <span class="tok-kw">and</span> !lessThan(context, items[x], items[y]))) {</span>
<span class="line" id="L1072">        mem.swap(T, &amp;items[x], &amp;items[y]);</span>
<span class="line" id="L1073">        mem.swap(<span class="tok-type">u8</span>, &amp;(order.*)[x], &amp;(order.*)[y]);</span>
<span class="line" id="L1074">    }</span>
<span class="line" id="L1075">}</span>
<span class="line" id="L1076"></span>
</code></pre></body>
</html>