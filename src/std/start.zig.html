<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>start.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg==">
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-comment">// This file is included in the compilation unit when exporting an executable.</span>
</span>
<span class="line" id="L2"></span>
<span class="line" id="L3"><span class="tok-kw">const</span> root = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;root&quot;</span>);</span>
<span class="line" id="L4"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std.zig&quot;</span>);</span>
<span class="line" id="L5"><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);</span>
<span class="line" id="L6"><span class="tok-kw">const</span> assert = std.debug.assert;</span>
<span class="line" id="L7"><span class="tok-kw">const</span> uefi = std.os.uefi;</span>
<span class="line" id="L8"><span class="tok-kw">const</span> elf = std.elf;</span>
<span class="line" id="L9"><span class="tok-kw">const</span> native_arch = builtin.cpu.arch;</span>
<span class="line" id="L10"><span class="tok-kw">const</span> native_os = builtin.os.tag;</span>
<span class="line" id="L11"></span>
<span class="line" id="L12"><span class="tok-kw">var</span> argc_argv_ptr: [*]<span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L13"></span>
<span class="line" id="L14"><span class="tok-kw">const</span> start_sym_name = <span class="tok-kw">if</span> (native_arch.isMIPS()) <span class="tok-str">&quot;__start&quot;</span> <span class="tok-kw">else</span> <span class="tok-str">&quot;_start&quot;</span>;</span>
<span class="line" id="L15"></span>
<span class="line" id="L16"><span class="tok-comment">// The self-hosted compiler is not fully capable of handling all of this start.zig file.</span>
</span>
<span class="line" id="L17"><span class="tok-comment">// Until then, we have simplified logic here for self-hosted. TODO remove this once</span>
</span>
<span class="line" id="L18"><span class="tok-comment">// self-hosted is capable enough to handle all of the real start.zig logic.</span>
</span>
<span class="line" id="L19"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> simplified_logic =</span>
<span class="line" id="L20">    builtin.zig_backend == .stage2_x86 <span class="tok-kw">or</span></span>
<span class="line" id="L21">    builtin.zig_backend == .stage2_aarch64 <span class="tok-kw">or</span></span>
<span class="line" id="L22">    builtin.zig_backend == .stage2_arm <span class="tok-kw">or</span></span>
<span class="line" id="L23">    builtin.zig_backend == .stage2_riscv64 <span class="tok-kw">or</span></span>
<span class="line" id="L24">    builtin.zig_backend == .stage2_sparc64 <span class="tok-kw">or</span></span>
<span class="line" id="L25">    builtin.cpu.arch == .spirv32 <span class="tok-kw">or</span></span>
<span class="line" id="L26">    builtin.cpu.arch == .spirv64;</span>
<span class="line" id="L27"></span>
<span class="line" id="L28"><span class="tok-kw">comptime</span> {</span>
<span class="line" id="L29">    <span class="tok-comment">// No matter what, we import the root file, so that any export, test, comptime</span>
</span>
<span class="line" id="L30">    <span class="tok-comment">// decls there get run.</span>
</span>
<span class="line" id="L31">    _ = root;</span>
<span class="line" id="L32"></span>
<span class="line" id="L33">    <span class="tok-kw">if</span> (simplified_logic) {</span>
<span class="line" id="L34">        <span class="tok-kw">if</span> (builtin.output_mode == .Exe) {</span>
<span class="line" id="L35">            <span class="tok-kw">if</span> ((builtin.link_libc <span class="tok-kw">or</span> builtin.object_format == .c) <span class="tok-kw">and</span> <span class="tok-builtin">@hasDecl</span>(root, <span class="tok-str">&quot;main&quot;</span>)) {</span>
<span class="line" id="L36">                <span class="tok-kw">if</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(root.main)).Fn.calling_convention != .C) {</span>
<span class="line" id="L37">                    <span class="tok-builtin">@export</span>(main2, .{ .name = <span class="tok-str">&quot;main&quot;</span> });</span>
<span class="line" id="L38">                }</span>
<span class="line" id="L39">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L40">                <span class="tok-kw">if</span> (!<span class="tok-builtin">@hasDecl</span>(root, <span class="tok-str">&quot;wWinMainCRTStartup&quot;</span>) <span class="tok-kw">and</span> !<span class="tok-builtin">@hasDecl</span>(root, <span class="tok-str">&quot;mainCRTStartup&quot;</span>)) {</span>
<span class="line" id="L41">                    <span class="tok-builtin">@export</span>(wWinMainCRTStartup2, .{ .name = <span class="tok-str">&quot;wWinMainCRTStartup&quot;</span> });</span>
<span class="line" id="L42">                }</span>
<span class="line" id="L43">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (builtin.os.tag == .opencl) {</span>
<span class="line" id="L44">                <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(root, <span class="tok-str">&quot;main&quot;</span>))</span>
<span class="line" id="L45">                    <span class="tok-builtin">@export</span>(spirvMain2, .{ .name = <span class="tok-str">&quot;main&quot;</span> });</span>
<span class="line" id="L46">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L47">                <span class="tok-kw">if</span> (!<span class="tok-builtin">@hasDecl</span>(root, <span class="tok-str">&quot;_start&quot;</span>)) {</span>
<span class="line" id="L48">                    <span class="tok-builtin">@export</span>(_start2, .{ .name = <span class="tok-str">&quot;_start&quot;</span> });</span>
<span class="line" id="L49">                }</span>
<span class="line" id="L50">            }</span>
<span class="line" id="L51">        }</span>
<span class="line" id="L52">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L53">        <span class="tok-kw">if</span> (builtin.output_mode == .Lib <span class="tok-kw">and</span> builtin.link_mode == .Dynamic) {</span>
<span class="line" id="L54">            <span class="tok-kw">if</span> (native_os == .windows <span class="tok-kw">and</span> !<span class="tok-builtin">@hasDecl</span>(root, <span class="tok-str">&quot;_DllMainCRTStartup&quot;</span>)) {</span>
<span class="line" id="L55">                <span class="tok-builtin">@export</span>(_DllMainCRTStartup, .{ .name = <span class="tok-str">&quot;_DllMainCRTStartup&quot;</span> });</span>
<span class="line" id="L56">            }</span>
<span class="line" id="L57">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (builtin.output_mode == .Exe <span class="tok-kw">or</span> <span class="tok-builtin">@hasDecl</span>(root, <span class="tok-str">&quot;main&quot;</span>)) {</span>
<span class="line" id="L58">            <span class="tok-kw">if</span> (builtin.link_libc <span class="tok-kw">and</span> <span class="tok-builtin">@hasDecl</span>(root, <span class="tok-str">&quot;main&quot;</span>)) {</span>
<span class="line" id="L59">                <span class="tok-kw">if</span> (native_arch.isWasm()) {</span>
<span class="line" id="L60">                    <span class="tok-builtin">@export</span>(mainWithoutEnv, .{ .name = <span class="tok-str">&quot;main&quot;</span> });</span>
<span class="line" id="L61">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(root.main)).Fn.calling_convention != .C) {</span>
<span class="line" id="L62">                    <span class="tok-builtin">@export</span>(main, .{ .name = <span class="tok-str">&quot;main&quot;</span> });</span>
<span class="line" id="L63">                }</span>
<span class="line" id="L64">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (native_os == .windows) {</span>
<span class="line" id="L65">                <span class="tok-kw">if</span> (!<span class="tok-builtin">@hasDecl</span>(root, <span class="tok-str">&quot;WinMain&quot;</span>) <span class="tok-kw">and</span> !<span class="tok-builtin">@hasDecl</span>(root, <span class="tok-str">&quot;WinMainCRTStartup&quot;</span>) <span class="tok-kw">and</span></span>
<span class="line" id="L66">                    !<span class="tok-builtin">@hasDecl</span>(root, <span class="tok-str">&quot;wWinMain&quot;</span>) <span class="tok-kw">and</span> !<span class="tok-builtin">@hasDecl</span>(root, <span class="tok-str">&quot;wWinMainCRTStartup&quot;</span>))</span>
<span class="line" id="L67">                {</span>
<span class="line" id="L68">                    <span class="tok-builtin">@export</span>(WinStartup, .{ .name = <span class="tok-str">&quot;wWinMainCRTStartup&quot;</span> });</span>
<span class="line" id="L69">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(root, <span class="tok-str">&quot;WinMain&quot;</span>) <span class="tok-kw">and</span> !<span class="tok-builtin">@hasDecl</span>(root, <span class="tok-str">&quot;WinMainCRTStartup&quot;</span>) <span class="tok-kw">and</span></span>
<span class="line" id="L70">                    !<span class="tok-builtin">@hasDecl</span>(root, <span class="tok-str">&quot;wWinMain&quot;</span>) <span class="tok-kw">and</span> !<span class="tok-builtin">@hasDecl</span>(root, <span class="tok-str">&quot;wWinMainCRTStartup&quot;</span>))</span>
<span class="line" id="L71">                {</span>
<span class="line" id="L72">                    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;WinMain not supported; declare wWinMain or main instead&quot;</span>);</span>
<span class="line" id="L73">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(root, <span class="tok-str">&quot;wWinMain&quot;</span>) <span class="tok-kw">and</span> !<span class="tok-builtin">@hasDecl</span>(root, <span class="tok-str">&quot;wWinMainCRTStartup&quot;</span>) <span class="tok-kw">and</span></span>
<span class="line" id="L74">                    !<span class="tok-builtin">@hasDecl</span>(root, <span class="tok-str">&quot;WinMain&quot;</span>) <span class="tok-kw">and</span> !<span class="tok-builtin">@hasDecl</span>(root, <span class="tok-str">&quot;WinMainCRTStartup&quot;</span>))</span>
<span class="line" id="L75">                {</span>
<span class="line" id="L76">                    <span class="tok-builtin">@export</span>(wWinMainCRTStartup, .{ .name = <span class="tok-str">&quot;wWinMainCRTStartup&quot;</span> });</span>
<span class="line" id="L77">                }</span>
<span class="line" id="L78">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (native_os == .uefi) {</span>
<span class="line" id="L79">                <span class="tok-kw">if</span> (!<span class="tok-builtin">@hasDecl</span>(root, <span class="tok-str">&quot;EfiMain&quot;</span>)) <span class="tok-builtin">@export</span>(EfiMain, .{ .name = <span class="tok-str">&quot;EfiMain&quot;</span> });</span>
<span class="line" id="L80">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (native_os == .wasi) {</span>
<span class="line" id="L81">                <span class="tok-kw">const</span> wasm_start_sym = <span class="tok-kw">switch</span> (builtin.wasi_exec_model) {</span>
<span class="line" id="L82">                    .reactor =&gt; <span class="tok-str">&quot;_initialize&quot;</span>,</span>
<span class="line" id="L83">                    .command =&gt; <span class="tok-str">&quot;_start&quot;</span>,</span>
<span class="line" id="L84">                };</span>
<span class="line" id="L85">                <span class="tok-kw">if</span> (!<span class="tok-builtin">@hasDecl</span>(root, wasm_start_sym) <span class="tok-kw">and</span> <span class="tok-builtin">@hasDecl</span>(root, <span class="tok-str">&quot;main&quot;</span>)) {</span>
<span class="line" id="L86">                    <span class="tok-comment">// Only call main when defined. For WebAssembly it's allowed to pass `-fno-entry` in which</span>
</span>
<span class="line" id="L87">                    <span class="tok-comment">// case it's not required to provide an entrypoint such as main.</span>
</span>
<span class="line" id="L88">                    <span class="tok-builtin">@export</span>(wasi_start, .{ .name = wasm_start_sym });</span>
<span class="line" id="L89">                }</span>
<span class="line" id="L90">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (native_arch.isWasm() <span class="tok-kw">and</span> native_os == .freestanding) {</span>
<span class="line" id="L91">                <span class="tok-comment">// Only call main when defined. For WebAssembly it's allowed to pass `-fno-entry` in which</span>
</span>
<span class="line" id="L92">                <span class="tok-comment">// case it's not required to provide an entrypoint such as main.</span>
</span>
<span class="line" id="L93">                <span class="tok-kw">if</span> (!<span class="tok-builtin">@hasDecl</span>(root, start_sym_name) <span class="tok-kw">and</span> <span class="tok-builtin">@hasDecl</span>(root, <span class="tok-str">&quot;main&quot;</span>)) <span class="tok-builtin">@export</span>(wasm_freestanding_start, .{ .name = start_sym_name });</span>
<span class="line" id="L94">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (native_os != .other <span class="tok-kw">and</span> native_os != .freestanding) {</span>
<span class="line" id="L95">                <span class="tok-kw">if</span> (!<span class="tok-builtin">@hasDecl</span>(root, start_sym_name)) <span class="tok-builtin">@export</span>(_start, .{ .name = start_sym_name });</span>
<span class="line" id="L96">            }</span>
<span class="line" id="L97">        }</span>
<span class="line" id="L98">    }</span>
<span class="line" id="L99">}</span>
<span class="line" id="L100"></span>
<span class="line" id="L101"><span class="tok-comment">// Simplified start code for stage2 until it supports more language features ///</span>
</span>
<span class="line" id="L102"></span>
<span class="line" id="L103"><span class="tok-kw">fn</span> <span class="tok-fn">main2</span>() <span class="tok-kw">callconv</span>(.C) <span class="tok-type">c_int</span> {</span>
<span class="line" id="L104">    root.main();</span>
<span class="line" id="L105">    <span class="tok-kw">return</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L106">}</span>
<span class="line" id="L107"></span>
<span class="line" id="L108"><span class="tok-kw">fn</span> <span class="tok-fn">_start2</span>() <span class="tok-type">noreturn</span> {</span>
<span class="line" id="L109">    callMain2();</span>
<span class="line" id="L110">}</span>
<span class="line" id="L111"></span>
<span class="line" id="L112"><span class="tok-kw">fn</span> <span class="tok-fn">callMain2</span>() <span class="tok-type">noreturn</span> {</span>
<span class="line" id="L113">    <span class="tok-builtin">@setAlignStack</span>(<span class="tok-number">16</span>);</span>
<span class="line" id="L114">    root.main();</span>
<span class="line" id="L115">    exit2(<span class="tok-number">0</span>);</span>
<span class="line" id="L116">}</span>
<span class="line" id="L117"></span>
<span class="line" id="L118"><span class="tok-kw">fn</span> <span class="tok-fn">spirvMain2</span>() <span class="tok-kw">callconv</span>(.Kernel) <span class="tok-type">void</span> {</span>
<span class="line" id="L119">    root.main();</span>
<span class="line" id="L120">}</span>
<span class="line" id="L121"></span>
<span class="line" id="L122"><span class="tok-kw">fn</span> <span class="tok-fn">wWinMainCRTStartup2</span>() <span class="tok-kw">callconv</span>(.C) <span class="tok-type">noreturn</span> {</span>
<span class="line" id="L123">    root.main();</span>
<span class="line" id="L124">    exit2(<span class="tok-number">0</span>);</span>
<span class="line" id="L125">}</span>
<span class="line" id="L126"></span>
<span class="line" id="L127"><span class="tok-kw">fn</span> <span class="tok-fn">exit2</span>(code: <span class="tok-type">usize</span>) <span class="tok-type">noreturn</span> {</span>
<span class="line" id="L128">    <span class="tok-kw">switch</span> (native_os) {</span>
<span class="line" id="L129">        .linux =&gt; <span class="tok-kw">switch</span> (builtin.cpu.arch) {</span>
<span class="line" id="L130">            .x86_64 =&gt; {</span>
<span class="line" id="L131">                <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (<span class="tok-str">&quot;syscall&quot;</span></span>
<span class="line" id="L132">                    :</span>
<span class="line" id="L133">                    : [number] <span class="tok-str">&quot;{rax}&quot;</span> (<span class="tok-number">231</span>),</span>
<span class="line" id="L134">                      [arg1] <span class="tok-str">&quot;{rdi}&quot;</span> (code),</span>
<span class="line" id="L135">                    : <span class="tok-str">&quot;rcx&quot;</span>, <span class="tok-str">&quot;r11&quot;</span>, <span class="tok-str">&quot;memory&quot;</span></span>
<span class="line" id="L136">                );</span>
<span class="line" id="L137">            },</span>
<span class="line" id="L138">            .arm =&gt; {</span>
<span class="line" id="L139">                <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (<span class="tok-str">&quot;svc #0&quot;</span></span>
<span class="line" id="L140">                    :</span>
<span class="line" id="L141">                    : [number] <span class="tok-str">&quot;{r7}&quot;</span> (<span class="tok-number">1</span>),</span>
<span class="line" id="L142">                      [arg1] <span class="tok-str">&quot;{r0}&quot;</span> (code),</span>
<span class="line" id="L143">                    : <span class="tok-str">&quot;memory&quot;</span></span>
<span class="line" id="L144">                );</span>
<span class="line" id="L145">            },</span>
<span class="line" id="L146">            .aarch64 =&gt; {</span>
<span class="line" id="L147">                <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (<span class="tok-str">&quot;svc #0&quot;</span></span>
<span class="line" id="L148">                    :</span>
<span class="line" id="L149">                    : [number] <span class="tok-str">&quot;{x8}&quot;</span> (<span class="tok-number">93</span>),</span>
<span class="line" id="L150">                      [arg1] <span class="tok-str">&quot;{x0}&quot;</span> (code),</span>
<span class="line" id="L151">                    : <span class="tok-str">&quot;memory&quot;</span>, <span class="tok-str">&quot;cc&quot;</span></span>
<span class="line" id="L152">                );</span>
<span class="line" id="L153">            },</span>
<span class="line" id="L154">            .riscv64 =&gt; {</span>
<span class="line" id="L155">                <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (<span class="tok-str">&quot;ecall&quot;</span></span>
<span class="line" id="L156">                    :</span>
<span class="line" id="L157">                    : [number] <span class="tok-str">&quot;{a7}&quot;</span> (<span class="tok-number">94</span>),</span>
<span class="line" id="L158">                      [arg1] <span class="tok-str">&quot;{a0}&quot;</span> (<span class="tok-number">0</span>),</span>
<span class="line" id="L159">                    : <span class="tok-str">&quot;rcx&quot;</span>, <span class="tok-str">&quot;r11&quot;</span>, <span class="tok-str">&quot;memory&quot;</span></span>
<span class="line" id="L160">                );</span>
<span class="line" id="L161">            },</span>
<span class="line" id="L162">            .sparc64 =&gt; {</span>
<span class="line" id="L163">                <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (<span class="tok-str">&quot;ta 0x6d&quot;</span></span>
<span class="line" id="L164">                    :</span>
<span class="line" id="L165">                    : [number] <span class="tok-str">&quot;{g1}&quot;</span> (<span class="tok-number">1</span>),</span>
<span class="line" id="L166">                      [arg1] <span class="tok-str">&quot;{o0}&quot;</span> (code),</span>
<span class="line" id="L167">                    : <span class="tok-str">&quot;o0&quot;</span>, <span class="tok-str">&quot;o1&quot;</span>, <span class="tok-str">&quot;o2&quot;</span>, <span class="tok-str">&quot;o3&quot;</span>, <span class="tok-str">&quot;o4&quot;</span>, <span class="tok-str">&quot;o5&quot;</span>, <span class="tok-str">&quot;o6&quot;</span>, <span class="tok-str">&quot;o7&quot;</span>, <span class="tok-str">&quot;memory&quot;</span></span>
<span class="line" id="L168">                );</span>
<span class="line" id="L169">            },</span>
<span class="line" id="L170">            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;TODO&quot;</span>),</span>
<span class="line" id="L171">        },</span>
<span class="line" id="L172">        <span class="tok-comment">// exits(0)</span>
</span>
<span class="line" id="L173">        .plan9 =&gt; std.os.plan9.exits(<span class="tok-null">null</span>),</span>
<span class="line" id="L174">        .windows =&gt; {</span>
<span class="line" id="L175">            std.os.windows.ntdll.RtlExitUserProcess(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@truncate</span>(code)));</span>
<span class="line" id="L176">        },</span>
<span class="line" id="L177">        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;TODO&quot;</span>),</span>
<span class="line" id="L178">    }</span>
<span class="line" id="L179">    <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L180">}</span>
<span class="line" id="L181"></span>
<span class="line" id="L182"><span class="tok-comment">////////////////////////////////////////////////////////////////////////////////</span>
</span>
<span class="line" id="L183"></span>
<span class="line" id="L184"><span class="tok-kw">fn</span> <span class="tok-fn">_DllMainCRTStartup</span>(</span>
<span class="line" id="L185">    hinstDLL: std.os.windows.HINSTANCE,</span>
<span class="line" id="L186">    fdwReason: std.os.windows.DWORD,</span>
<span class="line" id="L187">    lpReserved: std.os.windows.LPVOID,</span>
<span class="line" id="L188">) <span class="tok-kw">callconv</span>(std.os.windows.WINAPI) std.os.windows.BOOL {</span>
<span class="line" id="L189">    <span class="tok-kw">if</span> (!builtin.single_threaded <span class="tok-kw">and</span> !builtin.link_libc) {</span>
<span class="line" id="L190">        _ = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;start_windows_tls.zig&quot;</span>);</span>
<span class="line" id="L191">    }</span>
<span class="line" id="L192"></span>
<span class="line" id="L193">    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(root, <span class="tok-str">&quot;DllMain&quot;</span>)) {</span>
<span class="line" id="L194">        <span class="tok-kw">return</span> root.DllMain(hinstDLL, fdwReason, lpReserved);</span>
<span class="line" id="L195">    }</span>
<span class="line" id="L196"></span>
<span class="line" id="L197">    <span class="tok-kw">return</span> std.os.windows.TRUE;</span>
<span class="line" id="L198">}</span>
<span class="line" id="L199"></span>
<span class="line" id="L200"><span class="tok-kw">fn</span> <span class="tok-fn">wasm_freestanding_start</span>() <span class="tok-kw">callconv</span>(.C) <span class="tok-type">void</span> {</span>
<span class="line" id="L201">    <span class="tok-comment">// This is marked inline because for some reason LLVM in</span>
</span>
<span class="line" id="L202">    <span class="tok-comment">// release mode fails to inline it, and we want fewer call frames in stack traces.</span>
</span>
<span class="line" id="L203">    _ = <span class="tok-builtin">@call</span>(.always_inline, callMain, .{});</span>
<span class="line" id="L204">}</span>
<span class="line" id="L205"></span>
<span class="line" id="L206"><span class="tok-kw">fn</span> <span class="tok-fn">wasi_start</span>() <span class="tok-kw">callconv</span>(.C) <span class="tok-type">void</span> {</span>
<span class="line" id="L207">    <span class="tok-comment">// The function call is marked inline because for some reason LLVM in</span>
</span>
<span class="line" id="L208">    <span class="tok-comment">// release mode fails to inline it, and we want fewer call frames in stack traces.</span>
</span>
<span class="line" id="L209">    <span class="tok-kw">switch</span> (builtin.wasi_exec_model) {</span>
<span class="line" id="L210">        .reactor =&gt; _ = <span class="tok-builtin">@call</span>(.always_inline, callMain, .{}),</span>
<span class="line" id="L211">        .command =&gt; std.os.wasi.proc_exit(<span class="tok-builtin">@call</span>(.always_inline, callMain, .{})),</span>
<span class="line" id="L212">    }</span>
<span class="line" id="L213">}</span>
<span class="line" id="L214"></span>
<span class="line" id="L215"><span class="tok-kw">fn</span> <span class="tok-fn">EfiMain</span>(handle: uefi.Handle, system_table: *uefi.tables.SystemTable) <span class="tok-kw">callconv</span>(.C) <span class="tok-type">usize</span> {</span>
<span class="line" id="L216">    uefi.handle = handle;</span>
<span class="line" id="L217">    uefi.system_table = system_table;</span>
<span class="line" id="L218"></span>
<span class="line" id="L219">    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(root.main)).Fn.return_type.?) {</span>
<span class="line" id="L220">        <span class="tok-type">noreturn</span> =&gt; {</span>
<span class="line" id="L221">            root.main();</span>
<span class="line" id="L222">        },</span>
<span class="line" id="L223">        <span class="tok-type">void</span> =&gt; {</span>
<span class="line" id="L224">            root.main();</span>
<span class="line" id="L225">            <span class="tok-kw">return</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L226">        },</span>
<span class="line" id="L227">        <span class="tok-type">usize</span> =&gt; {</span>
<span class="line" id="L228">            <span class="tok-kw">return</span> root.main();</span>
<span class="line" id="L229">        },</span>
<span class="line" id="L230">        uefi.Status =&gt; {</span>
<span class="line" id="L231">            <span class="tok-kw">return</span> <span class="tok-builtin">@intFromEnum</span>(root.main());</span>
<span class="line" id="L232">        },</span>
<span class="line" id="L233">        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;expected return type of main to be 'void', 'noreturn', 'usize', or 'std.os.uefi.Status'&quot;</span>),</span>
<span class="line" id="L234">    }</span>
<span class="line" id="L235">}</span>
<span class="line" id="L236"></span>
<span class="line" id="L237"><span class="tok-kw">fn</span> <span class="tok-fn">_start</span>() <span class="tok-kw">callconv</span>(.Naked) <span class="tok-type">noreturn</span> {</span>
<span class="line" id="L238">    <span class="tok-comment">// TODO set Top of Stack on non x86_64-plan9</span>
</span>
<span class="line" id="L239">    <span class="tok-kw">if</span> (native_os == .plan9 <span class="tok-kw">and</span> native_arch == .x86_64) {</span>
<span class="line" id="L240">        <span class="tok-comment">// from /sys/src/libc/amd64/main9.s</span>
</span>
<span class="line" id="L241">        std.os.plan9.tos = <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (<span class="tok-str">&quot;&quot;</span></span>
<span class="line" id="L242">            : [tos] <span class="tok-str">&quot;={rax}&quot;</span> (-&gt; *std.os.plan9.Tos),</span>
<span class="line" id="L243">        );</span>
<span class="line" id="L244">    }</span>
<span class="line" id="L245">    <span class="tok-kw">switch</span> (native_arch) {</span>
<span class="line" id="L246">        <span class="tok-comment">// https://github.com/ziglang/zig/issues/16799</span>
</span>
<span class="line" id="L247">        .riscv64 =&gt; <span class="tok-builtin">@export</span>(argc_argv_ptr, .{</span>
<span class="line" id="L248">            .name = <span class="tok-str">&quot;__zig_argc_argv_ptr&quot;</span>,</span>
<span class="line" id="L249">            .visibility = .hidden,</span>
<span class="line" id="L250">        }),</span>
<span class="line" id="L251">        <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L252">    }</span>
<span class="line" id="L253">    <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (<span class="tok-kw">switch</span> (native_arch) {</span>
<span class="line" id="L254">            .x86_64 =&gt;</span>
<span class="line" id="L255">            <span class="tok-str">\\ xorl %%ebp, %%ebp</span></span>

<span class="line" id="L256">            <span class="tok-str">\\ movq %%rsp, %[argc_argv_ptr]</span></span>

<span class="line" id="L257">            <span class="tok-str">\\ andq $-16, %%rsp</span></span>

<span class="line" id="L258">            <span class="tok-str">\\ callq %[posixCallMainAndExit:P]</span></span>

<span class="line" id="L259">            ,</span>
<span class="line" id="L260">            .x86 =&gt;</span>
<span class="line" id="L261">            <span class="tok-str">\\ xorl %%ebp, %%ebp</span></span>

<span class="line" id="L262">            <span class="tok-str">\\ movl %%esp, %[argc_argv_ptr]</span></span>

<span class="line" id="L263">            <span class="tok-str">\\ andl $-16, %%esp</span></span>

<span class="line" id="L264">            <span class="tok-str">\\ calll %[posixCallMainAndExit:P]</span></span>

<span class="line" id="L265">            ,</span>
<span class="line" id="L266">            .aarch64, .aarch64_be =&gt;</span>
<span class="line" id="L267">            <span class="tok-str">\\ mov fp, #0</span></span>

<span class="line" id="L268">            <span class="tok-str">\\ mov lr, #0</span></span>

<span class="line" id="L269">            <span class="tok-str">\\ mov x0, sp</span></span>

<span class="line" id="L270">            <span class="tok-str">\\ str x0, %[argc_argv_ptr]</span></span>

<span class="line" id="L271">            <span class="tok-str">\\ b %[posixCallMainAndExit]</span></span>

<span class="line" id="L272">            ,</span>
<span class="line" id="L273">            .arm, .armeb, .thumb, .thumbeb =&gt;</span>
<span class="line" id="L274">            <span class="tok-str">\\ mov fp, #0</span></span>

<span class="line" id="L275">            <span class="tok-str">\\ mov lr, #0</span></span>

<span class="line" id="L276">            <span class="tok-str">\\ str sp, %[argc_argv_ptr]</span></span>

<span class="line" id="L277">            <span class="tok-str">\\ and sp, #-16</span></span>

<span class="line" id="L278">            <span class="tok-str">\\ b %[posixCallMainAndExit]</span></span>

<span class="line" id="L279">            ,</span>
<span class="line" id="L280">            .riscv64 =&gt;</span>
<span class="line" id="L281">            <span class="tok-str">\\ li s0, 0</span></span>

<span class="line" id="L282">            <span class="tok-str">\\ li ra, 0</span></span>

<span class="line" id="L283">            <span class="tok-str">\\ lui a0, %hi(__zig_argc_argv_ptr)</span></span>

<span class="line" id="L284">            <span class="tok-str">\\ sd sp, %lo(__zig_argc_argv_ptr)(a0)</span></span>

<span class="line" id="L285">            <span class="tok-str">\\ andi sp, sp, -16</span></span>

<span class="line" id="L286">            <span class="tok-str">\\ tail %[posixCallMainAndExit]@plt</span></span>

<span class="line" id="L287">            ,</span>
<span class="line" id="L288">            .mips, .mipsel =&gt;</span>
<span class="line" id="L289">            <span class="tok-comment">// The lr is already zeroed on entry, as specified by the ABI.</span>
</span>
<span class="line" id="L290">            <span class="tok-str">\\ addiu $fp, $zero, 0</span></span>

<span class="line" id="L291">            <span class="tok-str">\\ sw $sp, %[argc_argv_ptr]</span></span>

<span class="line" id="L292">            <span class="tok-str">\\ .set push</span></span>

<span class="line" id="L293">            <span class="tok-str">\\ .set noat</span></span>

<span class="line" id="L294">            <span class="tok-str">\\ addiu $1, $zero, -16</span></span>

<span class="line" id="L295">            <span class="tok-str">\\ and $sp, $sp, $1</span></span>

<span class="line" id="L296">            <span class="tok-str">\\ .set pop</span></span>

<span class="line" id="L297">            <span class="tok-str">\\ j %[posixCallMainAndExit]</span></span>

<span class="line" id="L298">            ,</span>
<span class="line" id="L299">            .mips64, .mips64el =&gt;</span>
<span class="line" id="L300">            <span class="tok-comment">// The lr is already zeroed on entry, as specified by the ABI.</span>
</span>
<span class="line" id="L301">            <span class="tok-str">\\ addiu $fp, $zero, 0</span></span>

<span class="line" id="L302">            <span class="tok-str">\\ sd $sp, %[argc_argv_ptr]</span></span>

<span class="line" id="L303">            <span class="tok-str">\\ .set push</span></span>

<span class="line" id="L304">            <span class="tok-str">\\ .set noat</span></span>

<span class="line" id="L305">            <span class="tok-str">\\ daddiu $1, $zero, -16</span></span>

<span class="line" id="L306">            <span class="tok-str">\\ and $sp, $sp, $1</span></span>

<span class="line" id="L307">            <span class="tok-str">\\ .set pop</span></span>

<span class="line" id="L308">            <span class="tok-str">\\ j %[posixCallMainAndExit]</span></span>

<span class="line" id="L309">            ,</span>
<span class="line" id="L310">            .powerpc, .powerpcle =&gt;</span>
<span class="line" id="L311">            <span class="tok-comment">// Setup the initial stack frame and clear the back chain pointer.</span>
</span>
<span class="line" id="L312">            <span class="tok-str">\\ stw 1, %[argc_argv_ptr]</span></span>

<span class="line" id="L313">            <span class="tok-str">\\ li 0, 0</span></span>

<span class="line" id="L314">            <span class="tok-str">\\ stwu 1, -16(1)</span></span>

<span class="line" id="L315">            <span class="tok-str">\\ stw 0, 0(1)</span></span>

<span class="line" id="L316">            <span class="tok-str">\\ mtlr 0</span></span>

<span class="line" id="L317">            <span class="tok-str">\\ b %[posixCallMainAndExit]</span></span>

<span class="line" id="L318">            ,</span>
<span class="line" id="L319">            .powerpc64, .powerpc64le =&gt;</span>
<span class="line" id="L320">            <span class="tok-comment">// Setup the initial stack frame and clear the back chain pointer.</span>
</span>
<span class="line" id="L321">            <span class="tok-comment">// TODO: Support powerpc64 (big endian) on ELFv2.</span>
</span>
<span class="line" id="L322">            <span class="tok-str">\\ std 1, %[argc_argv_ptr]</span></span>

<span class="line" id="L323">            <span class="tok-str">\\ li 0, 0</span></span>

<span class="line" id="L324">            <span class="tok-str">\\ stdu 0, -32(1)</span></span>

<span class="line" id="L325">            <span class="tok-str">\\ mtlr 0</span></span>

<span class="line" id="L326">            <span class="tok-str">\\ b %[posixCallMainAndExit]</span></span>

<span class="line" id="L327">            ,</span>
<span class="line" id="L328">            .sparc64 =&gt;</span>
<span class="line" id="L329">            <span class="tok-comment">// argc is stored after a register window (16 registers) plus stack bias</span>
</span>
<span class="line" id="L330">            <span class="tok-str">\\ mov %%g0, %%i6</span></span>

<span class="line" id="L331">            <span class="tok-str">\\ add %%o6, 2175, %%l0</span></span>

<span class="line" id="L332">            <span class="tok-str">\\ ba %[posixCallMainAndExit]</span></span>

<span class="line" id="L333">            <span class="tok-str">\\  stx %%l0, %[argc_argv_ptr]</span></span>

<span class="line" id="L334">            ,</span>
<span class="line" id="L335">            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unsupported arch&quot;</span>),</span>
<span class="line" id="L336">        }</span>
<span class="line" id="L337">        : [argc_argv_ptr] <span class="tok-str">&quot;=m&quot;</span> (argc_argv_ptr),</span>
<span class="line" id="L338">        : [posixCallMainAndExit] <span class="tok-str">&quot;X&quot;</span> (&amp;posixCallMainAndExit),</span>
<span class="line" id="L339">    );</span>
<span class="line" id="L340">}</span>
<span class="line" id="L341"></span>
<span class="line" id="L342"><span class="tok-kw">fn</span> <span class="tok-fn">WinStartup</span>() <span class="tok-kw">callconv</span>(std.os.windows.WINAPI) <span class="tok-type">noreturn</span> {</span>
<span class="line" id="L343">    <span class="tok-builtin">@setAlignStack</span>(<span class="tok-number">16</span>);</span>
<span class="line" id="L344">    <span class="tok-kw">if</span> (!builtin.single_threaded <span class="tok-kw">and</span> !builtin.link_libc) {</span>
<span class="line" id="L345">        _ = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;start_windows_tls.zig&quot;</span>);</span>
<span class="line" id="L346">    }</span>
<span class="line" id="L347"></span>
<span class="line" id="L348">    std.debug.maybeEnableSegfaultHandler();</span>
<span class="line" id="L349"></span>
<span class="line" id="L350">    std.os.windows.ntdll.RtlExitUserProcess(initEventLoopAndCallMain());</span>
<span class="line" id="L351">}</span>
<span class="line" id="L352"></span>
<span class="line" id="L353"><span class="tok-kw">fn</span> <span class="tok-fn">wWinMainCRTStartup</span>() <span class="tok-kw">callconv</span>(std.os.windows.WINAPI) <span class="tok-type">noreturn</span> {</span>
<span class="line" id="L354">    <span class="tok-builtin">@setAlignStack</span>(<span class="tok-number">16</span>);</span>
<span class="line" id="L355">    <span class="tok-kw">if</span> (!builtin.single_threaded <span class="tok-kw">and</span> !builtin.link_libc) {</span>
<span class="line" id="L356">        _ = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;start_windows_tls.zig&quot;</span>);</span>
<span class="line" id="L357">    }</span>
<span class="line" id="L358"></span>
<span class="line" id="L359">    std.debug.maybeEnableSegfaultHandler();</span>
<span class="line" id="L360"></span>
<span class="line" id="L361">    <span class="tok-kw">const</span> result: std.os.windows.INT = initEventLoopAndCallWinMain();</span>
<span class="line" id="L362">    std.os.windows.ntdll.RtlExitUserProcess(<span class="tok-builtin">@as</span>(std.os.windows.UINT, <span class="tok-builtin">@bitCast</span>(result)));</span>
<span class="line" id="L363">}</span>
<span class="line" id="L364"></span>
<span class="line" id="L365"><span class="tok-kw">fn</span> <span class="tok-fn">posixCallMainAndExit</span>() <span class="tok-kw">callconv</span>(.C) <span class="tok-type">noreturn</span> {</span>
<span class="line" id="L366">    <span class="tok-kw">const</span> argc = argc_argv_ptr[<span class="tok-number">0</span>];</span>
<span class="line" id="L367">    <span class="tok-kw">const</span> argv = <span class="tok-builtin">@as</span>([*][*:<span class="tok-number">0</span>]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(argc_argv_ptr + <span class="tok-number">1</span>));</span>
<span class="line" id="L368"></span>
<span class="line" id="L369">    <span class="tok-kw">const</span> envp_optional: [*:<span class="tok-null">null</span>]?[*:<span class="tok-number">0</span>]<span class="tok-type">u8</span> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(argv + argc + <span class="tok-number">1</span>));</span>
<span class="line" id="L370">    <span class="tok-kw">var</span> envp_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L371">    <span class="tok-kw">while</span> (envp_optional[envp_count]) |_| : (envp_count += <span class="tok-number">1</span>) {}</span>
<span class="line" id="L372">    <span class="tok-kw">const</span> envp = <span class="tok-builtin">@as</span>([*][*:<span class="tok-number">0</span>]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(envp_optional))[<span class="tok-number">0</span>..envp_count];</span>
<span class="line" id="L373"></span>
<span class="line" id="L374">    <span class="tok-kw">if</span> (native_os == .linux) {</span>
<span class="line" id="L375">        <span class="tok-comment">// Find the beginning of the auxiliary vector</span>
</span>
<span class="line" id="L376">        <span class="tok-kw">const</span> auxv: [*]elf.Auxv = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(envp.ptr + envp_count + <span class="tok-number">1</span>));</span>
<span class="line" id="L377">        std.os.linux.elf_aux_maybe = auxv;</span>
<span class="line" id="L378"></span>
<span class="line" id="L379">        <span class="tok-kw">var</span> at_hwcap: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L380">        <span class="tok-kw">const</span> phdrs = init: {</span>
<span class="line" id="L381">            <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L382">            <span class="tok-kw">var</span> at_phdr: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L383">            <span class="tok-kw">var</span> at_phnum: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L384">            <span class="tok-kw">while</span> (auxv[i].a_type != elf.AT_NULL) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L385">                <span class="tok-kw">switch</span> (auxv[i].a_type) {</span>
<span class="line" id="L386">                    elf.AT_PHNUM =&gt; at_phnum = auxv[i].a_un.a_val,</span>
<span class="line" id="L387">                    elf.AT_PHDR =&gt; at_phdr = auxv[i].a_un.a_val,</span>
<span class="line" id="L388">                    elf.AT_HWCAP =&gt; at_hwcap = auxv[i].a_un.a_val,</span>
<span class="line" id="L389">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L390">                }</span>
<span class="line" id="L391">            }</span>
<span class="line" id="L392">            <span class="tok-kw">break</span> :init <span class="tok-builtin">@as</span>([*]elf.Phdr, <span class="tok-builtin">@ptrFromInt</span>(at_phdr))[<span class="tok-number">0</span>..at_phnum];</span>
<span class="line" id="L393">        };</span>
<span class="line" id="L394"></span>
<span class="line" id="L395">        <span class="tok-comment">// Apply the initial relocations as early as possible in the startup</span>
</span>
<span class="line" id="L396">        <span class="tok-comment">// process.</span>
</span>
<span class="line" id="L397">        <span class="tok-kw">if</span> (builtin.position_independent_executable) {</span>
<span class="line" id="L398">            std.os.linux.pie.relocate(phdrs);</span>
<span class="line" id="L399">        }</span>
<span class="line" id="L400"></span>
<span class="line" id="L401">        <span class="tok-kw">if</span> (!builtin.single_threaded) {</span>
<span class="line" id="L402">            <span class="tok-comment">// ARMv6 targets (and earlier) have no support for TLS in hardware.</span>
</span>
<span class="line" id="L403">            <span class="tok-comment">// FIXME: Elide the check for targets &gt;= ARMv7 when the target feature API</span>
</span>
<span class="line" id="L404">            <span class="tok-comment">// becomes less verbose (and more usable).</span>
</span>
<span class="line" id="L405">            <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> native_arch.isARM()) {</span>
<span class="line" id="L406">                <span class="tok-kw">if</span> (at_hwcap &amp; std.os.linux.HWCAP.TLS == <span class="tok-number">0</span>) {</span>
<span class="line" id="L407">                    <span class="tok-comment">// FIXME: Make __aeabi_read_tp call the kernel helper kuser_get_tls</span>
</span>
<span class="line" id="L408">                    <span class="tok-comment">// For the time being use a simple abort instead of a @panic call to</span>
</span>
<span class="line" id="L409">                    <span class="tok-comment">// keep the binary bloat under control.</span>
</span>
<span class="line" id="L410">                    std.os.abort();</span>
<span class="line" id="L411">                }</span>
<span class="line" id="L412">            }</span>
<span class="line" id="L413"></span>
<span class="line" id="L414">            <span class="tok-comment">// Initialize the TLS area.</span>
</span>
<span class="line" id="L415">            std.os.linux.tls.initStaticTLS(phdrs);</span>
<span class="line" id="L416">        }</span>
<span class="line" id="L417"></span>
<span class="line" id="L418">        <span class="tok-comment">// The way Linux executables represent stack size is via the PT_GNU_STACK</span>
</span>
<span class="line" id="L419">        <span class="tok-comment">// program header. However the kernel does not recognize it; it always gives 8 MiB.</span>
</span>
<span class="line" id="L420">        <span class="tok-comment">// Here we look for the stack size in our program headers and use setrlimit</span>
</span>
<span class="line" id="L421">        <span class="tok-comment">// to ask for more stack space.</span>
</span>
<span class="line" id="L422">        expandStackSize(phdrs);</span>
<span class="line" id="L423">    }</span>
<span class="line" id="L424"></span>
<span class="line" id="L425">    std.os.exit(<span class="tok-builtin">@call</span>(.always_inline, callMainWithArgs, .{ argc, argv, envp }));</span>
<span class="line" id="L426">}</span>
<span class="line" id="L427"></span>
<span class="line" id="L428"><span class="tok-kw">fn</span> <span class="tok-fn">expandStackSize</span>(phdrs: []elf.Phdr) <span class="tok-type">void</span> {</span>
<span class="line" id="L429">    <span class="tok-kw">for</span> (phdrs) |*phdr| {</span>
<span class="line" id="L430">        <span class="tok-kw">switch</span> (phdr.p_type) {</span>
<span class="line" id="L431">            elf.PT_GNU_STACK =&gt; {</span>
<span class="line" id="L432">                assert(phdr.p_memsz % std.mem.page_size == <span class="tok-number">0</span>);</span>
<span class="line" id="L433"></span>
<span class="line" id="L434">                <span class="tok-comment">// Silently fail if we are unable to get limits.</span>
</span>
<span class="line" id="L435">                <span class="tok-kw">const</span> limits = std.os.getrlimit(.STACK) <span class="tok-kw">catch</span> <span class="tok-kw">break</span>;</span>
<span class="line" id="L436"></span>
<span class="line" id="L437">                <span class="tok-comment">// Clamp to limits.max .</span>
</span>
<span class="line" id="L438">                <span class="tok-kw">const</span> wanted_stack_size = <span class="tok-builtin">@min</span>(phdr.p_memsz, limits.max);</span>
<span class="line" id="L439"></span>
<span class="line" id="L440">                <span class="tok-kw">if</span> (wanted_stack_size &gt; limits.cur) {</span>
<span class="line" id="L441">                    std.os.setrlimit(.STACK, .{</span>
<span class="line" id="L442">                        .cur = wanted_stack_size,</span>
<span class="line" id="L443">                        .max = limits.max,</span>
<span class="line" id="L444">                    }) <span class="tok-kw">catch</span> {</span>
<span class="line" id="L445">                        <span class="tok-comment">// Because we could not increase the stack size to the upper bound,</span>
</span>
<span class="line" id="L446">                        <span class="tok-comment">// depending on what happens at runtime, a stack overflow may occur.</span>
</span>
<span class="line" id="L447">                        <span class="tok-comment">// However it would cause a segmentation fault, thanks to stack probing,</span>
</span>
<span class="line" id="L448">                        <span class="tok-comment">// so we do not have a memory safety issue here.</span>
</span>
<span class="line" id="L449">                        <span class="tok-comment">// This is intentional silent failure.</span>
</span>
<span class="line" id="L450">                        <span class="tok-comment">// This logic should be revisited when the following issues are addressed:</span>
</span>
<span class="line" id="L451">                        <span class="tok-comment">// https://github.com/ziglang/zig/issues/157</span>
</span>
<span class="line" id="L452">                        <span class="tok-comment">// https://github.com/ziglang/zig/issues/1006</span>
</span>
<span class="line" id="L453">                    };</span>
<span class="line" id="L454">                }</span>
<span class="line" id="L455">                <span class="tok-kw">break</span>;</span>
<span class="line" id="L456">            },</span>
<span class="line" id="L457">            <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L458">        }</span>
<span class="line" id="L459">    }</span>
<span class="line" id="L460">}</span>
<span class="line" id="L461"></span>
<span class="line" id="L462"><span class="tok-kw">fn</span> <span class="tok-fn">callMainWithArgs</span>(argc: <span class="tok-type">usize</span>, argv: [*][*:<span class="tok-number">0</span>]<span class="tok-type">u8</span>, envp: [][*:<span class="tok-number">0</span>]<span class="tok-type">u8</span>) <span class="tok-type">u8</span> {</span>
<span class="line" id="L463">    std.os.argv = argv[<span class="tok-number">0</span>..argc];</span>
<span class="line" id="L464">    std.os.environ = envp;</span>
<span class="line" id="L465"></span>
<span class="line" id="L466">    std.debug.maybeEnableSegfaultHandler();</span>
<span class="line" id="L467">    std.os.maybeIgnoreSigpipe();</span>
<span class="line" id="L468"></span>
<span class="line" id="L469">    <span class="tok-kw">return</span> initEventLoopAndCallMain();</span>
<span class="line" id="L470">}</span>
<span class="line" id="L471"></span>
<span class="line" id="L472"><span class="tok-kw">fn</span> <span class="tok-fn">main</span>(c_argc: <span class="tok-type">c_int</span>, c_argv: [*][*:<span class="tok-number">0</span>]<span class="tok-type">c_char</span>, c_envp: [*:<span class="tok-null">null</span>]?[*:<span class="tok-number">0</span>]<span class="tok-type">c_char</span>) <span class="tok-kw">callconv</span>(.C) <span class="tok-type">c_int</span> {</span>
<span class="line" id="L473">    <span class="tok-kw">var</span> env_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L474">    <span class="tok-kw">while</span> (c_envp[env_count] != <span class="tok-null">null</span>) : (env_count += <span class="tok-number">1</span>) {}</span>
<span class="line" id="L475">    <span class="tok-kw">const</span> envp = <span class="tok-builtin">@as</span>([*][*:<span class="tok-number">0</span>]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(c_envp))[<span class="tok-number">0</span>..env_count];</span>
<span class="line" id="L476"></span>
<span class="line" id="L477">    <span class="tok-kw">if</span> (builtin.os.tag == .linux) {</span>
<span class="line" id="L478">        <span class="tok-kw">const</span> at_phdr = std.c.getauxval(elf.AT_PHDR);</span>
<span class="line" id="L479">        <span class="tok-kw">const</span> at_phnum = std.c.getauxval(elf.AT_PHNUM);</span>
<span class="line" id="L480">        <span class="tok-kw">const</span> phdrs = (<span class="tok-builtin">@as</span>([*]elf.Phdr, <span class="tok-builtin">@ptrFromInt</span>(at_phdr)))[<span class="tok-number">0</span>..at_phnum];</span>
<span class="line" id="L481">        expandStackSize(phdrs);</span>
<span class="line" id="L482">    }</span>
<span class="line" id="L483"></span>
<span class="line" id="L484">    <span class="tok-kw">return</span> <span class="tok-builtin">@call</span>(.always_inline, callMainWithArgs, .{ <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(c_argc)), <span class="tok-builtin">@as</span>([*][*:<span class="tok-number">0</span>]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(c_argv)), envp });</span>
<span class="line" id="L485">}</span>
<span class="line" id="L486"></span>
<span class="line" id="L487"><span class="tok-kw">fn</span> <span class="tok-fn">mainWithoutEnv</span>(c_argc: <span class="tok-type">c_int</span>, c_argv: [*][*:<span class="tok-number">0</span>]<span class="tok-type">c_char</span>) <span class="tok-kw">callconv</span>(.C) <span class="tok-type">c_int</span> {</span>
<span class="line" id="L488">    std.os.argv = <span class="tok-builtin">@as</span>([*][*:<span class="tok-number">0</span>]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(c_argv))[<span class="tok-number">0</span>..<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(c_argc))];</span>
<span class="line" id="L489">    <span class="tok-kw">return</span> <span class="tok-builtin">@call</span>(.always_inline, callMain, .{});</span>
<span class="line" id="L490">}</span>
<span class="line" id="L491"></span>
<span class="line" id="L492"><span class="tok-comment">// General error message for a malformed return type</span>
</span>
<span class="line" id="L493"><span class="tok-kw">const</span> bad_main_ret = <span class="tok-str">&quot;expected return type of main to be 'void', '!void', 'noreturn', 'u8', or '!u8'&quot;</span>;</span>
<span class="line" id="L494"></span>
<span class="line" id="L495"><span class="tok-comment">// This is marked inline because for some reason LLVM in release mode fails to inline it,</span>
</span>
<span class="line" id="L496"><span class="tok-comment">// and we want fewer call frames in stack traces.</span>
</span>
<span class="line" id="L497"><span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">initEventLoopAndCallMain</span>() <span class="tok-type">u8</span> {</span>
<span class="line" id="L498">    <span class="tok-kw">if</span> (std.event.Loop.instance) |loop| {</span>
<span class="line" id="L499">        <span class="tok-kw">if</span> (loop == std.event.Loop.default_instance) {</span>
<span class="line" id="L500">            loop.init() <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L501">                std.log.err(<span class="tok-str">&quot;{s}&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)});</span>
<span class="line" id="L502">                <span class="tok-kw">if</span> (<span class="tok-builtin">@errorReturnTrace</span>()) |trace| {</span>
<span class="line" id="L503">                    std.debug.dumpStackTrace(trace.*);</span>
<span class="line" id="L504">                }</span>
<span class="line" id="L505">                <span class="tok-kw">return</span> <span class="tok-number">1</span>;</span>
<span class="line" id="L506">            };</span>
<span class="line" id="L507">            <span class="tok-kw">defer</span> loop.deinit();</span>
<span class="line" id="L508"></span>
<span class="line" id="L509">            <span class="tok-kw">var</span> result: <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L510">            <span class="tok-kw">var</span> frame: <span class="tok-builtin">@Frame</span>(callMainAsync) = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L511">            _ = <span class="tok-builtin">@asyncCall</span>(&amp;frame, &amp;result, callMainAsync, .{loop});</span>
<span class="line" id="L512">            loop.run();</span>
<span class="line" id="L513">            <span class="tok-kw">return</span> result;</span>
<span class="line" id="L514">        }</span>
<span class="line" id="L515">    }</span>
<span class="line" id="L516"></span>
<span class="line" id="L517">    <span class="tok-comment">// This is marked inline because for some reason LLVM in release mode fails to inline it,</span>
</span>
<span class="line" id="L518">    <span class="tok-comment">// and we want fewer call frames in stack traces.</span>
</span>
<span class="line" id="L519">    <span class="tok-kw">return</span> <span class="tok-builtin">@call</span>(.always_inline, callMain, .{});</span>
<span class="line" id="L520">}</span>
<span class="line" id="L521"></span>
<span class="line" id="L522"><span class="tok-comment">// This is marked inline because for some reason LLVM in release mode fails to inline it,</span>
</span>
<span class="line" id="L523"><span class="tok-comment">// and we want fewer call frames in stack traces.</span>
</span>
<span class="line" id="L524"><span class="tok-comment">// TODO This function is duplicated from initEventLoopAndCallMain instead of using generics</span>
</span>
<span class="line" id="L525"><span class="tok-comment">// because it is working around stage1 compiler bugs.</span>
</span>
<span class="line" id="L526"><span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">initEventLoopAndCallWinMain</span>() std.os.windows.INT {</span>
<span class="line" id="L527">    <span class="tok-kw">if</span> (std.event.Loop.instance) |loop| {</span>
<span class="line" id="L528">        <span class="tok-kw">if</span> (loop == std.event.Loop.default_instance) {</span>
<span class="line" id="L529">            loop.init() <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L530">                std.log.err(<span class="tok-str">&quot;{s}&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)});</span>
<span class="line" id="L531">                <span class="tok-kw">if</span> (<span class="tok-builtin">@errorReturnTrace</span>()) |trace| {</span>
<span class="line" id="L532">                    std.debug.dumpStackTrace(trace.*);</span>
<span class="line" id="L533">                }</span>
<span class="line" id="L534">                <span class="tok-kw">return</span> <span class="tok-number">1</span>;</span>
<span class="line" id="L535">            };</span>
<span class="line" id="L536">            <span class="tok-kw">defer</span> loop.deinit();</span>
<span class="line" id="L537"></span>
<span class="line" id="L538">            <span class="tok-kw">var</span> result: std.os.windows.INT = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L539">            <span class="tok-kw">var</span> frame: <span class="tok-builtin">@Frame</span>(callWinMainAsync) = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L540">            _ = <span class="tok-builtin">@asyncCall</span>(&amp;frame, &amp;result, callWinMainAsync, .{loop});</span>
<span class="line" id="L541">            loop.run();</span>
<span class="line" id="L542">            <span class="tok-kw">return</span> result;</span>
<span class="line" id="L543">        }</span>
<span class="line" id="L544">    }</span>
<span class="line" id="L545"></span>
<span class="line" id="L546">    <span class="tok-comment">// This is marked inline because for some reason LLVM in release mode fails to inline it,</span>
</span>
<span class="line" id="L547">    <span class="tok-comment">// and we want fewer call frames in stack traces.</span>
</span>
<span class="line" id="L548">    <span class="tok-kw">return</span> <span class="tok-builtin">@call</span>(.always_inline, call_wWinMain, .{});</span>
<span class="line" id="L549">}</span>
<span class="line" id="L550"></span>
<span class="line" id="L551"><span class="tok-kw">fn</span> <span class="tok-fn">callMainAsync</span>(loop: *std.event.Loop) <span class="tok-kw">callconv</span>(.Async) <span class="tok-type">u8</span> {</span>
<span class="line" id="L552">    <span class="tok-comment">// This prevents the event loop from terminating at least until main() has returned.</span>
</span>
<span class="line" id="L553">    <span class="tok-comment">// TODO This shouldn't be needed here; it should be in the event loop code.</span>
</span>
<span class="line" id="L554">    loop.beginOneEvent();</span>
<span class="line" id="L555">    <span class="tok-kw">defer</span> loop.finishOneEvent();</span>
<span class="line" id="L556">    <span class="tok-kw">return</span> callMain();</span>
<span class="line" id="L557">}</span>
<span class="line" id="L558"></span>
<span class="line" id="L559"><span class="tok-kw">fn</span> <span class="tok-fn">callWinMainAsync</span>(loop: *std.event.Loop) <span class="tok-kw">callconv</span>(.Async) std.os.windows.INT {</span>
<span class="line" id="L560">    <span class="tok-comment">// This prevents the event loop from terminating at least until main() has returned.</span>
</span>
<span class="line" id="L561">    <span class="tok-comment">// TODO This shouldn't be needed here; it should be in the event loop code.</span>
</span>
<span class="line" id="L562">    loop.beginOneEvent();</span>
<span class="line" id="L563">    <span class="tok-kw">defer</span> loop.finishOneEvent();</span>
<span class="line" id="L564">    <span class="tok-kw">return</span> call_wWinMain();</span>
<span class="line" id="L565">}</span>
<span class="line" id="L566"></span>
<span class="line" id="L567"><span class="tok-comment">// This is not marked inline because it is called with @asyncCall when</span>
</span>
<span class="line" id="L568"><span class="tok-comment">// there is an event loop.</span>
</span>
<span class="line" id="L569"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">callMain</span>() <span class="tok-type">u8</span> {</span>
<span class="line" id="L570">    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(root.main)).Fn.return_type.?)) {</span>
<span class="line" id="L571">        .NoReturn =&gt; {</span>
<span class="line" id="L572">            root.main();</span>
<span class="line" id="L573">        },</span>
<span class="line" id="L574">        .Void =&gt; {</span>
<span class="line" id="L575">            root.main();</span>
<span class="line" id="L576">            <span class="tok-kw">return</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L577">        },</span>
<span class="line" id="L578">        .Int =&gt; |info| {</span>
<span class="line" id="L579">            <span class="tok-kw">if</span> (info.bits != <span class="tok-number">8</span> <span class="tok-kw">or</span> info.signedness == .signed) {</span>
<span class="line" id="L580">                <span class="tok-builtin">@compileError</span>(bad_main_ret);</span>
<span class="line" id="L581">            }</span>
<span class="line" id="L582">            <span class="tok-kw">return</span> root.main();</span>
<span class="line" id="L583">        },</span>
<span class="line" id="L584">        .ErrorUnion =&gt; {</span>
<span class="line" id="L585">            <span class="tok-kw">const</span> result = root.main() <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L586">                std.log.err(<span class="tok-str">&quot;{s}&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)});</span>
<span class="line" id="L587">                <span class="tok-kw">if</span> (<span class="tok-builtin">@errorReturnTrace</span>()) |trace| {</span>
<span class="line" id="L588">                    std.debug.dumpStackTrace(trace.*);</span>
<span class="line" id="L589">                }</span>
<span class="line" id="L590">                <span class="tok-kw">return</span> <span class="tok-number">1</span>;</span>
<span class="line" id="L591">            };</span>
<span class="line" id="L592">            <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(result))) {</span>
<span class="line" id="L593">                .Void =&gt; <span class="tok-kw">return</span> <span class="tok-number">0</span>,</span>
<span class="line" id="L594">                .Int =&gt; |info| {</span>
<span class="line" id="L595">                    <span class="tok-kw">if</span> (info.bits != <span class="tok-number">8</span> <span class="tok-kw">or</span> info.signedness == .signed) {</span>
<span class="line" id="L596">                        <span class="tok-builtin">@compileError</span>(bad_main_ret);</span>
<span class="line" id="L597">                    }</span>
<span class="line" id="L598">                    <span class="tok-kw">return</span> result;</span>
<span class="line" id="L599">                },</span>
<span class="line" id="L600">                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(bad_main_ret),</span>
<span class="line" id="L601">            }</span>
<span class="line" id="L602">        },</span>
<span class="line" id="L603">        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(bad_main_ret),</span>
<span class="line" id="L604">    }</span>
<span class="line" id="L605">}</span>
<span class="line" id="L606"></span>
<span class="line" id="L607"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">call_wWinMain</span>() std.os.windows.INT {</span>
<span class="line" id="L608">    <span class="tok-kw">const</span> peb = std.os.windows.peb();</span>
<span class="line" id="L609">    <span class="tok-kw">const</span> MAIN_HINSTANCE = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(root.wWinMain)).Fn.params[<span class="tok-number">0</span>].<span class="tok-type">type</span>.?;</span>
<span class="line" id="L610">    <span class="tok-kw">const</span> hInstance = <span class="tok-builtin">@as</span>(MAIN_HINSTANCE, <span class="tok-builtin">@ptrCast</span>(peb.ImageBaseAddress));</span>
<span class="line" id="L611">    <span class="tok-kw">const</span> lpCmdLine: [*:<span class="tok-number">0</span>]<span class="tok-type">u16</span> = <span class="tok-builtin">@ptrCast</span>(peb.ProcessParameters.CommandLine.Buffer);</span>
<span class="line" id="L612"></span>
<span class="line" id="L613">    <span class="tok-comment">// There are various types used for the 'show window' variable through the Win32 APIs:</span>
</span>
<span class="line" id="L614">    <span class="tok-comment">// - u16 in STARTUPINFOA.wShowWindow / STARTUPINFOW.wShowWindow</span>
</span>
<span class="line" id="L615">    <span class="tok-comment">// - c_int in ShowWindow</span>
</span>
<span class="line" id="L616">    <span class="tok-comment">// - u32 in PEB.ProcessParameters.dwShowWindow</span>
</span>
<span class="line" id="L617">    <span class="tok-comment">// Since STARTUPINFO is the bottleneck for the allowed values, we use `u16` as the</span>
</span>
<span class="line" id="L618">    <span class="tok-comment">// type which can coerce into i32/c_int/u32 depending on how the user defines their wWinMain</span>
</span>
<span class="line" id="L619">    <span class="tok-comment">// (the Win32 docs show wWinMain with `int` as the type for nCmdShow).</span>
</span>
<span class="line" id="L620">    <span class="tok-kw">const</span> nCmdShow: <span class="tok-type">u16</span> = nCmdShow: {</span>
<span class="line" id="L621">        <span class="tok-comment">// This makes Zig match the nCmdShow behavior of a C program with a WinMain symbol:</span>
</span>
<span class="line" id="L622">        <span class="tok-comment">// - With STARTF_USESHOWWINDOW set in STARTUPINFO.dwFlags of the CreateProcess call:</span>
</span>
<span class="line" id="L623">        <span class="tok-comment">//   - Compiled with subsystem:console -&gt; nCmdShow is always SW_SHOWDEFAULT</span>
</span>
<span class="line" id="L624">        <span class="tok-comment">//   - Compiled with subsystem:windows -&gt; nCmdShow is STARTUPINFO.wShowWindow from</span>
</span>
<span class="line" id="L625">        <span class="tok-comment">//     the parent CreateProcess call</span>
</span>
<span class="line" id="L626">        <span class="tok-comment">// - With STARTF_USESHOWWINDOW unset:</span>
</span>
<span class="line" id="L627">        <span class="tok-comment">//   - nCmdShow is always SW_SHOWDEFAULT</span>
</span>
<span class="line" id="L628">        <span class="tok-kw">const</span> SW_SHOWDEFAULT = <span class="tok-number">10</span>;</span>
<span class="line" id="L629">        <span class="tok-kw">const</span> STARTF_USESHOWWINDOW = <span class="tok-number">1</span>;</span>
<span class="line" id="L630">        <span class="tok-comment">// root having a wWinMain means that std.builtin.subsystem will always have a non-null value.</span>
</span>
<span class="line" id="L631">        <span class="tok-kw">if</span> (std.builtin.subsystem.? == .Windows <span class="tok-kw">and</span> peb.ProcessParameters.dwFlags &amp; STARTF_USESHOWWINDOW != <span class="tok-number">0</span>) {</span>
<span class="line" id="L632">            <span class="tok-kw">break</span> :nCmdShow <span class="tok-builtin">@truncate</span>(peb.ProcessParameters.dwShowWindow);</span>
<span class="line" id="L633">        }</span>
<span class="line" id="L634">        <span class="tok-kw">break</span> :nCmdShow SW_SHOWDEFAULT;</span>
<span class="line" id="L635">    };</span>
<span class="line" id="L636"></span>
<span class="line" id="L637">    <span class="tok-comment">// second parameter hPrevInstance, MSDN: &quot;This parameter is always NULL&quot;</span>
</span>
<span class="line" id="L638">    <span class="tok-kw">return</span> root.wWinMain(hInstance, <span class="tok-null">null</span>, lpCmdLine, nCmdShow);</span>
<span class="line" id="L639">}</span>
<span class="line" id="L640"></span>
</code></pre></body>
</html>