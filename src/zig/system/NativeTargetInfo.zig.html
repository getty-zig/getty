<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>zig/system/NativeTargetInfo.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg=="/>
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;../../std.zig&quot;</span>);</span>
<span class="line" id="L2"><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);</span>
<span class="line" id="L3"><span class="tok-kw">const</span> mem = std.mem;</span>
<span class="line" id="L4"><span class="tok-kw">const</span> assert = std.debug.assert;</span>
<span class="line" id="L5"><span class="tok-kw">const</span> fs = std.fs;</span>
<span class="line" id="L6"><span class="tok-kw">const</span> elf = std.elf;</span>
<span class="line" id="L7"><span class="tok-kw">const</span> native_endian = builtin.cpu.arch.endian();</span>
<span class="line" id="L8"></span>
<span class="line" id="L9"><span class="tok-kw">const</span> NativeTargetInfo = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L10"><span class="tok-kw">const</span> Target = std.Target;</span>
<span class="line" id="L11"><span class="tok-kw">const</span> Allocator = std.mem.Allocator;</span>
<span class="line" id="L12"><span class="tok-kw">const</span> CrossTarget = std.zig.CrossTarget;</span>
<span class="line" id="L13"><span class="tok-kw">const</span> windows = std.zig.system.windows;</span>
<span class="line" id="L14"><span class="tok-kw">const</span> darwin = std.zig.system.darwin;</span>
<span class="line" id="L15"><span class="tok-kw">const</span> linux = std.zig.system.linux;</span>
<span class="line" id="L16"></span>
<span class="line" id="L17">target: Target,</span>
<span class="line" id="L18">dynamic_linker: DynamicLinker = DynamicLinker{},</span>
<span class="line" id="L19"></span>
<span class="line" id="L20"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DynamicLinker = Target.DynamicLinker;</span>
<span class="line" id="L21"></span>
<span class="line" id="L22"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DetectError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L23">    FileSystem,</span>
<span class="line" id="L24">    SystemResources,</span>
<span class="line" id="L25">    SymLinkLoop,</span>
<span class="line" id="L26">    ProcessFdQuotaExceeded,</span>
<span class="line" id="L27">    SystemFdQuotaExceeded,</span>
<span class="line" id="L28">    DeviceBusy,</span>
<span class="line" id="L29">    OSVersionDetectionFail,</span>
<span class="line" id="L30">    Unexpected,</span>
<span class="line" id="L31">};</span>
<span class="line" id="L32"></span>
<span class="line" id="L33"><span class="tok-comment">/// Given a `CrossTarget`, which specifies in detail which parts of the target should be detected</span></span>
<span class="line" id="L34"><span class="tok-comment">/// natively, which should be standard or default, and which are provided explicitly, this function</span></span>
<span class="line" id="L35"><span class="tok-comment">/// resolves the native components by detecting the native system, and then resolves standard/default parts</span></span>
<span class="line" id="L36"><span class="tok-comment">/// relative to that.</span></span>
<span class="line" id="L37"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">detect</span>(cross_target: CrossTarget) DetectError!NativeTargetInfo {</span>
<span class="line" id="L38">    <span class="tok-kw">var</span> os = cross_target.getOsTag().defaultVersionRange(cross_target.getCpuArch());</span>
<span class="line" id="L39">    <span class="tok-kw">if</span> (cross_target.os_tag == <span class="tok-null">null</span>) {</span>
<span class="line" id="L40">        <span class="tok-kw">switch</span> (builtin.target.os.tag) {</span>
<span class="line" id="L41">            .linux =&gt; {</span>
<span class="line" id="L42">                <span class="tok-kw">const</span> uts = std.os.uname();</span>
<span class="line" id="L43">                <span class="tok-kw">const</span> release = mem.sliceTo(&amp;uts.release, <span class="tok-number">0</span>);</span>
<span class="line" id="L44">                <span class="tok-comment">// The release field sometimes has a weird format,</span>
</span>
<span class="line" id="L45">                <span class="tok-comment">// `Version.parse` will attempt to find some meaningful interpretation.</span>
</span>
<span class="line" id="L46">                <span class="tok-kw">if</span> (std.builtin.Version.parse(release)) |ver| {</span>
<span class="line" id="L47">                    os.version_range.linux.range.min = ver;</span>
<span class="line" id="L48">                    os.version_range.linux.range.max = ver;</span>
<span class="line" id="L49">                } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L50">                    <span class="tok-kw">error</span>.Overflow =&gt; {},</span>
<span class="line" id="L51">                    <span class="tok-kw">error</span>.InvalidCharacter =&gt; {},</span>
<span class="line" id="L52">                    <span class="tok-kw">error</span>.InvalidVersion =&gt; {},</span>
<span class="line" id="L53">                }</span>
<span class="line" id="L54">            },</span>
<span class="line" id="L55">            .solaris =&gt; {</span>
<span class="line" id="L56">                <span class="tok-kw">const</span> uts = std.os.uname();</span>
<span class="line" id="L57">                <span class="tok-kw">const</span> release = mem.sliceTo(&amp;uts.release, <span class="tok-number">0</span>);</span>
<span class="line" id="L58">                <span class="tok-kw">if</span> (std.builtin.Version.parse(release)) |ver| {</span>
<span class="line" id="L59">                    os.version_range.semver.min = ver;</span>
<span class="line" id="L60">                    os.version_range.semver.max = ver;</span>
<span class="line" id="L61">                } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L62">                    <span class="tok-kw">error</span>.Overflow =&gt; {},</span>
<span class="line" id="L63">                    <span class="tok-kw">error</span>.InvalidCharacter =&gt; {},</span>
<span class="line" id="L64">                    <span class="tok-kw">error</span>.InvalidVersion =&gt; {},</span>
<span class="line" id="L65">                }</span>
<span class="line" id="L66">            },</span>
<span class="line" id="L67">            .windows =&gt; {</span>
<span class="line" id="L68">                <span class="tok-kw">const</span> detected_version = windows.detectRuntimeVersion();</span>
<span class="line" id="L69">                os.version_range.windows.min = detected_version;</span>
<span class="line" id="L70">                os.version_range.windows.max = detected_version;</span>
<span class="line" id="L71">            },</span>
<span class="line" id="L72">            .macos =&gt; <span class="tok-kw">try</span> darwin.macos.detect(&amp;os),</span>
<span class="line" id="L73">            .freebsd, .netbsd, .dragonfly =&gt; {</span>
<span class="line" id="L74">                <span class="tok-kw">const</span> key = <span class="tok-kw">switch</span> (builtin.target.os.tag) {</span>
<span class="line" id="L75">                    .freebsd =&gt; <span class="tok-str">&quot;kern.osreldate&quot;</span>,</span>
<span class="line" id="L76">                    .netbsd, .dragonfly =&gt; <span class="tok-str">&quot;kern.osrevision&quot;</span>,</span>
<span class="line" id="L77">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L78">                };</span>
<span class="line" id="L79">                <span class="tok-kw">var</span> value: <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L80">                <span class="tok-kw">var</span> len: <span class="tok-type">usize</span> = <span class="tok-builtin">@sizeOf</span>(<span class="tok-builtin">@TypeOf</span>(value));</span>
<span class="line" id="L81"></span>
<span class="line" id="L82">                std.os.sysctlbynameZ(key, &amp;value, &amp;len, <span class="tok-null">null</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L83">                    <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// constant, known good value</span>
</span>
<span class="line" id="L84">                    <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// only when setting values,</span>
</span>
<span class="line" id="L85">                    <span class="tok-kw">error</span>.SystemResources =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// memory already on the stack</span>
</span>
<span class="line" id="L86">                    <span class="tok-kw">error</span>.UnknownName =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// constant, known good value</span>
</span>
<span class="line" id="L87">                    <span class="tok-kw">error</span>.Unexpected =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OSVersionDetectionFail,</span>
<span class="line" id="L88">                };</span>
<span class="line" id="L89"></span>
<span class="line" id="L90">                <span class="tok-kw">switch</span> (builtin.target.os.tag) {</span>
<span class="line" id="L91">                    .freebsd =&gt; {</span>
<span class="line" id="L92">                        <span class="tok-comment">// https://www.freebsd.org/doc/en_US.ISO8859-1/books/porters-handbook/versions.html</span>
</span>
<span class="line" id="L93">                        <span class="tok-comment">// Major * 100,000 has been convention since FreeBSD 2.2 (1997)</span>
</span>
<span class="line" id="L94">                        <span class="tok-comment">// Minor * 1(0),000 summed has been convention since FreeBSD 2.2 (1997)</span>
</span>
<span class="line" id="L95">                        <span class="tok-comment">// e.g. 492101 = 4.11-STABLE = 4.(9+2)</span>
</span>
<span class="line" id="L96">                        <span class="tok-kw">const</span> major = value / <span class="tok-number">100_000</span>;</span>
<span class="line" id="L97">                        <span class="tok-kw">const</span> minor1 = value % <span class="tok-number">100_000</span> / <span class="tok-number">10_000</span>; <span class="tok-comment">// usually 0 since 5.1</span>
</span>
<span class="line" id="L98">                        <span class="tok-kw">const</span> minor2 = value % <span class="tok-number">10_000</span> / <span class="tok-number">1_000</span>; <span class="tok-comment">// 0 before 5.1, minor version since</span>
</span>
<span class="line" id="L99">                        <span class="tok-kw">const</span> patch = value % <span class="tok-number">1_000</span>;</span>
<span class="line" id="L100">                        os.version_range.semver.min = .{ .major = major, .minor = minor1 + minor2, .patch = patch };</span>
<span class="line" id="L101">                        os.version_range.semver.max = os.version_range.semver.min;</span>
<span class="line" id="L102">                    },</span>
<span class="line" id="L103">                    .netbsd =&gt; {</span>
<span class="line" id="L104">                        <span class="tok-comment">// #define __NetBSD_Version__ MMmmrrpp00</span>
</span>
<span class="line" id="L105">                        <span class="tok-comment">//</span>
</span>
<span class="line" id="L106">                        <span class="tok-comment">// M = major version</span>
</span>
<span class="line" id="L107">                        <span class="tok-comment">// m = minor version; a minor number of 99 indicates current.</span>
</span>
<span class="line" id="L108">                        <span class="tok-comment">// r = 0 (*)</span>
</span>
<span class="line" id="L109">                        <span class="tok-comment">// p = patchlevel</span>
</span>
<span class="line" id="L110">                        <span class="tok-kw">const</span> major = value / <span class="tok-number">100_000_000</span>;</span>
<span class="line" id="L111">                        <span class="tok-kw">const</span> minor = value % <span class="tok-number">100_000_000</span> / <span class="tok-number">1_000_000</span>;</span>
<span class="line" id="L112">                        <span class="tok-kw">const</span> patch = value % <span class="tok-number">10_000</span> / <span class="tok-number">100</span>;</span>
<span class="line" id="L113">                        os.version_range.semver.min = .{ .major = major, .minor = minor, .patch = patch };</span>
<span class="line" id="L114">                        os.version_range.semver.max = os.version_range.semver.min;</span>
<span class="line" id="L115">                    },</span>
<span class="line" id="L116">                    .dragonfly =&gt; {</span>
<span class="line" id="L117">                        <span class="tok-comment">// https://github.com/DragonFlyBSD/DragonFlyBSD/blob/cb2cde83771754aeef9bb3251ee48959138dec87/Makefile.inc1#L15-L17</span>
</span>
<span class="line" id="L118">                        <span class="tok-comment">// flat base10 format: Mmmmpp</span>
</span>
<span class="line" id="L119">                        <span class="tok-comment">//   M = major</span>
</span>
<span class="line" id="L120">                        <span class="tok-comment">//   m = minor; odd-numbers indicate current dev branch</span>
</span>
<span class="line" id="L121">                        <span class="tok-comment">//   p = patch</span>
</span>
<span class="line" id="L122">                        <span class="tok-kw">const</span> major = value / <span class="tok-number">100_000</span>;</span>
<span class="line" id="L123">                        <span class="tok-kw">const</span> minor = value % <span class="tok-number">100_000</span> / <span class="tok-number">100</span>;</span>
<span class="line" id="L124">                        <span class="tok-kw">const</span> patch = value % <span class="tok-number">100</span>;</span>
<span class="line" id="L125">                        os.version_range.semver.min = .{ .major = major, .minor = minor, .patch = patch };</span>
<span class="line" id="L126">                        os.version_range.semver.max = os.version_range.semver.min;</span>
<span class="line" id="L127">                    },</span>
<span class="line" id="L128">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L129">                }</span>
<span class="line" id="L130">            },</span>
<span class="line" id="L131">            .openbsd =&gt; {</span>
<span class="line" id="L132">                <span class="tok-kw">const</span> mib: [<span class="tok-number">2</span>]<span class="tok-type">c_int</span> = [_]<span class="tok-type">c_int</span>{</span>
<span class="line" id="L133">                    std.os.CTL.KERN,</span>
<span class="line" id="L134">                    std.os.KERN.OSRELEASE,</span>
<span class="line" id="L135">                };</span>
<span class="line" id="L136">                <span class="tok-kw">var</span> buf: [<span class="tok-number">64</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L137">                <span class="tok-kw">var</span> len: <span class="tok-type">usize</span> = buf.len;</span>
<span class="line" id="L138"></span>
<span class="line" id="L139">                std.os.sysctl(&amp;mib, &amp;buf, &amp;len, <span class="tok-null">null</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L140">                    <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// constant, known good value</span>
</span>
<span class="line" id="L141">                    <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// only when setting values,</span>
</span>
<span class="line" id="L142">                    <span class="tok-kw">error</span>.SystemResources =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// memory already on the stack</span>
</span>
<span class="line" id="L143">                    <span class="tok-kw">error</span>.UnknownName =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// constant, known good value</span>
</span>
<span class="line" id="L144">                    <span class="tok-kw">error</span>.Unexpected =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OSVersionDetectionFail,</span>
<span class="line" id="L145">                };</span>
<span class="line" id="L146"></span>
<span class="line" id="L147">                <span class="tok-kw">if</span> (std.builtin.Version.parse(buf[<span class="tok-number">0</span> .. len - <span class="tok-number">1</span>])) |ver| {</span>
<span class="line" id="L148">                    os.version_range.semver.min = ver;</span>
<span class="line" id="L149">                    os.version_range.semver.max = ver;</span>
<span class="line" id="L150">                } <span class="tok-kw">else</span> |_| {</span>
<span class="line" id="L151">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OSVersionDetectionFail;</span>
<span class="line" id="L152">                }</span>
<span class="line" id="L153">            },</span>
<span class="line" id="L154">            <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L155">                <span class="tok-comment">// Unimplemented, fall back to default version range.</span>
</span>
<span class="line" id="L156">            },</span>
<span class="line" id="L157">        }</span>
<span class="line" id="L158">    }</span>
<span class="line" id="L159"></span>
<span class="line" id="L160">    <span class="tok-kw">if</span> (cross_target.os_version_min) |min| <span class="tok-kw">switch</span> (min) {</span>
<span class="line" id="L161">        .none =&gt; {},</span>
<span class="line" id="L162">        .semver =&gt; |semver| <span class="tok-kw">switch</span> (cross_target.getOsTag()) {</span>
<span class="line" id="L163">            .linux =&gt; os.version_range.linux.range.min = semver,</span>
<span class="line" id="L164">            <span class="tok-kw">else</span> =&gt; os.version_range.semver.min = semver,</span>
<span class="line" id="L165">        },</span>
<span class="line" id="L166">        .windows =&gt; |win_ver| os.version_range.windows.min = win_ver,</span>
<span class="line" id="L167">    };</span>
<span class="line" id="L168"></span>
<span class="line" id="L169">    <span class="tok-kw">if</span> (cross_target.os_version_max) |max| <span class="tok-kw">switch</span> (max) {</span>
<span class="line" id="L170">        .none =&gt; {},</span>
<span class="line" id="L171">        .semver =&gt; |semver| <span class="tok-kw">switch</span> (cross_target.getOsTag()) {</span>
<span class="line" id="L172">            .linux =&gt; os.version_range.linux.range.max = semver,</span>
<span class="line" id="L173">            <span class="tok-kw">else</span> =&gt; os.version_range.semver.max = semver,</span>
<span class="line" id="L174">        },</span>
<span class="line" id="L175">        .windows =&gt; |win_ver| os.version_range.windows.max = win_ver,</span>
<span class="line" id="L176">    };</span>
<span class="line" id="L177"></span>
<span class="line" id="L178">    <span class="tok-kw">if</span> (cross_target.glibc_version) |glibc| {</span>
<span class="line" id="L179">        assert(cross_target.isGnuLibC());</span>
<span class="line" id="L180">        os.version_range.linux.glibc = glibc;</span>
<span class="line" id="L181">    }</span>
<span class="line" id="L182"></span>
<span class="line" id="L183">    <span class="tok-comment">// Until https://github.com/ziglang/zig/issues/4592 is implemented (support detecting the</span>
</span>
<span class="line" id="L184">    <span class="tok-comment">// native CPU architecture as being different than the current target), we use this:</span>
</span>
<span class="line" id="L185">    <span class="tok-kw">const</span> cpu_arch = cross_target.getCpuArch();</span>
<span class="line" id="L186"></span>
<span class="line" id="L187">    <span class="tok-kw">var</span> cpu = <span class="tok-kw">switch</span> (cross_target.cpu_model) {</span>
<span class="line" id="L188">        .native =&gt; detectNativeCpuAndFeatures(cpu_arch, os, cross_target),</span>
<span class="line" id="L189">        .baseline =&gt; Target.Cpu.baseline(cpu_arch),</span>
<span class="line" id="L190">        .determined_by_cpu_arch =&gt; <span class="tok-kw">if</span> (cross_target.cpu_arch == <span class="tok-null">null</span>)</span>
<span class="line" id="L191">            detectNativeCpuAndFeatures(cpu_arch, os, cross_target)</span>
<span class="line" id="L192">        <span class="tok-kw">else</span></span>
<span class="line" id="L193">            Target.Cpu.baseline(cpu_arch),</span>
<span class="line" id="L194">        .explicit =&gt; |model| model.toCpu(cpu_arch),</span>
<span class="line" id="L195">    } <span class="tok-kw">orelse</span> backup_cpu_detection: {</span>
<span class="line" id="L196">        <span class="tok-kw">break</span> :backup_cpu_detection Target.Cpu.baseline(cpu_arch);</span>
<span class="line" id="L197">    };</span>
<span class="line" id="L198">    <span class="tok-kw">var</span> result = <span class="tok-kw">try</span> detectAbiAndDynamicLinker(cpu, os, cross_target);</span>
<span class="line" id="L199">    <span class="tok-comment">// For x86, we need to populate some CPU feature flags depending on architecture</span>
</span>
<span class="line" id="L200">    <span class="tok-comment">// and mode:</span>
</span>
<span class="line" id="L201">    <span class="tok-comment">//  * 16bit_mode =&gt; if the abi is code16</span>
</span>
<span class="line" id="L202">    <span class="tok-comment">//  * 32bit_mode =&gt; if the arch is i386</span>
</span>
<span class="line" id="L203">    <span class="tok-comment">// However, the &quot;mode&quot; flags can be used as overrides, so if the user explicitly</span>
</span>
<span class="line" id="L204">    <span class="tok-comment">// sets one of them, that takes precedence.</span>
</span>
<span class="line" id="L205">    <span class="tok-kw">switch</span> (cpu_arch) {</span>
<span class="line" id="L206">        .<span class="tok-type">i386</span> =&gt; {</span>
<span class="line" id="L207">            <span class="tok-kw">if</span> (!std.Target.x86.featureSetHasAny(cross_target.cpu_features_add, .{</span>
<span class="line" id="L208">                .@&quot;16bit_mode&quot;, .@&quot;32bit_mode&quot;,</span>
<span class="line" id="L209">            })) {</span>
<span class="line" id="L210">                <span class="tok-kw">switch</span> (result.target.abi) {</span>
<span class="line" id="L211">                    .code16 =&gt; result.target.cpu.features.addFeature(</span>
<span class="line" id="L212">                        <span class="tok-builtin">@enumToInt</span>(std.Target.x86.Feature.@&quot;16bit_mode&quot;),</span>
<span class="line" id="L213">                    ),</span>
<span class="line" id="L214">                    <span class="tok-kw">else</span> =&gt; result.target.cpu.features.addFeature(</span>
<span class="line" id="L215">                        <span class="tok-builtin">@enumToInt</span>(std.Target.x86.Feature.@&quot;32bit_mode&quot;),</span>
<span class="line" id="L216">                    ),</span>
<span class="line" id="L217">                }</span>
<span class="line" id="L218">            }</span>
<span class="line" id="L219">        },</span>
<span class="line" id="L220">        .arm, .armeb =&gt; {</span>
<span class="line" id="L221">            <span class="tok-comment">// XXX What do we do if the target has the noarm feature?</span>
</span>
<span class="line" id="L222">            <span class="tok-comment">//     What do we do if the user specifies +thumb_mode?</span>
</span>
<span class="line" id="L223">        },</span>
<span class="line" id="L224">        .thumb, .thumbeb =&gt; {</span>
<span class="line" id="L225">            result.target.cpu.features.addFeature(</span>
<span class="line" id="L226">                <span class="tok-builtin">@enumToInt</span>(std.Target.arm.Feature.thumb_mode),</span>
<span class="line" id="L227">            );</span>
<span class="line" id="L228">        },</span>
<span class="line" id="L229">        <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L230">    }</span>
<span class="line" id="L231">    cross_target.updateCpuFeatures(&amp;result.target.cpu.features);</span>
<span class="line" id="L232">    <span class="tok-kw">return</span> result;</span>
<span class="line" id="L233">}</span>
<span class="line" id="L234"></span>
<span class="line" id="L235"><span class="tok-comment">/// In the past, this function attempted to use the executable's own binary if it was dynamically</span></span>
<span class="line" id="L236"><span class="tok-comment">/// linked to answer both the C ABI question and the dynamic linker question. However, this</span></span>
<span class="line" id="L237"><span class="tok-comment">/// could be problematic on a system that uses a RUNPATH for the compiler binary, locking</span></span>
<span class="line" id="L238"><span class="tok-comment">/// it to an older glibc version, while system binaries such as /usr/bin/env use a newer glibc</span></span>
<span class="line" id="L239"><span class="tok-comment">/// version. The problem is that libc.so.6 glibc version will match that of the system while</span></span>
<span class="line" id="L240"><span class="tok-comment">/// the dynamic linker will match that of the compiler binary. Executables with these versions</span></span>
<span class="line" id="L241"><span class="tok-comment">/// mismatching will fail to run.</span></span>
<span class="line" id="L242"><span class="tok-comment">///</span></span>
<span class="line" id="L243"><span class="tok-comment">/// Therefore, this function works the same regardless of whether the compiler binary is</span></span>
<span class="line" id="L244"><span class="tok-comment">/// dynamically or statically linked. It inspects `/usr/bin/env` as an ELF file to find the</span></span>
<span class="line" id="L245"><span class="tok-comment">/// answer to these questions, or if there is a shebang line, then it chases the referenced</span></span>
<span class="line" id="L246"><span class="tok-comment">/// file recursively. If that does not provide the answer, then the function falls back to</span></span>
<span class="line" id="L247"><span class="tok-comment">/// defaults.</span></span>
<span class="line" id="L248"><span class="tok-kw">fn</span> <span class="tok-fn">detectAbiAndDynamicLinker</span>(</span>
<span class="line" id="L249">    cpu: Target.Cpu,</span>
<span class="line" id="L250">    os: Target.Os,</span>
<span class="line" id="L251">    cross_target: CrossTarget,</span>
<span class="line" id="L252">) DetectError!NativeTargetInfo {</span>
<span class="line" id="L253">    <span class="tok-kw">const</span> native_target_has_ld = <span class="tok-kw">comptime</span> builtin.target.hasDynamicLinker();</span>
<span class="line" id="L254">    <span class="tok-kw">const</span> is_linux = builtin.target.os.tag == .linux;</span>
<span class="line" id="L255">    <span class="tok-kw">const</span> have_all_info = cross_target.dynamic_linker.get() != <span class="tok-null">null</span> <span class="tok-kw">and</span></span>
<span class="line" id="L256">        cross_target.abi != <span class="tok-null">null</span> <span class="tok-kw">and</span> (!is_linux <span class="tok-kw">or</span> cross_target.abi.?.isGnu());</span>
<span class="line" id="L257">    <span class="tok-kw">const</span> os_is_non_native = cross_target.os_tag != <span class="tok-null">null</span>;</span>
<span class="line" id="L258">    <span class="tok-kw">if</span> (!native_target_has_ld <span class="tok-kw">or</span> have_all_info <span class="tok-kw">or</span> os_is_non_native) {</span>
<span class="line" id="L259">        <span class="tok-kw">return</span> defaultAbiAndDynamicLinker(cpu, os, cross_target);</span>
<span class="line" id="L260">    }</span>
<span class="line" id="L261">    <span class="tok-kw">if</span> (cross_target.abi) |abi| {</span>
<span class="line" id="L262">        <span class="tok-kw">if</span> (abi.isMusl()) {</span>
<span class="line" id="L263">            <span class="tok-comment">// musl implies static linking.</span>
</span>
<span class="line" id="L264">            <span class="tok-kw">return</span> defaultAbiAndDynamicLinker(cpu, os, cross_target);</span>
<span class="line" id="L265">        }</span>
<span class="line" id="L266">    }</span>
<span class="line" id="L267">    <span class="tok-comment">// The current target's ABI cannot be relied on for this. For example, we may build the zig</span>
</span>
<span class="line" id="L268">    <span class="tok-comment">// compiler for target riscv64-linux-musl and provide a tarball for users to download.</span>
</span>
<span class="line" id="L269">    <span class="tok-comment">// A user could then run that zig compiler on riscv64-linux-gnu. This use case is well-defined</span>
</span>
<span class="line" id="L270">    <span class="tok-comment">// and supported by Zig. But that means that we must detect the system ABI here rather than</span>
</span>
<span class="line" id="L271">    <span class="tok-comment">// relying on `builtin.target`.</span>
</span>
<span class="line" id="L272">    <span class="tok-kw">const</span> all_abis = <span class="tok-kw">comptime</span> blk: {</span>
<span class="line" id="L273">        assert(<span class="tok-builtin">@enumToInt</span>(Target.Abi.none) == <span class="tok-number">0</span>);</span>
<span class="line" id="L274">        <span class="tok-kw">const</span> fields = std.meta.fields(Target.Abi)[<span class="tok-number">1</span>..];</span>
<span class="line" id="L275">        <span class="tok-kw">var</span> array: [fields.len]Target.Abi = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L276">        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (fields) |field, i| {</span>
<span class="line" id="L277">            array[i] = <span class="tok-builtin">@field</span>(Target.Abi, field.name);</span>
<span class="line" id="L278">        }</span>
<span class="line" id="L279">        <span class="tok-kw">break</span> :blk array;</span>
<span class="line" id="L280">    };</span>
<span class="line" id="L281">    <span class="tok-kw">var</span> ld_info_list_buffer: [all_abis.len]LdInfo = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L282">    <span class="tok-kw">var</span> ld_info_list_len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L283">    <span class="tok-kw">const</span> ofmt = cross_target.ofmt <span class="tok-kw">orelse</span> Target.ObjectFormat.default(os.tag, cpu.arch);</span>
<span class="line" id="L284"></span>
<span class="line" id="L285">    <span class="tok-kw">for</span> (all_abis) |abi| {</span>
<span class="line" id="L286">        <span class="tok-comment">// This may be a nonsensical parameter. We detect this with</span>
</span>
<span class="line" id="L287">        <span class="tok-comment">// error.UnknownDynamicLinkerPath and skip adding it to `ld_info_list`.</span>
</span>
<span class="line" id="L288">        <span class="tok-kw">const</span> target: Target = .{</span>
<span class="line" id="L289">            .cpu = cpu,</span>
<span class="line" id="L290">            .os = os,</span>
<span class="line" id="L291">            .abi = abi,</span>
<span class="line" id="L292">            .ofmt = ofmt,</span>
<span class="line" id="L293">        };</span>
<span class="line" id="L294">        <span class="tok-kw">const</span> ld = target.standardDynamicLinkerPath();</span>
<span class="line" id="L295">        <span class="tok-kw">if</span> (ld.get() == <span class="tok-null">null</span>) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L296"></span>
<span class="line" id="L297">        ld_info_list_buffer[ld_info_list_len] = .{</span>
<span class="line" id="L298">            .ld = ld,</span>
<span class="line" id="L299">            .abi = abi,</span>
<span class="line" id="L300">        };</span>
<span class="line" id="L301">        ld_info_list_len += <span class="tok-number">1</span>;</span>
<span class="line" id="L302">    }</span>
<span class="line" id="L303">    <span class="tok-kw">const</span> ld_info_list = ld_info_list_buffer[<span class="tok-number">0</span>..ld_info_list_len];</span>
<span class="line" id="L304"></span>
<span class="line" id="L305">    <span class="tok-comment">// Best case scenario: the executable is dynamically linked, and we can iterate</span>
</span>
<span class="line" id="L306">    <span class="tok-comment">// over our own shared objects and find a dynamic linker.</span>
</span>
<span class="line" id="L307">    <span class="tok-kw">const</span> elf_file = blk: {</span>
<span class="line" id="L308">        <span class="tok-comment">// This block looks for a shebang line in /usr/bin/env,</span>
</span>
<span class="line" id="L309">        <span class="tok-comment">// if it finds one, then instead of using /usr/bin/env as the ELF file to examine, it uses the file it references instead,</span>
</span>
<span class="line" id="L310">        <span class="tok-comment">// doing the same logic recursively in case it finds another shebang line.</span>
</span>
<span class="line" id="L311"></span>
<span class="line" id="L312">        <span class="tok-comment">// Since /usr/bin/env is hard-coded into the shebang line of many portable scripts, it's a</span>
</span>
<span class="line" id="L313">        <span class="tok-comment">// reasonably reliable path to start with.</span>
</span>
<span class="line" id="L314">        <span class="tok-kw">var</span> file_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;/usr/bin/env&quot;</span>;</span>
<span class="line" id="L315">        <span class="tok-comment">// #! (2) + 255 (max length of shebang line since Linux 5.1) + \n (1)</span>
</span>
<span class="line" id="L316">        <span class="tok-kw">var</span> buffer: [<span class="tok-number">258</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L317">        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L318">            <span class="tok-kw">const</span> file = fs.openFileAbsolute(file_name, .{}) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L319">                <span class="tok-kw">error</span>.NoSpaceLeft =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L320">                <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L321">                <span class="tok-kw">error</span>.PathAlreadyExists =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L322">                <span class="tok-kw">error</span>.SharingViolation =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L323">                <span class="tok-kw">error</span>.InvalidUtf8 =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L324">                <span class="tok-kw">error</span>.BadPathName =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L325">                <span class="tok-kw">error</span>.PipeBusy =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L326">                <span class="tok-kw">error</span>.FileLocksNotSupported =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L327">                <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L328">                <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// opened without write permissions</span>
</span>
<span class="line" id="L329"></span>
<span class="line" id="L330">                <span class="tok-kw">error</span>.IsDir,</span>
<span class="line" id="L331">                <span class="tok-kw">error</span>.NotDir,</span>
<span class="line" id="L332">                <span class="tok-kw">error</span>.InvalidHandle,</span>
<span class="line" id="L333">                <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L334">                <span class="tok-kw">error</span>.NoDevice,</span>
<span class="line" id="L335">                <span class="tok-kw">error</span>.FileNotFound,</span>
<span class="line" id="L336">                <span class="tok-kw">error</span>.FileTooBig,</span>
<span class="line" id="L337">                <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L338">                =&gt; |e| {</span>
<span class="line" id="L339">                    std.log.warn(<span class="tok-str">&quot;Encountered error: {s}, falling back to default ABI and dynamic linker.\n&quot;</span>, .{<span class="tok-builtin">@errorName</span>(e)});</span>
<span class="line" id="L340">                    <span class="tok-kw">return</span> defaultAbiAndDynamicLinker(cpu, os, cross_target);</span>
<span class="line" id="L341">                },</span>
<span class="line" id="L342"></span>
<span class="line" id="L343">                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L344">            };</span>
<span class="line" id="L345">            <span class="tok-kw">errdefer</span> file.close();</span>
<span class="line" id="L346"></span>
<span class="line" id="L347">            <span class="tok-kw">const</span> len = preadMin(file, &amp;buffer, <span class="tok-number">0</span>, buffer.len) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L348">                <span class="tok-kw">error</span>.UnexpectedEndOfFile,</span>
<span class="line" id="L349">                <span class="tok-kw">error</span>.UnableToReadElfFile,</span>
<span class="line" id="L350">                =&gt; <span class="tok-kw">break</span> :blk file,</span>
<span class="line" id="L351"></span>
<span class="line" id="L352">                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L353">            };</span>
<span class="line" id="L354">            <span class="tok-kw">const</span> newline = mem.indexOfScalar(<span class="tok-type">u8</span>, buffer[<span class="tok-number">0</span>..len], <span class="tok-str">'\n'</span>) <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :blk file;</span>
<span class="line" id="L355">            <span class="tok-kw">const</span> line = buffer[<span class="tok-number">0</span>..newline];</span>
<span class="line" id="L356">            <span class="tok-kw">if</span> (!mem.startsWith(<span class="tok-type">u8</span>, line, <span class="tok-str">&quot;#!&quot;</span>)) <span class="tok-kw">break</span> :blk file;</span>
<span class="line" id="L357">            <span class="tok-kw">var</span> it = mem.tokenize(<span class="tok-type">u8</span>, line[<span class="tok-number">2</span>..], <span class="tok-str">&quot; &quot;</span>);</span>
<span class="line" id="L358">            file_name = it.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> defaultAbiAndDynamicLinker(cpu, os, cross_target);</span>
<span class="line" id="L359">            file.close();</span>
<span class="line" id="L360">        }</span>
<span class="line" id="L361">    };</span>
<span class="line" id="L362">    <span class="tok-kw">defer</span> elf_file.close();</span>
<span class="line" id="L363"></span>
<span class="line" id="L364">    <span class="tok-comment">// If Zig is statically linked, such as via distributed binary static builds, the above</span>
</span>
<span class="line" id="L365">    <span class="tok-comment">// trick (block self_exe) won't work. The next thing we fall back to is the same thing, but for elf_file.</span>
</span>
<span class="line" id="L366">    <span class="tok-comment">// TODO: inline this function and combine the buffer we already read above to find</span>
</span>
<span class="line" id="L367">    <span class="tok-comment">// the possible shebang line with the buffer we use for the ELF header.</span>
</span>
<span class="line" id="L368">    <span class="tok-kw">return</span> abiAndDynamicLinkerFromFile(elf_file, cpu, os, ld_info_list, cross_target) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L369">        <span class="tok-kw">error</span>.FileSystem,</span>
<span class="line" id="L370">        <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L371">        <span class="tok-kw">error</span>.SymLinkLoop,</span>
<span class="line" id="L372">        <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,</span>
<span class="line" id="L373">        <span class="tok-kw">error</span>.SystemFdQuotaExceeded,</span>
<span class="line" id="L374">        =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L375"></span>
<span class="line" id="L376">        <span class="tok-kw">error</span>.UnableToReadElfFile,</span>
<span class="line" id="L377">        <span class="tok-kw">error</span>.InvalidElfClass,</span>
<span class="line" id="L378">        <span class="tok-kw">error</span>.InvalidElfVersion,</span>
<span class="line" id="L379">        <span class="tok-kw">error</span>.InvalidElfEndian,</span>
<span class="line" id="L380">        <span class="tok-kw">error</span>.InvalidElfFile,</span>
<span class="line" id="L381">        <span class="tok-kw">error</span>.InvalidElfMagic,</span>
<span class="line" id="L382">        <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L383">        <span class="tok-kw">error</span>.UnexpectedEndOfFile,</span>
<span class="line" id="L384">        <span class="tok-kw">error</span>.NameTooLong,</span>
<span class="line" id="L385">        <span class="tok-comment">// Finally, we fall back on the standard path.</span>
</span>
<span class="line" id="L386">        =&gt; |e| {</span>
<span class="line" id="L387">            std.log.warn(<span class="tok-str">&quot;Encountered error: {s}, falling back to default ABI and dynamic linker.\n&quot;</span>, .{<span class="tok-builtin">@errorName</span>(e)});</span>
<span class="line" id="L388">            <span class="tok-kw">return</span> defaultAbiAndDynamicLinker(cpu, os, cross_target);</span>
<span class="line" id="L389">        },</span>
<span class="line" id="L390">    };</span>
<span class="line" id="L391">}</span>
<span class="line" id="L392"></span>
<span class="line" id="L393"><span class="tok-kw">fn</span> <span class="tok-fn">glibcVerFromRPath</span>(rpath: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !std.builtin.Version {</span>
<span class="line" id="L394">    <span class="tok-kw">var</span> dir = fs.cwd().openDir(rpath, .{}) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L395">        <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L396">        <span class="tok-kw">error</span>.InvalidUtf8 =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L397">        <span class="tok-kw">error</span>.BadPathName =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L398">        <span class="tok-kw">error</span>.DeviceBusy =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L399"></span>
<span class="line" id="L400">        <span class="tok-kw">error</span>.FileNotFound,</span>
<span class="line" id="L401">        <span class="tok-kw">error</span>.NotDir,</span>
<span class="line" id="L402">        <span class="tok-kw">error</span>.InvalidHandle,</span>
<span class="line" id="L403">        <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L404">        <span class="tok-kw">error</span>.NoDevice,</span>
<span class="line" id="L405">        =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.GLibCNotFound,</span>
<span class="line" id="L406"></span>
<span class="line" id="L407">        <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,</span>
<span class="line" id="L408">        <span class="tok-kw">error</span>.SystemFdQuotaExceeded,</span>
<span class="line" id="L409">        <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L410">        <span class="tok-kw">error</span>.SymLinkLoop,</span>
<span class="line" id="L411">        <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L412">        =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L413">    };</span>
<span class="line" id="L414">    <span class="tok-kw">defer</span> dir.close();</span>
<span class="line" id="L415"></span>
<span class="line" id="L416">    <span class="tok-comment">// Now we have a candidate for the path to libc shared object. In</span>
</span>
<span class="line" id="L417">    <span class="tok-comment">// the past, we used readlink() here because the link name would</span>
</span>
<span class="line" id="L418">    <span class="tok-comment">// reveal the glibc version. However, in more recent GNU/Linux</span>
</span>
<span class="line" id="L419">    <span class="tok-comment">// installations, there is no symlink. Thus we instead use a more</span>
</span>
<span class="line" id="L420">    <span class="tok-comment">// robust check of opening the libc shared object and looking at the</span>
</span>
<span class="line" id="L421">    <span class="tok-comment">// .dynstr section, and finding the max version number of symbols</span>
</span>
<span class="line" id="L422">    <span class="tok-comment">// that start with &quot;GLIBC_2.&quot;.</span>
</span>
<span class="line" id="L423">    <span class="tok-kw">const</span> glibc_so_basename = <span class="tok-str">&quot;libc.so.6&quot;</span>;</span>
<span class="line" id="L424">    <span class="tok-kw">var</span> f = dir.openFile(glibc_so_basename, .{}) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L425">        <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L426">        <span class="tok-kw">error</span>.InvalidUtf8 =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Windows only</span>
</span>
<span class="line" id="L427">        <span class="tok-kw">error</span>.BadPathName =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Windows only</span>
</span>
<span class="line" id="L428">        <span class="tok-kw">error</span>.PipeBusy =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Windows-only</span>
</span>
<span class="line" id="L429">        <span class="tok-kw">error</span>.SharingViolation =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Windows-only</span>
</span>
<span class="line" id="L430">        <span class="tok-kw">error</span>.FileLocksNotSupported =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// No lock requested.</span>
</span>
<span class="line" id="L431">        <span class="tok-kw">error</span>.NoSpaceLeft =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// read-only</span>
</span>
<span class="line" id="L432">        <span class="tok-kw">error</span>.PathAlreadyExists =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// read-only</span>
</span>
<span class="line" id="L433">        <span class="tok-kw">error</span>.DeviceBusy =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// read-only</span>
</span>
<span class="line" id="L434">        <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// read-only</span>
</span>
<span class="line" id="L435">        <span class="tok-kw">error</span>.InvalidHandle =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// should not be in the error set</span>
</span>
<span class="line" id="L436">        <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// not using O_NONBLOCK</span>
</span>
<span class="line" id="L437">        <span class="tok-kw">error</span>.NoDevice =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// not asking for a special device</span>
</span>
<span class="line" id="L438"></span>
<span class="line" id="L439">        <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L440">        <span class="tok-kw">error</span>.FileNotFound,</span>
<span class="line" id="L441">        <span class="tok-kw">error</span>.NotDir,</span>
<span class="line" id="L442">        <span class="tok-kw">error</span>.IsDir,</span>
<span class="line" id="L443">        =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.GLibCNotFound,</span>
<span class="line" id="L444"></span>
<span class="line" id="L445">        <span class="tok-kw">error</span>.FileTooBig =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L446"></span>
<span class="line" id="L447">        <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,</span>
<span class="line" id="L448">        <span class="tok-kw">error</span>.SystemFdQuotaExceeded,</span>
<span class="line" id="L449">        <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L450">        <span class="tok-kw">error</span>.SymLinkLoop,</span>
<span class="line" id="L451">        <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L452">        =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L453">    };</span>
<span class="line" id="L454">    <span class="tok-kw">defer</span> f.close();</span>
<span class="line" id="L455"></span>
<span class="line" id="L456">    <span class="tok-kw">return</span> glibcVerFromSoFile(f) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L457">        <span class="tok-kw">error</span>.InvalidElfMagic,</span>
<span class="line" id="L458">        <span class="tok-kw">error</span>.InvalidElfEndian,</span>
<span class="line" id="L459">        <span class="tok-kw">error</span>.InvalidElfClass,</span>
<span class="line" id="L460">        <span class="tok-kw">error</span>.InvalidElfFile,</span>
<span class="line" id="L461">        <span class="tok-kw">error</span>.InvalidElfVersion,</span>
<span class="line" id="L462">        <span class="tok-kw">error</span>.InvalidGnuLibCVersion,</span>
<span class="line" id="L463">        <span class="tok-kw">error</span>.UnexpectedEndOfFile,</span>
<span class="line" id="L464">        =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.GLibCNotFound,</span>
<span class="line" id="L465"></span>
<span class="line" id="L466">        <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L467">        <span class="tok-kw">error</span>.UnableToReadElfFile,</span>
<span class="line" id="L468">        <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L469">        <span class="tok-kw">error</span>.FileSystem,</span>
<span class="line" id="L470">        =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L471">    };</span>
<span class="line" id="L472">}</span>
<span class="line" id="L473"></span>
<span class="line" id="L474"><span class="tok-kw">fn</span> <span class="tok-fn">glibcVerFromSoFile</span>(file: fs.File) !std.builtin.Version {</span>
<span class="line" id="L475">    <span class="tok-kw">var</span> hdr_buf: [<span class="tok-builtin">@sizeOf</span>(elf.Elf64_Ehdr)]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(elf.Elf64_Ehdr)) = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L476">    _ = <span class="tok-kw">try</span> preadMin(file, &amp;hdr_buf, <span class="tok-number">0</span>, hdr_buf.len);</span>
<span class="line" id="L477">    <span class="tok-kw">const</span> hdr32 = <span class="tok-builtin">@ptrCast</span>(*elf.Elf32_Ehdr, &amp;hdr_buf);</span>
<span class="line" id="L478">    <span class="tok-kw">const</span> hdr64 = <span class="tok-builtin">@ptrCast</span>(*elf.Elf64_Ehdr, &amp;hdr_buf);</span>
<span class="line" id="L479">    <span class="tok-kw">if</span> (!mem.eql(<span class="tok-type">u8</span>, hdr32.e_ident[<span class="tok-number">0</span>..<span class="tok-number">4</span>], elf.MAGIC)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfMagic;</span>
<span class="line" id="L480">    <span class="tok-kw">const</span> elf_endian: std.builtin.Endian = <span class="tok-kw">switch</span> (hdr32.e_ident[elf.EI_DATA]) {</span>
<span class="line" id="L481">        elf.ELFDATA2LSB =&gt; .Little,</span>
<span class="line" id="L482">        elf.ELFDATA2MSB =&gt; .Big,</span>
<span class="line" id="L483">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfEndian,</span>
<span class="line" id="L484">    };</span>
<span class="line" id="L485">    <span class="tok-kw">const</span> need_bswap = elf_endian != native_endian;</span>
<span class="line" id="L486">    <span class="tok-kw">if</span> (hdr32.e_ident[elf.EI_VERSION] != <span class="tok-number">1</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfVersion;</span>
<span class="line" id="L487"></span>
<span class="line" id="L488">    <span class="tok-kw">const</span> is_64 = <span class="tok-kw">switch</span> (hdr32.e_ident[elf.EI_CLASS]) {</span>
<span class="line" id="L489">        elf.ELFCLASS32 =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L490">        elf.ELFCLASS64 =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L491">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfClass,</span>
<span class="line" id="L492">    };</span>
<span class="line" id="L493">    <span class="tok-kw">const</span> shstrndx = elfInt(is_64, need_bswap, hdr32.e_shstrndx, hdr64.e_shstrndx);</span>
<span class="line" id="L494">    <span class="tok-kw">var</span> shoff = elfInt(is_64, need_bswap, hdr32.e_shoff, hdr64.e_shoff);</span>
<span class="line" id="L495">    <span class="tok-kw">const</span> shentsize = elfInt(is_64, need_bswap, hdr32.e_shentsize, hdr64.e_shentsize);</span>
<span class="line" id="L496">    <span class="tok-kw">const</span> str_section_off = shoff + <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, shentsize) * <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, shstrndx);</span>
<span class="line" id="L497">    <span class="tok-kw">var</span> sh_buf: [<span class="tok-number">16</span> * <span class="tok-builtin">@sizeOf</span>(elf.Elf64_Shdr)]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(elf.Elf64_Shdr)) = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L498">    <span class="tok-kw">if</span> (sh_buf.len &lt; shentsize) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfFile;</span>
<span class="line" id="L499"></span>
<span class="line" id="L500">    _ = <span class="tok-kw">try</span> preadMin(file, &amp;sh_buf, str_section_off, shentsize);</span>
<span class="line" id="L501">    <span class="tok-kw">const</span> shstr32 = <span class="tok-builtin">@ptrCast</span>(*elf.Elf32_Shdr, <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@alignOf</span>(elf.Elf32_Shdr), &amp;sh_buf));</span>
<span class="line" id="L502">    <span class="tok-kw">const</span> shstr64 = <span class="tok-builtin">@ptrCast</span>(*elf.Elf64_Shdr, <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@alignOf</span>(elf.Elf64_Shdr), &amp;sh_buf));</span>
<span class="line" id="L503">    <span class="tok-kw">const</span> shstrtab_off = elfInt(is_64, need_bswap, shstr32.sh_offset, shstr64.sh_offset);</span>
<span class="line" id="L504">    <span class="tok-kw">const</span> shstrtab_size = elfInt(is_64, need_bswap, shstr32.sh_size, shstr64.sh_size);</span>
<span class="line" id="L505">    <span class="tok-kw">var</span> strtab_buf: [<span class="tok-number">4096</span>:<span class="tok-number">0</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L506">    <span class="tok-kw">const</span> shstrtab_len = std.math.min(shstrtab_size, strtab_buf.len);</span>
<span class="line" id="L507">    <span class="tok-kw">const</span> shstrtab_read_len = <span class="tok-kw">try</span> preadMin(file, &amp;strtab_buf, shstrtab_off, shstrtab_len);</span>
<span class="line" id="L508">    <span class="tok-kw">const</span> shstrtab = strtab_buf[<span class="tok-number">0</span>..shstrtab_read_len];</span>
<span class="line" id="L509">    <span class="tok-kw">const</span> shnum = elfInt(is_64, need_bswap, hdr32.e_shnum, hdr64.e_shnum);</span>
<span class="line" id="L510">    <span class="tok-kw">var</span> sh_i: <span class="tok-type">u16</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L511">    <span class="tok-kw">const</span> dynstr: <span class="tok-kw">struct</span> { offset: <span class="tok-type">u64</span>, size: <span class="tok-type">u64</span> } = find_dyn_str: <span class="tok-kw">while</span> (sh_i &lt; shnum) {</span>
<span class="line" id="L512">        <span class="tok-comment">// Reserve some bytes so that we can deref the 64-bit struct fields</span>
</span>
<span class="line" id="L513">        <span class="tok-comment">// even when the ELF file is 32-bits.</span>
</span>
<span class="line" id="L514">        <span class="tok-kw">const</span> sh_reserve: <span class="tok-type">usize</span> = <span class="tok-builtin">@sizeOf</span>(elf.Elf64_Shdr) - <span class="tok-builtin">@sizeOf</span>(elf.Elf32_Shdr);</span>
<span class="line" id="L515">        <span class="tok-kw">const</span> sh_read_byte_len = <span class="tok-kw">try</span> preadMin(</span>
<span class="line" id="L516">            file,</span>
<span class="line" id="L517">            sh_buf[<span class="tok-number">0</span> .. sh_buf.len - sh_reserve],</span>
<span class="line" id="L518">            shoff,</span>
<span class="line" id="L519">            shentsize,</span>
<span class="line" id="L520">        );</span>
<span class="line" id="L521">        <span class="tok-kw">var</span> sh_buf_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L522">        <span class="tok-kw">while</span> (sh_buf_i &lt; sh_read_byte_len <span class="tok-kw">and</span> sh_i &lt; shnum) : ({</span>
<span class="line" id="L523">            sh_i += <span class="tok-number">1</span>;</span>
<span class="line" id="L524">            shoff += shentsize;</span>
<span class="line" id="L525">            sh_buf_i += shentsize;</span>
<span class="line" id="L526">        }) {</span>
<span class="line" id="L527">            <span class="tok-kw">const</span> sh32 = <span class="tok-builtin">@ptrCast</span>(</span>
<span class="line" id="L528">                *elf.Elf32_Shdr,</span>
<span class="line" id="L529">                <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@alignOf</span>(elf.Elf32_Shdr), &amp;sh_buf[sh_buf_i]),</span>
<span class="line" id="L530">            );</span>
<span class="line" id="L531">            <span class="tok-kw">const</span> sh64 = <span class="tok-builtin">@ptrCast</span>(</span>
<span class="line" id="L532">                *elf.Elf64_Shdr,</span>
<span class="line" id="L533">                <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@alignOf</span>(elf.Elf64_Shdr), &amp;sh_buf[sh_buf_i]),</span>
<span class="line" id="L534">            );</span>
<span class="line" id="L535">            <span class="tok-kw">const</span> sh_name_off = elfInt(is_64, need_bswap, sh32.sh_name, sh64.sh_name);</span>
<span class="line" id="L536">            <span class="tok-comment">// TODO this pointer cast should not be necessary</span>
</span>
<span class="line" id="L537">            <span class="tok-kw">const</span> sh_name = mem.sliceTo(std.meta.assumeSentinel(shstrtab[sh_name_off..].ptr, <span class="tok-number">0</span>), <span class="tok-number">0</span>);</span>
<span class="line" id="L538">            <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, sh_name, <span class="tok-str">&quot;.dynstr&quot;</span>)) {</span>
<span class="line" id="L539">                <span class="tok-kw">break</span> :find_dyn_str .{</span>
<span class="line" id="L540">                    .offset = elfInt(is_64, need_bswap, sh32.sh_offset, sh64.sh_offset),</span>
<span class="line" id="L541">                    .size = elfInt(is_64, need_bswap, sh32.sh_size, sh64.sh_size),</span>
<span class="line" id="L542">                };</span>
<span class="line" id="L543">            }</span>
<span class="line" id="L544">        }</span>
<span class="line" id="L545">    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidGnuLibCVersion;</span>
<span class="line" id="L546"></span>
<span class="line" id="L547">    <span class="tok-comment">// Here we loop over all the strings in the dynstr string table, assuming that any</span>
</span>
<span class="line" id="L548">    <span class="tok-comment">// strings that start with &quot;GLIBC_2.&quot; indicate the existence of such a glibc version,</span>
</span>
<span class="line" id="L549">    <span class="tok-comment">// and furthermore, that the system-installed glibc is at minimum that version.</span>
</span>
<span class="line" id="L550"></span>
<span class="line" id="L551">    <span class="tok-comment">// Empirically, glibc 2.34 libc.so .dynstr section is 32441 bytes on my system.</span>
</span>
<span class="line" id="L552">    <span class="tok-comment">// Here I use double this value plus some headroom. This makes it only need</span>
</span>
<span class="line" id="L553">    <span class="tok-comment">// a single read syscall here.</span>
</span>
<span class="line" id="L554">    <span class="tok-kw">var</span> buf: [<span class="tok-number">80000</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L555">    <span class="tok-kw">if</span> (buf.len &lt; dynstr.size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidGnuLibCVersion;</span>
<span class="line" id="L556"></span>
<span class="line" id="L557">    <span class="tok-kw">const</span> dynstr_size = <span class="tok-builtin">@intCast</span>(<span class="tok-type">usize</span>, dynstr.size);</span>
<span class="line" id="L558">    <span class="tok-kw">const</span> dynstr_bytes = buf[<span class="tok-number">0</span>..dynstr_size];</span>
<span class="line" id="L559">    _ = <span class="tok-kw">try</span> preadMin(file, dynstr_bytes, dynstr.offset, dynstr_bytes.len);</span>
<span class="line" id="L560">    <span class="tok-kw">var</span> it = mem.split(<span class="tok-type">u8</span>, dynstr_bytes, &amp;.{<span class="tok-number">0</span>});</span>
<span class="line" id="L561">    <span class="tok-kw">var</span> max_ver: std.builtin.Version = .{ .major = <span class="tok-number">2</span>, .minor = <span class="tok-number">2</span>, .patch = <span class="tok-number">5</span> };</span>
<span class="line" id="L562">    <span class="tok-kw">while</span> (it.next()) |s| {</span>
<span class="line" id="L563">        <span class="tok-kw">if</span> (mem.startsWith(<span class="tok-type">u8</span>, s, <span class="tok-str">&quot;GLIBC_2.&quot;</span>)) {</span>
<span class="line" id="L564">            <span class="tok-kw">const</span> chopped = s[<span class="tok-str">&quot;GLIBC_&quot;</span>.len..];</span>
<span class="line" id="L565">            <span class="tok-kw">const</span> ver = std.builtin.Version.parse(chopped) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L566">                <span class="tok-kw">error</span>.Overflow =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidGnuLibCVersion,</span>
<span class="line" id="L567">                <span class="tok-kw">error</span>.InvalidCharacter =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidGnuLibCVersion,</span>
<span class="line" id="L568">                <span class="tok-kw">error</span>.InvalidVersion =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidGnuLibCVersion,</span>
<span class="line" id="L569">            };</span>
<span class="line" id="L570">            <span class="tok-kw">switch</span> (ver.order(max_ver)) {</span>
<span class="line" id="L571">                .gt =&gt; max_ver = ver,</span>
<span class="line" id="L572">                .lt, .eq =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L573">            }</span>
<span class="line" id="L574">        }</span>
<span class="line" id="L575">    }</span>
<span class="line" id="L576">    <span class="tok-kw">return</span> max_ver;</span>
<span class="line" id="L577">}</span>
<span class="line" id="L578"></span>
<span class="line" id="L579"><span class="tok-kw">fn</span> <span class="tok-fn">glibcVerFromLinkName</span>(link_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !std.builtin.Version {</span>
<span class="line" id="L580">    <span class="tok-comment">// example: &quot;libc-2.3.4.so&quot;</span>
</span>
<span class="line" id="L581">    <span class="tok-comment">// example: &quot;libc-2.27.so&quot;</span>
</span>
<span class="line" id="L582">    <span class="tok-comment">// example: &quot;ld-2.33.so&quot;</span>
</span>
<span class="line" id="L583">    <span class="tok-kw">const</span> suffix = <span class="tok-str">&quot;.so&quot;</span>;</span>
<span class="line" id="L584">    <span class="tok-kw">if</span> (!mem.startsWith(<span class="tok-type">u8</span>, link_name, prefix) <span class="tok-kw">or</span> !mem.endsWith(<span class="tok-type">u8</span>, link_name, suffix)) {</span>
<span class="line" id="L585">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnrecognizedGnuLibCFileName;</span>
<span class="line" id="L586">    }</span>
<span class="line" id="L587">    <span class="tok-comment">// chop off &quot;libc-&quot; and &quot;.so&quot;</span>
</span>
<span class="line" id="L588">    <span class="tok-kw">const</span> link_name_chopped = link_name[prefix.len .. link_name.len - suffix.len];</span>
<span class="line" id="L589">    <span class="tok-kw">return</span> std.builtin.Version.parse(link_name_chopped) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L590">        <span class="tok-kw">error</span>.Overflow =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidGnuLibCVersion,</span>
<span class="line" id="L591">        <span class="tok-kw">error</span>.InvalidCharacter =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidGnuLibCVersion,</span>
<span class="line" id="L592">        <span class="tok-kw">error</span>.InvalidVersion =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidGnuLibCVersion,</span>
<span class="line" id="L593">    };</span>
<span class="line" id="L594">}</span>
<span class="line" id="L595"></span>
<span class="line" id="L596"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> AbiAndDynamicLinkerFromFileError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L597">    FileSystem,</span>
<span class="line" id="L598">    SystemResources,</span>
<span class="line" id="L599">    SymLinkLoop,</span>
<span class="line" id="L600">    ProcessFdQuotaExceeded,</span>
<span class="line" id="L601">    SystemFdQuotaExceeded,</span>
<span class="line" id="L602">    UnableToReadElfFile,</span>
<span class="line" id="L603">    InvalidElfClass,</span>
<span class="line" id="L604">    InvalidElfVersion,</span>
<span class="line" id="L605">    InvalidElfEndian,</span>
<span class="line" id="L606">    InvalidElfFile,</span>
<span class="line" id="L607">    InvalidElfMagic,</span>
<span class="line" id="L608">    Unexpected,</span>
<span class="line" id="L609">    UnexpectedEndOfFile,</span>
<span class="line" id="L610">    NameTooLong,</span>
<span class="line" id="L611">};</span>
<span class="line" id="L612"></span>
<span class="line" id="L613"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">abiAndDynamicLinkerFromFile</span>(</span>
<span class="line" id="L614">    file: fs.File,</span>
<span class="line" id="L615">    cpu: Target.Cpu,</span>
<span class="line" id="L616">    os: Target.Os,</span>
<span class="line" id="L617">    ld_info_list: []<span class="tok-kw">const</span> LdInfo,</span>
<span class="line" id="L618">    cross_target: CrossTarget,</span>
<span class="line" id="L619">) AbiAndDynamicLinkerFromFileError!NativeTargetInfo {</span>
<span class="line" id="L620">    <span class="tok-kw">var</span> hdr_buf: [<span class="tok-builtin">@sizeOf</span>(elf.Elf64_Ehdr)]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(elf.Elf64_Ehdr)) = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L621">    _ = <span class="tok-kw">try</span> preadMin(file, &amp;hdr_buf, <span class="tok-number">0</span>, hdr_buf.len);</span>
<span class="line" id="L622">    <span class="tok-kw">const</span> hdr32 = <span class="tok-builtin">@ptrCast</span>(*elf.Elf32_Ehdr, &amp;hdr_buf);</span>
<span class="line" id="L623">    <span class="tok-kw">const</span> hdr64 = <span class="tok-builtin">@ptrCast</span>(*elf.Elf64_Ehdr, &amp;hdr_buf);</span>
<span class="line" id="L624">    <span class="tok-kw">if</span> (!mem.eql(<span class="tok-type">u8</span>, hdr32.e_ident[<span class="tok-number">0</span>..<span class="tok-number">4</span>], elf.MAGIC)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfMagic;</span>
<span class="line" id="L625">    <span class="tok-kw">const</span> elf_endian: std.builtin.Endian = <span class="tok-kw">switch</span> (hdr32.e_ident[elf.EI_DATA]) {</span>
<span class="line" id="L626">        elf.ELFDATA2LSB =&gt; .Little,</span>
<span class="line" id="L627">        elf.ELFDATA2MSB =&gt; .Big,</span>
<span class="line" id="L628">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfEndian,</span>
<span class="line" id="L629">    };</span>
<span class="line" id="L630">    <span class="tok-kw">const</span> need_bswap = elf_endian != native_endian;</span>
<span class="line" id="L631">    <span class="tok-kw">if</span> (hdr32.e_ident[elf.EI_VERSION] != <span class="tok-number">1</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfVersion;</span>
<span class="line" id="L632"></span>
<span class="line" id="L633">    <span class="tok-kw">const</span> is_64 = <span class="tok-kw">switch</span> (hdr32.e_ident[elf.EI_CLASS]) {</span>
<span class="line" id="L634">        elf.ELFCLASS32 =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L635">        elf.ELFCLASS64 =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L636">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfClass,</span>
<span class="line" id="L637">    };</span>
<span class="line" id="L638">    <span class="tok-kw">var</span> phoff = elfInt(is_64, need_bswap, hdr32.e_phoff, hdr64.e_phoff);</span>
<span class="line" id="L639">    <span class="tok-kw">const</span> phentsize = elfInt(is_64, need_bswap, hdr32.e_phentsize, hdr64.e_phentsize);</span>
<span class="line" id="L640">    <span class="tok-kw">const</span> phnum = elfInt(is_64, need_bswap, hdr32.e_phnum, hdr64.e_phnum);</span>
<span class="line" id="L641"></span>
<span class="line" id="L642">    <span class="tok-kw">var</span> result: NativeTargetInfo = .{</span>
<span class="line" id="L643">        .target = .{</span>
<span class="line" id="L644">            .cpu = cpu,</span>
<span class="line" id="L645">            .os = os,</span>
<span class="line" id="L646">            .abi = cross_target.abi <span class="tok-kw">orelse</span> Target.Abi.default(cpu.arch, os),</span>
<span class="line" id="L647">            .ofmt = cross_target.ofmt <span class="tok-kw">orelse</span> Target.ObjectFormat.default(os.tag, cpu.arch),</span>
<span class="line" id="L648">        },</span>
<span class="line" id="L649">        .dynamic_linker = cross_target.dynamic_linker,</span>
<span class="line" id="L650">    };</span>
<span class="line" id="L651">    <span class="tok-kw">var</span> rpath_offset: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span>; <span class="tok-comment">// Found inside PT_DYNAMIC</span>
</span>
<span class="line" id="L652">    <span class="tok-kw">const</span> look_for_ld = cross_target.dynamic_linker.get() == <span class="tok-null">null</span>;</span>
<span class="line" id="L653"></span>
<span class="line" id="L654">    <span class="tok-kw">var</span> ph_buf: [<span class="tok-number">16</span> * <span class="tok-builtin">@sizeOf</span>(elf.Elf64_Phdr)]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(elf.Elf64_Phdr)) = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L655">    <span class="tok-kw">if</span> (phentsize &gt; <span class="tok-builtin">@sizeOf</span>(elf.Elf64_Phdr)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfFile;</span>
<span class="line" id="L656"></span>
<span class="line" id="L657">    <span class="tok-kw">var</span> ph_i: <span class="tok-type">u16</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L658">    <span class="tok-kw">while</span> (ph_i &lt; phnum) {</span>
<span class="line" id="L659">        <span class="tok-comment">// Reserve some bytes so that we can deref the 64-bit struct fields</span>
</span>
<span class="line" id="L660">        <span class="tok-comment">// even when the ELF file is 32-bits.</span>
</span>
<span class="line" id="L661">        <span class="tok-kw">const</span> ph_reserve: <span class="tok-type">usize</span> = <span class="tok-builtin">@sizeOf</span>(elf.Elf64_Phdr) - <span class="tok-builtin">@sizeOf</span>(elf.Elf32_Phdr);</span>
<span class="line" id="L662">        <span class="tok-kw">const</span> ph_read_byte_len = <span class="tok-kw">try</span> preadMin(file, ph_buf[<span class="tok-number">0</span> .. ph_buf.len - ph_reserve], phoff, phentsize);</span>
<span class="line" id="L663">        <span class="tok-kw">var</span> ph_buf_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L664">        <span class="tok-kw">while</span> (ph_buf_i &lt; ph_read_byte_len <span class="tok-kw">and</span> ph_i &lt; phnum) : ({</span>
<span class="line" id="L665">            ph_i += <span class="tok-number">1</span>;</span>
<span class="line" id="L666">            phoff += phentsize;</span>
<span class="line" id="L667">            ph_buf_i += phentsize;</span>
<span class="line" id="L668">        }) {</span>
<span class="line" id="L669">            <span class="tok-kw">const</span> ph32 = <span class="tok-builtin">@ptrCast</span>(*elf.Elf32_Phdr, <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@alignOf</span>(elf.Elf32_Phdr), &amp;ph_buf[ph_buf_i]));</span>
<span class="line" id="L670">            <span class="tok-kw">const</span> ph64 = <span class="tok-builtin">@ptrCast</span>(*elf.Elf64_Phdr, <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@alignOf</span>(elf.Elf64_Phdr), &amp;ph_buf[ph_buf_i]));</span>
<span class="line" id="L671">            <span class="tok-kw">const</span> p_type = elfInt(is_64, need_bswap, ph32.p_type, ph64.p_type);</span>
<span class="line" id="L672">            <span class="tok-kw">switch</span> (p_type) {</span>
<span class="line" id="L673">                elf.PT_INTERP =&gt; <span class="tok-kw">if</span> (look_for_ld) {</span>
<span class="line" id="L674">                    <span class="tok-kw">const</span> p_offset = elfInt(is_64, need_bswap, ph32.p_offset, ph64.p_offset);</span>
<span class="line" id="L675">                    <span class="tok-kw">const</span> p_filesz = elfInt(is_64, need_bswap, ph32.p_filesz, ph64.p_filesz);</span>
<span class="line" id="L676">                    <span class="tok-kw">if</span> (p_filesz &gt; result.dynamic_linker.buffer.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;</span>
<span class="line" id="L677">                    <span class="tok-kw">const</span> filesz = <span class="tok-builtin">@intCast</span>(<span class="tok-type">usize</span>, p_filesz);</span>
<span class="line" id="L678">                    _ = <span class="tok-kw">try</span> preadMin(file, result.dynamic_linker.buffer[<span class="tok-number">0</span>..filesz], p_offset, filesz);</span>
<span class="line" id="L679">                    <span class="tok-comment">// PT_INTERP includes a null byte in filesz.</span>
</span>
<span class="line" id="L680">                    <span class="tok-kw">const</span> len = filesz - <span class="tok-number">1</span>;</span>
<span class="line" id="L681">                    <span class="tok-comment">// dynamic_linker.max_byte is &quot;max&quot;, not &quot;len&quot;.</span>
</span>
<span class="line" id="L682">                    <span class="tok-comment">// We know it will fit in u8 because we check against dynamic_linker.buffer.len above.</span>
</span>
<span class="line" id="L683">                    result.dynamic_linker.max_byte = <span class="tok-builtin">@intCast</span>(<span class="tok-type">u8</span>, len - <span class="tok-number">1</span>);</span>
<span class="line" id="L684"></span>
<span class="line" id="L685">                    <span class="tok-comment">// Use it to determine ABI.</span>
</span>
<span class="line" id="L686">                    <span class="tok-kw">const</span> full_ld_path = result.dynamic_linker.buffer[<span class="tok-number">0</span>..len];</span>
<span class="line" id="L687">                    <span class="tok-kw">for</span> (ld_info_list) |ld_info| {</span>
<span class="line" id="L688">                        <span class="tok-kw">const</span> standard_ld_basename = fs.path.basename(ld_info.ld.get().?);</span>
<span class="line" id="L689">                        <span class="tok-kw">if</span> (std.mem.endsWith(<span class="tok-type">u8</span>, full_ld_path, standard_ld_basename)) {</span>
<span class="line" id="L690">                            result.target.abi = ld_info.abi;</span>
<span class="line" id="L691">                            <span class="tok-kw">break</span>;</span>
<span class="line" id="L692">                        }</span>
<span class="line" id="L693">                    }</span>
<span class="line" id="L694">                },</span>
<span class="line" id="L695">                <span class="tok-comment">// We only need this for detecting glibc version.</span>
</span>
<span class="line" id="L696">                elf.PT_DYNAMIC =&gt; <span class="tok-kw">if</span> (builtin.target.os.tag == .linux <span class="tok-kw">and</span> result.target.isGnuLibC() <span class="tok-kw">and</span></span>
<span class="line" id="L697">                    cross_target.glibc_version == <span class="tok-null">null</span>)</span>
<span class="line" id="L698">                {</span>
<span class="line" id="L699">                    <span class="tok-kw">var</span> dyn_off = elfInt(is_64, need_bswap, ph32.p_offset, ph64.p_offset);</span>
<span class="line" id="L700">                    <span class="tok-kw">const</span> p_filesz = elfInt(is_64, need_bswap, ph32.p_filesz, ph64.p_filesz);</span>
<span class="line" id="L701">                    <span class="tok-kw">const</span> dyn_size: <span class="tok-type">usize</span> = <span class="tok-kw">if</span> (is_64) <span class="tok-builtin">@sizeOf</span>(elf.Elf64_Dyn) <span class="tok-kw">else</span> <span class="tok-builtin">@sizeOf</span>(elf.Elf32_Dyn);</span>
<span class="line" id="L702">                    <span class="tok-kw">const</span> dyn_num = p_filesz / dyn_size;</span>
<span class="line" id="L703">                    <span class="tok-kw">var</span> dyn_buf: [<span class="tok-number">16</span> * <span class="tok-builtin">@sizeOf</span>(elf.Elf64_Dyn)]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(elf.Elf64_Dyn)) = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L704">                    <span class="tok-kw">var</span> dyn_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L705">                    dyn: <span class="tok-kw">while</span> (dyn_i &lt; dyn_num) {</span>
<span class="line" id="L706">                        <span class="tok-comment">// Reserve some bytes so that we can deref the 64-bit struct fields</span>
</span>
<span class="line" id="L707">                        <span class="tok-comment">// even when the ELF file is 32-bits.</span>
</span>
<span class="line" id="L708">                        <span class="tok-kw">const</span> dyn_reserve: <span class="tok-type">usize</span> = <span class="tok-builtin">@sizeOf</span>(elf.Elf64_Dyn) - <span class="tok-builtin">@sizeOf</span>(elf.Elf32_Dyn);</span>
<span class="line" id="L709">                        <span class="tok-kw">const</span> dyn_read_byte_len = <span class="tok-kw">try</span> preadMin(</span>
<span class="line" id="L710">                            file,</span>
<span class="line" id="L711">                            dyn_buf[<span class="tok-number">0</span> .. dyn_buf.len - dyn_reserve],</span>
<span class="line" id="L712">                            dyn_off,</span>
<span class="line" id="L713">                            dyn_size,</span>
<span class="line" id="L714">                        );</span>
<span class="line" id="L715">                        <span class="tok-kw">var</span> dyn_buf_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L716">                        <span class="tok-kw">while</span> (dyn_buf_i &lt; dyn_read_byte_len <span class="tok-kw">and</span> dyn_i &lt; dyn_num) : ({</span>
<span class="line" id="L717">                            dyn_i += <span class="tok-number">1</span>;</span>
<span class="line" id="L718">                            dyn_off += dyn_size;</span>
<span class="line" id="L719">                            dyn_buf_i += dyn_size;</span>
<span class="line" id="L720">                        }) {</span>
<span class="line" id="L721">                            <span class="tok-kw">const</span> dyn32 = <span class="tok-builtin">@ptrCast</span>(</span>
<span class="line" id="L722">                                *elf.Elf32_Dyn,</span>
<span class="line" id="L723">                                <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@alignOf</span>(elf.Elf32_Dyn), &amp;dyn_buf[dyn_buf_i]),</span>
<span class="line" id="L724">                            );</span>
<span class="line" id="L725">                            <span class="tok-kw">const</span> dyn64 = <span class="tok-builtin">@ptrCast</span>(</span>
<span class="line" id="L726">                                *elf.Elf64_Dyn,</span>
<span class="line" id="L727">                                <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@alignOf</span>(elf.Elf64_Dyn), &amp;dyn_buf[dyn_buf_i]),</span>
<span class="line" id="L728">                            );</span>
<span class="line" id="L729">                            <span class="tok-kw">const</span> tag = elfInt(is_64, need_bswap, dyn32.d_tag, dyn64.d_tag);</span>
<span class="line" id="L730">                            <span class="tok-kw">const</span> val = elfInt(is_64, need_bswap, dyn32.d_val, dyn64.d_val);</span>
<span class="line" id="L731">                            <span class="tok-kw">if</span> (tag == elf.DT_RUNPATH) {</span>
<span class="line" id="L732">                                rpath_offset = val;</span>
<span class="line" id="L733">                                <span class="tok-kw">break</span> :dyn;</span>
<span class="line" id="L734">                            }</span>
<span class="line" id="L735">                        }</span>
<span class="line" id="L736">                    }</span>
<span class="line" id="L737">                },</span>
<span class="line" id="L738">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L739">            }</span>
<span class="line" id="L740">        }</span>
<span class="line" id="L741">    }</span>
<span class="line" id="L742"></span>
<span class="line" id="L743">    <span class="tok-kw">if</span> (builtin.target.os.tag == .linux <span class="tok-kw">and</span> result.target.isGnuLibC() <span class="tok-kw">and</span></span>
<span class="line" id="L744">        cross_target.glibc_version == <span class="tok-null">null</span>)</span>
<span class="line" id="L745">    {</span>
<span class="line" id="L746">        <span class="tok-kw">const</span> shstrndx = elfInt(is_64, need_bswap, hdr32.e_shstrndx, hdr64.e_shstrndx);</span>
<span class="line" id="L747"></span>
<span class="line" id="L748">        <span class="tok-kw">var</span> shoff = elfInt(is_64, need_bswap, hdr32.e_shoff, hdr64.e_shoff);</span>
<span class="line" id="L749">        <span class="tok-kw">const</span> shentsize = elfInt(is_64, need_bswap, hdr32.e_shentsize, hdr64.e_shentsize);</span>
<span class="line" id="L750">        <span class="tok-kw">const</span> str_section_off = shoff + <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, shentsize) * <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, shstrndx);</span>
<span class="line" id="L751"></span>
<span class="line" id="L752">        <span class="tok-kw">var</span> sh_buf: [<span class="tok-number">16</span> * <span class="tok-builtin">@sizeOf</span>(elf.Elf64_Shdr)]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(elf.Elf64_Shdr)) = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L753">        <span class="tok-kw">if</span> (sh_buf.len &lt; shentsize) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfFile;</span>
<span class="line" id="L754"></span>
<span class="line" id="L755">        _ = <span class="tok-kw">try</span> preadMin(file, &amp;sh_buf, str_section_off, shentsize);</span>
<span class="line" id="L756">        <span class="tok-kw">const</span> shstr32 = <span class="tok-builtin">@ptrCast</span>(*elf.Elf32_Shdr, <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@alignOf</span>(elf.Elf32_Shdr), &amp;sh_buf));</span>
<span class="line" id="L757">        <span class="tok-kw">const</span> shstr64 = <span class="tok-builtin">@ptrCast</span>(*elf.Elf64_Shdr, <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@alignOf</span>(elf.Elf64_Shdr), &amp;sh_buf));</span>
<span class="line" id="L758">        <span class="tok-kw">const</span> shstrtab_off = elfInt(is_64, need_bswap, shstr32.sh_offset, shstr64.sh_offset);</span>
<span class="line" id="L759">        <span class="tok-kw">const</span> shstrtab_size = elfInt(is_64, need_bswap, shstr32.sh_size, shstr64.sh_size);</span>
<span class="line" id="L760">        <span class="tok-kw">var</span> strtab_buf: [<span class="tok-number">4096</span>:<span class="tok-number">0</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L761">        <span class="tok-kw">const</span> shstrtab_len = std.math.min(shstrtab_size, strtab_buf.len);</span>
<span class="line" id="L762">        <span class="tok-kw">const</span> shstrtab_read_len = <span class="tok-kw">try</span> preadMin(file, &amp;strtab_buf, shstrtab_off, shstrtab_len);</span>
<span class="line" id="L763">        <span class="tok-kw">const</span> shstrtab = strtab_buf[<span class="tok-number">0</span>..shstrtab_read_len];</span>
<span class="line" id="L764"></span>
<span class="line" id="L765">        <span class="tok-kw">const</span> shnum = elfInt(is_64, need_bswap, hdr32.e_shnum, hdr64.e_shnum);</span>
<span class="line" id="L766">        <span class="tok-kw">var</span> sh_i: <span class="tok-type">u16</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L767">        <span class="tok-kw">const</span> dynstr: ?<span class="tok-kw">struct</span> { offset: <span class="tok-type">u64</span>, size: <span class="tok-type">u64</span> } = find_dyn_str: <span class="tok-kw">while</span> (sh_i &lt; shnum) {</span>
<span class="line" id="L768">            <span class="tok-comment">// Reserve some bytes so that we can deref the 64-bit struct fields</span>
</span>
<span class="line" id="L769">            <span class="tok-comment">// even when the ELF file is 32-bits.</span>
</span>
<span class="line" id="L770">            <span class="tok-kw">const</span> sh_reserve: <span class="tok-type">usize</span> = <span class="tok-builtin">@sizeOf</span>(elf.Elf64_Shdr) - <span class="tok-builtin">@sizeOf</span>(elf.Elf32_Shdr);</span>
<span class="line" id="L771">            <span class="tok-kw">const</span> sh_read_byte_len = <span class="tok-kw">try</span> preadMin(</span>
<span class="line" id="L772">                file,</span>
<span class="line" id="L773">                sh_buf[<span class="tok-number">0</span> .. sh_buf.len - sh_reserve],</span>
<span class="line" id="L774">                shoff,</span>
<span class="line" id="L775">                shentsize,</span>
<span class="line" id="L776">            );</span>
<span class="line" id="L777">            <span class="tok-kw">var</span> sh_buf_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L778">            <span class="tok-kw">while</span> (sh_buf_i &lt; sh_read_byte_len <span class="tok-kw">and</span> sh_i &lt; shnum) : ({</span>
<span class="line" id="L779">                sh_i += <span class="tok-number">1</span>;</span>
<span class="line" id="L780">                shoff += shentsize;</span>
<span class="line" id="L781">                sh_buf_i += shentsize;</span>
<span class="line" id="L782">            }) {</span>
<span class="line" id="L783">                <span class="tok-kw">const</span> sh32 = <span class="tok-builtin">@ptrCast</span>(</span>
<span class="line" id="L784">                    *elf.Elf32_Shdr,</span>
<span class="line" id="L785">                    <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@alignOf</span>(elf.Elf32_Shdr), &amp;sh_buf[sh_buf_i]),</span>
<span class="line" id="L786">                );</span>
<span class="line" id="L787">                <span class="tok-kw">const</span> sh64 = <span class="tok-builtin">@ptrCast</span>(</span>
<span class="line" id="L788">                    *elf.Elf64_Shdr,</span>
<span class="line" id="L789">                    <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@alignOf</span>(elf.Elf64_Shdr), &amp;sh_buf[sh_buf_i]),</span>
<span class="line" id="L790">                );</span>
<span class="line" id="L791">                <span class="tok-kw">const</span> sh_name_off = elfInt(is_64, need_bswap, sh32.sh_name, sh64.sh_name);</span>
<span class="line" id="L792">                <span class="tok-comment">// TODO this pointer cast should not be necessary</span>
</span>
<span class="line" id="L793">                <span class="tok-kw">const</span> sh_name = mem.sliceTo(std.meta.assumeSentinel(shstrtab[sh_name_off..].ptr, <span class="tok-number">0</span>), <span class="tok-number">0</span>);</span>
<span class="line" id="L794">                <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, sh_name, <span class="tok-str">&quot;.dynstr&quot;</span>)) {</span>
<span class="line" id="L795">                    <span class="tok-kw">break</span> :find_dyn_str .{</span>
<span class="line" id="L796">                        .offset = elfInt(is_64, need_bswap, sh32.sh_offset, sh64.sh_offset),</span>
<span class="line" id="L797">                        .size = elfInt(is_64, need_bswap, sh32.sh_size, sh64.sh_size),</span>
<span class="line" id="L798">                    };</span>
<span class="line" id="L799">                }</span>
<span class="line" id="L800">            }</span>
<span class="line" id="L801">        } <span class="tok-kw">else</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L802"></span>
<span class="line" id="L803">        <span class="tok-kw">if</span> (dynstr) |ds| {</span>
<span class="line" id="L804">            <span class="tok-kw">if</span> (rpath_offset) |rpoff| {</span>
<span class="line" id="L805">                <span class="tok-comment">// TODO this pointer cast should not be necessary</span>
</span>
<span class="line" id="L806">                <span class="tok-kw">const</span> rpoff_usize = std.math.cast(<span class="tok-type">usize</span>, rpoff) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfFile;</span>
<span class="line" id="L807">                <span class="tok-kw">if</span> (rpoff_usize &gt; ds.size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfFile;</span>
<span class="line" id="L808">                <span class="tok-kw">const</span> rpoff_file = ds.offset + rpoff_usize;</span>
<span class="line" id="L809">                <span class="tok-kw">const</span> rp_max_size = ds.size - rpoff_usize;</span>
<span class="line" id="L810"></span>
<span class="line" id="L811">                <span class="tok-kw">const</span> strtab_len = std.math.min(rp_max_size, strtab_buf.len);</span>
<span class="line" id="L812">                <span class="tok-kw">const</span> strtab_read_len = <span class="tok-kw">try</span> preadMin(file, &amp;strtab_buf, rpoff_file, strtab_len);</span>
<span class="line" id="L813">                <span class="tok-kw">const</span> strtab = strtab_buf[<span class="tok-number">0</span>..strtab_read_len];</span>
<span class="line" id="L814"></span>
<span class="line" id="L815">                <span class="tok-kw">const</span> rpath_list = mem.sliceTo(std.meta.assumeSentinel(strtab.ptr, <span class="tok-number">0</span>), <span class="tok-number">0</span>);</span>
<span class="line" id="L816">                <span class="tok-kw">var</span> it = mem.tokenize(<span class="tok-type">u8</span>, rpath_list, <span class="tok-str">&quot;:&quot;</span>);</span>
<span class="line" id="L817">                <span class="tok-kw">while</span> (it.next()) |rpath| {</span>
<span class="line" id="L818">                    <span class="tok-kw">if</span> (glibcVerFromRPath(rpath)) |ver| {</span>
<span class="line" id="L819">                        result.target.os.version_range.linux.glibc = ver;</span>
<span class="line" id="L820">                        <span class="tok-kw">return</span> result;</span>
<span class="line" id="L821">                    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L822">                        <span class="tok-kw">error</span>.GLibCNotFound =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L823">                        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L824">                    }</span>
<span class="line" id="L825">                }</span>
<span class="line" id="L826">            }</span>
<span class="line" id="L827">        }</span>
<span class="line" id="L828"></span>
<span class="line" id="L829">        <span class="tok-kw">if</span> (result.dynamic_linker.get()) |dl_path| glibc_ver: {</span>
<span class="line" id="L830">            <span class="tok-comment">// There is no DT_RUNPATH so we try to find libc.so.6 inside the same</span>
</span>
<span class="line" id="L831">            <span class="tok-comment">// directory as the dynamic linker.</span>
</span>
<span class="line" id="L832">            <span class="tok-kw">if</span> (fs.path.dirname(dl_path)) |rpath| {</span>
<span class="line" id="L833">                <span class="tok-kw">if</span> (glibcVerFromRPath(rpath)) |ver| {</span>
<span class="line" id="L834">                    result.target.os.version_range.linux.glibc = ver;</span>
<span class="line" id="L835">                    <span class="tok-kw">return</span> result;</span>
<span class="line" id="L836">                } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L837">                    <span class="tok-kw">error</span>.GLibCNotFound =&gt; {},</span>
<span class="line" id="L838">                    <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L839">                }</span>
<span class="line" id="L840">            }</span>
<span class="line" id="L841"></span>
<span class="line" id="L842">            <span class="tok-comment">// So far, no luck. Next we try to see if the information is</span>
</span>
<span class="line" id="L843">            <span class="tok-comment">// present in the symlink data for the dynamic linker path.</span>
</span>
<span class="line" id="L844">            <span class="tok-kw">var</span> link_buf: [std.os.PATH_MAX]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L845">            <span class="tok-kw">const</span> link_name = std.os.readlink(dl_path, &amp;link_buf) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L846">                <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L847">                <span class="tok-kw">error</span>.InvalidUtf8 =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Windows only</span>
</span>
<span class="line" id="L848">                <span class="tok-kw">error</span>.BadPathName =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Windows only</span>
</span>
<span class="line" id="L849">                <span class="tok-kw">error</span>.UnsupportedReparsePointType =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Windows only</span>
</span>
<span class="line" id="L850"></span>
<span class="line" id="L851">                <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L852">                <span class="tok-kw">error</span>.FileNotFound,</span>
<span class="line" id="L853">                <span class="tok-kw">error</span>.NotLink,</span>
<span class="line" id="L854">                <span class="tok-kw">error</span>.NotDir,</span>
<span class="line" id="L855">                =&gt; <span class="tok-kw">break</span> :glibc_ver,</span>
<span class="line" id="L856"></span>
<span class="line" id="L857">                <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L858">                <span class="tok-kw">error</span>.FileSystem,</span>
<span class="line" id="L859">                <span class="tok-kw">error</span>.SymLinkLoop,</span>
<span class="line" id="L860">                <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L861">                =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L862">            };</span>
<span class="line" id="L863">            result.target.os.version_range.linux.glibc = glibcVerFromLinkName(</span>
<span class="line" id="L864">                fs.path.basename(link_name),</span>
<span class="line" id="L865">                <span class="tok-str">&quot;ld-&quot;</span>,</span>
<span class="line" id="L866">            ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L867">                <span class="tok-kw">error</span>.UnrecognizedGnuLibCFileName,</span>
<span class="line" id="L868">                <span class="tok-kw">error</span>.InvalidGnuLibCVersion,</span>
<span class="line" id="L869">                =&gt; <span class="tok-kw">break</span> :glibc_ver,</span>
<span class="line" id="L870">            };</span>
<span class="line" id="L871">            <span class="tok-kw">return</span> result;</span>
<span class="line" id="L872">        }</span>
<span class="line" id="L873"></span>
<span class="line" id="L874">        <span class="tok-comment">// Nothing worked so far. Finally we fall back to hard-coded search paths.</span>
</span>
<span class="line" id="L875">        <span class="tok-comment">// Some distros such as Debian keep their libc.so.6 in `/lib/$triple/`.</span>
</span>
<span class="line" id="L876">        <span class="tok-kw">var</span> path_buf: [std.os.PATH_MAX]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L877">        <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L878">        <span class="tok-kw">const</span> prefix = <span class="tok-str">&quot;/lib/&quot;</span>;</span>
<span class="line" id="L879">        <span class="tok-kw">const</span> cpu_arch = <span class="tok-builtin">@tagName</span>(result.target.cpu.arch);</span>
<span class="line" id="L880">        <span class="tok-kw">const</span> os_tag = <span class="tok-builtin">@tagName</span>(result.target.os.tag);</span>
<span class="line" id="L881">        <span class="tok-kw">const</span> abi = <span class="tok-builtin">@tagName</span>(result.target.abi);</span>
<span class="line" id="L882">        mem.copy(<span class="tok-type">u8</span>, path_buf[index..], prefix);</span>
<span class="line" id="L883">        index += prefix.len;</span>
<span class="line" id="L884">        mem.copy(<span class="tok-type">u8</span>, path_buf[index..], cpu_arch);</span>
<span class="line" id="L885">        index += cpu_arch.len;</span>
<span class="line" id="L886">        path_buf[index] = <span class="tok-str">'-'</span>;</span>
<span class="line" id="L887">        index += <span class="tok-number">1</span>;</span>
<span class="line" id="L888">        mem.copy(<span class="tok-type">u8</span>, path_buf[index..], os_tag);</span>
<span class="line" id="L889">        index += os_tag.len;</span>
<span class="line" id="L890">        path_buf[index] = <span class="tok-str">'-'</span>;</span>
<span class="line" id="L891">        index += <span class="tok-number">1</span>;</span>
<span class="line" id="L892">        mem.copy(<span class="tok-type">u8</span>, path_buf[index..], abi);</span>
<span class="line" id="L893">        index += abi.len;</span>
<span class="line" id="L894">        <span class="tok-kw">const</span> rpath = path_buf[<span class="tok-number">0</span>..index];</span>
<span class="line" id="L895">        <span class="tok-kw">if</span> (glibcVerFromRPath(rpath)) |ver| {</span>
<span class="line" id="L896">            result.target.os.version_range.linux.glibc = ver;</span>
<span class="line" id="L897">            <span class="tok-kw">return</span> result;</span>
<span class="line" id="L898">        } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L899">            <span class="tok-kw">error</span>.GLibCNotFound =&gt; {},</span>
<span class="line" id="L900">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L901">        }</span>
<span class="line" id="L902">    }</span>
<span class="line" id="L903"></span>
<span class="line" id="L904">    <span class="tok-kw">return</span> result;</span>
<span class="line" id="L905">}</span>
<span class="line" id="L906"></span>
<span class="line" id="L907"><span class="tok-kw">fn</span> <span class="tok-fn">preadMin</span>(file: fs.File, buf: []<span class="tok-type">u8</span>, offset: <span class="tok-type">u64</span>, min_read_len: <span class="tok-type">usize</span>) !<span class="tok-type">usize</span> {</span>
<span class="line" id="L908">    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L909">    <span class="tok-kw">while</span> (i &lt; min_read_len) {</span>
<span class="line" id="L910">        <span class="tok-kw">const</span> len = file.pread(buf[i..], offset + i) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L911">            <span class="tok-kw">error</span>.OperationAborted =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Windows-only</span>
</span>
<span class="line" id="L912">            <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Did not request blocking mode</span>
</span>
<span class="line" id="L913">            <span class="tok-kw">error</span>.NotOpenForReading =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L914">            <span class="tok-kw">error</span>.SystemResources =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L915">            <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReadElfFile,</span>
<span class="line" id="L916">            <span class="tok-kw">error</span>.BrokenPipe =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReadElfFile,</span>
<span class="line" id="L917">            <span class="tok-kw">error</span>.Unseekable =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReadElfFile,</span>
<span class="line" id="L918">            <span class="tok-kw">error</span>.ConnectionResetByPeer =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReadElfFile,</span>
<span class="line" id="L919">            <span class="tok-kw">error</span>.ConnectionTimedOut =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReadElfFile,</span>
<span class="line" id="L920">            <span class="tok-kw">error</span>.Unexpected =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L921">            <span class="tok-kw">error</span>.InputOutput =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,</span>
<span class="line" id="L922">            <span class="tok-kw">error</span>.AccessDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L923">        };</span>
<span class="line" id="L924">        <span class="tok-kw">if</span> (len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedEndOfFile;</span>
<span class="line" id="L925">        i += len;</span>
<span class="line" id="L926">    }</span>
<span class="line" id="L927">    <span class="tok-kw">return</span> i;</span>
<span class="line" id="L928">}</span>
<span class="line" id="L929"></span>
<span class="line" id="L930"><span class="tok-kw">fn</span> <span class="tok-fn">defaultAbiAndDynamicLinker</span>(cpu: Target.Cpu, os: Target.Os, cross_target: CrossTarget) !NativeTargetInfo {</span>
<span class="line" id="L931">    <span class="tok-kw">const</span> target: Target = .{</span>
<span class="line" id="L932">        .cpu = cpu,</span>
<span class="line" id="L933">        .os = os,</span>
<span class="line" id="L934">        .abi = cross_target.abi <span class="tok-kw">orelse</span> Target.Abi.default(cpu.arch, os),</span>
<span class="line" id="L935">        .ofmt = cross_target.ofmt <span class="tok-kw">orelse</span> Target.ObjectFormat.default(os.tag, cpu.arch),</span>
<span class="line" id="L936">    };</span>
<span class="line" id="L937">    <span class="tok-kw">return</span> NativeTargetInfo{</span>
<span class="line" id="L938">        .target = target,</span>
<span class="line" id="L939">        .dynamic_linker = <span class="tok-kw">if</span> (cross_target.dynamic_linker.get() == <span class="tok-null">null</span>)</span>
<span class="line" id="L940">            target.standardDynamicLinkerPath()</span>
<span class="line" id="L941">        <span class="tok-kw">else</span></span>
<span class="line" id="L942">            cross_target.dynamic_linker,</span>
<span class="line" id="L943">    };</span>
<span class="line" id="L944">}</span>
<span class="line" id="L945"></span>
<span class="line" id="L946"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> LdInfo = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L947">    ld: DynamicLinker,</span>
<span class="line" id="L948">    abi: Target.Abi,</span>
<span class="line" id="L949">};</span>
<span class="line" id="L950"></span>
<span class="line" id="L951"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">elfInt</span>(is_64: <span class="tok-type">bool</span>, need_bswap: <span class="tok-type">bool</span>, int_32: <span class="tok-kw">anytype</span>, int_64: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(int_64) {</span>
<span class="line" id="L952">    <span class="tok-kw">if</span> (is_64) {</span>
<span class="line" id="L953">        <span class="tok-kw">if</span> (need_bswap) {</span>
<span class="line" id="L954">            <span class="tok-kw">return</span> <span class="tok-builtin">@byteSwap</span>(int_64);</span>
<span class="line" id="L955">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L956">            <span class="tok-kw">return</span> int_64;</span>
<span class="line" id="L957">        }</span>
<span class="line" id="L958">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L959">        <span class="tok-kw">if</span> (need_bswap) {</span>
<span class="line" id="L960">            <span class="tok-kw">return</span> <span class="tok-builtin">@byteSwap</span>(int_32);</span>
<span class="line" id="L961">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L962">            <span class="tok-kw">return</span> int_32;</span>
<span class="line" id="L963">        }</span>
<span class="line" id="L964">    }</span>
<span class="line" id="L965">}</span>
<span class="line" id="L966"></span>
<span class="line" id="L967"><span class="tok-kw">fn</span> <span class="tok-fn">detectNativeCpuAndFeatures</span>(cpu_arch: Target.Cpu.Arch, os: Target.Os, cross_target: CrossTarget) ?Target.Cpu {</span>
<span class="line" id="L968">    <span class="tok-comment">// Here we switch on a comptime value rather than `cpu_arch`. This is valid because `cpu_arch`,</span>
</span>
<span class="line" id="L969">    <span class="tok-comment">// although it is a runtime value, is guaranteed to be one of the architectures in the set</span>
</span>
<span class="line" id="L970">    <span class="tok-comment">// of the respective switch prong.</span>
</span>
<span class="line" id="L971">    <span class="tok-kw">switch</span> (builtin.cpu.arch) {</span>
<span class="line" id="L972">        .x86_64, .<span class="tok-type">i386</span> =&gt; {</span>
<span class="line" id="L973">            <span class="tok-kw">return</span> <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;x86.zig&quot;</span>).detectNativeCpuAndFeatures(cpu_arch, os, cross_target);</span>
<span class="line" id="L974">        },</span>
<span class="line" id="L975">        <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L976">    }</span>
<span class="line" id="L977"></span>
<span class="line" id="L978">    <span class="tok-kw">switch</span> (builtin.os.tag) {</span>
<span class="line" id="L979">        .linux =&gt; <span class="tok-kw">return</span> linux.detectNativeCpuAndFeatures(),</span>
<span class="line" id="L980">        .macos =&gt; <span class="tok-kw">return</span> darwin.macos.detectNativeCpuAndFeatures(),</span>
<span class="line" id="L981">        <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L982">    }</span>
<span class="line" id="L983"></span>
<span class="line" id="L984">    <span class="tok-comment">// This architecture does not have CPU model &amp; feature detection yet.</span>
</span>
<span class="line" id="L985">    <span class="tok-comment">// See https://github.com/ziglang/zig/issues/4591</span>
</span>
<span class="line" id="L986">    <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L987">}</span>
<span class="line" id="L988"></span>
<span class="line" id="L989"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Executor = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L990">    native,</span>
<span class="line" id="L991">    rosetta,</span>
<span class="line" id="L992">    qemu: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L993">    wine: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L994">    wasmtime: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L995">    darling: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L996">    bad_dl: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L997">    bad_os_or_cpu,</span>
<span class="line" id="L998">};</span>
<span class="line" id="L999"></span>
<span class="line" id="L1000"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetExternalExecutorOptions = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1001">    allow_darling: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,</span>
<span class="line" id="L1002">    allow_qemu: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,</span>
<span class="line" id="L1003">    allow_rosetta: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,</span>
<span class="line" id="L1004">    allow_wasmtime: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,</span>
<span class="line" id="L1005">    allow_wine: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,</span>
<span class="line" id="L1006">    qemu_fixes_dl: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L1007">    link_libc: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L1008">};</span>
<span class="line" id="L1009"></span>
<span class="line" id="L1010"><span class="tok-comment">/// Return whether or not the given host target is capable of executing natively executables</span></span>
<span class="line" id="L1011"><span class="tok-comment">/// of the other target.</span></span>
<span class="line" id="L1012"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getExternalExecutor</span>(</span>
<span class="line" id="L1013">    host: NativeTargetInfo,</span>
<span class="line" id="L1014">    candidate: NativeTargetInfo,</span>
<span class="line" id="L1015">    options: GetExternalExecutorOptions,</span>
<span class="line" id="L1016">) Executor {</span>
<span class="line" id="L1017">    <span class="tok-kw">const</span> os_match = host.target.os.tag == candidate.target.os.tag;</span>
<span class="line" id="L1018">    <span class="tok-kw">const</span> cpu_ok = cpu_ok: {</span>
<span class="line" id="L1019">        <span class="tok-kw">if</span> (host.target.cpu.arch == candidate.target.cpu.arch)</span>
<span class="line" id="L1020">            <span class="tok-kw">break</span> :cpu_ok <span class="tok-null">true</span>;</span>
<span class="line" id="L1021"></span>
<span class="line" id="L1022">        <span class="tok-kw">if</span> (host.target.cpu.arch == .x86_64 <span class="tok-kw">and</span> candidate.target.cpu.arch == .<span class="tok-type">i386</span>)</span>
<span class="line" id="L1023">            <span class="tok-kw">break</span> :cpu_ok <span class="tok-null">true</span>;</span>
<span class="line" id="L1024"></span>
<span class="line" id="L1025">        <span class="tok-kw">if</span> (host.target.cpu.arch == .aarch64 <span class="tok-kw">and</span> candidate.target.cpu.arch == .arm)</span>
<span class="line" id="L1026">            <span class="tok-kw">break</span> :cpu_ok <span class="tok-null">true</span>;</span>
<span class="line" id="L1027"></span>
<span class="line" id="L1028">        <span class="tok-kw">if</span> (host.target.cpu.arch == .aarch64_be <span class="tok-kw">and</span> candidate.target.cpu.arch == .armeb)</span>
<span class="line" id="L1029">            <span class="tok-kw">break</span> :cpu_ok <span class="tok-null">true</span>;</span>
<span class="line" id="L1030"></span>
<span class="line" id="L1031">        <span class="tok-comment">// TODO additionally detect incompatible CPU features.</span>
</span>
<span class="line" id="L1032">        <span class="tok-comment">// Note that in some cases the OS kernel will emulate missing CPU features</span>
</span>
<span class="line" id="L1033">        <span class="tok-comment">// when an illegal instruction is encountered.</span>
</span>
<span class="line" id="L1034"></span>
<span class="line" id="L1035">        <span class="tok-kw">break</span> :cpu_ok <span class="tok-null">false</span>;</span>
<span class="line" id="L1036">    };</span>
<span class="line" id="L1037"></span>
<span class="line" id="L1038">    <span class="tok-kw">var</span> bad_result: Executor = .bad_os_or_cpu;</span>
<span class="line" id="L1039"></span>
<span class="line" id="L1040">    <span class="tok-kw">if</span> (os_match <span class="tok-kw">and</span> cpu_ok) native: {</span>
<span class="line" id="L1041">        <span class="tok-kw">if</span> (options.link_libc) {</span>
<span class="line" id="L1042">            <span class="tok-kw">if</span> (candidate.dynamic_linker.get()) |candidate_dl| {</span>
<span class="line" id="L1043">                fs.cwd().access(candidate_dl, .{}) <span class="tok-kw">catch</span> {</span>
<span class="line" id="L1044">                    bad_result = .{ .bad_dl = candidate_dl };</span>
<span class="line" id="L1045">                    <span class="tok-kw">break</span> :native;</span>
<span class="line" id="L1046">                };</span>
<span class="line" id="L1047">            }</span>
<span class="line" id="L1048">        }</span>
<span class="line" id="L1049">        <span class="tok-kw">return</span> .native;</span>
<span class="line" id="L1050">    }</span>
<span class="line" id="L1051"></span>
<span class="line" id="L1052">    <span class="tok-comment">// If the OS match and OS is macOS and CPU is arm64, we can use Rosetta 2</span>
</span>
<span class="line" id="L1053">    <span class="tok-comment">// to emulate the foreign architecture.</span>
</span>
<span class="line" id="L1054">    <span class="tok-kw">if</span> (options.allow_rosetta <span class="tok-kw">and</span> os_match <span class="tok-kw">and</span></span>
<span class="line" id="L1055">        host.target.os.tag == .macos <span class="tok-kw">and</span> host.target.cpu.arch == .aarch64)</span>
<span class="line" id="L1056">    {</span>
<span class="line" id="L1057">        <span class="tok-kw">switch</span> (candidate.target.cpu.arch) {</span>
<span class="line" id="L1058">            .x86_64 =&gt; <span class="tok-kw">return</span> .rosetta,</span>
<span class="line" id="L1059">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> bad_result,</span>
<span class="line" id="L1060">        }</span>
<span class="line" id="L1061">    }</span>
<span class="line" id="L1062"></span>
<span class="line" id="L1063">    <span class="tok-comment">// If the OS matches, we can use QEMU to emulate a foreign architecture.</span>
</span>
<span class="line" id="L1064">    <span class="tok-kw">if</span> (options.allow_qemu <span class="tok-kw">and</span> os_match <span class="tok-kw">and</span> (!cpu_ok <span class="tok-kw">or</span> options.qemu_fixes_dl)) {</span>
<span class="line" id="L1065">        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (candidate.target.cpu.arch) {</span>
<span class="line" id="L1066">            .aarch64 =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-aarch64&quot;</span> },</span>
<span class="line" id="L1067">            .aarch64_be =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-aarch64_be&quot;</span> },</span>
<span class="line" id="L1068">            .arm =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-arm&quot;</span> },</span>
<span class="line" id="L1069">            .armeb =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-armeb&quot;</span> },</span>
<span class="line" id="L1070">            .hexagon =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-hexagon&quot;</span> },</span>
<span class="line" id="L1071">            .<span class="tok-type">i386</span> =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-i386&quot;</span> },</span>
<span class="line" id="L1072">            .m68k =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-m68k&quot;</span> },</span>
<span class="line" id="L1073">            .mips =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-mips&quot;</span> },</span>
<span class="line" id="L1074">            .mipsel =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-mipsel&quot;</span> },</span>
<span class="line" id="L1075">            .mips64 =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-mips64&quot;</span> },</span>
<span class="line" id="L1076">            .mips64el =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-mips64el&quot;</span> },</span>
<span class="line" id="L1077">            .powerpc =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-ppc&quot;</span> },</span>
<span class="line" id="L1078">            .powerpc64 =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-ppc64&quot;</span> },</span>
<span class="line" id="L1079">            .powerpc64le =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-ppc64le&quot;</span> },</span>
<span class="line" id="L1080">            .riscv32 =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-riscv32&quot;</span> },</span>
<span class="line" id="L1081">            .riscv64 =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-riscv64&quot;</span> },</span>
<span class="line" id="L1082">            .s390x =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-s390x&quot;</span> },</span>
<span class="line" id="L1083">            .sparc =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-sparc&quot;</span> },</span>
<span class="line" id="L1084">            .sparc64 =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-sparc64&quot;</span> },</span>
<span class="line" id="L1085">            .x86_64 =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-x86_64&quot;</span> },</span>
<span class="line" id="L1086">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> bad_result,</span>
<span class="line" id="L1087">        };</span>
<span class="line" id="L1088">    }</span>
<span class="line" id="L1089"></span>
<span class="line" id="L1090">    <span class="tok-kw">switch</span> (candidate.target.os.tag) {</span>
<span class="line" id="L1091">        .windows =&gt; {</span>
<span class="line" id="L1092">            <span class="tok-kw">if</span> (options.allow_wine) {</span>
<span class="line" id="L1093">                <span class="tok-kw">switch</span> (candidate.target.cpu.arch.ptrBitWidth()) {</span>
<span class="line" id="L1094">                    <span class="tok-number">32</span> =&gt; <span class="tok-kw">return</span> Executor{ .wine = <span class="tok-str">&quot;wine&quot;</span> },</span>
<span class="line" id="L1095">                    <span class="tok-number">64</span> =&gt; <span class="tok-kw">return</span> Executor{ .wine = <span class="tok-str">&quot;wine64&quot;</span> },</span>
<span class="line" id="L1096">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> bad_result,</span>
<span class="line" id="L1097">                }</span>
<span class="line" id="L1098">            }</span>
<span class="line" id="L1099">            <span class="tok-kw">return</span> bad_result;</span>
<span class="line" id="L1100">        },</span>
<span class="line" id="L1101">        .wasi =&gt; {</span>
<span class="line" id="L1102">            <span class="tok-kw">if</span> (options.allow_wasmtime) {</span>
<span class="line" id="L1103">                <span class="tok-kw">switch</span> (candidate.target.cpu.arch.ptrBitWidth()) {</span>
<span class="line" id="L1104">                    <span class="tok-number">32</span> =&gt; <span class="tok-kw">return</span> Executor{ .wasmtime = <span class="tok-str">&quot;wasmtime&quot;</span> },</span>
<span class="line" id="L1105">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> bad_result,</span>
<span class="line" id="L1106">                }</span>
<span class="line" id="L1107">            }</span>
<span class="line" id="L1108">            <span class="tok-kw">return</span> bad_result;</span>
<span class="line" id="L1109">        },</span>
<span class="line" id="L1110">        .macos =&gt; {</span>
<span class="line" id="L1111">            <span class="tok-kw">if</span> (options.allow_darling) {</span>
<span class="line" id="L1112">                <span class="tok-comment">// This check can be loosened once darling adds a QEMU-based emulation</span>
</span>
<span class="line" id="L1113">                <span class="tok-comment">// layer for non-host architectures:</span>
</span>
<span class="line" id="L1114">                <span class="tok-comment">// https://github.com/darlinghq/darling/issues/863</span>
</span>
<span class="line" id="L1115">                <span class="tok-kw">if</span> (candidate.target.cpu.arch != builtin.cpu.arch) {</span>
<span class="line" id="L1116">                    <span class="tok-kw">return</span> bad_result;</span>
<span class="line" id="L1117">                }</span>
<span class="line" id="L1118">                <span class="tok-kw">return</span> Executor{ .darling = <span class="tok-str">&quot;darling&quot;</span> };</span>
<span class="line" id="L1119">            }</span>
<span class="line" id="L1120">            <span class="tok-kw">return</span> bad_result;</span>
<span class="line" id="L1121">        },</span>
<span class="line" id="L1122">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> bad_result,</span>
<span class="line" id="L1123">    }</span>
<span class="line" id="L1124">}</span>
<span class="line" id="L1125"></span>
</code></pre></body>
</html>